[
  {
    "function_name": "btrfs_clear_biovec_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "1069-1091",
    "snippet": "void btrfs_clear_biovec_end(struct bio_vec *bvec, int vcnt,\n\t\t\t\t   unsigned long pg_index,\n\t\t\t\t   unsigned long pg_offset)\n{\n\twhile (pg_index < vcnt) {\n\t\tstruct page *page = bvec[pg_index].bv_page;\n\t\tunsigned long off = bvec[pg_index].bv_offset;\n\t\tunsigned long len = bvec[pg_index].bv_len;\n\n\t\tif (pg_offset < off)\n\t\t\tpg_offset = off;\n\t\tif (pg_offset < off + len) {\n\t\t\tunsigned long bytes = off + len - pg_offset;\n\t\t\tchar *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tmemset(kaddr + pg_offset, 0, bytes);\n\t\t\tkunmap_atomic(kaddr);\n\t\t}\n\t\tpg_index++;\n\t\tpg_offset = 0;\n\t}\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + pg_offset",
            "0",
            "bytes"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid btrfs_clear_biovec_end(struct bio_vec *bvec, int vcnt,\n\t\t\t\t   unsigned long pg_index,\n\t\t\t\t   unsigned long pg_offset)\n{\n\twhile (pg_index < vcnt) {\n\t\tstruct page *page = bvec[pg_index].bv_page;\n\t\tunsigned long off = bvec[pg_index].bv_offset;\n\t\tunsigned long len = bvec[pg_index].bv_len;\n\n\t\tif (pg_offset < off)\n\t\t\tpg_offset = off;\n\t\tif (pg_offset < off + len) {\n\t\t\tunsigned long bytes = off + len - pg_offset;\n\t\t\tchar *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tmemset(kaddr + pg_offset, 0, bytes);\n\t\t\tkunmap_atomic(kaddr);\n\t\t}\n\t\tpg_index++;\n\t\tpg_offset = 0;\n\t}\n}"
  },
  {
    "function_name": "btrfs_decompress_buf2page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "977-1060",
    "snippet": "int btrfs_decompress_buf2page(char *buf, unsigned long buf_start,\n\t\t\t      unsigned long total_out, u64 disk_start,\n\t\t\t      struct bio_vec *bvec, int vcnt,\n\t\t\t      unsigned long *pg_index,\n\t\t\t      unsigned long *pg_offset)\n{\n\tunsigned long buf_offset;\n\tunsigned long current_buf_start;\n\tunsigned long start_byte;\n\tunsigned long working_bytes = total_out - buf_start;\n\tunsigned long bytes;\n\tchar *kaddr;\n\tstruct page *page_out = bvec[*pg_index].bv_page;\n\n\t/*\n\t * start byte is the first byte of the page we're currently\n\t * copying into relative to the start of the compressed data.\n\t */\n\tstart_byte = page_offset(page_out) - disk_start;\n\n\t/* we haven't yet hit data corresponding to this page */\n\tif (total_out <= start_byte)\n\t\treturn 1;\n\n\t/*\n\t * the start of the data we care about is offset into\n\t * the middle of our working buffer\n\t */\n\tif (total_out > start_byte && buf_start < start_byte) {\n\t\tbuf_offset = start_byte - buf_start;\n\t\tworking_bytes -= buf_offset;\n\t} else {\n\t\tbuf_offset = 0;\n\t}\n\tcurrent_buf_start = buf_start;\n\n\t/* copy bytes from the working buffer into the pages */\n\twhile (working_bytes > 0) {\n\t\tbytes = min(PAGE_CACHE_SIZE - *pg_offset,\n\t\t\t    PAGE_CACHE_SIZE - buf_offset);\n\t\tbytes = min(bytes, working_bytes);\n\t\tkaddr = kmap_atomic(page_out);\n\t\tmemcpy(kaddr + *pg_offset, buf + buf_offset, bytes);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page_out);\n\n\t\t*pg_offset += bytes;\n\t\tbuf_offset += bytes;\n\t\tworking_bytes -= bytes;\n\t\tcurrent_buf_start += bytes;\n\n\t\t/* check if we need to pick another page */\n\t\tif (*pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t(*pg_index)++;\n\t\t\tif (*pg_index >= vcnt)\n\t\t\t\treturn 0;\n\n\t\t\tpage_out = bvec[*pg_index].bv_page;\n\t\t\t*pg_offset = 0;\n\t\t\tstart_byte = page_offset(page_out) - disk_start;\n\n\t\t\t/*\n\t\t\t * make sure our new page is covered by this\n\t\t\t * working buffer\n\t\t\t */\n\t\t\tif (total_out <= start_byte)\n\t\t\t\treturn 1;\n\n\t\t\t/*\n\t\t\t * the next page in the biovec might not be adjacent\n\t\t\t * to the last page, but it might still be found\n\t\t\t * inside this working buffer. bump our offset pointer\n\t\t\t */\n\t\t\tif (total_out > start_byte &&\n\t\t\t    current_buf_start < start_byte) {\n\t\t\t\tbuf_offset = start_byte - buf_start;\n\t\t\t\tworking_bytes = total_out - start_byte;\n\t\t\t\tcurrent_buf_start = buf_start + buf_offset;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page_out"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page_out"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr + *pg_offset",
            "buf + buf_offset",
            "bytes"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page_out"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes",
            "working_bytes"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page_out"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_decompress_buf2page(char *buf, unsigned long buf_start,\n\t\t\t      unsigned long total_out, u64 disk_start,\n\t\t\t      struct bio_vec *bvec, int vcnt,\n\t\t\t      unsigned long *pg_index,\n\t\t\t      unsigned long *pg_offset)\n{\n\tunsigned long buf_offset;\n\tunsigned long current_buf_start;\n\tunsigned long start_byte;\n\tunsigned long working_bytes = total_out - buf_start;\n\tunsigned long bytes;\n\tchar *kaddr;\n\tstruct page *page_out = bvec[*pg_index].bv_page;\n\n\t/*\n\t * start byte is the first byte of the page we're currently\n\t * copying into relative to the start of the compressed data.\n\t */\n\tstart_byte = page_offset(page_out) - disk_start;\n\n\t/* we haven't yet hit data corresponding to this page */\n\tif (total_out <= start_byte)\n\t\treturn 1;\n\n\t/*\n\t * the start of the data we care about is offset into\n\t * the middle of our working buffer\n\t */\n\tif (total_out > start_byte && buf_start < start_byte) {\n\t\tbuf_offset = start_byte - buf_start;\n\t\tworking_bytes -= buf_offset;\n\t} else {\n\t\tbuf_offset = 0;\n\t}\n\tcurrent_buf_start = buf_start;\n\n\t/* copy bytes from the working buffer into the pages */\n\twhile (working_bytes > 0) {\n\t\tbytes = min(PAGE_CACHE_SIZE - *pg_offset,\n\t\t\t    PAGE_CACHE_SIZE - buf_offset);\n\t\tbytes = min(bytes, working_bytes);\n\t\tkaddr = kmap_atomic(page_out);\n\t\tmemcpy(kaddr + *pg_offset, buf + buf_offset, bytes);\n\t\tkunmap_atomic(kaddr);\n\t\tflush_dcache_page(page_out);\n\n\t\t*pg_offset += bytes;\n\t\tbuf_offset += bytes;\n\t\tworking_bytes -= bytes;\n\t\tcurrent_buf_start += bytes;\n\n\t\t/* check if we need to pick another page */\n\t\tif (*pg_offset == PAGE_CACHE_SIZE) {\n\t\t\t(*pg_index)++;\n\t\t\tif (*pg_index >= vcnt)\n\t\t\t\treturn 0;\n\n\t\t\tpage_out = bvec[*pg_index].bv_page;\n\t\t\t*pg_offset = 0;\n\t\t\tstart_byte = page_offset(page_out) - disk_start;\n\n\t\t\t/*\n\t\t\t * make sure our new page is covered by this\n\t\t\t * working buffer\n\t\t\t */\n\t\t\tif (total_out <= start_byte)\n\t\t\t\treturn 1;\n\n\t\t\t/*\n\t\t\t * the next page in the biovec might not be adjacent\n\t\t\t * to the last page, but it might still be found\n\t\t\t * inside this working buffer. bump our offset pointer\n\t\t\t */\n\t\t\tif (total_out > start_byte &&\n\t\t\t    current_buf_start < start_byte) {\n\t\t\t\tbuf_offset = start_byte - buf_start;\n\t\t\t\tworking_bytes = total_out - start_byte;\n\t\t\t\tcurrent_buf_start = buf_start + buf_offset;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_exit_compress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "965-968",
    "snippet": "void btrfs_exit_compress(void)\n{\n\tfree_workspaces();\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workspaces",
          "args": [],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "free_workspaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "849-862",
          "snippet": "static void free_workspaces(void)\n{\n\tstruct list_head *workspace;\n\tint i;\n\n\tfor (i = 0; i < BTRFS_COMPRESS_TYPES; i++) {\n\t\twhile (!list_empty(&comp_idle_workspace[i])) {\n\t\t\tworkspace = comp_idle_workspace[i].next;\n\t\t\tlist_del(workspace);\n\t\t\tbtrfs_compress_op[i]->free_workspace(workspace);\n\t\t\tatomic_dec(&comp_alloc_workspace[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];",
            "static atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];",
            "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];\nstatic atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nstatic void free_workspaces(void)\n{\n\tstruct list_head *workspace;\n\tint i;\n\n\tfor (i = 0; i < BTRFS_COMPRESS_TYPES; i++) {\n\t\twhile (!list_empty(&comp_idle_workspace[i])) {\n\t\t\tworkspace = comp_idle_workspace[i].next;\n\t\t\tlist_del(workspace);\n\t\t\tbtrfs_compress_op[i]->free_workspace(workspace);\n\t\t\tatomic_dec(&comp_alloc_workspace[i]);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid btrfs_exit_compress(void)\n{\n\tfree_workspaces();\n}"
  },
  {
    "function_name": "btrfs_decompress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "947-963",
    "snippet": "int btrfs_decompress(int type, unsigned char *data_in, struct page *dest_page,\n\t\t     unsigned long start_byte, size_t srclen, size_t destlen)\n{\n\tstruct list_head *workspace;\n\tint ret;\n\n\tworkspace = find_workspace(type);\n\tif (IS_ERR(workspace))\n\t\treturn PTR_ERR(workspace);\n\n\tret = btrfs_compress_op[type-1]->decompress(workspace, data_in,\n\t\t\t\t\t\t  dest_page, start_byte,\n\t\t\t\t\t\t  srclen, destlen);\n\n\tfree_workspace(type, workspace);\n\treturn ret;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_decompress_biovec(int type, struct page **pages_in,\n\t\t\t\t   u64 disk_start, struct bio_vec *bvec,\n\t\t\t\t   int vcnt, size_t srclen);",
      "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workspace",
          "args": [
            "type",
            "workspace"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "free_workspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "820-844",
          "snippet": "static void free_workspace(int type, struct list_head *workspace)\n{\n\tint idx = type - 1;\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\n\n\tspin_lock(workspace_lock);\n\tif (*num_workspace < num_online_cpus()) {\n\t\tlist_add(workspace, idle_workspace);\n\t\t(*num_workspace)++;\n\t\tspin_unlock(workspace_lock);\n\t\tgoto wake;\n\t}\n\tspin_unlock(workspace_lock);\n\n\tbtrfs_compress_op[idx]->free_workspace(workspace);\n\tatomic_dec(alloc_workspace);\nwake:\n\tsmp_mb();\n\tif (waitqueue_active(workspace_wait))\n\t\twake_up(workspace_wait);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];",
            "static spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];",
            "static int comp_num_workspace[BTRFS_COMPRESS_TYPES];",
            "static atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];",
            "static wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];",
            "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];\nstatic spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];\nstatic int comp_num_workspace[BTRFS_COMPRESS_TYPES];\nstatic atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];\nstatic wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nstatic void free_workspace(int type, struct list_head *workspace)\n{\n\tint idx = type - 1;\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\n\n\tspin_lock(workspace_lock);\n\tif (*num_workspace < num_online_cpus()) {\n\t\tlist_add(workspace, idle_workspace);\n\t\t(*num_workspace)++;\n\t\tspin_unlock(workspace_lock);\n\t\tgoto wake;\n\t}\n\tspin_unlock(workspace_lock);\n\n\tbtrfs_compress_op[idx]->free_workspace(workspace);\n\tatomic_dec(alloc_workspace);\nwake:\n\tsmp_mb();\n\tif (waitqueue_active(workspace_wait))\n\t\twake_up(workspace_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_compress_op[type-1]->decompress",
          "args": [
            "workspace",
            "data_in",
            "dest_page",
            "start_byte",
            "srclen",
            "destlen"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "workspace"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "workspace"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_workspace",
          "args": [
            "type"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "find_workspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "774-814",
          "snippet": "static struct list_head *find_workspace(int type)\n{\n\tstruct list_head *workspace;\n\tint cpus = num_online_cpus();\n\tint idx = type - 1;\n\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\nagain:\n\tspin_lock(workspace_lock);\n\tif (!list_empty(idle_workspace)) {\n\t\tworkspace = idle_workspace->next;\n\t\tlist_del(workspace);\n\t\t(*num_workspace)--;\n\t\tspin_unlock(workspace_lock);\n\t\treturn workspace;\n\n\t}\n\tif (atomic_read(alloc_workspace) > cpus) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tspin_unlock(workspace_lock);\n\t\tprepare_to_wait(workspace_wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(alloc_workspace) > cpus && !*num_workspace)\n\t\t\tschedule();\n\t\tfinish_wait(workspace_wait, &wait);\n\t\tgoto again;\n\t}\n\tatomic_inc(alloc_workspace);\n\tspin_unlock(workspace_lock);\n\n\tworkspace = btrfs_compress_op[idx]->alloc_workspace();\n\tif (IS_ERR(workspace)) {\n\t\tatomic_dec(alloc_workspace);\n\t\twake_up(workspace_wait);\n\t}\n\treturn workspace;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];",
            "static spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];",
            "static int comp_num_workspace[BTRFS_COMPRESS_TYPES];",
            "static atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];",
            "static wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];",
            "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];\nstatic spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];\nstatic int comp_num_workspace[BTRFS_COMPRESS_TYPES];\nstatic atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];\nstatic wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nstatic struct list_head *find_workspace(int type)\n{\n\tstruct list_head *workspace;\n\tint cpus = num_online_cpus();\n\tint idx = type - 1;\n\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\nagain:\n\tspin_lock(workspace_lock);\n\tif (!list_empty(idle_workspace)) {\n\t\tworkspace = idle_workspace->next;\n\t\tlist_del(workspace);\n\t\t(*num_workspace)--;\n\t\tspin_unlock(workspace_lock);\n\t\treturn workspace;\n\n\t}\n\tif (atomic_read(alloc_workspace) > cpus) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tspin_unlock(workspace_lock);\n\t\tprepare_to_wait(workspace_wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(alloc_workspace) > cpus && !*num_workspace)\n\t\t\tschedule();\n\t\tfinish_wait(workspace_wait, &wait);\n\t\tgoto again;\n\t}\n\tatomic_inc(alloc_workspace);\n\tspin_unlock(workspace_lock);\n\n\tworkspace = btrfs_compress_op[idx]->alloc_workspace();\n\tif (IS_ERR(workspace)) {\n\t\tatomic_dec(alloc_workspace);\n\t\twake_up(workspace_wait);\n\t}\n\treturn workspace;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_decompress_biovec(int type, struct page **pages_in,\n\t\t\t\t   u64 disk_start, struct bio_vec *bvec,\n\t\t\t\t   int vcnt, size_t srclen);\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nint btrfs_decompress(int type, unsigned char *data_in, struct page *dest_page,\n\t\t     unsigned long start_byte, size_t srclen, size_t destlen)\n{\n\tstruct list_head *workspace;\n\tint ret;\n\n\tworkspace = find_workspace(type);\n\tif (IS_ERR(workspace))\n\t\treturn PTR_ERR(workspace);\n\n\tret = btrfs_compress_op[type-1]->decompress(workspace, data_in,\n\t\t\t\t\t\t  dest_page, start_byte,\n\t\t\t\t\t\t  srclen, destlen);\n\n\tfree_workspace(type, workspace);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_decompress_biovec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "924-940",
    "snippet": "static int btrfs_decompress_biovec(int type, struct page **pages_in,\n\t\t\t\t   u64 disk_start, struct bio_vec *bvec,\n\t\t\t\t   int vcnt, size_t srclen)\n{\n\tstruct list_head *workspace;\n\tint ret;\n\n\tworkspace = find_workspace(type);\n\tif (IS_ERR(workspace))\n\t\treturn PTR_ERR(workspace);\n\n\tret = btrfs_compress_op[type-1]->decompress_biovec(workspace, pages_in,\n\t\t\t\t\t\t\t disk_start,\n\t\t\t\t\t\t\t bvec, vcnt, srclen);\n\tfree_workspace(type, workspace);\n\treturn ret;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_decompress_biovec(int type, struct page **pages_in,\n\t\t\t\t   u64 disk_start, struct bio_vec *bvec,\n\t\t\t\t   int vcnt, size_t srclen);",
      "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workspace",
          "args": [
            "type",
            "workspace"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "free_workspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "820-844",
          "snippet": "static void free_workspace(int type, struct list_head *workspace)\n{\n\tint idx = type - 1;\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\n\n\tspin_lock(workspace_lock);\n\tif (*num_workspace < num_online_cpus()) {\n\t\tlist_add(workspace, idle_workspace);\n\t\t(*num_workspace)++;\n\t\tspin_unlock(workspace_lock);\n\t\tgoto wake;\n\t}\n\tspin_unlock(workspace_lock);\n\n\tbtrfs_compress_op[idx]->free_workspace(workspace);\n\tatomic_dec(alloc_workspace);\nwake:\n\tsmp_mb();\n\tif (waitqueue_active(workspace_wait))\n\t\twake_up(workspace_wait);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];",
            "static spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];",
            "static int comp_num_workspace[BTRFS_COMPRESS_TYPES];",
            "static atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];",
            "static wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];",
            "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];\nstatic spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];\nstatic int comp_num_workspace[BTRFS_COMPRESS_TYPES];\nstatic atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];\nstatic wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nstatic void free_workspace(int type, struct list_head *workspace)\n{\n\tint idx = type - 1;\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\n\n\tspin_lock(workspace_lock);\n\tif (*num_workspace < num_online_cpus()) {\n\t\tlist_add(workspace, idle_workspace);\n\t\t(*num_workspace)++;\n\t\tspin_unlock(workspace_lock);\n\t\tgoto wake;\n\t}\n\tspin_unlock(workspace_lock);\n\n\tbtrfs_compress_op[idx]->free_workspace(workspace);\n\tatomic_dec(alloc_workspace);\nwake:\n\tsmp_mb();\n\tif (waitqueue_active(workspace_wait))\n\t\twake_up(workspace_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_compress_op[type-1]->decompress_biovec",
          "args": [
            "workspace",
            "pages_in",
            "disk_start",
            "bvec",
            "vcnt",
            "srclen"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "workspace"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "workspace"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_workspace",
          "args": [
            "type"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "find_workspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "774-814",
          "snippet": "static struct list_head *find_workspace(int type)\n{\n\tstruct list_head *workspace;\n\tint cpus = num_online_cpus();\n\tint idx = type - 1;\n\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\nagain:\n\tspin_lock(workspace_lock);\n\tif (!list_empty(idle_workspace)) {\n\t\tworkspace = idle_workspace->next;\n\t\tlist_del(workspace);\n\t\t(*num_workspace)--;\n\t\tspin_unlock(workspace_lock);\n\t\treturn workspace;\n\n\t}\n\tif (atomic_read(alloc_workspace) > cpus) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tspin_unlock(workspace_lock);\n\t\tprepare_to_wait(workspace_wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(alloc_workspace) > cpus && !*num_workspace)\n\t\t\tschedule();\n\t\tfinish_wait(workspace_wait, &wait);\n\t\tgoto again;\n\t}\n\tatomic_inc(alloc_workspace);\n\tspin_unlock(workspace_lock);\n\n\tworkspace = btrfs_compress_op[idx]->alloc_workspace();\n\tif (IS_ERR(workspace)) {\n\t\tatomic_dec(alloc_workspace);\n\t\twake_up(workspace_wait);\n\t}\n\treturn workspace;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];",
            "static spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];",
            "static int comp_num_workspace[BTRFS_COMPRESS_TYPES];",
            "static atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];",
            "static wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];",
            "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];\nstatic spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];\nstatic int comp_num_workspace[BTRFS_COMPRESS_TYPES];\nstatic atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];\nstatic wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nstatic struct list_head *find_workspace(int type)\n{\n\tstruct list_head *workspace;\n\tint cpus = num_online_cpus();\n\tint idx = type - 1;\n\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\nagain:\n\tspin_lock(workspace_lock);\n\tif (!list_empty(idle_workspace)) {\n\t\tworkspace = idle_workspace->next;\n\t\tlist_del(workspace);\n\t\t(*num_workspace)--;\n\t\tspin_unlock(workspace_lock);\n\t\treturn workspace;\n\n\t}\n\tif (atomic_read(alloc_workspace) > cpus) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tspin_unlock(workspace_lock);\n\t\tprepare_to_wait(workspace_wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(alloc_workspace) > cpus && !*num_workspace)\n\t\t\tschedule();\n\t\tfinish_wait(workspace_wait, &wait);\n\t\tgoto again;\n\t}\n\tatomic_inc(alloc_workspace);\n\tspin_unlock(workspace_lock);\n\n\tworkspace = btrfs_compress_op[idx]->alloc_workspace();\n\tif (IS_ERR(workspace)) {\n\t\tatomic_dec(alloc_workspace);\n\t\twake_up(workspace_wait);\n\t}\n\treturn workspace;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_decompress_biovec(int type, struct page **pages_in,\n\t\t\t\t   u64 disk_start, struct bio_vec *bvec,\n\t\t\t\t   int vcnt, size_t srclen);\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nstatic int btrfs_decompress_biovec(int type, struct page **pages_in,\n\t\t\t\t   u64 disk_start, struct bio_vec *bvec,\n\t\t\t\t   int vcnt, size_t srclen)\n{\n\tstruct list_head *workspace;\n\tint ret;\n\n\tworkspace = find_workspace(type);\n\tif (IS_ERR(workspace))\n\t\treturn PTR_ERR(workspace);\n\n\tret = btrfs_compress_op[type-1]->decompress_biovec(workspace, pages_in,\n\t\t\t\t\t\t\t disk_start,\n\t\t\t\t\t\t\t bvec, vcnt, srclen);\n\tfree_workspace(type, workspace);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_compress_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "883-906",
    "snippet": "int btrfs_compress_pages(int type, struct address_space *mapping,\n\t\t\t u64 start, unsigned long len,\n\t\t\t struct page **pages,\n\t\t\t unsigned long nr_dest_pages,\n\t\t\t unsigned long *out_pages,\n\t\t\t unsigned long *total_in,\n\t\t\t unsigned long *total_out,\n\t\t\t unsigned long max_out)\n{\n\tstruct list_head *workspace;\n\tint ret;\n\n\tworkspace = find_workspace(type);\n\tif (IS_ERR(workspace))\n\t\treturn PTR_ERR(workspace);\n\n\tret = btrfs_compress_op[type-1]->compress_pages(workspace, mapping,\n\t\t\t\t\t\t      start, len, pages,\n\t\t\t\t\t\t      nr_dest_pages, out_pages,\n\t\t\t\t\t\t      total_in, total_out,\n\t\t\t\t\t\t      max_out);\n\tfree_workspace(type, workspace);\n\treturn ret;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_workspace",
          "args": [
            "type",
            "workspace"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "free_workspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "820-844",
          "snippet": "static void free_workspace(int type, struct list_head *workspace)\n{\n\tint idx = type - 1;\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\n\n\tspin_lock(workspace_lock);\n\tif (*num_workspace < num_online_cpus()) {\n\t\tlist_add(workspace, idle_workspace);\n\t\t(*num_workspace)++;\n\t\tspin_unlock(workspace_lock);\n\t\tgoto wake;\n\t}\n\tspin_unlock(workspace_lock);\n\n\tbtrfs_compress_op[idx]->free_workspace(workspace);\n\tatomic_dec(alloc_workspace);\nwake:\n\tsmp_mb();\n\tif (waitqueue_active(workspace_wait))\n\t\twake_up(workspace_wait);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];",
            "static spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];",
            "static int comp_num_workspace[BTRFS_COMPRESS_TYPES];",
            "static atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];",
            "static wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];",
            "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];\nstatic spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];\nstatic int comp_num_workspace[BTRFS_COMPRESS_TYPES];\nstatic atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];\nstatic wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nstatic void free_workspace(int type, struct list_head *workspace)\n{\n\tint idx = type - 1;\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\n\n\tspin_lock(workspace_lock);\n\tif (*num_workspace < num_online_cpus()) {\n\t\tlist_add(workspace, idle_workspace);\n\t\t(*num_workspace)++;\n\t\tspin_unlock(workspace_lock);\n\t\tgoto wake;\n\t}\n\tspin_unlock(workspace_lock);\n\n\tbtrfs_compress_op[idx]->free_workspace(workspace);\n\tatomic_dec(alloc_workspace);\nwake:\n\tsmp_mb();\n\tif (waitqueue_active(workspace_wait))\n\t\twake_up(workspace_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_compress_op[type-1]->compress_pages",
          "args": [
            "workspace",
            "mapping",
            "start",
            "len",
            "pages",
            "nr_dest_pages",
            "out_pages",
            "total_in",
            "total_out",
            "max_out"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "workspace"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "workspace"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_workspace",
          "args": [
            "type"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "find_workspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "774-814",
          "snippet": "static struct list_head *find_workspace(int type)\n{\n\tstruct list_head *workspace;\n\tint cpus = num_online_cpus();\n\tint idx = type - 1;\n\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\nagain:\n\tspin_lock(workspace_lock);\n\tif (!list_empty(idle_workspace)) {\n\t\tworkspace = idle_workspace->next;\n\t\tlist_del(workspace);\n\t\t(*num_workspace)--;\n\t\tspin_unlock(workspace_lock);\n\t\treturn workspace;\n\n\t}\n\tif (atomic_read(alloc_workspace) > cpus) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tspin_unlock(workspace_lock);\n\t\tprepare_to_wait(workspace_wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(alloc_workspace) > cpus && !*num_workspace)\n\t\t\tschedule();\n\t\tfinish_wait(workspace_wait, &wait);\n\t\tgoto again;\n\t}\n\tatomic_inc(alloc_workspace);\n\tspin_unlock(workspace_lock);\n\n\tworkspace = btrfs_compress_op[idx]->alloc_workspace();\n\tif (IS_ERR(workspace)) {\n\t\tatomic_dec(alloc_workspace);\n\t\twake_up(workspace_wait);\n\t}\n\treturn workspace;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];",
            "static spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];",
            "static int comp_num_workspace[BTRFS_COMPRESS_TYPES];",
            "static atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];",
            "static wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];",
            "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];\nstatic spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];\nstatic int comp_num_workspace[BTRFS_COMPRESS_TYPES];\nstatic atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];\nstatic wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nstatic struct list_head *find_workspace(int type)\n{\n\tstruct list_head *workspace;\n\tint cpus = num_online_cpus();\n\tint idx = type - 1;\n\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\nagain:\n\tspin_lock(workspace_lock);\n\tif (!list_empty(idle_workspace)) {\n\t\tworkspace = idle_workspace->next;\n\t\tlist_del(workspace);\n\t\t(*num_workspace)--;\n\t\tspin_unlock(workspace_lock);\n\t\treturn workspace;\n\n\t}\n\tif (atomic_read(alloc_workspace) > cpus) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tspin_unlock(workspace_lock);\n\t\tprepare_to_wait(workspace_wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(alloc_workspace) > cpus && !*num_workspace)\n\t\t\tschedule();\n\t\tfinish_wait(workspace_wait, &wait);\n\t\tgoto again;\n\t}\n\tatomic_inc(alloc_workspace);\n\tspin_unlock(workspace_lock);\n\n\tworkspace = btrfs_compress_op[idx]->alloc_workspace();\n\tif (IS_ERR(workspace)) {\n\t\tatomic_dec(alloc_workspace);\n\t\twake_up(workspace_wait);\n\t}\n\treturn workspace;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nint btrfs_compress_pages(int type, struct address_space *mapping,\n\t\t\t u64 start, unsigned long len,\n\t\t\t struct page **pages,\n\t\t\t unsigned long nr_dest_pages,\n\t\t\t unsigned long *out_pages,\n\t\t\t unsigned long *total_in,\n\t\t\t unsigned long *total_out,\n\t\t\t unsigned long max_out)\n{\n\tstruct list_head *workspace;\n\tint ret;\n\n\tworkspace = find_workspace(type);\n\tif (IS_ERR(workspace))\n\t\treturn PTR_ERR(workspace);\n\n\tret = btrfs_compress_op[type-1]->compress_pages(workspace, mapping,\n\t\t\t\t\t\t      start, len, pages,\n\t\t\t\t\t\t      nr_dest_pages, out_pages,\n\t\t\t\t\t\t      total_in, total_out,\n\t\t\t\t\t\t      max_out);\n\tfree_workspace(type, workspace);\n\treturn ret;\n}"
  },
  {
    "function_name": "free_workspaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "849-862",
    "snippet": "static void free_workspaces(void)\n{\n\tstruct list_head *workspace;\n\tint i;\n\n\tfor (i = 0; i < BTRFS_COMPRESS_TYPES; i++) {\n\t\twhile (!list_empty(&comp_idle_workspace[i])) {\n\t\t\tworkspace = comp_idle_workspace[i].next;\n\t\t\tlist_del(workspace);\n\t\t\tbtrfs_compress_op[i]->free_workspace(workspace);\n\t\t\tatomic_dec(&comp_alloc_workspace[i]);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];",
      "static atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];",
      "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&comp_alloc_workspace[i]"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_compress_op[i]->free_workspace",
          "args": [
            "workspace"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "workspace"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&comp_idle_workspace[i]"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];\nstatic atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nstatic void free_workspaces(void)\n{\n\tstruct list_head *workspace;\n\tint i;\n\n\tfor (i = 0; i < BTRFS_COMPRESS_TYPES; i++) {\n\t\twhile (!list_empty(&comp_idle_workspace[i])) {\n\t\t\tworkspace = comp_idle_workspace[i].next;\n\t\t\tlist_del(workspace);\n\t\t\tbtrfs_compress_op[i]->free_workspace(workspace);\n\t\t\tatomic_dec(&comp_alloc_workspace[i]);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "free_workspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "820-844",
    "snippet": "static void free_workspace(int type, struct list_head *workspace)\n{\n\tint idx = type - 1;\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\n\n\tspin_lock(workspace_lock);\n\tif (*num_workspace < num_online_cpus()) {\n\t\tlist_add(workspace, idle_workspace);\n\t\t(*num_workspace)++;\n\t\tspin_unlock(workspace_lock);\n\t\tgoto wake;\n\t}\n\tspin_unlock(workspace_lock);\n\n\tbtrfs_compress_op[idx]->free_workspace(workspace);\n\tatomic_dec(alloc_workspace);\nwake:\n\tsmp_mb();\n\tif (waitqueue_active(workspace_wait))\n\t\twake_up(workspace_wait);\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];",
      "static spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];",
      "static int comp_num_workspace[BTRFS_COMPRESS_TYPES];",
      "static atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];",
      "static wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];",
      "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "workspace_wait"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "workspace_wait"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "alloc_workspace"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_compress_op[idx]->free_workspace",
          "args": [
            "workspace"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "workspace_lock"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "workspace",
            "idle_workspace"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "workspace_lock"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];\nstatic spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];\nstatic int comp_num_workspace[BTRFS_COMPRESS_TYPES];\nstatic atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];\nstatic wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nstatic void free_workspace(int type, struct list_head *workspace)\n{\n\tint idx = type - 1;\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\n\n\tspin_lock(workspace_lock);\n\tif (*num_workspace < num_online_cpus()) {\n\t\tlist_add(workspace, idle_workspace);\n\t\t(*num_workspace)++;\n\t\tspin_unlock(workspace_lock);\n\t\tgoto wake;\n\t}\n\tspin_unlock(workspace_lock);\n\n\tbtrfs_compress_op[idx]->free_workspace(workspace);\n\tatomic_dec(alloc_workspace);\nwake:\n\tsmp_mb();\n\tif (waitqueue_active(workspace_wait))\n\t\twake_up(workspace_wait);\n}"
  },
  {
    "function_name": "find_workspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "774-814",
    "snippet": "static struct list_head *find_workspace(int type)\n{\n\tstruct list_head *workspace;\n\tint cpus = num_online_cpus();\n\tint idx = type - 1;\n\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\nagain:\n\tspin_lock(workspace_lock);\n\tif (!list_empty(idle_workspace)) {\n\t\tworkspace = idle_workspace->next;\n\t\tlist_del(workspace);\n\t\t(*num_workspace)--;\n\t\tspin_unlock(workspace_lock);\n\t\treturn workspace;\n\n\t}\n\tif (atomic_read(alloc_workspace) > cpus) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tspin_unlock(workspace_lock);\n\t\tprepare_to_wait(workspace_wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(alloc_workspace) > cpus && !*num_workspace)\n\t\t\tschedule();\n\t\tfinish_wait(workspace_wait, &wait);\n\t\tgoto again;\n\t}\n\tatomic_inc(alloc_workspace);\n\tspin_unlock(workspace_lock);\n\n\tworkspace = btrfs_compress_op[idx]->alloc_workspace();\n\tif (IS_ERR(workspace)) {\n\t\tatomic_dec(alloc_workspace);\n\t\twake_up(workspace_wait);\n\t}\n\treturn workspace;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];",
      "static spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];",
      "static int comp_num_workspace[BTRFS_COMPRESS_TYPES];",
      "static atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];",
      "static wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];",
      "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "workspace_wait"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "alloc_workspace"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "workspace"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_compress_op[idx]->alloc_workspace",
          "args": [],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "workspace_lock"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "alloc_workspace"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "workspace_wait",
            "&wait"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "alloc_workspace"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "workspace_wait",
            "&wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "alloc_workspace"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "workspace"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "idle_workspace"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "workspace_lock"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];\nstatic spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];\nstatic int comp_num_workspace[BTRFS_COMPRESS_TYPES];\nstatic atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];\nstatic wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nstatic struct list_head *find_workspace(int type)\n{\n\tstruct list_head *workspace;\n\tint cpus = num_online_cpus();\n\tint idx = type - 1;\n\n\tstruct list_head *idle_workspace\t= &comp_idle_workspace[idx];\n\tspinlock_t *workspace_lock\t\t= &comp_workspace_lock[idx];\n\tatomic_t *alloc_workspace\t\t= &comp_alloc_workspace[idx];\n\twait_queue_head_t *workspace_wait\t= &comp_workspace_wait[idx];\n\tint *num_workspace\t\t\t= &comp_num_workspace[idx];\nagain:\n\tspin_lock(workspace_lock);\n\tif (!list_empty(idle_workspace)) {\n\t\tworkspace = idle_workspace->next;\n\t\tlist_del(workspace);\n\t\t(*num_workspace)--;\n\t\tspin_unlock(workspace_lock);\n\t\treturn workspace;\n\n\t}\n\tif (atomic_read(alloc_workspace) > cpus) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tspin_unlock(workspace_lock);\n\t\tprepare_to_wait(workspace_wait, &wait, TASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(alloc_workspace) > cpus && !*num_workspace)\n\t\t\tschedule();\n\t\tfinish_wait(workspace_wait, &wait);\n\t\tgoto again;\n\t}\n\tatomic_inc(alloc_workspace);\n\tspin_unlock(workspace_lock);\n\n\tworkspace = btrfs_compress_op[idx]->alloc_workspace();\n\tif (IS_ERR(workspace)) {\n\t\tatomic_dec(alloc_workspace);\n\t\twake_up(workspace_wait);\n\t}\n\treturn workspace;\n}"
  },
  {
    "function_name": "btrfs_init_compress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "758-768",
    "snippet": "void __init btrfs_init_compress(void)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_COMPRESS_TYPES; i++) {\n\t\tINIT_LIST_HEAD(&comp_idle_workspace[i]);\n\t\tspin_lock_init(&comp_workspace_lock[i]);\n\t\tatomic_set(&comp_alloc_workspace[i], 0);\n\t\tinit_waitqueue_head(&comp_workspace_wait[i]);\n\t}\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];",
      "static spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];",
      "static atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];",
      "static wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&comp_workspace_wait[i]"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&comp_alloc_workspace[i]",
            "0"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&comp_workspace_lock[i]"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&comp_idle_workspace[i]"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];\nstatic spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];\nstatic atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];\nstatic wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];\n\nvoid __init btrfs_init_compress(void)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_COMPRESS_TYPES; i++) {\n\t\tINIT_LIST_HEAD(&comp_idle_workspace[i]);\n\t\tspin_lock_init(&comp_workspace_lock[i]);\n\t\tatomic_set(&comp_alloc_workspace[i], 0);\n\t\tinit_waitqueue_head(&comp_workspace_wait[i]);\n\t}\n}"
  },
  {
    "function_name": "btrfs_submit_compressed_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "567-745",
    "snippet": "int btrfs_submit_compressed_read(struct inode *inode, struct bio *bio,\n\t\t\t\t int mirror_num, unsigned long bio_flags)\n{\n\tstruct extent_io_tree *tree;\n\tstruct extent_map_tree *em_tree;\n\tstruct compressed_bio *cb;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tunsigned long uncompressed_len = bio->bi_vcnt * PAGE_CACHE_SIZE;\n\tunsigned long compressed_len;\n\tunsigned long nr_pages;\n\tunsigned long pg_index;\n\tstruct page *page;\n\tstruct block_device *bdev;\n\tstruct bio *comp_bio;\n\tu64 cur_disk_byte = (u64)bio->bi_iter.bi_sector << 9;\n\tu64 em_len;\n\tu64 em_start;\n\tstruct extent_map *em;\n\tint ret = -ENOMEM;\n\tint faili = 0;\n\tu32 *sums;\n\n\ttree = &BTRFS_I(inode)->io_tree;\n\tem_tree = &BTRFS_I(inode)->extent_tree;\n\n\t/* we need the actual starting offset of this extent in the file */\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree,\n\t\t\t\t   page_offset(bio->bi_io_vec->bv_page),\n\t\t\t\t   PAGE_CACHE_SIZE);\n\tread_unlock(&em_tree->lock);\n\tif (!em)\n\t\treturn -EIO;\n\n\tcompressed_len = em->block_len;\n\tcb = kmalloc(compressed_bio_size(root, compressed_len), GFP_NOFS);\n\tif (!cb)\n\t\tgoto out;\n\n\tatomic_set(&cb->pending_bios, 0);\n\tcb->errors = 0;\n\tcb->inode = inode;\n\tcb->mirror_num = mirror_num;\n\tsums = &cb->sums;\n\n\tcb->start = em->orig_start;\n\tem_len = em->len;\n\tem_start = em->start;\n\n\tfree_extent_map(em);\n\tem = NULL;\n\n\tcb->len = uncompressed_len;\n\tcb->compressed_len = compressed_len;\n\tcb->compress_type = extent_compress_type(bio_flags);\n\tcb->orig_bio = bio;\n\n\tnr_pages = DIV_ROUND_UP(compressed_len, PAGE_CACHE_SIZE);\n\tcb->compressed_pages = kzalloc(sizeof(struct page *) * nr_pages,\n\t\t\t\t       GFP_NOFS);\n\tif (!cb->compressed_pages)\n\t\tgoto fail1;\n\n\tbdev = BTRFS_I(inode)->root->fs_info->fs_devices->latest_bdev;\n\n\tfor (pg_index = 0; pg_index < nr_pages; pg_index++) {\n\t\tcb->compressed_pages[pg_index] = alloc_page(GFP_NOFS |\n\t\t\t\t\t\t\t      __GFP_HIGHMEM);\n\t\tif (!cb->compressed_pages[pg_index]) {\n\t\t\tfaili = pg_index - 1;\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail2;\n\t\t}\n\t}\n\tfaili = nr_pages - 1;\n\tcb->nr_pages = nr_pages;\n\n\t/* In the parent-locked case, we only locked the range we are\n\t * interested in.  In all other cases, we can opportunistically\n\t * cache decompressed data that goes beyond the requested range. */\n\tif (!(bio_flags & EXTENT_BIO_PARENT_LOCKED))\n\t\tadd_ra_bio_pages(inode, em_start + em_len, cb);\n\n\t/* include any pages we added in add_ra-bio_pages */\n\tuncompressed_len = bio->bi_vcnt * PAGE_CACHE_SIZE;\n\tcb->len = uncompressed_len;\n\n\tcomp_bio = compressed_bio_alloc(bdev, cur_disk_byte, GFP_NOFS);\n\tif (!comp_bio)\n\t\tgoto fail2;\n\tcomp_bio->bi_private = cb;\n\tcomp_bio->bi_end_io = end_compressed_bio_read;\n\tatomic_inc(&cb->pending_bios);\n\n\tfor (pg_index = 0; pg_index < nr_pages; pg_index++) {\n\t\tpage = cb->compressed_pages[pg_index];\n\t\tpage->mapping = inode->i_mapping;\n\t\tpage->index = em_start >> PAGE_CACHE_SHIFT;\n\n\t\tif (comp_bio->bi_iter.bi_size)\n\t\t\tret = tree->ops->merge_bio_hook(READ, page, 0,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE,\n\t\t\t\t\t\t\tcomp_bio, 0);\n\t\telse\n\t\t\tret = 0;\n\n\t\tpage->mapping = NULL;\n\t\tif (ret || bio_add_page(comp_bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t    PAGE_CACHE_SIZE) {\n\t\t\tbio_get(comp_bio);\n\n\t\t\tret = btrfs_bio_wq_end_io(root->fs_info, comp_bio,\n\t\t\t\t\tBTRFS_WQ_ENDIO_DATA);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\n\t\t\t/*\n\t\t\t * inc the count before we submit the bio so\n\t\t\t * we know the end IO handler won't happen before\n\t\t\t * we inc the count.  Otherwise, the cb might get\n\t\t\t * freed before we're done setting it up\n\t\t\t */\n\t\t\tatomic_inc(&cb->pending_bios);\n\n\t\t\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)) {\n\t\t\t\tret = btrfs_lookup_bio_sums(root, inode,\n\t\t\t\t\t\t\tcomp_bio, sums);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tsums += DIV_ROUND_UP(comp_bio->bi_iter.bi_size,\n\t\t\t\t\t     root->sectorsize);\n\n\t\t\tret = btrfs_map_bio(root, READ, comp_bio,\n\t\t\t\t\t    mirror_num, 0);\n\t\t\tif (ret)\n\t\t\t\tbio_endio(comp_bio, ret);\n\n\t\t\tbio_put(comp_bio);\n\n\t\t\tcomp_bio = compressed_bio_alloc(bdev, cur_disk_byte,\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\tBUG_ON(!comp_bio);\n\t\t\tcomp_bio->bi_private = cb;\n\t\t\tcomp_bio->bi_end_io = end_compressed_bio_read;\n\n\t\t\tbio_add_page(comp_bio, page, PAGE_CACHE_SIZE, 0);\n\t\t}\n\t\tcur_disk_byte += PAGE_CACHE_SIZE;\n\t}\n\tbio_get(comp_bio);\n\n\tret = btrfs_bio_wq_end_io(root->fs_info, comp_bio,\n\t\t\tBTRFS_WQ_ENDIO_DATA);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)) {\n\t\tret = btrfs_lookup_bio_sums(root, inode, comp_bio, sums);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tret = btrfs_map_bio(root, READ, comp_bio, mirror_num, 0);\n\tif (ret)\n\t\tbio_endio(comp_bio, ret);\n\n\tbio_put(comp_bio);\n\treturn 0;\n\nfail2:\n\twhile (faili >= 0) {\n\t\t__free_page(cb->compressed_pages[faili]);\n\t\tfaili--;\n\t}\n\n\tkfree(cb->compressed_pages);\nfail1:\n\tkfree(cb);\nout:\n\tfree_extent_map(em);\n\treturn ret;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cb"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cb->compressed_pages"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "cb->compressed_pages[faili]"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "comp_bio"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_endio",
          "args": [
            "comp_bio",
            "ret"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_bio_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2667-2679",
          "snippet": "static void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_map_bio",
          "args": [
            "root",
            "READ",
            "comp_bio",
            "mirror_num",
            "0"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_map_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5829-5916",
          "snippet": "int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,\n\t\t  int mirror_num, int async_submit)\n{\n\tstruct btrfs_device *dev;\n\tstruct bio *first_bio = bio;\n\tu64 logical = (u64)bio->bi_iter.bi_sector << 9;\n\tu64 length = 0;\n\tu64 map_length;\n\tint ret;\n\tint dev_nr = 0;\n\tint total_devs = 1;\n\tstruct btrfs_bio *bbio = NULL;\n\n\tlength = bio->bi_iter.bi_size;\n\tmap_length = length;\n\n\tbtrfs_bio_counter_inc_blocked(root->fs_info);\n\tret = __btrfs_map_block(root->fs_info, rw, logical, &map_length, &bbio,\n\t\t\t      mirror_num, 1);\n\tif (ret) {\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\ttotal_devs = bbio->num_stripes;\n\tbbio->orig_bio = first_bio;\n\tbbio->private = first_bio->bi_private;\n\tbbio->end_io = first_bio->bi_end_io;\n\tbbio->fs_info = root->fs_info;\n\tatomic_set(&bbio->stripes_pending, bbio->num_stripes);\n\n\tif (bbio->raid_map) {\n\t\t/* In this case, map_length has been set to the length of\n\t\t   a single stripe; not the whole write */\n\t\tif (rw & WRITE) {\n\t\t\tret = raid56_parity_write(root, bio, bbio, map_length);\n\t\t} else {\n\t\t\tret = raid56_parity_recover(root, bio, bbio, map_length,\n\t\t\t\t\t\t    mirror_num, 1);\n\t\t}\n\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tif (map_length < length) {\n\t\tbtrfs_crit(root->fs_info, \"mapping failed logical %llu bio len %llu len %llu\",\n\t\t\tlogical, length, map_length);\n\t\tBUG();\n\t}\n\n\twhile (dev_nr < total_devs) {\n\t\tdev = bbio->stripes[dev_nr].dev;\n\t\tif (!dev || !dev->bdev || (rw & WRITE && !dev->writeable)) {\n\t\t\tbbio_error(bbio, first_bio, logical);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check and see if we're ok with this bio based on it's size\n\t\t * and offset with the given device.\n\t\t */\n\t\tif (!bio_size_ok(dev->bdev, first_bio,\n\t\t\t\t bbio->stripes[dev_nr].physical >> 9)) {\n\t\t\tret = breakup_stripe_bio(root, bbio, first_bio, dev,\n\t\t\t\t\t\t dev_nr, rw, async_submit);\n\t\t\tBUG_ON(ret);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_nr < total_devs - 1) {\n\t\t\tbio = btrfs_bio_clone(first_bio, GFP_NOFS);\n\t\t\tBUG_ON(!bio); /* -ENOMEM */\n\t\t} else {\n\t\t\tbio = first_bio;\n\t\t\tbbio->flags |= BTRFS_BIO_ORIG_BIO_SUBMITTED;\n\t\t}\n\n\t\tsubmit_stripe_bio(root, bbio, bio,\n\t\t\t\t  bbio->stripes[dev_nr].physical, dev_nr, rw,\n\t\t\t\t  async_submit);\n\t\tdev_nr++;\n\t}\n\tbtrfs_bio_counter_dec(root->fs_info);\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,\n\t\t  int mirror_num, int async_submit)\n{\n\tstruct btrfs_device *dev;\n\tstruct bio *first_bio = bio;\n\tu64 logical = (u64)bio->bi_iter.bi_sector << 9;\n\tu64 length = 0;\n\tu64 map_length;\n\tint ret;\n\tint dev_nr = 0;\n\tint total_devs = 1;\n\tstruct btrfs_bio *bbio = NULL;\n\n\tlength = bio->bi_iter.bi_size;\n\tmap_length = length;\n\n\tbtrfs_bio_counter_inc_blocked(root->fs_info);\n\tret = __btrfs_map_block(root->fs_info, rw, logical, &map_length, &bbio,\n\t\t\t      mirror_num, 1);\n\tif (ret) {\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\ttotal_devs = bbio->num_stripes;\n\tbbio->orig_bio = first_bio;\n\tbbio->private = first_bio->bi_private;\n\tbbio->end_io = first_bio->bi_end_io;\n\tbbio->fs_info = root->fs_info;\n\tatomic_set(&bbio->stripes_pending, bbio->num_stripes);\n\n\tif (bbio->raid_map) {\n\t\t/* In this case, map_length has been set to the length of\n\t\t   a single stripe; not the whole write */\n\t\tif (rw & WRITE) {\n\t\t\tret = raid56_parity_write(root, bio, bbio, map_length);\n\t\t} else {\n\t\t\tret = raid56_parity_recover(root, bio, bbio, map_length,\n\t\t\t\t\t\t    mirror_num, 1);\n\t\t}\n\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tif (map_length < length) {\n\t\tbtrfs_crit(root->fs_info, \"mapping failed logical %llu bio len %llu len %llu\",\n\t\t\tlogical, length, map_length);\n\t\tBUG();\n\t}\n\n\twhile (dev_nr < total_devs) {\n\t\tdev = bbio->stripes[dev_nr].dev;\n\t\tif (!dev || !dev->bdev || (rw & WRITE && !dev->writeable)) {\n\t\t\tbbio_error(bbio, first_bio, logical);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check and see if we're ok with this bio based on it's size\n\t\t * and offset with the given device.\n\t\t */\n\t\tif (!bio_size_ok(dev->bdev, first_bio,\n\t\t\t\t bbio->stripes[dev_nr].physical >> 9)) {\n\t\t\tret = breakup_stripe_bio(root, bbio, first_bio, dev,\n\t\t\t\t\t\t dev_nr, rw, async_submit);\n\t\t\tBUG_ON(ret);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_nr < total_devs - 1) {\n\t\t\tbio = btrfs_bio_clone(first_bio, GFP_NOFS);\n\t\t\tBUG_ON(!bio); /* -ENOMEM */\n\t\t} else {\n\t\t\tbio = first_bio;\n\t\t\tbbio->flags |= BTRFS_BIO_ORIG_BIO_SUBMITTED;\n\t\t}\n\n\t\tsubmit_stripe_bio(root, bbio, bio,\n\t\t\t\t  bbio->stripes[dev_nr].physical, dev_nr, rw,\n\t\t\t\t  async_submit);\n\t\tdev_nr++;\n\t}\n\tbtrfs_bio_counter_dec(root->fs_info);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_bio_sums",
          "args": [
            "root",
            "inode",
            "comp_bio",
            "sums"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_bio_sums_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "301-305",
          "snippet": "int btrfs_lookup_bio_sums_dio(struct btrfs_root *root, struct inode *inode,\n\t\t\t      struct bio *bio, u64 offset)\n{\n\treturn __btrfs_lookup_bio_sums(root, inode, bio, offset, NULL, 1);\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_lookup_bio_sums_dio(struct btrfs_root *root, struct inode *inode,\n\t\t\t      struct bio *bio, u64 offset)\n{\n\treturn __btrfs_lookup_bio_sums(root, inode, bio, offset, NULL, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_bio_wq_end_io",
          "args": [
            "root->fs_info",
            "comp_bio",
            "BTRFS_WQ_ENDIO_DATA"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_wq_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "756-775",
          "snippet": "int btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_end_io_wq_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_end_io_wq_cache;\n\nint btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_get",
          "args": [
            "comp_bio"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "comp_bio",
            "page",
            "PAGE_CACHE_SIZE",
            "0"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!comp_bio"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compressed_bio_alloc",
          "args": [
            "bdev",
            "cur_disk_byte",
            "GFP_NOFS"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "compressed_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "97-104",
          "snippet": "static struct bio *compressed_bio_alloc(struct block_device *bdev,\n\t\t\t\t\tu64 first_byte, gfp_t gfp_flags)\n{\n\tint nr_vecs;\n\n\tnr_vecs = bio_get_nr_vecs(bdev);\n\treturn btrfs_bio_alloc(bdev, first_byte >> 9, nr_vecs, gfp_flags);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct bio *compressed_bio_alloc(struct block_device *bdev,\n\t\t\t\t\tu64 first_byte, gfp_t gfp_flags)\n{\n\tint nr_vecs;\n\n\tnr_vecs = bio_get_nr_vecs(bdev);\n\treturn btrfs_bio_alloc(bdev, first_byte >> 9, nr_vecs, gfp_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "comp_bio"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "comp_bio->bi_iter.bi_size",
            "root->sectorsize"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cb->pending_bios"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_get",
          "args": [
            "comp_bio"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "comp_bio",
            "page",
            "PAGE_CACHE_SIZE",
            "0"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree->ops->merge_bio_hook",
          "args": [
            "READ",
            "page",
            "0",
            "PAGE_CACHE_SIZE",
            "comp_bio",
            "0"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cb->pending_bios"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_ra_bio_pages",
          "args": [
            "inode",
            "em_start + em_len",
            "cb"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "add_ra_bio_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "444-553",
          "snippet": "static noinline int add_ra_bio_pages(struct inode *inode,\n\t\t\t\t     u64 compressed_end,\n\t\t\t\t     struct compressed_bio *cb)\n{\n\tunsigned long end_index;\n\tunsigned long pg_index;\n\tu64 last_offset;\n\tu64 isize = i_size_read(inode);\n\tint ret;\n\tstruct page *page;\n\tunsigned long nr_pages = 0;\n\tstruct extent_map *em;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_io_tree *tree;\n\tu64 end;\n\tint misses = 0;\n\n\tpage = cb->orig_bio->bi_io_vec[cb->orig_bio->bi_vcnt - 1].bv_page;\n\tlast_offset = (page_offset(page) + PAGE_CACHE_SIZE);\n\tem_tree = &BTRFS_I(inode)->extent_tree;\n\ttree = &BTRFS_I(inode)->io_tree;\n\n\tif (isize == 0)\n\t\treturn 0;\n\n\tend_index = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\n\n\twhile (last_offset < compressed_end) {\n\t\tpg_index = last_offset >> PAGE_CACHE_SHIFT;\n\n\t\tif (pg_index > end_index)\n\t\t\tbreak;\n\n\t\trcu_read_lock();\n\t\tpage = radix_tree_lookup(&mapping->page_tree, pg_index);\n\t\trcu_read_unlock();\n\t\tif (page && !radix_tree_exceptional_entry(page)) {\n\t\t\tmisses++;\n\t\t\tif (misses > 4)\n\t\t\t\tbreak;\n\t\t\tgoto next;\n\t\t}\n\n\t\tpage = __page_cache_alloc(mapping_gfp_mask(mapping) &\n\t\t\t\t\t\t\t\t~__GFP_FS);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (add_to_page_cache_lru(page, mapping, pg_index,\n\t\t\t\t\t\t\t\tGFP_NOFS)) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto next;\n\t\t}\n\n\t\tend = last_offset + PAGE_CACHE_SIZE - 1;\n\t\t/*\n\t\t * at this point, we have a locked page in the page cache\n\t\t * for these bytes in the file.  But, we have to make\n\t\t * sure they map to this compressed extent on disk.\n\t\t */\n\t\tset_page_extent_mapped(page);\n\t\tlock_extent(tree, last_offset, end);\n\t\tread_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, last_offset,\n\t\t\t\t\t   PAGE_CACHE_SIZE);\n\t\tread_unlock(&em_tree->lock);\n\n\t\tif (!em || last_offset < em->start ||\n\t\t    (last_offset + PAGE_CACHE_SIZE > extent_map_end(em)) ||\n\t\t    (em->block_start >> 9) != cb->orig_bio->bi_iter.bi_sector) {\n\t\t\tfree_extent_map(em);\n\t\t\tunlock_extent(tree, last_offset, end);\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbreak;\n\t\t}\n\t\tfree_extent_map(em);\n\n\t\tif (page->index == end_index) {\n\t\t\tchar *userpage;\n\t\t\tsize_t zero_offset = isize & (PAGE_CACHE_SIZE - 1);\n\n\t\t\tif (zero_offset) {\n\t\t\t\tint zeros;\n\t\t\t\tzeros = PAGE_CACHE_SIZE - zero_offset;\n\t\t\t\tuserpage = kmap_atomic(page);\n\t\t\t\tmemset(userpage + zero_offset, 0, zeros);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap_atomic(userpage);\n\t\t\t}\n\t\t}\n\n\t\tret = bio_add_page(cb->orig_bio, page,\n\t\t\t\t   PAGE_CACHE_SIZE, 0);\n\n\t\tif (ret == PAGE_CACHE_SIZE) {\n\t\t\tnr_pages++;\n\t\t\tpage_cache_release(page);\n\t\t} else {\n\t\t\tunlock_extent(tree, last_offset, end);\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbreak;\n\t\t}\nnext:\n\t\tlast_offset += PAGE_CACHE_SIZE;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int add_ra_bio_pages(struct inode *inode,\n\t\t\t\t     u64 compressed_end,\n\t\t\t\t     struct compressed_bio *cb)\n{\n\tunsigned long end_index;\n\tunsigned long pg_index;\n\tu64 last_offset;\n\tu64 isize = i_size_read(inode);\n\tint ret;\n\tstruct page *page;\n\tunsigned long nr_pages = 0;\n\tstruct extent_map *em;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_io_tree *tree;\n\tu64 end;\n\tint misses = 0;\n\n\tpage = cb->orig_bio->bi_io_vec[cb->orig_bio->bi_vcnt - 1].bv_page;\n\tlast_offset = (page_offset(page) + PAGE_CACHE_SIZE);\n\tem_tree = &BTRFS_I(inode)->extent_tree;\n\ttree = &BTRFS_I(inode)->io_tree;\n\n\tif (isize == 0)\n\t\treturn 0;\n\n\tend_index = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\n\n\twhile (last_offset < compressed_end) {\n\t\tpg_index = last_offset >> PAGE_CACHE_SHIFT;\n\n\t\tif (pg_index > end_index)\n\t\t\tbreak;\n\n\t\trcu_read_lock();\n\t\tpage = radix_tree_lookup(&mapping->page_tree, pg_index);\n\t\trcu_read_unlock();\n\t\tif (page && !radix_tree_exceptional_entry(page)) {\n\t\t\tmisses++;\n\t\t\tif (misses > 4)\n\t\t\t\tbreak;\n\t\t\tgoto next;\n\t\t}\n\n\t\tpage = __page_cache_alloc(mapping_gfp_mask(mapping) &\n\t\t\t\t\t\t\t\t~__GFP_FS);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (add_to_page_cache_lru(page, mapping, pg_index,\n\t\t\t\t\t\t\t\tGFP_NOFS)) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto next;\n\t\t}\n\n\t\tend = last_offset + PAGE_CACHE_SIZE - 1;\n\t\t/*\n\t\t * at this point, we have a locked page in the page cache\n\t\t * for these bytes in the file.  But, we have to make\n\t\t * sure they map to this compressed extent on disk.\n\t\t */\n\t\tset_page_extent_mapped(page);\n\t\tlock_extent(tree, last_offset, end);\n\t\tread_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, last_offset,\n\t\t\t\t\t   PAGE_CACHE_SIZE);\n\t\tread_unlock(&em_tree->lock);\n\n\t\tif (!em || last_offset < em->start ||\n\t\t    (last_offset + PAGE_CACHE_SIZE > extent_map_end(em)) ||\n\t\t    (em->block_start >> 9) != cb->orig_bio->bi_iter.bi_sector) {\n\t\t\tfree_extent_map(em);\n\t\t\tunlock_extent(tree, last_offset, end);\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbreak;\n\t\t}\n\t\tfree_extent_map(em);\n\n\t\tif (page->index == end_index) {\n\t\t\tchar *userpage;\n\t\t\tsize_t zero_offset = isize & (PAGE_CACHE_SIZE - 1);\n\n\t\t\tif (zero_offset) {\n\t\t\t\tint zeros;\n\t\t\t\tzeros = PAGE_CACHE_SIZE - zero_offset;\n\t\t\t\tuserpage = kmap_atomic(page);\n\t\t\t\tmemset(userpage + zero_offset, 0, zeros);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap_atomic(userpage);\n\t\t\t}\n\t\t}\n\n\t\tret = bio_add_page(cb->orig_bio, page,\n\t\t\t\t   PAGE_CACHE_SIZE, 0);\n\n\t\tif (ret == PAGE_CACHE_SIZE) {\n\t\t\tnr_pages++;\n\t\t\tpage_cache_release(page);\n\t\t} else {\n\t\t\tunlock_extent(tree, last_offset, end);\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbreak;\n\t\t}\nnext:\n\t\tlast_offset += PAGE_CACHE_SIZE;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_NOFS |\n\t\t\t\t\t\t\t      __GFP_HIGHMEM"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct page *) * nr_pages",
            "GFP_NOFS"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "compressed_len",
            "PAGE_CACHE_SIZE"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_compress_type",
          "args": [
            "bio_flags"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "extent_compress_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "170-173",
          "snippet": "static inline int extent_compress_type(unsigned long bio_flags)\n{\n\treturn bio_flags >> EXTENT_BIO_FLAG_SHIFT;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [
            "#define EXTENT_BIO_FLAG_SHIFT 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\n#define EXTENT_BIO_FLAG_SHIFT 16\n\nstatic inline int extent_compress_type(unsigned long bio_flags)\n{\n\treturn bio_flags >> EXTENT_BIO_FLAG_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cb->pending_bios",
            "0"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "compressed_bio_size(root, compressed_len)",
            "GFP_NOFS"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compressed_bio_size",
          "args": [
            "root",
            "compressed_len"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "compressed_bio_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "88-95",
          "snippet": "static inline int compressed_bio_size(struct btrfs_root *root,\n\t\t\t\t      unsigned long disk_size)\n{\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\treturn sizeof(struct compressed_bio) +\n\t\t(DIV_ROUND_UP(disk_size, root->sectorsize)) * csum_size;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline int compressed_bio_size(struct btrfs_root *root,\n\t\t\t\t      unsigned long disk_size)\n{\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\treturn sizeof(struct compressed_bio) +\n\t\t(DIV_ROUND_UP(disk_size, root->sectorsize)) * csum_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "page_offset(bio->bi_io_vec->bv_page)",
            "PAGE_CACHE_SIZE"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "bio->bi_io_vec->bv_page"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_submit_compressed_read(struct inode *inode, struct bio *bio,\n\t\t\t\t int mirror_num, unsigned long bio_flags)\n{\n\tstruct extent_io_tree *tree;\n\tstruct extent_map_tree *em_tree;\n\tstruct compressed_bio *cb;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tunsigned long uncompressed_len = bio->bi_vcnt * PAGE_CACHE_SIZE;\n\tunsigned long compressed_len;\n\tunsigned long nr_pages;\n\tunsigned long pg_index;\n\tstruct page *page;\n\tstruct block_device *bdev;\n\tstruct bio *comp_bio;\n\tu64 cur_disk_byte = (u64)bio->bi_iter.bi_sector << 9;\n\tu64 em_len;\n\tu64 em_start;\n\tstruct extent_map *em;\n\tint ret = -ENOMEM;\n\tint faili = 0;\n\tu32 *sums;\n\n\ttree = &BTRFS_I(inode)->io_tree;\n\tem_tree = &BTRFS_I(inode)->extent_tree;\n\n\t/* we need the actual starting offset of this extent in the file */\n\tread_lock(&em_tree->lock);\n\tem = lookup_extent_mapping(em_tree,\n\t\t\t\t   page_offset(bio->bi_io_vec->bv_page),\n\t\t\t\t   PAGE_CACHE_SIZE);\n\tread_unlock(&em_tree->lock);\n\tif (!em)\n\t\treturn -EIO;\n\n\tcompressed_len = em->block_len;\n\tcb = kmalloc(compressed_bio_size(root, compressed_len), GFP_NOFS);\n\tif (!cb)\n\t\tgoto out;\n\n\tatomic_set(&cb->pending_bios, 0);\n\tcb->errors = 0;\n\tcb->inode = inode;\n\tcb->mirror_num = mirror_num;\n\tsums = &cb->sums;\n\n\tcb->start = em->orig_start;\n\tem_len = em->len;\n\tem_start = em->start;\n\n\tfree_extent_map(em);\n\tem = NULL;\n\n\tcb->len = uncompressed_len;\n\tcb->compressed_len = compressed_len;\n\tcb->compress_type = extent_compress_type(bio_flags);\n\tcb->orig_bio = bio;\n\n\tnr_pages = DIV_ROUND_UP(compressed_len, PAGE_CACHE_SIZE);\n\tcb->compressed_pages = kzalloc(sizeof(struct page *) * nr_pages,\n\t\t\t\t       GFP_NOFS);\n\tif (!cb->compressed_pages)\n\t\tgoto fail1;\n\n\tbdev = BTRFS_I(inode)->root->fs_info->fs_devices->latest_bdev;\n\n\tfor (pg_index = 0; pg_index < nr_pages; pg_index++) {\n\t\tcb->compressed_pages[pg_index] = alloc_page(GFP_NOFS |\n\t\t\t\t\t\t\t      __GFP_HIGHMEM);\n\t\tif (!cb->compressed_pages[pg_index]) {\n\t\t\tfaili = pg_index - 1;\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail2;\n\t\t}\n\t}\n\tfaili = nr_pages - 1;\n\tcb->nr_pages = nr_pages;\n\n\t/* In the parent-locked case, we only locked the range we are\n\t * interested in.  In all other cases, we can opportunistically\n\t * cache decompressed data that goes beyond the requested range. */\n\tif (!(bio_flags & EXTENT_BIO_PARENT_LOCKED))\n\t\tadd_ra_bio_pages(inode, em_start + em_len, cb);\n\n\t/* include any pages we added in add_ra-bio_pages */\n\tuncompressed_len = bio->bi_vcnt * PAGE_CACHE_SIZE;\n\tcb->len = uncompressed_len;\n\n\tcomp_bio = compressed_bio_alloc(bdev, cur_disk_byte, GFP_NOFS);\n\tif (!comp_bio)\n\t\tgoto fail2;\n\tcomp_bio->bi_private = cb;\n\tcomp_bio->bi_end_io = end_compressed_bio_read;\n\tatomic_inc(&cb->pending_bios);\n\n\tfor (pg_index = 0; pg_index < nr_pages; pg_index++) {\n\t\tpage = cb->compressed_pages[pg_index];\n\t\tpage->mapping = inode->i_mapping;\n\t\tpage->index = em_start >> PAGE_CACHE_SHIFT;\n\n\t\tif (comp_bio->bi_iter.bi_size)\n\t\t\tret = tree->ops->merge_bio_hook(READ, page, 0,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE,\n\t\t\t\t\t\t\tcomp_bio, 0);\n\t\telse\n\t\t\tret = 0;\n\n\t\tpage->mapping = NULL;\n\t\tif (ret || bio_add_page(comp_bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t    PAGE_CACHE_SIZE) {\n\t\t\tbio_get(comp_bio);\n\n\t\t\tret = btrfs_bio_wq_end_io(root->fs_info, comp_bio,\n\t\t\t\t\tBTRFS_WQ_ENDIO_DATA);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\n\t\t\t/*\n\t\t\t * inc the count before we submit the bio so\n\t\t\t * we know the end IO handler won't happen before\n\t\t\t * we inc the count.  Otherwise, the cb might get\n\t\t\t * freed before we're done setting it up\n\t\t\t */\n\t\t\tatomic_inc(&cb->pending_bios);\n\n\t\t\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)) {\n\t\t\t\tret = btrfs_lookup_bio_sums(root, inode,\n\t\t\t\t\t\t\tcomp_bio, sums);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tsums += DIV_ROUND_UP(comp_bio->bi_iter.bi_size,\n\t\t\t\t\t     root->sectorsize);\n\n\t\t\tret = btrfs_map_bio(root, READ, comp_bio,\n\t\t\t\t\t    mirror_num, 0);\n\t\t\tif (ret)\n\t\t\t\tbio_endio(comp_bio, ret);\n\n\t\t\tbio_put(comp_bio);\n\n\t\t\tcomp_bio = compressed_bio_alloc(bdev, cur_disk_byte,\n\t\t\t\t\t\t\tGFP_NOFS);\n\t\t\tBUG_ON(!comp_bio);\n\t\t\tcomp_bio->bi_private = cb;\n\t\t\tcomp_bio->bi_end_io = end_compressed_bio_read;\n\n\t\t\tbio_add_page(comp_bio, page, PAGE_CACHE_SIZE, 0);\n\t\t}\n\t\tcur_disk_byte += PAGE_CACHE_SIZE;\n\t}\n\tbio_get(comp_bio);\n\n\tret = btrfs_bio_wq_end_io(root->fs_info, comp_bio,\n\t\t\tBTRFS_WQ_ENDIO_DATA);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\tif (!(BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)) {\n\t\tret = btrfs_lookup_bio_sums(root, inode, comp_bio, sums);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tret = btrfs_map_bio(root, READ, comp_bio, mirror_num, 0);\n\tif (ret)\n\t\tbio_endio(comp_bio, ret);\n\n\tbio_put(comp_bio);\n\treturn 0;\n\nfail2:\n\twhile (faili >= 0) {\n\t\t__free_page(cb->compressed_pages[faili]);\n\t\tfaili--;\n\t}\n\n\tkfree(cb->compressed_pages);\nfail1:\n\tkfree(cb);\nout:\n\tfree_extent_map(em);\n\treturn ret;\n}"
  },
  {
    "function_name": "add_ra_bio_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "444-553",
    "snippet": "static noinline int add_ra_bio_pages(struct inode *inode,\n\t\t\t\t     u64 compressed_end,\n\t\t\t\t     struct compressed_bio *cb)\n{\n\tunsigned long end_index;\n\tunsigned long pg_index;\n\tu64 last_offset;\n\tu64 isize = i_size_read(inode);\n\tint ret;\n\tstruct page *page;\n\tunsigned long nr_pages = 0;\n\tstruct extent_map *em;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_io_tree *tree;\n\tu64 end;\n\tint misses = 0;\n\n\tpage = cb->orig_bio->bi_io_vec[cb->orig_bio->bi_vcnt - 1].bv_page;\n\tlast_offset = (page_offset(page) + PAGE_CACHE_SIZE);\n\tem_tree = &BTRFS_I(inode)->extent_tree;\n\ttree = &BTRFS_I(inode)->io_tree;\n\n\tif (isize == 0)\n\t\treturn 0;\n\n\tend_index = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\n\n\twhile (last_offset < compressed_end) {\n\t\tpg_index = last_offset >> PAGE_CACHE_SHIFT;\n\n\t\tif (pg_index > end_index)\n\t\t\tbreak;\n\n\t\trcu_read_lock();\n\t\tpage = radix_tree_lookup(&mapping->page_tree, pg_index);\n\t\trcu_read_unlock();\n\t\tif (page && !radix_tree_exceptional_entry(page)) {\n\t\t\tmisses++;\n\t\t\tif (misses > 4)\n\t\t\t\tbreak;\n\t\t\tgoto next;\n\t\t}\n\n\t\tpage = __page_cache_alloc(mapping_gfp_mask(mapping) &\n\t\t\t\t\t\t\t\t~__GFP_FS);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (add_to_page_cache_lru(page, mapping, pg_index,\n\t\t\t\t\t\t\t\tGFP_NOFS)) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto next;\n\t\t}\n\n\t\tend = last_offset + PAGE_CACHE_SIZE - 1;\n\t\t/*\n\t\t * at this point, we have a locked page in the page cache\n\t\t * for these bytes in the file.  But, we have to make\n\t\t * sure they map to this compressed extent on disk.\n\t\t */\n\t\tset_page_extent_mapped(page);\n\t\tlock_extent(tree, last_offset, end);\n\t\tread_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, last_offset,\n\t\t\t\t\t   PAGE_CACHE_SIZE);\n\t\tread_unlock(&em_tree->lock);\n\n\t\tif (!em || last_offset < em->start ||\n\t\t    (last_offset + PAGE_CACHE_SIZE > extent_map_end(em)) ||\n\t\t    (em->block_start >> 9) != cb->orig_bio->bi_iter.bi_sector) {\n\t\t\tfree_extent_map(em);\n\t\t\tunlock_extent(tree, last_offset, end);\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbreak;\n\t\t}\n\t\tfree_extent_map(em);\n\n\t\tif (page->index == end_index) {\n\t\t\tchar *userpage;\n\t\t\tsize_t zero_offset = isize & (PAGE_CACHE_SIZE - 1);\n\n\t\t\tif (zero_offset) {\n\t\t\t\tint zeros;\n\t\t\t\tzeros = PAGE_CACHE_SIZE - zero_offset;\n\t\t\t\tuserpage = kmap_atomic(page);\n\t\t\t\tmemset(userpage + zero_offset, 0, zeros);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap_atomic(userpage);\n\t\t\t}\n\t\t}\n\n\t\tret = bio_add_page(cb->orig_bio, page,\n\t\t\t\t   PAGE_CACHE_SIZE, 0);\n\n\t\tif (ret == PAGE_CACHE_SIZE) {\n\t\t\tnr_pages++;\n\t\t\tpage_cache_release(page);\n\t\t} else {\n\t\t\tunlock_extent(tree, last_offset, end);\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbreak;\n\t\t}\nnext:\n\t\tlast_offset += PAGE_CACHE_SIZE;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "tree",
            "last_offset",
            "end"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "cb->orig_bio",
            "page",
            "PAGE_CACHE_SIZE",
            "0"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "userpage"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "userpage + zero_offset",
            "0",
            "zeros"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_map",
          "args": [
            "em"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "70-82",
          "snippet": "void free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid free_extent_map(struct extent_map *em)\n{\n\tif (!em)\n\t\treturn;\n\tWARN_ON(atomic_read(&em->refs) == 0);\n\tif (atomic_dec_and_test(&em->refs)) {\n\t\tWARN_ON(extent_map_in_tree(em));\n\t\tWARN_ON(!list_empty(&em->list));\n\t\tif (test_bit(EXTENT_FLAG_FS_MAPPING, &em->flags))\n\t\t\tkfree(em->bdev);\n\t\tkmem_cache_free(extent_map_cache, em);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_map_end",
          "args": [
            "em"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.h",
          "lines": "52-57",
          "snippet": "static inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline u64 extent_map_end(struct extent_map *em)\n{\n\tif (em->start + em->len < em->start)\n\t\treturn (u64)-1;\n\treturn em->start + em->len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_extent_mapping",
          "args": [
            "em_tree",
            "last_offset",
            "PAGE_CACHE_SIZE"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_extent_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "399-403",
          "snippet": "struct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstruct extent_map *lookup_extent_mapping(struct extent_map_tree *tree,\n\t\t\t\t\t u64 start, u64 len)\n{\n\treturn __lookup_extent_mapping(tree, start, len, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&em_tree->lock"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_extent",
          "args": [
            "tree",
            "last_offset",
            "end"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "lock_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ioctl.c",
          "lines": "2778-2801",
          "snippet": "static inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"props.h\"",
            "#include \"dev-replace.h\"",
            "#include \"send.h\"",
            "#include \"rcu-string.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"props.h\"\n#include \"dev-replace.h\"\n#include \"send.h\"\n#include \"rcu-string.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uaccess.h>\n#include <linux/btrfs.h>\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/xattr.h>\n#include <linux/security.h>\n#include <linux/bit_spinlock.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline void lock_extent_range(struct inode *inode, u64 off, u64 len)\n{\n\t/* do any pending delalloc/csum calc on src, one way or\n\t   another, and lock file content */\n\twhile (1) {\n\t\tstruct btrfs_ordered_extent *ordered;\n\t\tlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tordered = btrfs_lookup_first_ordered_extent(inode,\n\t\t\t\t\t\t\t    off + len - 1);\n\t\tif ((!ordered ||\n\t\t     ordered->file_offset + ordered->len <= off ||\n\t\t     ordered->file_offset >= off + len) &&\n\t\t    !test_range_bit(&BTRFS_I(inode)->io_tree, off,\n\t\t\t\t    off + len - 1, EXTENT_DELALLOC, 0, NULL)) {\n\t\t\tif (ordered)\n\t\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\t\tbreak;\n\t\t}\n\t\tunlock_extent(&BTRFS_I(inode)->io_tree, off, off + len - 1);\n\t\tif (ordered)\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\t\tbtrfs_wait_ordered_range(inode, off, len);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_extent_mapped",
          "args": [
            "page"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "set_page_extent_mapped",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2862-2869",
          "snippet": "void set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid set_page_extent_mapped(struct page *page)\n{\n\tif (!PagePrivate(page)) {\n\t\tSetPagePrivate(page);\n\t\tpage_cache_get(page);\n\t\tset_page_private(page, EXTENT_PAGE_PRIVATE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "mapping",
            "pg_index",
            "GFP_NOFS"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__page_cache_alloc",
          "args": [
            "mapping_gfp_mask(mapping) &\n\t\t\t\t\t\t\t\t~__GFP_FS"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_exceptional_entry",
          "args": [
            "page"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&mapping->page_tree",
            "pg_index"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline int add_ra_bio_pages(struct inode *inode,\n\t\t\t\t     u64 compressed_end,\n\t\t\t\t     struct compressed_bio *cb)\n{\n\tunsigned long end_index;\n\tunsigned long pg_index;\n\tu64 last_offset;\n\tu64 isize = i_size_read(inode);\n\tint ret;\n\tstruct page *page;\n\tunsigned long nr_pages = 0;\n\tstruct extent_map *em;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct extent_map_tree *em_tree;\n\tstruct extent_io_tree *tree;\n\tu64 end;\n\tint misses = 0;\n\n\tpage = cb->orig_bio->bi_io_vec[cb->orig_bio->bi_vcnt - 1].bv_page;\n\tlast_offset = (page_offset(page) + PAGE_CACHE_SIZE);\n\tem_tree = &BTRFS_I(inode)->extent_tree;\n\ttree = &BTRFS_I(inode)->io_tree;\n\n\tif (isize == 0)\n\t\treturn 0;\n\n\tend_index = (i_size_read(inode) - 1) >> PAGE_CACHE_SHIFT;\n\n\twhile (last_offset < compressed_end) {\n\t\tpg_index = last_offset >> PAGE_CACHE_SHIFT;\n\n\t\tif (pg_index > end_index)\n\t\t\tbreak;\n\n\t\trcu_read_lock();\n\t\tpage = radix_tree_lookup(&mapping->page_tree, pg_index);\n\t\trcu_read_unlock();\n\t\tif (page && !radix_tree_exceptional_entry(page)) {\n\t\t\tmisses++;\n\t\t\tif (misses > 4)\n\t\t\t\tbreak;\n\t\t\tgoto next;\n\t\t}\n\n\t\tpage = __page_cache_alloc(mapping_gfp_mask(mapping) &\n\t\t\t\t\t\t\t\t~__GFP_FS);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (add_to_page_cache_lru(page, mapping, pg_index,\n\t\t\t\t\t\t\t\tGFP_NOFS)) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto next;\n\t\t}\n\n\t\tend = last_offset + PAGE_CACHE_SIZE - 1;\n\t\t/*\n\t\t * at this point, we have a locked page in the page cache\n\t\t * for these bytes in the file.  But, we have to make\n\t\t * sure they map to this compressed extent on disk.\n\t\t */\n\t\tset_page_extent_mapped(page);\n\t\tlock_extent(tree, last_offset, end);\n\t\tread_lock(&em_tree->lock);\n\t\tem = lookup_extent_mapping(em_tree, last_offset,\n\t\t\t\t\t   PAGE_CACHE_SIZE);\n\t\tread_unlock(&em_tree->lock);\n\n\t\tif (!em || last_offset < em->start ||\n\t\t    (last_offset + PAGE_CACHE_SIZE > extent_map_end(em)) ||\n\t\t    (em->block_start >> 9) != cb->orig_bio->bi_iter.bi_sector) {\n\t\t\tfree_extent_map(em);\n\t\t\tunlock_extent(tree, last_offset, end);\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbreak;\n\t\t}\n\t\tfree_extent_map(em);\n\n\t\tif (page->index == end_index) {\n\t\t\tchar *userpage;\n\t\t\tsize_t zero_offset = isize & (PAGE_CACHE_SIZE - 1);\n\n\t\t\tif (zero_offset) {\n\t\t\t\tint zeros;\n\t\t\t\tzeros = PAGE_CACHE_SIZE - zero_offset;\n\t\t\t\tuserpage = kmap_atomic(page);\n\t\t\t\tmemset(userpage + zero_offset, 0, zeros);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tkunmap_atomic(userpage);\n\t\t\t}\n\t\t}\n\n\t\tret = bio_add_page(cb->orig_bio, page,\n\t\t\t\t   PAGE_CACHE_SIZE, 0);\n\n\t\tif (ret == PAGE_CACHE_SIZE) {\n\t\t\tnr_pages++;\n\t\t\tpage_cache_release(page);\n\t\t} else {\n\t\t\tunlock_extent(tree, last_offset, end);\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbreak;\n\t\t}\nnext:\n\t\tlast_offset += PAGE_CACHE_SIZE;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_submit_compressed_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "329-442",
    "snippet": "int btrfs_submit_compressed_write(struct inode *inode, u64 start,\n\t\t\t\t unsigned long len, u64 disk_start,\n\t\t\t\t unsigned long compressed_len,\n\t\t\t\t struct page **compressed_pages,\n\t\t\t\t unsigned long nr_pages)\n{\n\tstruct bio *bio = NULL;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct compressed_bio *cb;\n\tunsigned long bytes_left;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tint pg_index = 0;\n\tstruct page *page;\n\tu64 first_byte = disk_start;\n\tstruct block_device *bdev;\n\tint ret;\n\tint skip_sum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\n\tWARN_ON(start & ((u64)PAGE_CACHE_SIZE - 1));\n\tcb = kmalloc(compressed_bio_size(root, compressed_len), GFP_NOFS);\n\tif (!cb)\n\t\treturn -ENOMEM;\n\tatomic_set(&cb->pending_bios, 0);\n\tcb->errors = 0;\n\tcb->inode = inode;\n\tcb->start = start;\n\tcb->len = len;\n\tcb->mirror_num = 0;\n\tcb->compressed_pages = compressed_pages;\n\tcb->compressed_len = compressed_len;\n\tcb->orig_bio = NULL;\n\tcb->nr_pages = nr_pages;\n\n\tbdev = BTRFS_I(inode)->root->fs_info->fs_devices->latest_bdev;\n\n\tbio = compressed_bio_alloc(bdev, first_byte, GFP_NOFS);\n\tif (!bio) {\n\t\tkfree(cb);\n\t\treturn -ENOMEM;\n\t}\n\tbio->bi_private = cb;\n\tbio->bi_end_io = end_compressed_bio_write;\n\tatomic_inc(&cb->pending_bios);\n\n\t/* create and submit bios for the compressed pages */\n\tbytes_left = compressed_len;\n\tfor (pg_index = 0; pg_index < cb->nr_pages; pg_index++) {\n\t\tpage = compressed_pages[pg_index];\n\t\tpage->mapping = inode->i_mapping;\n\t\tif (bio->bi_iter.bi_size)\n\t\t\tret = io_tree->ops->merge_bio_hook(WRITE, page, 0,\n\t\t\t\t\t\t\t   PAGE_CACHE_SIZE,\n\t\t\t\t\t\t\t   bio, 0);\n\t\telse\n\t\t\tret = 0;\n\n\t\tpage->mapping = NULL;\n\t\tif (ret || bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t    PAGE_CACHE_SIZE) {\n\t\t\tbio_get(bio);\n\n\t\t\t/*\n\t\t\t * inc the count before we submit the bio so\n\t\t\t * we know the end IO handler won't happen before\n\t\t\t * we inc the count.  Otherwise, the cb might get\n\t\t\t * freed before we're done setting it up\n\t\t\t */\n\t\t\tatomic_inc(&cb->pending_bios);\n\t\t\tret = btrfs_bio_wq_end_io(root->fs_info, bio,\n\t\t\t\t\tBTRFS_WQ_ENDIO_DATA);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\n\t\t\tif (!skip_sum) {\n\t\t\t\tret = btrfs_csum_one_bio(root, inode, bio,\n\t\t\t\t\t\t\t start, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\n\t\t\tret = btrfs_map_bio(root, WRITE, bio, 0, 1);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\n\t\t\tbio_put(bio);\n\n\t\t\tbio = compressed_bio_alloc(bdev, first_byte, GFP_NOFS);\n\t\t\tBUG_ON(!bio);\n\t\t\tbio->bi_private = cb;\n\t\t\tbio->bi_end_io = end_compressed_bio_write;\n\t\t\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\t\t}\n\t\tif (bytes_left < PAGE_CACHE_SIZE) {\n\t\t\tbtrfs_info(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t\"bytes left %lu compress len %lu nr %lu\",\n\t\t\t       bytes_left, cb->compressed_len, cb->nr_pages);\n\t\t}\n\t\tbytes_left -= PAGE_CACHE_SIZE;\n\t\tfirst_byte += PAGE_CACHE_SIZE;\n\t\tcond_resched();\n\t}\n\tbio_get(bio);\n\n\tret = btrfs_bio_wq_end_io(root->fs_info, bio, BTRFS_WQ_ENDIO_DATA);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\tif (!skip_sum) {\n\t\tret = btrfs_csum_one_bio(root, inode, bio, start, 1);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tret = btrfs_map_bio(root, WRITE, bio, 0, 1);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\tbio_put(bio);\n\treturn 0;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_map_bio",
          "args": [
            "root",
            "WRITE",
            "bio",
            "0",
            "1"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_map_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5829-5916",
          "snippet": "int btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,\n\t\t  int mirror_num, int async_submit)\n{\n\tstruct btrfs_device *dev;\n\tstruct bio *first_bio = bio;\n\tu64 logical = (u64)bio->bi_iter.bi_sector << 9;\n\tu64 length = 0;\n\tu64 map_length;\n\tint ret;\n\tint dev_nr = 0;\n\tint total_devs = 1;\n\tstruct btrfs_bio *bbio = NULL;\n\n\tlength = bio->bi_iter.bi_size;\n\tmap_length = length;\n\n\tbtrfs_bio_counter_inc_blocked(root->fs_info);\n\tret = __btrfs_map_block(root->fs_info, rw, logical, &map_length, &bbio,\n\t\t\t      mirror_num, 1);\n\tif (ret) {\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\ttotal_devs = bbio->num_stripes;\n\tbbio->orig_bio = first_bio;\n\tbbio->private = first_bio->bi_private;\n\tbbio->end_io = first_bio->bi_end_io;\n\tbbio->fs_info = root->fs_info;\n\tatomic_set(&bbio->stripes_pending, bbio->num_stripes);\n\n\tif (bbio->raid_map) {\n\t\t/* In this case, map_length has been set to the length of\n\t\t   a single stripe; not the whole write */\n\t\tif (rw & WRITE) {\n\t\t\tret = raid56_parity_write(root, bio, bbio, map_length);\n\t\t} else {\n\t\t\tret = raid56_parity_recover(root, bio, bbio, map_length,\n\t\t\t\t\t\t    mirror_num, 1);\n\t\t}\n\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tif (map_length < length) {\n\t\tbtrfs_crit(root->fs_info, \"mapping failed logical %llu bio len %llu len %llu\",\n\t\t\tlogical, length, map_length);\n\t\tBUG();\n\t}\n\n\twhile (dev_nr < total_devs) {\n\t\tdev = bbio->stripes[dev_nr].dev;\n\t\tif (!dev || !dev->bdev || (rw & WRITE && !dev->writeable)) {\n\t\t\tbbio_error(bbio, first_bio, logical);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check and see if we're ok with this bio based on it's size\n\t\t * and offset with the given device.\n\t\t */\n\t\tif (!bio_size_ok(dev->bdev, first_bio,\n\t\t\t\t bbio->stripes[dev_nr].physical >> 9)) {\n\t\t\tret = breakup_stripe_bio(root, bbio, first_bio, dev,\n\t\t\t\t\t\t dev_nr, rw, async_submit);\n\t\t\tBUG_ON(ret);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_nr < total_devs - 1) {\n\t\t\tbio = btrfs_bio_clone(first_bio, GFP_NOFS);\n\t\t\tBUG_ON(!bio); /* -ENOMEM */\n\t\t} else {\n\t\t\tbio = first_bio;\n\t\t\tbbio->flags |= BTRFS_BIO_ORIG_BIO_SUBMITTED;\n\t\t}\n\n\t\tsubmit_stripe_bio(root, bbio, bio,\n\t\t\t\t  bbio->stripes[dev_nr].physical, dev_nr, rw,\n\t\t\t\t  async_submit);\n\t\tdev_nr++;\n\t}\n\tbtrfs_bio_counter_dec(root->fs_info);\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void __btrfs_reset_dev_stats(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void __btrfs_reset_dev_stats(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_error(struct btrfs_device *dev);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_bio(struct btrfs_root *root, int rw, struct bio *bio,\n\t\t  int mirror_num, int async_submit)\n{\n\tstruct btrfs_device *dev;\n\tstruct bio *first_bio = bio;\n\tu64 logical = (u64)bio->bi_iter.bi_sector << 9;\n\tu64 length = 0;\n\tu64 map_length;\n\tint ret;\n\tint dev_nr = 0;\n\tint total_devs = 1;\n\tstruct btrfs_bio *bbio = NULL;\n\n\tlength = bio->bi_iter.bi_size;\n\tmap_length = length;\n\n\tbtrfs_bio_counter_inc_blocked(root->fs_info);\n\tret = __btrfs_map_block(root->fs_info, rw, logical, &map_length, &bbio,\n\t\t\t      mirror_num, 1);\n\tif (ret) {\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\ttotal_devs = bbio->num_stripes;\n\tbbio->orig_bio = first_bio;\n\tbbio->private = first_bio->bi_private;\n\tbbio->end_io = first_bio->bi_end_io;\n\tbbio->fs_info = root->fs_info;\n\tatomic_set(&bbio->stripes_pending, bbio->num_stripes);\n\n\tif (bbio->raid_map) {\n\t\t/* In this case, map_length has been set to the length of\n\t\t   a single stripe; not the whole write */\n\t\tif (rw & WRITE) {\n\t\t\tret = raid56_parity_write(root, bio, bbio, map_length);\n\t\t} else {\n\t\t\tret = raid56_parity_recover(root, bio, bbio, map_length,\n\t\t\t\t\t\t    mirror_num, 1);\n\t\t}\n\n\t\tbtrfs_bio_counter_dec(root->fs_info);\n\t\treturn ret;\n\t}\n\n\tif (map_length < length) {\n\t\tbtrfs_crit(root->fs_info, \"mapping failed logical %llu bio len %llu len %llu\",\n\t\t\tlogical, length, map_length);\n\t\tBUG();\n\t}\n\n\twhile (dev_nr < total_devs) {\n\t\tdev = bbio->stripes[dev_nr].dev;\n\t\tif (!dev || !dev->bdev || (rw & WRITE && !dev->writeable)) {\n\t\t\tbbio_error(bbio, first_bio, logical);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Check and see if we're ok with this bio based on it's size\n\t\t * and offset with the given device.\n\t\t */\n\t\tif (!bio_size_ok(dev->bdev, first_bio,\n\t\t\t\t bbio->stripes[dev_nr].physical >> 9)) {\n\t\t\tret = breakup_stripe_bio(root, bbio, first_bio, dev,\n\t\t\t\t\t\t dev_nr, rw, async_submit);\n\t\t\tBUG_ON(ret);\n\t\t\tdev_nr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (dev_nr < total_devs - 1) {\n\t\t\tbio = btrfs_bio_clone(first_bio, GFP_NOFS);\n\t\t\tBUG_ON(!bio); /* -ENOMEM */\n\t\t} else {\n\t\t\tbio = first_bio;\n\t\t\tbbio->flags |= BTRFS_BIO_ORIG_BIO_SUBMITTED;\n\t\t}\n\n\t\tsubmit_stripe_bio(root, bbio, bio,\n\t\t\t\t  bbio->stripes[dev_nr].physical, dev_nr, rw,\n\t\t\t\t  async_submit);\n\t\tdev_nr++;\n\t}\n\tbtrfs_bio_counter_dec(root->fs_info);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_one_bio",
          "args": [
            "root",
            "inode",
            "bio",
            "start",
            "1"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_one_bio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file-item.c",
          "lines": "426-503",
          "snippet": "int btrfs_csum_one_bio(struct btrfs_root *root, struct inode *inode,\n\t\t       struct bio *bio, u64 file_start, int contig)\n{\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_ordered_extent *ordered;\n\tchar *data;\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tint bio_index = 0;\n\tint index;\n\tunsigned long total_bytes = 0;\n\tunsigned long this_sum_bytes = 0;\n\tu64 offset;\n\n\tWARN_ON(bio->bi_vcnt <= 0);\n\tsums = kzalloc(btrfs_ordered_sum_size(root, bio->bi_iter.bi_size),\n\t\t       GFP_NOFS);\n\tif (!sums)\n\t\treturn -ENOMEM;\n\n\tsums->len = bio->bi_iter.bi_size;\n\tINIT_LIST_HEAD(&sums->list);\n\n\tif (contig)\n\t\toffset = file_start;\n\telse\n\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\n\tordered = btrfs_lookup_ordered_extent(inode, offset);\n\tBUG_ON(!ordered); /* Logic error */\n\tsums->bytenr = (u64)bio->bi_iter.bi_sector << 9;\n\tindex = 0;\n\n\twhile (bio_index < bio->bi_vcnt) {\n\t\tif (!contig)\n\t\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\n\t\tif (offset >= ordered->file_offset + ordered->len ||\n\t\t    offset < ordered->file_offset) {\n\t\t\tunsigned long bytes_left;\n\t\t\tsums->len = this_sum_bytes;\n\t\t\tthis_sum_bytes = 0;\n\t\t\tbtrfs_add_ordered_sum(inode, ordered, sums);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\n\t\t\tbytes_left = bio->bi_iter.bi_size - total_bytes;\n\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, bytes_left),\n\t\t\t\t       GFP_NOFS);\n\t\t\tBUG_ON(!sums); /* -ENOMEM */\n\t\t\tsums->len = bytes_left;\n\t\t\tordered = btrfs_lookup_ordered_extent(inode, offset);\n\t\t\tBUG_ON(!ordered); /* Logic error */\n\t\t\tsums->bytenr = ((u64)bio->bi_iter.bi_sector << 9) +\n\t\t\t\t       total_bytes;\n\t\t\tindex = 0;\n\t\t}\n\n\t\tdata = kmap_atomic(bvec->bv_page);\n\t\tsums->sums[index] = ~(u32)0;\n\t\tsums->sums[index] = btrfs_csum_data(data + bvec->bv_offset,\n\t\t\t\t\t\t    sums->sums[index],\n\t\t\t\t\t\t    bvec->bv_len);\n\t\tkunmap_atomic(data);\n\t\tbtrfs_csum_final(sums->sums[index],\n\t\t\t\t (char *)(sums->sums + index));\n\n\t\tbio_index++;\n\t\tindex++;\n\t\ttotal_bytes += bvec->bv_len;\n\t\tthis_sum_bytes += bvec->bv_len;\n\t\toffset += bvec->bv_len;\n\t\tbvec++;\n\t}\n\tthis_sum_bytes = 0;\n\tbtrfs_add_ordered_sum(inode, ordered, sums);\n\tbtrfs_put_ordered_extent(ordered);\n\treturn 0;\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n\nint btrfs_csum_one_bio(struct btrfs_root *root, struct inode *inode,\n\t\t       struct bio *bio, u64 file_start, int contig)\n{\n\tstruct btrfs_ordered_sum *sums;\n\tstruct btrfs_ordered_extent *ordered;\n\tchar *data;\n\tstruct bio_vec *bvec = bio->bi_io_vec;\n\tint bio_index = 0;\n\tint index;\n\tunsigned long total_bytes = 0;\n\tunsigned long this_sum_bytes = 0;\n\tu64 offset;\n\n\tWARN_ON(bio->bi_vcnt <= 0);\n\tsums = kzalloc(btrfs_ordered_sum_size(root, bio->bi_iter.bi_size),\n\t\t       GFP_NOFS);\n\tif (!sums)\n\t\treturn -ENOMEM;\n\n\tsums->len = bio->bi_iter.bi_size;\n\tINIT_LIST_HEAD(&sums->list);\n\n\tif (contig)\n\t\toffset = file_start;\n\telse\n\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\n\tordered = btrfs_lookup_ordered_extent(inode, offset);\n\tBUG_ON(!ordered); /* Logic error */\n\tsums->bytenr = (u64)bio->bi_iter.bi_sector << 9;\n\tindex = 0;\n\n\twhile (bio_index < bio->bi_vcnt) {\n\t\tif (!contig)\n\t\t\toffset = page_offset(bvec->bv_page) + bvec->bv_offset;\n\n\t\tif (offset >= ordered->file_offset + ordered->len ||\n\t\t    offset < ordered->file_offset) {\n\t\t\tunsigned long bytes_left;\n\t\t\tsums->len = this_sum_bytes;\n\t\t\tthis_sum_bytes = 0;\n\t\t\tbtrfs_add_ordered_sum(inode, ordered, sums);\n\t\t\tbtrfs_put_ordered_extent(ordered);\n\n\t\t\tbytes_left = bio->bi_iter.bi_size - total_bytes;\n\n\t\t\tsums = kzalloc(btrfs_ordered_sum_size(root, bytes_left),\n\t\t\t\t       GFP_NOFS);\n\t\t\tBUG_ON(!sums); /* -ENOMEM */\n\t\t\tsums->len = bytes_left;\n\t\t\tordered = btrfs_lookup_ordered_extent(inode, offset);\n\t\t\tBUG_ON(!ordered); /* Logic error */\n\t\t\tsums->bytenr = ((u64)bio->bi_iter.bi_sector << 9) +\n\t\t\t\t       total_bytes;\n\t\t\tindex = 0;\n\t\t}\n\n\t\tdata = kmap_atomic(bvec->bv_page);\n\t\tsums->sums[index] = ~(u32)0;\n\t\tsums->sums[index] = btrfs_csum_data(data + bvec->bv_offset,\n\t\t\t\t\t\t    sums->sums[index],\n\t\t\t\t\t\t    bvec->bv_len);\n\t\tkunmap_atomic(data);\n\t\tbtrfs_csum_final(sums->sums[index],\n\t\t\t\t (char *)(sums->sums + index));\n\n\t\tbio_index++;\n\t\tindex++;\n\t\ttotal_bytes += bvec->bv_len;\n\t\tthis_sum_bytes += bvec->bv_len;\n\t\toffset += bvec->bv_len;\n\t\tbvec++;\n\t}\n\tthis_sum_bytes = 0;\n\tbtrfs_add_ordered_sum(inode, ordered, sums);\n\tbtrfs_put_ordered_extent(ordered);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_bio_wq_end_io",
          "args": [
            "root->fs_info",
            "bio",
            "BTRFS_WQ_ENDIO_DATA"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_wq_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "756-775",
          "snippet": "int btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_end_io_wq_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_end_io_wq_cache;\n\nint btrfs_bio_wq_end_io(struct btrfs_fs_info *info, struct bio *bio,\n\t\t\tenum btrfs_wq_endio_type metadata)\n{\n\tstruct btrfs_end_io_wq *end_io_wq;\n\n\tend_io_wq = kmem_cache_alloc(btrfs_end_io_wq_cache, GFP_NOFS);\n\tif (!end_io_wq)\n\t\treturn -ENOMEM;\n\n\tend_io_wq->private = bio->bi_private;\n\tend_io_wq->end_io = bio->bi_end_io;\n\tend_io_wq->info = info;\n\tend_io_wq->error = 0;\n\tend_io_wq->bio = bio;\n\tend_io_wq->metadata = metadata;\n\n\tbio->bi_private = end_io_wq;\n\tbio->bi_end_io = end_workqueue_bio;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_get",
          "args": [
            "bio"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "BTRFS_I(inode)->root->fs_info",
            "\"bytes left %lu compress len %lu nr %lu\"",
            "bytes_left",
            "cb->compressed_len",
            "cb->nr_pages"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "PAGE_CACHE_SIZE",
            "0"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!bio"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compressed_bio_alloc",
          "args": [
            "bdev",
            "first_byte",
            "GFP_NOFS"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "compressed_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "97-104",
          "snippet": "static struct bio *compressed_bio_alloc(struct block_device *bdev,\n\t\t\t\t\tu64 first_byte, gfp_t gfp_flags)\n{\n\tint nr_vecs;\n\n\tnr_vecs = bio_get_nr_vecs(bdev);\n\treturn btrfs_bio_alloc(bdev, first_byte >> 9, nr_vecs, gfp_flags);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct bio *compressed_bio_alloc(struct block_device *bdev,\n\t\t\t\t\tu64 first_byte, gfp_t gfp_flags)\n{\n\tint nr_vecs;\n\n\tnr_vecs = bio_get_nr_vecs(bdev);\n\treturn btrfs_bio_alloc(bdev, first_byte >> 9, nr_vecs, gfp_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cb->pending_bios"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_get",
          "args": [
            "bio"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_add_page",
          "args": [
            "bio",
            "page",
            "PAGE_CACHE_SIZE",
            "0"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_tree->ops->merge_bio_hook",
          "args": [
            "WRITE",
            "page",
            "0",
            "PAGE_CACHE_SIZE",
            "bio",
            "0"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&cb->pending_bios"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cb"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cb->pending_bios",
            "0"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "compressed_bio_size(root, compressed_len)",
            "GFP_NOFS"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compressed_bio_size",
          "args": [
            "root",
            "compressed_len"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "compressed_bio_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "88-95",
          "snippet": "static inline int compressed_bio_size(struct btrfs_root *root,\n\t\t\t\t      unsigned long disk_size)\n{\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\treturn sizeof(struct compressed_bio) +\n\t\t(DIV_ROUND_UP(disk_size, root->sectorsize)) * csum_size;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline int compressed_bio_size(struct btrfs_root *root,\n\t\t\t\t      unsigned long disk_size)\n{\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\treturn sizeof(struct compressed_bio) +\n\t\t(DIV_ROUND_UP(disk_size, root->sectorsize)) * csum_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "start & ((u64)PAGE_CACHE_SIZE - 1)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nint btrfs_submit_compressed_write(struct inode *inode, u64 start,\n\t\t\t\t unsigned long len, u64 disk_start,\n\t\t\t\t unsigned long compressed_len,\n\t\t\t\t struct page **compressed_pages,\n\t\t\t\t unsigned long nr_pages)\n{\n\tstruct bio *bio = NULL;\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct compressed_bio *cb;\n\tunsigned long bytes_left;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(inode)->io_tree;\n\tint pg_index = 0;\n\tstruct page *page;\n\tu64 first_byte = disk_start;\n\tstruct block_device *bdev;\n\tint ret;\n\tint skip_sum = BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM;\n\n\tWARN_ON(start & ((u64)PAGE_CACHE_SIZE - 1));\n\tcb = kmalloc(compressed_bio_size(root, compressed_len), GFP_NOFS);\n\tif (!cb)\n\t\treturn -ENOMEM;\n\tatomic_set(&cb->pending_bios, 0);\n\tcb->errors = 0;\n\tcb->inode = inode;\n\tcb->start = start;\n\tcb->len = len;\n\tcb->mirror_num = 0;\n\tcb->compressed_pages = compressed_pages;\n\tcb->compressed_len = compressed_len;\n\tcb->orig_bio = NULL;\n\tcb->nr_pages = nr_pages;\n\n\tbdev = BTRFS_I(inode)->root->fs_info->fs_devices->latest_bdev;\n\n\tbio = compressed_bio_alloc(bdev, first_byte, GFP_NOFS);\n\tif (!bio) {\n\t\tkfree(cb);\n\t\treturn -ENOMEM;\n\t}\n\tbio->bi_private = cb;\n\tbio->bi_end_io = end_compressed_bio_write;\n\tatomic_inc(&cb->pending_bios);\n\n\t/* create and submit bios for the compressed pages */\n\tbytes_left = compressed_len;\n\tfor (pg_index = 0; pg_index < cb->nr_pages; pg_index++) {\n\t\tpage = compressed_pages[pg_index];\n\t\tpage->mapping = inode->i_mapping;\n\t\tif (bio->bi_iter.bi_size)\n\t\t\tret = io_tree->ops->merge_bio_hook(WRITE, page, 0,\n\t\t\t\t\t\t\t   PAGE_CACHE_SIZE,\n\t\t\t\t\t\t\t   bio, 0);\n\t\telse\n\t\t\tret = 0;\n\n\t\tpage->mapping = NULL;\n\t\tif (ret || bio_add_page(bio, page, PAGE_CACHE_SIZE, 0) <\n\t\t    PAGE_CACHE_SIZE) {\n\t\t\tbio_get(bio);\n\n\t\t\t/*\n\t\t\t * inc the count before we submit the bio so\n\t\t\t * we know the end IO handler won't happen before\n\t\t\t * we inc the count.  Otherwise, the cb might get\n\t\t\t * freed before we're done setting it up\n\t\t\t */\n\t\t\tatomic_inc(&cb->pending_bios);\n\t\t\tret = btrfs_bio_wq_end_io(root->fs_info, bio,\n\t\t\t\t\tBTRFS_WQ_ENDIO_DATA);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\n\t\t\tif (!skip_sum) {\n\t\t\t\tret = btrfs_csum_one_bio(root, inode, bio,\n\t\t\t\t\t\t\t start, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\n\t\t\tret = btrfs_map_bio(root, WRITE, bio, 0, 1);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\n\t\t\tbio_put(bio);\n\n\t\t\tbio = compressed_bio_alloc(bdev, first_byte, GFP_NOFS);\n\t\t\tBUG_ON(!bio);\n\t\t\tbio->bi_private = cb;\n\t\t\tbio->bi_end_io = end_compressed_bio_write;\n\t\t\tbio_add_page(bio, page, PAGE_CACHE_SIZE, 0);\n\t\t}\n\t\tif (bytes_left < PAGE_CACHE_SIZE) {\n\t\t\tbtrfs_info(BTRFS_I(inode)->root->fs_info,\n\t\t\t\t\t\"bytes left %lu compress len %lu nr %lu\",\n\t\t\t       bytes_left, cb->compressed_len, cb->nr_pages);\n\t\t}\n\t\tbytes_left -= PAGE_CACHE_SIZE;\n\t\tfirst_byte += PAGE_CACHE_SIZE;\n\t\tcond_resched();\n\t}\n\tbio_get(bio);\n\n\tret = btrfs_bio_wq_end_io(root->fs_info, bio, BTRFS_WQ_ENDIO_DATA);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\tif (!skip_sum) {\n\t\tret = btrfs_csum_one_bio(root, inode, bio, start, 1);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tret = btrfs_map_bio(root, WRITE, bio, 0, 1);\n\tBUG_ON(ret); /* -ENOMEM */\n\n\tbio_put(bio);\n\treturn 0;\n}"
  },
  {
    "function_name": "end_compressed_bio_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "269-318",
    "snippet": "static void end_compressed_bio_write(struct bio *bio, int err)\n{\n\tstruct extent_io_tree *tree;\n\tstruct compressed_bio *cb = bio->bi_private;\n\tstruct inode *inode;\n\tstruct page *page;\n\tunsigned long index;\n\n\tif (err)\n\t\tcb->errors = 1;\n\n\t/* if there are more bios still pending for this compressed\n\t * extent, just exit\n\t */\n\tif (!atomic_dec_and_test(&cb->pending_bios))\n\t\tgoto out;\n\n\t/* ok, we're the last bio for this extent, step one is to\n\t * call back into the FS and do all the end_io operations\n\t */\n\tinode = cb->inode;\n\ttree = &BTRFS_I(inode)->io_tree;\n\tcb->compressed_pages[0]->mapping = cb->inode->i_mapping;\n\ttree->ops->writepage_end_io_hook(cb->compressed_pages[0],\n\t\t\t\t\t cb->start,\n\t\t\t\t\t cb->start + cb->len - 1,\n\t\t\t\t\t NULL,\n\t\t\t\t\t err ? 0 : 1);\n\tcb->compressed_pages[0]->mapping = NULL;\n\n\tend_compressed_writeback(inode, cb);\n\t/* note, our inode could be gone now */\n\n\t/*\n\t * release the compressed pages, these came from alloc_page and\n\t * are not attached to the inode at all\n\t */\n\tindex = 0;\n\tfor (index = 0; index < cb->nr_pages; index++) {\n\t\tpage = cb->compressed_pages[index];\n\t\tpage->mapping = NULL;\n\t\tpage_cache_release(page);\n\t}\n\n\t/* finally free the cb struct */\n\tkfree(cb->compressed_pages);\n\tkfree(cb);\nout:\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cb"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cb->compressed_pages"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_compressed_writeback",
          "args": [
            "inode",
            "cb"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "end_compressed_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "227-259",
          "snippet": "static noinline void end_compressed_writeback(struct inode *inode,\n\t\t\t\t\t      const struct compressed_bio *cb)\n{\n\tunsigned long index = cb->start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = (cb->start + cb->len - 1) >> PAGE_CACHE_SHIFT;\n\tstruct page *pages[16];\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\tint ret;\n\n\tif (cb->errors)\n\t\tmapping_set_error(inode->i_mapping, -EIO);\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long,\n\t\t\t\t     nr_pages, ARRAY_SIZE(pages)), pages);\n\t\tif (ret == 0) {\n\t\t\tnr_pages -= 1;\n\t\t\tindex += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (cb->errors)\n\t\t\t\tSetPageError(pages[i]);\n\t\t\tend_page_writeback(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t}\n\t/* the inode may be gone now */\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline void end_compressed_writeback(struct inode *inode,\n\t\t\t\t\t      const struct compressed_bio *cb)\n{\n\tunsigned long index = cb->start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = (cb->start + cb->len - 1) >> PAGE_CACHE_SHIFT;\n\tstruct page *pages[16];\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\tint ret;\n\n\tif (cb->errors)\n\t\tmapping_set_error(inode->i_mapping, -EIO);\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long,\n\t\t\t\t     nr_pages, ARRAY_SIZE(pages)), pages);\n\t\tif (ret == 0) {\n\t\t\tnr_pages -= 1;\n\t\t\tindex += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (cb->errors)\n\t\t\t\tSetPageError(pages[i]);\n\t\t\tend_page_writeback(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t}\n\t/* the inode may be gone now */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree->ops->writepage_end_io_hook",
          "args": [
            "cb->compressed_pages[0]",
            "cb->start",
            "cb->start + cb->len - 1",
            "NULL",
            "err ? 0 : 1"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&cb->pending_bios"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic void end_compressed_bio_write(struct bio *bio, int err)\n{\n\tstruct extent_io_tree *tree;\n\tstruct compressed_bio *cb = bio->bi_private;\n\tstruct inode *inode;\n\tstruct page *page;\n\tunsigned long index;\n\n\tif (err)\n\t\tcb->errors = 1;\n\n\t/* if there are more bios still pending for this compressed\n\t * extent, just exit\n\t */\n\tif (!atomic_dec_and_test(&cb->pending_bios))\n\t\tgoto out;\n\n\t/* ok, we're the last bio for this extent, step one is to\n\t * call back into the FS and do all the end_io operations\n\t */\n\tinode = cb->inode;\n\ttree = &BTRFS_I(inode)->io_tree;\n\tcb->compressed_pages[0]->mapping = cb->inode->i_mapping;\n\ttree->ops->writepage_end_io_hook(cb->compressed_pages[0],\n\t\t\t\t\t cb->start,\n\t\t\t\t\t cb->start + cb->len - 1,\n\t\t\t\t\t NULL,\n\t\t\t\t\t err ? 0 : 1);\n\tcb->compressed_pages[0]->mapping = NULL;\n\n\tend_compressed_writeback(inode, cb);\n\t/* note, our inode could be gone now */\n\n\t/*\n\t * release the compressed pages, these came from alloc_page and\n\t * are not attached to the inode at all\n\t */\n\tindex = 0;\n\tfor (index = 0; index < cb->nr_pages; index++) {\n\t\tpage = cb->compressed_pages[index];\n\t\tpage->mapping = NULL;\n\t\tpage_cache_release(page);\n\t}\n\n\t/* finally free the cb struct */\n\tkfree(cb->compressed_pages);\n\tkfree(cb);\nout:\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "end_compressed_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "227-259",
    "snippet": "static noinline void end_compressed_writeback(struct inode *inode,\n\t\t\t\t\t      const struct compressed_bio *cb)\n{\n\tunsigned long index = cb->start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = (cb->start + cb->len - 1) >> PAGE_CACHE_SHIFT;\n\tstruct page *pages[16];\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\tint ret;\n\n\tif (cb->errors)\n\t\tmapping_set_error(inode->i_mapping, -EIO);\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long,\n\t\t\t\t     nr_pages, ARRAY_SIZE(pages)), pages);\n\t\tif (ret == 0) {\n\t\t\tnr_pages -= 1;\n\t\t\tindex += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (cb->errors)\n\t\t\t\tSetPageError(pages[i]);\n\t\t\tend_page_writeback(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t}\n\t/* the inode may be gone now */\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_page_writeback",
          "args": [
            "pages[i]"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_end_page_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/write.c",
          "lines": "279-290",
          "snippet": "static void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}",
          "includes": [
            "#include \"nfstrace.h\"",
            "#include \"pnfs.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4_fs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/migrate.h>",
            "#include <linux/swap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))"
          ],
          "globals_used": [
            "static void nfs_redirty_request(struct nfs_page *req);",
            "static void nfs_clear_request_commit(struct nfs_page *req);",
            "static void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"nfstrace.h\"\n#include \"pnfs.h\"\n#include \"fscache.h\"\n#include \"nfs4_fs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include <asm/uaccess.h>\n#include <linux/export.h>\n#include <linux/backing-dev.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/migrate.h>\n#include <linux/swap.h>\n#include <linux/writeback.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\n#define NFS_CONGESTION_OFF_THRESH\t\\\n\t(NFS_CONGESTION_ON_THRESH - (NFS_CONGESTION_ON_THRESH >> 2))\n\nstatic void nfs_redirty_request(struct nfs_page *req);\nstatic void nfs_clear_request_commit(struct nfs_page *req);\nstatic void nfs_init_cinfo_from_inode(struct nfs_commit_info *cinfo,\n\t\t\t\t      struct inode *inode);\n\nstatic void nfs_end_page_writeback(struct nfs_page *req)\n{\n\tstruct inode *inode = page_file_mapping(req->wb_page)->host;\n\tstruct nfs_server *nfss = NFS_SERVER(inode);\n\n\tif (!nfs_page_group_sync_on_bit(req, PG_WB_END))\n\t\treturn;\n\n\tend_page_writeback(req->wb_page);\n\tif (atomic_long_dec_return(&nfss->writeback) < NFS_CONGESTION_OFF_THRESH)\n\t\tclear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "pages[i]"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages_contig",
          "args": [
            "inode->i_mapping",
            "index",
            "min_t(unsigned long,\n\t\t\t\t     nr_pages, ARRAY_SIZE(pages))",
            "pages"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "nr_pages",
            "ARRAY_SIZE(pages)"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pages"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_set_error",
          "args": [
            "inode->i_mapping",
            "-EIO"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic noinline void end_compressed_writeback(struct inode *inode,\n\t\t\t\t\t      const struct compressed_bio *cb)\n{\n\tunsigned long index = cb->start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = (cb->start + cb->len - 1) >> PAGE_CACHE_SHIFT;\n\tstruct page *pages[16];\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\tint ret;\n\n\tif (cb->errors)\n\t\tmapping_set_error(inode->i_mapping, -EIO);\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long,\n\t\t\t\t     nr_pages, ARRAY_SIZE(pages)), pages);\n\t\tif (ret == 0) {\n\t\t\tnr_pages -= 1;\n\t\t\tindex += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (cb->errors)\n\t\t\t\tSetPageError(pages[i]);\n\t\t\tend_page_writeback(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t}\n\t/* the inode may be gone now */\n}"
  },
  {
    "function_name": "end_compressed_bio_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "155-221",
    "snippet": "static void end_compressed_bio_read(struct bio *bio, int err)\n{\n\tstruct compressed_bio *cb = bio->bi_private;\n\tstruct inode *inode;\n\tstruct page *page;\n\tunsigned long index;\n\tint ret;\n\n\tif (err)\n\t\tcb->errors = 1;\n\n\t/* if there are more bios still pending for this compressed\n\t * extent, just exit\n\t */\n\tif (!atomic_dec_and_test(&cb->pending_bios))\n\t\tgoto out;\n\n\tinode = cb->inode;\n\tret = check_compressed_csum(inode, cb,\n\t\t\t\t    (u64)bio->bi_iter.bi_sector << 9);\n\tif (ret)\n\t\tgoto csum_failed;\n\n\t/* ok, we're the last bio for this extent, lets start\n\t * the decompression.\n\t */\n\tret = btrfs_decompress_biovec(cb->compress_type,\n\t\t\t\t      cb->compressed_pages,\n\t\t\t\t      cb->start,\n\t\t\t\t      cb->orig_bio->bi_io_vec,\n\t\t\t\t      cb->orig_bio->bi_vcnt,\n\t\t\t\t      cb->compressed_len);\ncsum_failed:\n\tif (ret)\n\t\tcb->errors = 1;\n\n\t/* release the compressed pages */\n\tindex = 0;\n\tfor (index = 0; index < cb->nr_pages; index++) {\n\t\tpage = cb->compressed_pages[index];\n\t\tpage->mapping = NULL;\n\t\tpage_cache_release(page);\n\t}\n\n\t/* do io completion on the original bio */\n\tif (cb->errors) {\n\t\tbio_io_error(cb->orig_bio);\n\t} else {\n\t\tint i;\n\t\tstruct bio_vec *bvec;\n\n\t\t/*\n\t\t * we have verified the checksum already, set page\n\t\t * checked so the end_io handlers know about it\n\t\t */\n\t\tbio_for_each_segment_all(bvec, cb->orig_bio, i)\n\t\t\tSetPageChecked(bvec->bv_page);\n\n\t\tbio_endio(cb->orig_bio, 0);\n\t}\n\n\t/* finally free the cb struct */\n\tkfree(cb->compressed_pages);\n\tkfree(cb);\nout:\n\tbio_put(bio);\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bio_put",
          "args": [
            "bio"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cb"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cb->compressed_pages"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_endio",
          "args": [
            "cb->orig_bio",
            "0"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "scrub_parity_bio_endio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "2667-2679",
          "snippet": "static void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void scrub_pending_bio_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_bio_dec(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);",
            "static void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);",
            "static void scrub_parity_get(struct scrub_parity *sparity);",
            "static void scrub_parity_put(struct scrub_parity *sparity);",
            "static void scrub_wr_submit(struct scrub_ctx *sctx);",
            "static void scrub_put_ctx(struct scrub_ctx *sctx);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void scrub_pending_bio_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_bio_dec(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_inc(struct scrub_ctx *sctx);\nstatic void scrub_pending_trans_workers_dec(struct scrub_ctx *sctx);\nstatic void scrub_parity_get(struct scrub_parity *sparity);\nstatic void scrub_parity_put(struct scrub_parity *sparity);\nstatic void scrub_wr_submit(struct scrub_ctx *sctx);\nstatic void scrub_put_ctx(struct scrub_ctx *sctx);\nstatic noinline_for_stack\nstruct;\n\nstatic void scrub_parity_bio_endio(struct bio *bio, int error)\n{\n\tstruct scrub_parity *sparity = (struct scrub_parity *)bio->bi_private;\n\tstruct scrub_ctx *sctx = sparity->sctx;\n\n\tif (error)\n\t\tbitmap_or(sparity->ebitmap, sparity->ebitmap, sparity->dbitmap,\n\t\t\t  sparity->nsectors);\n\n\tscrub_free_parity(sparity);\n\tscrub_pending_bio_dec(sctx);\n\tbio_put(bio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "bvec->bv_page"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_for_each_segment_all",
          "args": [
            "bvec",
            "cb->orig_bio",
            "i"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bio_io_error",
          "args": [
            "cb->orig_bio"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_decompress_biovec",
          "args": [
            "cb->compress_type",
            "cb->compressed_pages",
            "cb->start",
            "cb->orig_bio->bi_io_vec",
            "cb->orig_bio->bi_vcnt",
            "cb->compressed_len"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_decompress_biovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "924-940",
          "snippet": "static int btrfs_decompress_biovec(int type, struct page **pages_in,\n\t\t\t\t   u64 disk_start, struct bio_vec *bvec,\n\t\t\t\t   int vcnt, size_t srclen)\n{\n\tstruct list_head *workspace;\n\tint ret;\n\n\tworkspace = find_workspace(type);\n\tif (IS_ERR(workspace))\n\t\treturn PTR_ERR(workspace);\n\n\tret = btrfs_compress_op[type-1]->decompress_biovec(workspace, pages_in,\n\t\t\t\t\t\t\t disk_start,\n\t\t\t\t\t\t\t bvec, vcnt, srclen);\n\tfree_workspace(type, workspace);\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_decompress_biovec(int type, struct page **pages_in,\n\t\t\t\t   u64 disk_start, struct bio_vec *bvec,\n\t\t\t\t   int vcnt, size_t srclen);",
            "static struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_decompress_biovec(int type, struct page **pages_in,\n\t\t\t\t   u64 disk_start, struct bio_vec *bvec,\n\t\t\t\t   int vcnt, size_t srclen);\nstatic struct btrfs_compress_op *btrfs_compress_op[] = {\n\t&btrfs_zlib_compress,\n\t&btrfs_lzo_compress,\n};\n\nstatic int btrfs_decompress_biovec(int type, struct page **pages_in,\n\t\t\t\t   u64 disk_start, struct bio_vec *bvec,\n\t\t\t\t   int vcnt, size_t srclen)\n{\n\tstruct list_head *workspace;\n\tint ret;\n\n\tworkspace = find_workspace(type);\n\tif (IS_ERR(workspace))\n\t\treturn PTR_ERR(workspace);\n\n\tret = btrfs_compress_op[type-1]->decompress_biovec(workspace, pages_in,\n\t\t\t\t\t\t\t disk_start,\n\t\t\t\t\t\t\t bvec, vcnt, srclen);\n\tfree_workspace(type, workspace);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_compressed_csum",
          "args": [
            "inode",
            "cb",
            "(u64)bio->bi_iter.bi_sector << 9"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "check_compressed_csum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "106-143",
          "snippet": "static int check_compressed_csum(struct inode *inode,\n\t\t\t\t struct compressed_bio *cb,\n\t\t\t\t u64 disk_start)\n{\n\tint ret;\n\tstruct page *page;\n\tunsigned long i;\n\tchar *kaddr;\n\tu32 csum;\n\tu32 *cb_sum = &cb->sums;\n\n\tif (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)\n\t\treturn 0;\n\n\tfor (i = 0; i < cb->nr_pages; i++) {\n\t\tpage = cb->compressed_pages[i];\n\t\tcsum = ~(u32)0;\n\n\t\tkaddr = kmap_atomic(page);\n\t\tcsum = btrfs_csum_data(kaddr, csum, PAGE_CACHE_SIZE);\n\t\tbtrfs_csum_final(csum, (char *)&csum);\n\t\tkunmap_atomic(kaddr);\n\n\t\tif (csum != *cb_sum) {\n\t\t\tbtrfs_info(BTRFS_I(inode)->root->fs_info,\n\t\t\t   \"csum failed ino %llu extent %llu csum %u wanted %u mirror %d\",\n\t\t\t   btrfs_ino(inode), disk_start, csum, *cb_sum,\n\t\t\t   cb->mirror_num);\n\t\t\tret = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tcb_sum++;\n\n\t}\n\tret = 0;\nfail:\n\treturn ret;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int check_compressed_csum(struct inode *inode,\n\t\t\t\t struct compressed_bio *cb,\n\t\t\t\t u64 disk_start)\n{\n\tint ret;\n\tstruct page *page;\n\tunsigned long i;\n\tchar *kaddr;\n\tu32 csum;\n\tu32 *cb_sum = &cb->sums;\n\n\tif (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)\n\t\treturn 0;\n\n\tfor (i = 0; i < cb->nr_pages; i++) {\n\t\tpage = cb->compressed_pages[i];\n\t\tcsum = ~(u32)0;\n\n\t\tkaddr = kmap_atomic(page);\n\t\tcsum = btrfs_csum_data(kaddr, csum, PAGE_CACHE_SIZE);\n\t\tbtrfs_csum_final(csum, (char *)&csum);\n\t\tkunmap_atomic(kaddr);\n\n\t\tif (csum != *cb_sum) {\n\t\t\tbtrfs_info(BTRFS_I(inode)->root->fs_info,\n\t\t\t   \"csum failed ino %llu extent %llu csum %u wanted %u mirror %d\",\n\t\t\t   btrfs_ino(inode), disk_start, csum, *cb_sum,\n\t\t\t   cb->mirror_num);\n\t\t\tret = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tcb_sum++;\n\n\t}\n\tret = 0;\nfail:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&cb->pending_bios"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic void end_compressed_bio_read(struct bio *bio, int err)\n{\n\tstruct compressed_bio *cb = bio->bi_private;\n\tstruct inode *inode;\n\tstruct page *page;\n\tunsigned long index;\n\tint ret;\n\n\tif (err)\n\t\tcb->errors = 1;\n\n\t/* if there are more bios still pending for this compressed\n\t * extent, just exit\n\t */\n\tif (!atomic_dec_and_test(&cb->pending_bios))\n\t\tgoto out;\n\n\tinode = cb->inode;\n\tret = check_compressed_csum(inode, cb,\n\t\t\t\t    (u64)bio->bi_iter.bi_sector << 9);\n\tif (ret)\n\t\tgoto csum_failed;\n\n\t/* ok, we're the last bio for this extent, lets start\n\t * the decompression.\n\t */\n\tret = btrfs_decompress_biovec(cb->compress_type,\n\t\t\t\t      cb->compressed_pages,\n\t\t\t\t      cb->start,\n\t\t\t\t      cb->orig_bio->bi_io_vec,\n\t\t\t\t      cb->orig_bio->bi_vcnt,\n\t\t\t\t      cb->compressed_len);\ncsum_failed:\n\tif (ret)\n\t\tcb->errors = 1;\n\n\t/* release the compressed pages */\n\tindex = 0;\n\tfor (index = 0; index < cb->nr_pages; index++) {\n\t\tpage = cb->compressed_pages[index];\n\t\tpage->mapping = NULL;\n\t\tpage_cache_release(page);\n\t}\n\n\t/* do io completion on the original bio */\n\tif (cb->errors) {\n\t\tbio_io_error(cb->orig_bio);\n\t} else {\n\t\tint i;\n\t\tstruct bio_vec *bvec;\n\n\t\t/*\n\t\t * we have verified the checksum already, set page\n\t\t * checked so the end_io handlers know about it\n\t\t */\n\t\tbio_for_each_segment_all(bvec, cb->orig_bio, i)\n\t\t\tSetPageChecked(bvec->bv_page);\n\n\t\tbio_endio(cb->orig_bio, 0);\n\t}\n\n\t/* finally free the cb struct */\n\tkfree(cb->compressed_pages);\n\tkfree(cb);\nout:\n\tbio_put(bio);\n}"
  },
  {
    "function_name": "check_compressed_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "106-143",
    "snippet": "static int check_compressed_csum(struct inode *inode,\n\t\t\t\t struct compressed_bio *cb,\n\t\t\t\t u64 disk_start)\n{\n\tint ret;\n\tstruct page *page;\n\tunsigned long i;\n\tchar *kaddr;\n\tu32 csum;\n\tu32 *cb_sum = &cb->sums;\n\n\tif (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)\n\t\treturn 0;\n\n\tfor (i = 0; i < cb->nr_pages; i++) {\n\t\tpage = cb->compressed_pages[i];\n\t\tcsum = ~(u32)0;\n\n\t\tkaddr = kmap_atomic(page);\n\t\tcsum = btrfs_csum_data(kaddr, csum, PAGE_CACHE_SIZE);\n\t\tbtrfs_csum_final(csum, (char *)&csum);\n\t\tkunmap_atomic(kaddr);\n\n\t\tif (csum != *cb_sum) {\n\t\t\tbtrfs_info(BTRFS_I(inode)->root->fs_info,\n\t\t\t   \"csum failed ino %llu extent %llu csum %u wanted %u mirror %d\",\n\t\t\t   btrfs_ino(inode), disk_start, csum, *cb_sum,\n\t\t\t   cb->mirror_num);\n\t\t\tret = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tcb_sum++;\n\n\t}\n\tret = 0;\nfail:\n\treturn ret;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "BTRFS_I(inode)->root->fs_info",
            "\"csum failed ino %llu extent %llu csum %u wanted %u mirror %d\"",
            "btrfs_ino(inode)",
            "disk_start",
            "csum",
            "*cb_sum",
            "cb->mirror_num"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ino",
          "args": [
            "inode"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inode_resume_unlocked_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "311-316",
          "snippet": "static inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [
            "#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\n#define BTRFS_INODE_READDIO_NEED_LOCK\t\t10\n\nstatic inline void btrfs_inode_resume_unlocked_dio(struct inode *inode)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(BTRFS_INODE_READDIO_NEED_LOCK,\n\t\t  &BTRFS_I(inode)->runtime_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "inode"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_csum_final",
          "args": [
            "csum",
            "(char *)&csum"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_final",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "268-271",
          "snippet": "void btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nvoid btrfs_csum_final(u32 crc, char *result)\n{\n\tput_unaligned_le32(~crc, result);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_csum_data",
          "args": [
            "kaddr",
            "csum",
            "PAGE_CACHE_SIZE"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_csum_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "263-266",
          "snippet": "u32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nu32 btrfs_csum_data(char *data, u32 seed, size_t len)\n{\n\treturn btrfs_crc32c(seed, data, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int check_compressed_csum(struct inode *inode,\n\t\t\t\t struct compressed_bio *cb,\n\t\t\t\t u64 disk_start)\n{\n\tint ret;\n\tstruct page *page;\n\tunsigned long i;\n\tchar *kaddr;\n\tu32 csum;\n\tu32 *cb_sum = &cb->sums;\n\n\tif (BTRFS_I(inode)->flags & BTRFS_INODE_NODATASUM)\n\t\treturn 0;\n\n\tfor (i = 0; i < cb->nr_pages; i++) {\n\t\tpage = cb->compressed_pages[i];\n\t\tcsum = ~(u32)0;\n\n\t\tkaddr = kmap_atomic(page);\n\t\tcsum = btrfs_csum_data(kaddr, csum, PAGE_CACHE_SIZE);\n\t\tbtrfs_csum_final(csum, (char *)&csum);\n\t\tkunmap_atomic(kaddr);\n\n\t\tif (csum != *cb_sum) {\n\t\t\tbtrfs_info(BTRFS_I(inode)->root->fs_info,\n\t\t\t   \"csum failed ino %llu extent %llu csum %u wanted %u mirror %d\",\n\t\t\t   btrfs_ino(inode), disk_start, csum, *cb_sum,\n\t\t\t   cb->mirror_num);\n\t\t\tret = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tcb_sum++;\n\n\t}\n\tret = 0;\nfail:\n\treturn ret;\n}"
  },
  {
    "function_name": "compressed_bio_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "97-104",
    "snippet": "static struct bio *compressed_bio_alloc(struct block_device *bdev,\n\t\t\t\t\tu64 first_byte, gfp_t gfp_flags)\n{\n\tint nr_vecs;\n\n\tnr_vecs = bio_get_nr_vecs(bdev);\n\treturn btrfs_bio_alloc(bdev, first_byte >> 9, nr_vecs, gfp_flags);\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_bio_alloc",
          "args": [
            "bdev",
            "first_byte >> 9",
            "nr_vecs",
            "gfp_flags"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bio_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "2690-2715",
          "snippet": "struct bio *\nbtrfs_bio_alloc(struct block_device *bdev, u64 first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_flags, nr_vecs, btrfs_bioset);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2)) {\n\t\t\tbio = bio_alloc_bioset(gfp_flags,\n\t\t\t\t\t       nr_vecs, btrfs_bioset);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct bio_set *btrfs_bioset;\n\nstruct bio *\nbtrfs_bio_alloc(struct block_device *bdev, u64 first_sector, int nr_vecs,\n\t\tgfp_t gfp_flags)\n{\n\tstruct btrfs_io_bio *btrfs_bio;\n\tstruct bio *bio;\n\n\tbio = bio_alloc_bioset(gfp_flags, nr_vecs, btrfs_bioset);\n\n\tif (bio == NULL && (current->flags & PF_MEMALLOC)) {\n\t\twhile (!bio && (nr_vecs /= 2)) {\n\t\t\tbio = bio_alloc_bioset(gfp_flags,\n\t\t\t\t\t       nr_vecs, btrfs_bioset);\n\t\t}\n\t}\n\n\tif (bio) {\n\t\tbio->bi_bdev = bdev;\n\t\tbio->bi_iter.bi_sector = first_sector;\n\t\tbtrfs_bio = btrfs_io_bio(bio);\n\t\tbtrfs_bio->csum = NULL;\n\t\tbtrfs_bio->csum_allocated = NULL;\n\t\tbtrfs_bio->end_io = NULL;\n\t}\n\treturn bio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bio_get_nr_vecs",
          "args": [
            "bdev"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct bio *compressed_bio_alloc(struct block_device *bdev,\n\t\t\t\t\tu64 first_byte, gfp_t gfp_flags)\n{\n\tint nr_vecs;\n\n\tnr_vecs = bio_get_nr_vecs(bdev);\n\treturn btrfs_bio_alloc(bdev, first_byte >> 9, nr_vecs, gfp_flags);\n}"
  },
  {
    "function_name": "compressed_bio_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
    "lines": "88-95",
    "snippet": "static inline int compressed_bio_size(struct btrfs_root *root,\n\t\t\t\t      unsigned long disk_size)\n{\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\treturn sizeof(struct compressed_bio) +\n\t\t(DIV_ROUND_UP(disk_size, root->sectorsize)) * csum_size;\n}",
    "includes": [
      "#include \"extent_map.h\"",
      "#include \"extent_io.h\"",
      "#include \"compression.h\"",
      "#include \"ordered-data.h\"",
      "#include \"volumes.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/slab.h>",
      "#include <linux/bit_spinlock.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/bio.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "disk_size",
            "root->sectorsize"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_csum_size",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_super_csum_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3066-3073",
          "snippet": "static inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_super_csum_size(struct btrfs_super_block *s)\n{\n\tu16 t = btrfs_super_csum_type(s);\n\t/*\n\t * csum type is validated at mount time\n\t */\n\treturn btrfs_csum_sizes[t];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic inline int compressed_bio_size(struct btrfs_root *root,\n\t\t\t\t      unsigned long disk_size)\n{\n\tu16 csum_size = btrfs_super_csum_size(root->fs_info->super_copy);\n\n\treturn sizeof(struct compressed_bio) +\n\t\t(DIV_ROUND_UP(disk_size, root->sectorsize)) * csum_size;\n}"
  }
]