[
  {
    "function_name": "nfs_fhandle_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "679-682",
    "snippet": "static inline u32 nfs_fhandle_hash(const struct nfs_fh *fh)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct nfs_client *\nnfs4_find_client_sessionid(struct net *, const struct sockaddr *,\n\t\t\t\tstruct nfs4_sessionid *, u32);",
      "extern struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *,\n\t\t\t\t\t\t      struct nfs_fh *);",
      "extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,\n\t\t\t\t   const char *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct nfs_client *\nnfs4_find_client_sessionid(struct net *, const struct sockaddr *,\n\t\t\t\tstruct nfs4_sessionid *, u32);\nextern struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *,\n\t\t\t\t\t\t      struct nfs_fh *);\nextern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,\n\t\t\t\t   const char *);\n\nstatic inline u32 nfs_fhandle_hash(const struct nfs_fh *fh)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_fhandle_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "674-677",
    "snippet": "static inline u32 nfs_fhandle_hash(const struct nfs_fh *fh)\n{\n\treturn ~crc32_le(0xFFFFFFFF, &fh->data[0], fh->size);\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct nfs_client *\nnfs4_find_client_sessionid(struct net *, const struct sockaddr *,\n\t\t\t\tstruct nfs4_sessionid *, u32);",
      "extern struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *,\n\t\t\t\t\t\t      struct nfs_fh *);",
      "extern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,\n\t\t\t\t   const char *);",
      "void nfs_commitdata_release(struct nfs_commit_data *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "0xFFFFFFFF",
            "&fh->data[0]",
            "fh->size"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct nfs_client *\nnfs4_find_client_sessionid(struct net *, const struct sockaddr *,\n\t\t\t\tstruct nfs4_sessionid *, u32);\nextern struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *,\n\t\t\t\t\t\t      struct nfs_fh *);\nextern struct dentry *nfs_get_root(struct super_block *, struct nfs_fh *,\n\t\t\t\t   const char *);\nvoid nfs_commitdata_release(struct nfs_commit_data *data);\n\nstatic inline u32 nfs_fhandle_hash(const struct nfs_fh *fh)\n{\n\treturn ~crc32_le(0xFFFFFFFF, &fh->data[0], fh->size);\n}"
  },
  {
    "function_name": "nfs_timespec_to_change_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "660-664",
    "snippet": "static inline\nu64 nfs_timespec_to_change_attr(const struct timespec *ts)\n{\n\treturn ((u64)ts->tv_sec << 30) + ts->tv_nsec;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline\nu64 nfs_timespec_to_change_attr(const struct timespec *ts)\n{\n\treturn ((u64)ts->tv_sec << 30) + ts->tv_nsec;\n}"
  },
  {
    "function_name": "nfs_page_array_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "646-651",
    "snippet": "static inline\nunsigned int nfs_page_array_len(unsigned int base, size_t len)\n{\n\treturn ((unsigned long)len + (unsigned long)base +\n\t\tPAGE_SIZE - 1) >> PAGE_SHIFT;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "ssize_t nfs_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *,\n\t\t\t     size_t, unsigned int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nssize_t nfs_file_splice_read(struct file *, loff_t *, struct pipe_inode_info *,\n\t\t\t     size_t, unsigned int);\n\nstatic inline\nunsigned int nfs_page_array_len(unsigned int base, size_t len)\n{\n\treturn ((unsigned long)len + (unsigned long)base +\n\t\tPAGE_SIZE - 1) >> PAGE_SHIFT;\n}"
  },
  {
    "function_name": "nfs_umode_to_dtype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "636-640",
    "snippet": "static inline\nunsigned char nfs_umode_to_dtype(umode_t mode)\n{\n\treturn (mode >> 12) & 15;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int nfs_create(struct inode *, struct dentry *, umode_t, bool);",
      "int nfs_mkdir(struct inode *, struct dentry *, umode_t);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_create(struct inode *, struct dentry *, umode_t, bool);\nint nfs_mkdir(struct inode *, struct dentry *, umode_t);\n\nstatic inline\nunsigned char nfs_umode_to_dtype(umode_t mode)\n{\n\treturn (mode >> 12) & 15;\n}"
  },
  {
    "function_name": "nfs_page_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "617-631",
    "snippet": "static inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);",
      "loff_t nfs_file_llseek(struct file *, loff_t, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_file_index",
          "args": [
            "page"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "page_file_mapping(page)->host"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);\nloff_t nfs_file_llseek(struct file *, loff_t, int);\n\nstatic inline\nunsigned int nfs_page_length(struct page *page)\n{\n\tloff_t i_size = i_size_read(page_file_mapping(page)->host);\n\n\tif (i_size > 0) {\n\t\tpgoff_t page_index = page_file_index(page);\n\t\tpgoff_t end_index = (i_size - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (page_index < end_index)\n\t\t\treturn PAGE_CACHE_SIZE;\n\t\tif (page_index == end_index)\n\t\t\treturn ((i_size - 1) & ~PAGE_CACHE_MASK) + 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_mark_page_unstable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "604-612",
    "snippet": "static inline\nvoid nfs_mark_page_unstable(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\n\tinc_zone_page_state(page, NR_UNSTABLE_NFS);\n\tinc_bdi_stat(inode_to_bdi(inode), BDI_RECLAIMABLE);\n\t __mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
      "extern void nfs_destroy_inode(struct inode *);",
      "extern int nfs_drop_inode(struct inode *);",
      "extern void nfs_clear_inode(struct inode *);",
      "extern void nfs_evict_inode(struct inode *);",
      "void nfs_zap_acl_cache(struct inode *inode);",
      "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mark_inode_dirty",
          "args": [
            "inode",
            "I_DIRTY_DATASYNC"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1181-1285",
          "snippet": "void __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\n#define I_DIRTY_INODE (I_DIRTY_SYNC | I_DIRTY_DATASYNC)\n\nvoid __mark_inode_dirty(struct inode *inode, int flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct backing_dev_info *bdi = NULL;\n\tint dirtytime;\n\n\ttrace_writeback_mark_inode_dirty(inode, flags);\n\n\t/*\n\t * Don't do this for I_DIRTY_PAGES - that doesn't actually\n\t * dirty the inode itself\n\t */\n\tif (flags & (I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_TIME)) {\n\t\ttrace_writeback_dirty_inode_start(inode, flags);\n\n\t\tif (sb->s_op->dirty_inode)\n\t\t\tsb->s_op->dirty_inode(inode, flags);\n\n\t\ttrace_writeback_dirty_inode(inode, flags);\n\t}\n\tif (flags & I_DIRTY_INODE)\n\t\tflags &= ~I_DIRTY_TIME;\n\tdirtytime = flags & I_DIRTY_TIME;\n\n\t/*\n\t * Paired with smp_mb() in __writeback_single_inode() for the\n\t * following lockless i_state test.  See there for details.\n\t */\n\tsmp_mb();\n\n\tif (((inode->i_state & flags) == flags) ||\n\t    (dirtytime && (inode->i_state & I_DIRTY_INODE)))\n\t\treturn;\n\n\tif (unlikely(block_dump))\n\t\tblock_dump___mark_inode_dirty(inode);\n\n\tspin_lock(&inode->i_lock);\n\tif (dirtytime && (inode->i_state & I_DIRTY_INODE))\n\t\tgoto out_unlock_inode;\n\tif ((inode->i_state & flags) != flags) {\n\t\tconst int was_dirty = inode->i_state & I_DIRTY;\n\n\t\tif (flags & I_DIRTY_INODE)\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\tinode->i_state |= flags;\n\n\t\t/*\n\t\t * If the inode is being synced, just update its dirty state.\n\t\t * The unlocker will place the inode on the appropriate\n\t\t * superblock list, based upon its state.\n\t\t */\n\t\tif (inode->i_state & I_SYNC)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * Only add valid (hashed) inodes to the superblock's\n\t\t * dirty list.  Add blockdev inodes as well.\n\t\t */\n\t\tif (!S_ISBLK(inode->i_mode)) {\n\t\t\tif (inode_unhashed(inode))\n\t\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tif (inode->i_state & I_FREEING)\n\t\t\tgoto out_unlock_inode;\n\n\t\t/*\n\t\t * If the inode was already on b_dirty/b_io/b_more_io, don't\n\t\t * reposition it (that would break b_dirty time-ordering).\n\t\t */\n\t\tif (!was_dirty) {\n\t\t\tbool wakeup_bdi = false;\n\t\t\tbdi = inode_to_bdi(inode);\n\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tspin_lock(&bdi->wb.list_lock);\n\t\t\tif (bdi_cap_writeback_dirty(bdi)) {\n\t\t\t\tWARN(!test_bit(BDI_registered, &bdi->state),\n\t\t\t\t     \"bdi-%s not registered\\n\", bdi->name);\n\n\t\t\t\t/*\n\t\t\t\t * If this is the first dirty inode for this\n\t\t\t\t * bdi, we have to wake-up the corresponding\n\t\t\t\t * bdi thread to make sure background\n\t\t\t\t * write-back happens later.\n\t\t\t\t */\n\t\t\t\tif (!wb_has_dirty_io(&bdi->wb))\n\t\t\t\t\twakeup_bdi = true;\n\t\t\t}\n\n\t\t\tinode->dirtied_when = jiffies;\n\t\t\tlist_move(&inode->i_wb_list, dirtytime ?\n\t\t\t\t  &bdi->wb.b_dirty_time : &bdi->wb.b_dirty);\n\t\t\tspin_unlock(&bdi->wb.list_lock);\n\t\t\ttrace_writeback_dirty_inode_enqueue(inode);\n\n\t\t\tif (wakeup_bdi)\n\t\t\t\tbdi_wakeup_thread_delayed(bdi);\n\t\t\treturn;\n\t\t}\n\t}\nout_unlock_inode:\n\tspin_unlock(&inode->i_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_bdi_stat",
          "args": [
            "inode_to_bdi(inode)",
            "BDI_RECLAIMABLE"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_zone_page_state",
          "args": [
            "page",
            "NR_UNSTABLE_NFS"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_file_mapping",
          "args": [
            "page"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline\nvoid nfs_mark_page_unstable(struct page *page)\n{\n\tstruct inode *inode = page_file_mapping(page)->host;\n\n\tinc_zone_page_state(page, NR_UNSTABLE_NFS);\n\tinc_bdi_stat(inode_to_bdi(inode), BDI_RECLAIMABLE);\n\t __mark_inode_dirty(inode, I_DIRTY_DATASYNC);\n}"
  },
  {
    "function_name": "nfs_super_set_maxbytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "593-599",
    "snippet": "static inline\nvoid nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)\n{\n\tsb->s_maxbytes = (loff_t)maxfilesize;\n\tif (sb->s_maxbytes > MAX_LFS_FILESIZE || sb->s_maxbytes <= 0)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);",
      "loff_t nfs_file_llseek(struct file *, loff_t, int);",
      "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
      "void nfs_initialise_sb(struct super_block *);",
      "void nfs_kill_super(struct super_block *);",
      "extern bool nfs_sb_active(struct super_block *sb);",
      "extern void nfs_sb_deactive(struct super_block *sb);",
      "void nfs_umount_begin(struct super_block *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_file_fsync_commit(struct file *, loff_t, loff_t, int);\nloff_t nfs_file_llseek(struct file *, loff_t, int);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\n\nstatic inline\nvoid nfs_super_set_maxbytes(struct super_block *sb, __u64 maxfilesize)\n{\n\tsb->s_maxbytes = (loff_t)maxfilesize;\n\tif (sb->s_maxbytes > MAX_LFS_FILESIZE || sb->s_maxbytes <= 0)\n\t\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n}"
  },
  {
    "function_name": "nfs_block_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "579-588",
    "snippet": "static inline\nunsigned long nfs_block_size(unsigned long bsize, unsigned char *nrbitsp)\n{\n\tif (bsize < NFS_MIN_FILE_IO_SIZE)\n\t\tbsize = NFS_DEF_FILE_IO_SIZE;\n\telse if (bsize >= NFS_MAX_FILE_IO_SIZE)\n\t\tbsize = NFS_MAX_FILE_IO_SIZE;\n\n\treturn nfs_block_bits(bsize, nrbitsp);\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_block_bits",
          "args": [
            "bsize",
            "nrbitsp"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_block_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "550-565",
          "snippet": "static inline\nunsigned long nfs_block_bits(unsigned long bsize, unsigned char *nrbitsp)\n{\n\t/* make sure blocksize is a power of two */\n\tif ((bsize & (bsize - 1)) || nrbitsp) {\n\t\tunsigned char\tnrbits;\n\n\t\tfor (nrbits = 31; nrbits && !(bsize & (1 << nrbits)); nrbits--)\n\t\t\t;\n\t\tbsize = 1 << nrbits;\n\t\tif (nrbitsp)\n\t\t\t*nrbitsp = nrbits;\n\t}\n\n\treturn bsize;\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline\nunsigned long nfs_block_bits(unsigned long bsize, unsigned char *nrbitsp)\n{\n\t/* make sure blocksize is a power of two */\n\tif ((bsize & (bsize - 1)) || nrbitsp) {\n\t\tunsigned char\tnrbits;\n\n\t\tfor (nrbits = 31; nrbits && !(bsize & (1 << nrbits)); nrbits--)\n\t\t\t;\n\t\tbsize = 1 << nrbits;\n\t\tif (nrbitsp)\n\t\t\t*nrbitsp = nrbits;\n\t}\n\n\treturn bsize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline\nunsigned long nfs_block_size(unsigned long bsize, unsigned char *nrbitsp)\n{\n\tif (bsize < NFS_MIN_FILE_IO_SIZE)\n\t\tbsize = NFS_DEF_FILE_IO_SIZE;\n\telse if (bsize >= NFS_MAX_FILE_IO_SIZE)\n\t\tbsize = NFS_MAX_FILE_IO_SIZE;\n\n\treturn nfs_block_bits(bsize, nrbitsp);\n}"
  },
  {
    "function_name": "nfs_calc_block_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "570-574",
    "snippet": "static inline blkcnt_t nfs_calc_block_size(u64 tsize)\n{\n\tblkcnt_t used = (tsize + 511) >> 9;\n\treturn (used > ULONG_MAX) ? ULONG_MAX : used;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline blkcnt_t nfs_calc_block_size(u64 tsize)\n{\n\tblkcnt_t used = (tsize + 511) >> 9;\n\treturn (used > ULONG_MAX) ? ULONG_MAX : used;\n}"
  },
  {
    "function_name": "nfs_block_bits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "550-565",
    "snippet": "static inline\nunsigned long nfs_block_bits(unsigned long bsize, unsigned char *nrbitsp)\n{\n\t/* make sure blocksize is a power of two */\n\tif ((bsize & (bsize - 1)) || nrbitsp) {\n\t\tunsigned char\tnrbits;\n\n\t\tfor (nrbits = 31; nrbits && !(bsize & (1 << nrbits)); nrbits--)\n\t\t\t;\n\t\tbsize = 1 << nrbits;\n\t\tif (nrbitsp)\n\t\t\t*nrbitsp = nrbits;\n\t}\n\n\treturn bsize;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline\nunsigned long nfs_block_bits(unsigned long bsize, unsigned char *nrbitsp)\n{\n\t/* make sure blocksize is a power of two */\n\tif ((bsize & (bsize - 1)) || nrbitsp) {\n\t\tunsigned char\tnrbits;\n\n\t\tfor (nrbits = 31; nrbits && !(bsize & (1 << nrbits)); nrbits--)\n\t\t\t;\n\t\tbsize = 1 << nrbits;\n\t\tif (nrbitsp)\n\t\t\t*nrbitsp = nrbits;\n\t}\n\n\treturn bsize;\n}"
  },
  {
    "function_name": "nfs_devname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "540-545",
    "snippet": "static inline char *nfs_devname(struct dentry *dentry,\n\t\t\t\tchar *buffer, ssize_t buflen)\n{\n\tchar *dummy;\n\treturn nfs_path(&dummy, dentry, buffer, buflen, NFS_PATH_CANONICAL);\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [
      "#define NFS_PATH_CANONICAL 1"
    ],
    "globals_used": [
      "struct dentry *nfs_lookup(struct inode *, struct dentry *, unsigned int);",
      "int nfs_rmdir(struct inode *, struct dentry *);",
      "int nfs_unlink(struct inode *, struct dentry *);",
      "int nfs_symlink(struct inode *, struct dentry *, const char *);",
      "int nfs_link(struct dentry *, struct inode *, struct dentry *);",
      "int nfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);",
      "int  nfs_show_options(struct seq_file *, struct dentry *);",
      "int  nfs_show_devname(struct seq_file *, struct dentry *);",
      "int  nfs_show_path(struct seq_file *, struct dentry *);",
      "int  nfs_show_stats(struct seq_file *, struct dentry *);",
      "extern int nfs_sillyrename(struct inode *dir, struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_path",
          "args": [
            "&dummy",
            "dentry",
            "buffer",
            "buflen",
            "NFS_PATH_CANONICAL"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/namespace.c",
          "lines": "50-124",
          "snippet": "char *nfs_path(char **p, struct dentry *dentry, char *buffer, ssize_t buflen,\n\t       unsigned flags)\n{\n\tchar *end;\n\tint namelen;\n\tunsigned seq;\n\tconst char *base;\n\nrename_retry:\n\tend = buffer+buflen;\n\t*--end = '\\0';\n\tbuflen--;\n\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\twhile (1) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (IS_ROOT(dentry))\n\t\t\tbreak;\n\t\tnamelen = dentry->d_name.len;\n\t\tbuflen -= namelen + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong_unlock;\n\t\tend -= namelen;\n\t\tmemcpy(end, dentry->d_name.name, namelen);\n\t\t*--end = '/';\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdentry = dentry->d_parent;\n\t}\n\tif (read_seqretry(&rename_lock, seq)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto rename_retry;\n\t}\n\tif ((flags & NFS_PATH_CANONICAL) && *end != '/') {\n\t\tif (--buflen < 0) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\trcu_read_unlock();\n\t\t\tgoto Elong;\n\t\t}\n\t\t*--end = '/';\n\t}\n\t*p = end;\n\tbase = dentry->d_fsdata;\n\tif (!base) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tWARN_ON(1);\n\t\treturn end;\n\t}\n\tnamelen = strlen(base);\n\tif (flags & NFS_PATH_CANONICAL) {\n\t\t/* Strip off excess slashes in base string */\n\t\twhile (namelen > 0 && base[namelen - 1] == '/')\n\t\t\tnamelen--;\n\t}\n\tbuflen -= namelen;\n\tif (buflen < 0) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto Elong;\n\t}\n\tend -= namelen;\n\tmemcpy(end, base, namelen);\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\treturn end;\nElong_unlock:\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\tif (read_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sunrpc/gss_api.h>",
            "#include <linux/vfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/string.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/gfp.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sunrpc/gss_api.h>\n#include <linux/vfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/string.h>\n#include <linux/nfs_fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/gfp.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n\nchar *nfs_path(char **p, struct dentry *dentry, char *buffer, ssize_t buflen,\n\t       unsigned flags)\n{\n\tchar *end;\n\tint namelen;\n\tunsigned seq;\n\tconst char *base;\n\nrename_retry:\n\tend = buffer+buflen;\n\t*--end = '\\0';\n\tbuflen--;\n\n\tseq = read_seqbegin(&rename_lock);\n\trcu_read_lock();\n\twhile (1) {\n\t\tspin_lock(&dentry->d_lock);\n\t\tif (IS_ROOT(dentry))\n\t\t\tbreak;\n\t\tnamelen = dentry->d_name.len;\n\t\tbuflen -= namelen + 1;\n\t\tif (buflen < 0)\n\t\t\tgoto Elong_unlock;\n\t\tend -= namelen;\n\t\tmemcpy(end, dentry->d_name.name, namelen);\n\t\t*--end = '/';\n\t\tspin_unlock(&dentry->d_lock);\n\t\tdentry = dentry->d_parent;\n\t}\n\tif (read_seqretry(&rename_lock, seq)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto rename_retry;\n\t}\n\tif ((flags & NFS_PATH_CANONICAL) && *end != '/') {\n\t\tif (--buflen < 0) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\trcu_read_unlock();\n\t\t\tgoto Elong;\n\t\t}\n\t\t*--end = '/';\n\t}\n\t*p = end;\n\tbase = dentry->d_fsdata;\n\tif (!base) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tWARN_ON(1);\n\t\treturn end;\n\t}\n\tnamelen = strlen(base);\n\tif (flags & NFS_PATH_CANONICAL) {\n\t\t/* Strip off excess slashes in base string */\n\t\twhile (namelen > 0 && base[namelen - 1] == '/')\n\t\t\tnamelen--;\n\t}\n\tbuflen -= namelen;\n\tif (buflen < 0) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto Elong;\n\t}\n\tend -= namelen;\n\tmemcpy(end, base, namelen);\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\treturn end;\nElong_unlock:\n\tspin_unlock(&dentry->d_lock);\n\trcu_read_unlock();\n\tif (read_seqretry(&rename_lock, seq))\n\t\tgoto rename_retry;\nElong:\n\treturn ERR_PTR(-ENAMETOOLONG);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\n#define NFS_PATH_CANONICAL 1\n\nstruct dentry *nfs_lookup(struct inode *, struct dentry *, unsigned int);\nint nfs_rmdir(struct inode *, struct dentry *);\nint nfs_unlink(struct inode *, struct dentry *);\nint nfs_symlink(struct inode *, struct dentry *, const char *);\nint nfs_link(struct dentry *, struct inode *, struct dentry *);\nint nfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *);\nint  nfs_show_options(struct seq_file *, struct dentry *);\nint  nfs_show_devname(struct seq_file *, struct dentry *);\nint  nfs_show_path(struct seq_file *, struct dentry *);\nint  nfs_show_stats(struct seq_file *, struct dentry *);\nextern int nfs_sillyrename(struct inode *dir, struct dentry *dentry);\n\nstatic inline char *nfs_devname(struct dentry *dentry,\n\t\t\t\tchar *buffer, ssize_t buflen)\n{\n\tchar *dummy;\n\treturn nfs_path(&dummy, dentry, buffer, buflen, NFS_PATH_CANONICAL);\n}"
  },
  {
    "function_name": "nfs_iput_and_deactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "527-535",
    "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
      "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
      "extern void nfs_destroy_inode(struct inode *);",
      "extern int nfs_drop_inode(struct inode *);",
      "extern void nfs_clear_inode(struct inode *);",
      "extern void nfs_evict_inode(struct inode *);",
      "void nfs_zap_acl_cache(struct inode *inode);",
      "void nfs_initialise_sb(struct super_block *);",
      "void nfs_kill_super(struct super_block *);",
      "extern bool nfs_sb_active(struct super_block *sb);",
      "extern void nfs_sb_deactive(struct super_block *sb);",
      "void nfs_umount_begin(struct super_block *);",
      "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_sb_deactive",
          "args": [
            "sb"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_sb_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/super.c",
          "lines": "419-425",
          "snippet": "void nfs_sb_deactive(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}",
          "includes": [
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/netdevice.h>",
            "#include <net/ipv6.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/rcupdate.h>\n#include <linux/nsproxy.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/nfs_xdr.h>\n#include <linux/netdevice.h>\n#include <net/ipv6.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid nfs_sb_deactive(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (atomic_dec_and_test(&server->active))\n\t\tdeactivate_super(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iput_and_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "527-535",
          "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}"
  },
  {
    "function_name": "nfs_igrab_and_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "517-525",
    "snippet": "static inline struct inode *nfs_igrab_and_active(struct inode *inode)\n{\n\tinode = igrab(inode);\n\tif (inode != NULL && !nfs_sb_active(inode->i_sb)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
      "extern void nfs_destroy_inode(struct inode *);",
      "extern int nfs_drop_inode(struct inode *);",
      "extern void nfs_clear_inode(struct inode *);",
      "extern void nfs_evict_inode(struct inode *);",
      "void nfs_zap_acl_cache(struct inode *inode);",
      "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_iput_and_deactive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "527-535",
          "snippet": "static inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}",
          "includes": [
            "#include <linux/nfs_page.h>",
            "#include <linux/crc32.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include \"nfs4_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
            "extern struct inode *nfs_alloc_inode(struct super_block *sb);",
            "extern void nfs_destroy_inode(struct inode *);",
            "extern int nfs_drop_inode(struct inode *);",
            "extern void nfs_clear_inode(struct inode *);",
            "extern void nfs_evict_inode(struct inode *);",
            "void nfs_zap_acl_cache(struct inode *inode);",
            "void nfs_initialise_sb(struct super_block *);",
            "void nfs_kill_super(struct super_block *);",
            "extern bool nfs_sb_active(struct super_block *sb);",
            "extern void nfs_sb_deactive(struct super_block *sb);",
            "void nfs_umount_begin(struct super_block *);",
            "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern struct inode *nfs_alloc_inode(struct super_block *sb);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nextern bool nfs_sb_active(struct super_block *sb);\nextern void nfs_sb_deactive(struct super_block *sb);\nvoid nfs_umount_begin(struct super_block *);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_iput_and_deactive(struct inode *inode)\n{\n\tif (inode != NULL) {\n\t\tstruct super_block *sb = inode->i_sb;\n\n\t\tiput(inode);\n\t\tnfs_sb_deactive(sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs_sb_active",
          "args": [
            "inode->i_sb"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_sb_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/super.c",
          "lines": "407-416",
          "snippet": "bool nfs_sb_active(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (!atomic_inc_not_zero(&sb->s_active))\n\t\treturn false;\n\tif (atomic_inc_return(&server->active) != 1)\n\t\tatomic_dec(&sb->s_active);\n\treturn true;\n}",
          "includes": [
            "#include \"nfs.h\"",
            "#include \"pnfs.h\"",
            "#include \"nfs4session.h\"",
            "#include \"fscache.h\"",
            "#include \"internal.h\"",
            "#include \"iostat.h\"",
            "#include \"delegation.h\"",
            "#include \"callback.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/netdevice.h>",
            "#include <net/ipv6.h>",
            "#include <linux/slab.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/vfs.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/lockd/bind.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/xprtrdma.h>",
            "#include <linux/sunrpc/xprtsock.h>",
            "#include <linux/sunrpc/metrics.h>",
            "#include <linux/sunrpc/stats.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/unistd.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs.h\"\n#include \"pnfs.h\"\n#include \"nfs4session.h\"\n#include \"fscache.h\"\n#include \"internal.h\"\n#include \"iostat.h\"\n#include \"delegation.h\"\n#include \"callback.h\"\n#include \"nfs4_fs.h\"\n#include <asm/uaccess.h>\n#include <linux/rcupdate.h>\n#include <linux/nsproxy.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/nfs_xdr.h>\n#include <linux/netdevice.h>\n#include <net/ipv6.h>\n#include <linux/slab.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/vfs.h>\n#include <linux/nfs_idmap.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/seq_file.h>\n#include <linux/lockd/bind.h>\n#include <linux/nfs4_mount.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/xprtrdma.h>\n#include <linux/sunrpc/xprtsock.h>\n#include <linux/sunrpc/metrics.h>\n#include <linux/sunrpc/stats.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/unistd.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nbool nfs_sb_active(struct super_block *sb)\n{\n\tstruct nfs_server *server = NFS_SB(sb);\n\n\tif (!atomic_inc_not_zero(&sb->s_active))\n\t\treturn false;\n\tif (atomic_inc_return(&server->active) != 1)\n\t\tatomic_dec(&sb->s_active);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_igrab_and_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "517-525",
          "snippet": "static inline struct inode *nfs_igrab_and_active(struct inode *inode)\n{\n\tinode = igrab(inode);\n\tif (inode != NULL && !nfs_sb_active(inode->i_sb)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline struct inode *nfs_igrab_and_active(struct inode *inode)\n{\n\tinode = igrab(inode);\n\tif (inode != NULL && !nfs_sb_active(inode->i_sb)) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "nfs_inode_dio_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "498-501",
    "snippet": "static inline void nfs_inode_dio_wait(struct inode *inode)\n{\n\tinode_dio_wait(inode);\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);",
      "extern void nfs_destroy_inode(struct inode *);",
      "extern int nfs_drop_inode(struct inode *);",
      "extern void nfs_clear_inode(struct inode *);",
      "extern void nfs_evict_inode(struct inode *);",
      "void nfs_zap_acl_cache(struct inode *inode);",
      "int nfs_key_timeout_notify(struct file *filp, struct inode *inode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
          "lines": "498-501",
          "snippet": "static inline void nfs_inode_dio_wait(struct inode *inode)\n{\n\tinode_dio_wait(inode);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern struct rpc_clnt *nfs4_find_or_create_ds_client(struct nfs_client *,\n\t\t\t\t\t\tstruct inode *);\nextern void nfs_destroy_inode(struct inode *);\nextern int nfs_drop_inode(struct inode *);\nextern void nfs_clear_inode(struct inode *);\nextern void nfs_evict_inode(struct inode *);\nvoid nfs_zap_acl_cache(struct inode *inode);\nint nfs_key_timeout_notify(struct file *filp, struct inode *inode);\n\nstatic inline void nfs_inode_dio_wait(struct inode *inode)\n{\n\tinode_dio_wait(inode);\n}"
  },
  {
    "function_name": "nfs_zap_label_cache_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "316-318",
    "snippet": "static inline void nfs_zap_label_cache_locked(struct nfs_inode *nfsi)\n{\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline void nfs_zap_label_cache_locked(struct nfs_inode *nfsi)\n{\n}"
  },
  {
    "function_name": "nfs4_label_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "315-315",
    "snippet": "static inline void nfs4_label_free(void *label) {}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline void nfs4_label_free(void *label) {}"
  },
  {
    "function_name": "nfs4_label_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "314-314",
    "snippet": "static inline struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags) { return NULL; }",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void nfs_server_insert_lists(struct nfs_server *);",
      "void nfs_server_remove_lists(struct nfs_server *);",
      "void nfs_server_copy_userdata(struct nfs_server *, struct nfs_server *);",
      "extern void nfs_free_server(struct nfs_server *server);",
      "int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags);",
      "extern char *nfs_path(char **p, struct dentry *dentry,\n\t\t      char *buffer, ssize_t buflen, unsigned flags);",
      "extern int nfs_initiate_commit(struct rpc_clnt *clnt,\n\t\t\t       struct nfs_commit_data *data,\n\t\t\t       const struct nfs_rpc_ops *nfs_ops,\n\t\t\t       const struct rpc_call_ops *call_ops,\n\t\t\t       int how, int flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nvoid nfs_server_insert_lists(struct nfs_server *);\nvoid nfs_server_remove_lists(struct nfs_server *);\nvoid nfs_server_copy_userdata(struct nfs_server *, struct nfs_server *);\nextern void nfs_free_server(struct nfs_server *server);\nint nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags);\nextern char *nfs_path(char **p, struct dentry *dentry,\n\t\t      char *buffer, ssize_t buflen, unsigned flags);\nextern int nfs_initiate_commit(struct rpc_clnt *clnt,\n\t\t\t       struct nfs_commit_data *data,\n\t\t\t       const struct nfs_rpc_ops *nfs_ops,\n\t\t\t       const struct rpc_call_ops *call_ops,\n\t\t\t       int how, int flags);\n\nstatic inline struct nfs4_label *nfs4_label_alloc(struct nfs_server *server, gfp_t flags) { return NULL; }"
  },
  {
    "function_name": "nfs_zap_label_cache_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "308-312",
    "snippet": "static inline void nfs_zap_label_cache_locked(struct nfs_inode *nfsi)\n{\n\tif (nfs_server_capable(&nfsi->vfs_inode, NFS_CAP_SECURITY_LABEL))\n\t\tnfsi->cache_validity |= NFS_INO_INVALID_LABEL;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_server_capable",
          "args": [
            "&nfsi->vfs_inode",
            "NFS_CAP_SECURITY_LABEL"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline void nfs_zap_label_cache_locked(struct nfs_inode *nfsi)\n{\n\tif (nfs_server_capable(&nfsi->vfs_inode, NFS_CAP_SECURITY_LABEL))\n\t\tnfsi->cache_validity |= NFS_INO_INVALID_LABEL;\n}"
  },
  {
    "function_name": "nfs4_label_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "299-306",
    "snippet": "static inline void nfs4_label_free(struct nfs4_label *label)\n{\n\tif (label) {\n\t\tkfree(label->label);\n\t\tkfree(label);\n\t}\n\treturn;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "label"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "label->label"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline void nfs4_label_free(struct nfs4_label *label)\n{\n\tif (label) {\n\t\tkfree(label->label);\n\t\tkfree(label);\n\t}\n\treturn;\n}"
  },
  {
    "function_name": "nfs_pgio_has_mirroring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "265-269",
    "snippet": "static inline bool nfs_pgio_has_mirroring(struct nfs_pageio_descriptor *desc)\n{\n\tWARN_ON_ONCE(desc->pg_mirror_count < 1);\n\treturn desc->pg_mirror_count > 1;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "desc->pg_mirror_count < 1"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstruct nfs_pgio_mirror *\nnfs_pgio_current_mirror(struct nfs_pageio_descriptor *desc);\n\nstatic inline bool nfs_pgio_has_mirroring(struct nfs_pageio_descriptor *desc)\n{\n\tWARN_ON_ONCE(desc->pg_mirror_count < 1);\n\treturn desc->pg_mirror_count > 1;\n}"
  },
  {
    "function_name": "nfs_iocounter_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "259-263",
    "snippet": "static inline void nfs_iocounter_init(struct nfs_io_counter *c)\n{\n\tc->flags = 0;\n\tatomic_set(&c->io_count, 0);\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int nfs_iocounter_wait(struct nfs_io_counter *c);",
      "int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags);",
      "extern char *nfs_path(char **p, struct dentry *dentry,\n\t\t      char *buffer, ssize_t buflen, unsigned flags);",
      "extern int nfs_initiate_commit(struct rpc_clnt *clnt,\n\t\t\t       struct nfs_commit_data *data,\n\t\t\t       const struct nfs_rpc_ops *nfs_ops,\n\t\t\t       const struct rpc_call_ops *call_ops,\n\t\t\t       int how, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&c->io_count",
            "0"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_iocounter_wait(struct nfs_io_counter *c);\nint nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,\n\t\t      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,\n\t\t      const struct rpc_call_ops *call_ops, int how, int flags);\nextern char *nfs_path(char **p, struct dentry *dentry,\n\t\t      char *buffer, ssize_t buflen, unsigned flags);\nextern int nfs_initiate_commit(struct rpc_clnt *clnt,\n\t\t\t       struct nfs_commit_data *data,\n\t\t\t       const struct nfs_rpc_ops *nfs_ops,\n\t\t\t       const struct rpc_call_ops *call_ops,\n\t\t\t       int how, int flags);\n\nstatic inline void nfs_iocounter_init(struct nfs_io_counter *c)\n{\n\tc->flags = 0;\n\tatomic_set(&c->io_count, 0);\n}"
  },
  {
    "function_name": "nfs_fs_proc_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "217-219",
    "snippet": "static inline void nfs_fs_proc_exit(void)\n{\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline void nfs_fs_proc_exit(void)\n{\n}"
  },
  {
    "function_name": "nfs_fs_proc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "213-216",
    "snippet": "static inline int nfs_fs_proc_init(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nstatic inline int nfs_fs_proc_init(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_fs_proc_net_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "210-212",
    "snippet": "static inline void nfs_fs_proc_net_exit(struct net *net)\n{\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern void nfs_clients_init(struct net *net);",
      "extern void nfs_cleanup_cb_ident_idr(struct net *);",
      "extern struct nfs_client *nfs4_find_client_ident(struct net *, int);",
      "extern int nfs4_update_server(struct nfs_server *server, const char *hostname,\n\t\t\t\t\tstruct sockaddr *sap, size_t salen,\n\t\t\t\t\tstruct net *net);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern void nfs_clients_init(struct net *net);\nextern void nfs_cleanup_cb_ident_idr(struct net *);\nextern struct nfs_client *nfs4_find_client_ident(struct net *, int);\nextern int nfs4_update_server(struct nfs_server *server, const char *hostname,\n\t\t\t\t\tstruct sockaddr *sap, size_t salen,\n\t\t\t\t\tstruct net *net);\n\nstatic inline void nfs_fs_proc_net_exit(struct net *net)\n{\n}"
  },
  {
    "function_name": "nfs_fs_proc_net_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "206-209",
    "snippet": "static inline int nfs_fs_proc_net_init(struct net *net)\n{\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern void nfs_clients_init(struct net *net);",
      "extern void nfs_cleanup_cb_ident_idr(struct net *);",
      "extern struct nfs_client *nfs4_find_client_ident(struct net *, int);",
      "extern int nfs4_update_server(struct nfs_server *server, const char *hostname,\n\t\t\t\t\tstruct sockaddr *sap, size_t salen,\n\t\t\t\t\tstruct net *net);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nextern void nfs_clients_init(struct net *net);\nextern void nfs_cleanup_cb_ident_idr(struct net *);\nextern struct nfs_client *nfs4_find_client_ident(struct net *, int);\nextern int nfs4_update_server(struct nfs_server *server, const char *hostname,\n\t\t\t\t\tstruct sockaddr *sap, size_t salen,\n\t\t\t\t\tstruct net *net);\n\nstatic inline int nfs_fs_proc_net_init(struct net *net)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "nfs_attr_use_mounted_on_fileid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "29-36",
    "snippet": "static inline int nfs_attr_use_mounted_on_fileid(struct nfs_fattr *fattr)\n{\n\tif (((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) == 0) ||\n\t    (((fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT) == 0) &&\n\t     ((fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) == 0)))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int nfs_probe_fsinfo(struct nfs_server *server, struct nfs_fh *, struct nfs_fattr *);",
      "struct vfsmount *nfs_submount(struct nfs_server *, struct dentry *,\n\t\t\t      struct nfs_fh *, struct nfs_fattr *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_probe_fsinfo(struct nfs_server *server, struct nfs_fh *, struct nfs_fattr *);\nstruct vfsmount *nfs_submount(struct nfs_server *, struct dentry *,\n\t\t\t      struct nfs_fh *, struct nfs_fattr *);\n\nstatic inline int nfs_attr_use_mounted_on_fileid(struct nfs_fattr *fattr)\n{\n\tif (((fattr->valid & NFS_ATTR_FATTR_MOUNTED_ON_FILEID) == 0) ||\n\t    (((fattr->valid & NFS_ATTR_FATTR_MOUNTPOINT) == 0) &&\n\t     ((fattr->valid & NFS_ATTR_FATTR_V4_REFERRAL) == 0)))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "nfs_attr_check_mountpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/internal.h",
    "lines": "23-27",
    "snippet": "static inline void nfs_attr_check_mountpoint(struct super_block *parent, struct nfs_fattr *fattr)\n{\n\tif (!nfs_fsid_equal(&NFS_SB(parent)->fsid, &fattr->fsid))\n\t\tfattr->valid |= NFS_ATTR_FATTR_MOUNTPOINT;\n}",
    "includes": [
      "#include <linux/nfs_page.h>",
      "#include <linux/crc32.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include \"nfs4_fs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int nfs_probe_fsinfo(struct nfs_server *server, struct nfs_fh *, struct nfs_fattr *);",
      "void nfs_initialise_sb(struct super_block *);",
      "void nfs_kill_super(struct super_block *);",
      "struct vfsmount *nfs_submount(struct nfs_server *, struct dentry *,\n\t\t\t      struct nfs_fh *, struct nfs_fattr *);",
      "void nfs_umount_begin(struct super_block *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs_fsid_equal",
          "args": [
            "&NFS_SB(parent)->fsid",
            "&fattr->fsid"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NFS_SB",
          "args": [
            "parent"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nfs_page.h>\n#include <linux/crc32.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include \"nfs4_fs.h\"\n\nint nfs_probe_fsinfo(struct nfs_server *server, struct nfs_fh *, struct nfs_fattr *);\nvoid nfs_initialise_sb(struct super_block *);\nvoid nfs_kill_super(struct super_block *);\nstruct vfsmount *nfs_submount(struct nfs_server *, struct dentry *,\n\t\t\t      struct nfs_fh *, struct nfs_fattr *);\nvoid nfs_umount_begin(struct super_block *);\n\nstatic inline void nfs_attr_check_mountpoint(struct super_block *parent, struct nfs_fattr *fattr)\n{\n\tif (!nfs_fsid_equal(&NFS_SB(parent)->fsid, &fattr->fsid))\n\t\tfattr->valid |= NFS_ATTR_FATTR_MOUNTPOINT;\n}"
  }
]