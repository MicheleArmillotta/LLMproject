[
  {
    "function_name": "nge_xattr(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "1398-1464",
    "snippet": "_change_xattr(struct ubifs_info *c, const struct inode *inode,\n\t\t\t   const struct inode *host)\n{\n\tint err, len1, len2, aligned_len, aligned_len1, lnum, offs;\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tstruct ubifs_ino_node *ino;\n\tunion ubifs_key key;\n\tint sync = IS_DIRSYNC(host);\n\n\tdbg_jnl(\"ino %lu, ino %lu\", host->i_ino, inode->i_ino);\n\tubifs_assert(host->i_nlink > 0);\n\tubifs_assert(inode->i_nlink > 0);\n\tubifs_assert(mutex_is_locked(&host_ui->ui_mutex));\n\n\tlen1 = UBIFS_INO_NODE_SZ + host_ui->data_len;\n\tlen2 = UBIFS_INO_NODE_SZ + ubifs_inode(inode)->data_len;\n\taligned_len1 = ALIGN(len1, 8);\n\taligned_len = aligned_len1 + ALIGN(len2, 8);\n\n\tino = kmalloc(aligned_len, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, BASEHD, aligned_len);\n\tif (err)\n\t\tgoto out_free;\n\n\tpack_inode(c, ino, host, 0);\n\tpack_inode(c, (void *)ino + aligned_len1, inode, 1);\n\n\terr = write_head(c, BASEHD, ino, aligned_len, &lnum, &offs, 0);\n\tif (!sync && !err) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[BASEHD].wbuf;\n\n\t\tubifs_wbuf_add_ino_nolock(wbuf, host->i_ino);\n\t\tubifs_wbuf_add_ino_nolock(wbuf, inode->i_ino);\n\t}\n\trelease_head(c, BASEHD);\n\tif (err)\n\t\tgoto out_ro;\n\n\tino_key_init(c, &key, host->i_ino);\n\terr = ubifs_tnc_add(c, &key, lnum, offs, len1);\n\tif (err)\n\t\tgoto out_ro;\n\n\tino_key_init(c, &key, inode->i_ino);\n\terr = ubifs_tnc_add(c, &key, lnum, offs + aligned_len1, len2);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&host_ui->ui_lock);\n\thost_ui->synced_i_size = host_ui->ui_size;\n\tspin_unlock(&host_ui->ui_lock);\n\tmark_inode_clean(c, host_ui);\n\tkfree(ino);\n\treturn 0;\n\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tkfree(ino);\n\treturn err;\n}",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "er"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ation(c);\nout_free",
          "args": [],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\tfi",
          "args": [
            "i",
            "_re"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ean(c, host_ui);",
          "args": [
            "ree(ino"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "host_ui->ui",
          "args": [
            "lock);\n\tmark_inod"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_ui->ui",
          "args": [
            "lock);\n\thost_ui->"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ation(c);\n\tspin_lo",
          "args": [
            "k"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, lnu",
          "args": [
            ",",
            "ffs",
            "alig",
            "d_len1, len2);\n\tif",
            "rr)"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, ino",
          "args": [
            "e",
            "i_in",
            ";\n\terr = ubi"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, lnu",
          "args": [
            ",",
            "ffs,",
            "en1)",
            "if",
            "rr)"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, hos",
          "args": [
            "-",
            "_ino",
            "err = ubi"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, BASEHD);",
          "args": [
            "i",
            "(err)"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ino_nolock(wbuf, inode-",
          "args": [
            "i_in",
            ";\n\t}\n\treleas"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ino_nolock(wbuf, host->",
          "args": [
            "_ino",
            "ubifs_wb"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASEHD, i",
          "args": [
            "o",
            "aligne",
            "len",
            "&lnum, &off",
            "0);",
            "f (!s",
            "c"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(void *)i",
          "args": [
            "o",
            "aligned_len1, inode, 1);",
            "err =",
            "r"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino, host",
          "args": [
            ";",
            "ck_i",
            "d"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ion(c, BASEHD, a",
          "args": [
            "i",
            "ed_len",
            "if (err)"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed_len,",
          "args": [
            "GFP_NOFS);",
            "f (!ino)"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "no =",
            "m"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\ta",
          "args": [
            "igne",
            "l"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node)->data",
          "args": [
            "len;"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&host_ui->ui_mutex));\n\n\tlen1 = U"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&host_ui->ui",
          "args": [
            "mutex));\n\n\tlen1 ="
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_nli",
          "args": [
            "k > 0);\n\tubifs_ass"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "host->i_nlin",
          "args": [
            "> 0);\n\tubifs_ass"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu, in",
          "args": [
            "%lu\", host->i_ino",
            "inode->i_in",
            ";\n\tubifs_ass"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st);\n\n\tdbg",
          "args": [
            "jnl("
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost);\n\tstru",
          "args": [
            "t ub"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\n_change_xattr(struct ubifs_info *c, const struct inode *inode,\n\t\t\t   const struct inode *host)\n{\n\tint err, len1, len2, aligned_len, aligned_len1, lnum, offs;\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\tstruct ubifs_ino_node *ino;\n\tunion ubifs_key key;\n\tint sync = IS_DIRSYNC(host);\n\n\tdbg_jnl(\"ino %lu, ino %lu\", host->i_ino, inode->i_ino);\n\tubifs_assert(host->i_nlink > 0);\n\tubifs_assert(inode->i_nlink > 0);\n\tubifs_assert(mutex_is_locked(&host_ui->ui_mutex));\n\n\tlen1 = UBIFS_INO_NODE_SZ + host_ui->data_len;\n\tlen2 = UBIFS_INO_NODE_SZ + ubifs_inode(inode)->data_len;\n\taligned_len1 = ALIGN(len1, 8);\n\taligned_len = aligned_len1 + ALIGN(len2, 8);\n\n\tino = kmalloc(aligned_len, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, BASEHD, aligned_len);\n\tif (err)\n\t\tgoto out_free;\n\n\tpack_inode(c, ino, host, 0);\n\tpack_inode(c, (void *)ino + aligned_len1, inode, 1);\n\n\terr = write_head(c, BASEHD, ino, aligned_len, &lnum, &offs, 0);\n\tif (!sync && !err) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[BASEHD].wbuf;\n\n\t\tubifs_wbuf_add_ino_nolock(wbuf, host->i_ino);\n\t\tubifs_wbuf_add_ino_nolock(wbuf, inode->i_ino);\n\t}\n\trelease_head(c, BASEHD);\n\tif (err)\n\t\tgoto out_ro;\n\n\tino_key_init(c, &key, host->i_ino);\n\terr = ubifs_tnc_add(c, &key, lnum, offs, len1);\n\tif (err)\n\t\tgoto out_ro;\n\n\tino_key_init(c, &key, inode->i_ino);\n\terr = ubifs_tnc_add(c, &key, lnum, offs + aligned_len1, len2);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&host_ui->ui_lock);\n\thost_ui->synced_i_size = host_ui->ui_size;\n\tspin_unlock(&host_ui->ui_lock);\n\tmark_inode_clean(c, host_ui);\n\tkfree(ino);\n\treturn 0;\n\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tkfree(ino);\n\treturn err;\n}"
  },
  {
    "function_name": "ete_xattr(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "1285-1383",
    "snippet": "_delete_xattr(struct ubifs_info *c, const struct inode *host,\n\t\t\t   const struct inode *inode, const struct qstr *nm)\n{\n\tint err, xlen, hlen, len, lnum, xent_offs, aligned_xlen;\n\tstruct ubifs_dent_node *xent;\n\tstruct ubifs_ino_node *ino;\n\tunion ubifs_key xent_key, key1, key2;\n\tint sync = IS_DIRSYNC(host);\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\n\tdbg_jnl(\"host %lu, xattr ino %lu, name '%s', data len %d\",\n\t\thost->i_ino, inode->i_ino, nm->name,\n\t\tubifs_inode(inode)->data_len);\n\tubifs_assert(inode->i_nlink == 0);\n\tubifs_assert(mutex_is_locked(&host_ui->ui_mutex));\n\n\t/*\n\t * Since we are deleting the inode, we do not bother to attach any data\n\t * to it and assume its length is %UBIFS_INO_NODE_SZ.\n\t */\n\txlen = UBIFS_DENT_NODE_SZ + nm->len + 1;\n\taligned_xlen = ALIGN(xlen, 8);\n\thlen = host_ui->data_len + UBIFS_INO_NODE_SZ;\n\tlen = aligned_xlen + UBIFS_INO_NODE_SZ + ALIGN(hlen, 8);\n\n\txent = kmalloc(len, GFP_NOFS);\n\tif (!xent)\n\t\treturn -ENOMEM;\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, BASEHD, len);\n\tif (err) {\n\t\tkfree(xent);\n\t\treturn err;\n\t}\n\n\txent->ch.node_type = UBIFS_XENT_NODE;\n\txent_key_init(c, &xent_key, host->i_ino, nm);\n\tkey_write(c, &xent_key, xent->key);\n\txent->inum = 0;\n\txent->type = get_dent_type(inode->i_mode);\n\txent->nlen = cpu_to_le16(nm->len);\n\tmemcpy(xent->name, nm->name, nm->len);\n\txent->name[nm->len] = '\\0';\n\tzero_dent_node_unused(xent);\n\tubifs_prep_grp_node(c, xent, xlen, 0);\n\n\tino = (void *)xent + aligned_xlen;\n\tpack_inode(c, ino, inode, 0);\n\tino = (void *)ino + UBIFS_INO_NODE_SZ;\n\tpack_inode(c, ino, host, 1);\n\n\terr = write_head(c, BASEHD, xent, len, &lnum, &xent_offs, sync);\n\tif (!sync && !err)\n\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf, host->i_ino);\n\trelease_head(c, BASEHD);\n\tkfree(xent);\n\tif (err)\n\t\tgoto out_ro;\n\n\t/* Remove the extended attribute entry from TNC */\n\terr = ubifs_tnc_remove_nm(c, &xent_key, nm);\n\tif (err)\n\t\tgoto out_ro;\n\terr = ubifs_add_dirt(c, lnum, xlen);\n\tif (err)\n\t\tgoto out_ro;\n\n\t/*\n\t * Remove all nodes belonging to the extended attribute inode from TNC.\n\t * Well, there actually must be only one node - the inode itself.\n\t */\n\tlowest_ino_key(c, &key1, inode->i_ino);\n\thighest_ino_key(c, &key2, inode->i_ino);\n\terr = ubifs_tnc_remove_range(c, &key1, &key2);\n\tif (err)\n\t\tgoto out_ro;\n\terr = ubifs_add_dirt(c, lnum, UBIFS_INO_NODE_SZ);\n\tif (err)\n\t\tgoto out_ro;\n\n\t/* And update TNC with the new host inode position */\n\tino_key_init(c, &key1, host->i_ino);\n\terr = ubifs_tnc_add(c, &key1, lnum, xent_offs + len - hlen, hlen);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&host_ui->ui_lock);\n\thost_ui->synced_i_size = host_ui->ui_size;\n\tspin_unlock(&host_ui->ui_lock);\n\tmark_inode_clean(c, host_ui);\n\treturn 0;\n\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ation(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\tfi",
          "args": [
            "i",
            "_re"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ean(c, host_ui);",
          "args": [
            "turn 0;"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "host_ui->ui",
          "args": [
            "lock);\n\tmark_inod"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_ui->ui",
          "args": [
            "lock);\n\thost_ui->"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ation(c);\n\tspin_lo",
          "args": [
            "k"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key1, ln",
          "args": [
            "m",
            "xent_",
            "fs +",
            "en - hlen, hlen);\n\tif",
            "rr)"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key1, ho",
          "args": [
            "t",
            "i_ino",
            "err = ubi"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, lnum, UBI",
          "args": [
            "S",
            "NO_N",
            "E_SZ);\n\tif (err)"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove_range(c, &key1, &k",
          "args": [
            "y",
            ";\n\tif",
            "err)"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey(c, &key2, in",
          "args": [
            "d",
            ">i_in",
            ";\n\terr = ubi"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y(c, &key1, in",
          "args": [
            "d",
            ">i_in",
            ";\n\thighest_i"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, lnum, xle",
          "args": [
            ")",
            "if",
            "rr)"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove_nm(c, &xent_key",
          "args": [
            ");\n\tif (e",
            ")"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (",
          "args": [
            "rr)"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, BASEHD);",
          "args": [
            "k",
            "ee(xen"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ino_nolock(&c->jheads[B",
          "args": [
            "SEHD].wbuf, host->i_ino",
            "release_h"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASEHD, x",
          "args": [
            "n",
            "len,",
            "num,",
            "xen",
            "offs,",
            "ync);\n\tif",
            "sync"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino, host",
          "args": [
            ";",
            "rr =",
            "r"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino, inod",
          "args": [
            ",",
            ");",
            "no =",
            "o"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_node(c, xent, xle",
          "args": [
            ",",
            ");",
            "no =",
            "v"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_unused(xent);\n\tubif",
          "args": [
            "_pre"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name,",
          "args": [
            "m->name, n",
            ">len);",
            "nt->nam"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->len);\n\tm",
          "args": [
            "mcpy(xe"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(inode->i_mod",
          "args": [
            ");\n\txent->nle"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&xent_key",
          "args": [
            "nt->key);",
            "xent->inu"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &xent_key",
          "args": [
            "st->i_ino",
            "nm);\n\tkey_w",
            "te"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn e"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ion(c, BASEHD, l",
          "args": [
            "n",
            "if (",
            "r)"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFP_NOF",
          "args": [
            ");",
            "f (!xent"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "ent",
            "k"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\th",
          "args": [
            "en =",
            "o"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&host_ui->ui_mutex));\n\n\t/*\n\t * S"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&host_ui->ui",
          "args": [
            "mutex));\n\n\t/*\n\t *"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_nli",
          "args": [
            "k == 0);\n\tubifs_ass"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu, x",
          "args": [
            "ttr ino %lu, name '%s', data len %d\",\n\t\thost->i_i",
            "inode->i_in",
            "nm->name,",
            "bifs_ino",
            "node)->data_len);\n\tubifs_ass"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node)->data",
          "args": [
            "len);"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ost);\n\n\tdbg",
          "args": [
            "jnl("
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st);\n\tstru",
          "args": [
            "t ub"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\n_delete_xattr(struct ubifs_info *c, const struct inode *host,\n\t\t\t   const struct inode *inode, const struct qstr *nm)\n{\n\tint err, xlen, hlen, len, lnum, xent_offs, aligned_xlen;\n\tstruct ubifs_dent_node *xent;\n\tstruct ubifs_ino_node *ino;\n\tunion ubifs_key xent_key, key1, key2;\n\tint sync = IS_DIRSYNC(host);\n\tstruct ubifs_inode *host_ui = ubifs_inode(host);\n\n\tdbg_jnl(\"host %lu, xattr ino %lu, name '%s', data len %d\",\n\t\thost->i_ino, inode->i_ino, nm->name,\n\t\tubifs_inode(inode)->data_len);\n\tubifs_assert(inode->i_nlink == 0);\n\tubifs_assert(mutex_is_locked(&host_ui->ui_mutex));\n\n\t/*\n\t * Since we are deleting the inode, we do not bother to attach any data\n\t * to it and assume its length is %UBIFS_INO_NODE_SZ.\n\t */\n\txlen = UBIFS_DENT_NODE_SZ + nm->len + 1;\n\taligned_xlen = ALIGN(xlen, 8);\n\thlen = host_ui->data_len + UBIFS_INO_NODE_SZ;\n\tlen = aligned_xlen + UBIFS_INO_NODE_SZ + ALIGN(hlen, 8);\n\n\txent = kmalloc(len, GFP_NOFS);\n\tif (!xent)\n\t\treturn -ENOMEM;\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, BASEHD, len);\n\tif (err) {\n\t\tkfree(xent);\n\t\treturn err;\n\t}\n\n\txent->ch.node_type = UBIFS_XENT_NODE;\n\txent_key_init(c, &xent_key, host->i_ino, nm);\n\tkey_write(c, &xent_key, xent->key);\n\txent->inum = 0;\n\txent->type = get_dent_type(inode->i_mode);\n\txent->nlen = cpu_to_le16(nm->len);\n\tmemcpy(xent->name, nm->name, nm->len);\n\txent->name[nm->len] = '\\0';\n\tzero_dent_node_unused(xent);\n\tubifs_prep_grp_node(c, xent, xlen, 0);\n\n\tino = (void *)xent + aligned_xlen;\n\tpack_inode(c, ino, inode, 0);\n\tino = (void *)ino + UBIFS_INO_NODE_SZ;\n\tpack_inode(c, ino, host, 1);\n\n\terr = write_head(c, BASEHD, xent, len, &lnum, &xent_offs, sync);\n\tif (!sync && !err)\n\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf, host->i_ino);\n\trelease_head(c, BASEHD);\n\tkfree(xent);\n\tif (err)\n\t\tgoto out_ro;\n\n\t/* Remove the extended attribute entry from TNC */\n\terr = ubifs_tnc_remove_nm(c, &xent_key, nm);\n\tif (err)\n\t\tgoto out_ro;\n\terr = ubifs_add_dirt(c, lnum, xlen);\n\tif (err)\n\t\tgoto out_ro;\n\n\t/*\n\t * Remove all nodes belonging to the extended attribute inode from TNC.\n\t * Well, there actually must be only one node - the inode itself.\n\t */\n\tlowest_ino_key(c, &key1, inode->i_ino);\n\thighest_ino_key(c, &key2, inode->i_ino);\n\terr = ubifs_tnc_remove_range(c, &key1, &key2);\n\tif (err)\n\t\tgoto out_ro;\n\terr = ubifs_add_dirt(c, lnum, UBIFS_INO_NODE_SZ);\n\tif (err)\n\t\tgoto out_ro;\n\n\t/* And update TNC with the new host inode position */\n\tino_key_init(c, &key1, host->i_ino);\n\terr = ubifs_tnc_add(c, &key1, lnum, xent_offs + len - hlen, hlen);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&host_ui->ui_lock);\n\thost_ui->synced_i_size = host_ui->ui_size;\n\tspin_unlock(&host_ui->ui_lock);\n\tmark_inode_clean(c, host_ui);\n\treturn 0;\n\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ncate(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "1144-1270",
    "snippet": "_truncate(struct ubifs_info *c, const struct inode *inode,\n\t\t       loff_t old_size, loff_t new_size)\n{\n\tunion ubifs_key key, to_key;\n\tstruct ubifs_ino_node *ino;\n\tstruct ubifs_trun_node *trun;\n\tstruct ubifs_data_node *uninitialized_var(dn);\n\tint err, dlen, len, lnum, offs, bit, sz, sync = IS_SYNC(inode);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tino_t inum = inode->i_ino;\n\tunsigned int blk;\n\n\tdbg_jnl(\"ino %lu, size %lld -> %lld\",\n\t\t(unsigned long)inum, old_size, new_size);\n\tubifs_assert(!ui->data_len);\n\tubifs_assert(S_ISREG(inode->i_mode));\n\tubifs_assert(mutex_is_locked(&ui->ui_mutex));\n\n\tsz = UBIFS_TRUN_NODE_SZ + UBIFS_INO_NODE_SZ +\n\t     UBIFS_MAX_DATA_NODE_SZ * WORST_COMPR_FACTOR;\n\tino = kmalloc(sz, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\ttrun = (void *)ino + UBIFS_INO_NODE_SZ;\n\ttrun->ch.node_type = UBIFS_TRUN_NODE;\n\ttrun->inum = cpu_to_le32(inum);\n\ttrun->old_size = cpu_to_le64(old_size);\n\ttrun->new_size = cpu_to_le64(new_size);\n\tzero_trun_node_unused(trun);\n\n\tdlen = new_size & (UBIFS_BLOCK_SIZE - 1);\n\tif (dlen) {\n\t\t/* Get last data block so it can be truncated */\n\t\tdn = (void *)trun + UBIFS_TRUN_NODE_SZ;\n\t\tblk = new_size >> UBIFS_BLOCK_SHIFT;\n\t\tdata_key_init(c, &key, inum, blk);\n\t\tdbg_jnlk(&key, \"last block key \");\n\t\terr = ubifs_tnc_lookup(c, &key, dn);\n\t\tif (err == -ENOENT)\n\t\t\tdlen = 0; /* Not found (so it is a hole) */\n\t\telse if (err)\n\t\t\tgoto out_free;\n\t\telse {\n\t\t\tif (le32_to_cpu(dn->size) <= dlen)\n\t\t\t\tdlen = 0; /* Nothing to do */\n\t\t\telse {\n\t\t\t\tint compr_type = le16_to_cpu(dn->compr_type);\n\n\t\t\t\tif (compr_type != UBIFS_COMPR_NONE) {\n\t\t\t\t\terr = recomp_data_node(dn, &dlen);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\tgoto out_free;\n\t\t\t\t} else {\n\t\t\t\t\tdn->size = cpu_to_le32(dlen);\n\t\t\t\t\tdlen += UBIFS_DATA_NODE_SZ;\n\t\t\t\t}\n\t\t\t\tzero_data_node_unused(dn);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Must make reservation before allocating sequence numbers */\n\tlen = UBIFS_TRUN_NODE_SZ + UBIFS_INO_NODE_SZ;\n\tif (dlen)\n\t\tlen += dlen;\n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n\t\tgoto out_free;\n\n\tpack_inode(c, ino, inode, 0);\n\tubifs_prep_grp_node(c, trun, UBIFS_TRUN_NODE_SZ, dlen ? 0 : 1);\n\tif (dlen)\n\t\tubifs_prep_grp_node(c, dn, dlen, 1);\n\n\terr = write_head(c, BASEHD, ino, len, &lnum, &offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync)\n\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf, inum);\n\trelease_head(c, BASEHD);\n\n\tif (dlen) {\n\t\tsz = offs + UBIFS_INO_NODE_SZ + UBIFS_TRUN_NODE_SZ;\n\t\terr = ubifs_tnc_add(c, &key, lnum, sz, dlen);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t}\n\n\tino_key_init(c, &key, inum);\n\terr = ubifs_tnc_add(c, &key, lnum, offs, UBIFS_INO_NODE_SZ);\n\tif (err)\n\t\tgoto out_ro;\n\n\terr = ubifs_add_dirt(c, lnum, UBIFS_TRUN_NODE_SZ);\n\tif (err)\n\t\tgoto out_ro;\n\n\tbit = new_size & (UBIFS_BLOCK_SIZE - 1);\n\tblk = (new_size >> UBIFS_BLOCK_SHIFT) + (bit ? 1 : 0);\n\tdata_key_init(c, &key, inum, blk);\n\n\tbit = old_size & (UBIFS_BLOCK_SIZE - 1);\n\tblk = (old_size >> UBIFS_BLOCK_SHIFT) - (bit ? 0 : 1);\n\tdata_key_init(c, &to_key, inum, blk);\n\n\terr = ubifs_tnc_remove_range(c, &key, &to_key);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&ui->ui_lock);\n\tui->synced_i_size = ui->ui_size;\n\tspin_unlock(&ui->ui_lock);\n\tmark_inode_clean(c, ui);\n\tkfree(ino);\n\treturn 0;\n\nout_release:\n\trelease_head(c, BASEHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tkfree(ino);\n\treturn err;\n}\n\n\n/**\n * ubi",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "er"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ation(c);\nout_free",
          "args": [],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\tfi",
          "args": [
            "i",
            "_re"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, BASEHD);",
          "args": [
            "u",
            "ro:\n\tu"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ean(c, ui);\n\tkfr",
          "args": [
            "e",
            "no"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->ui_lock",
          "args": [
            ";\n\tmark_inod"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ui_lock",
          "args": [
            ";\n\tui->synce"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ation(c);\n\tspin_lo",
          "args": [
            "k"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove_range(c, &key, &to",
          "args": [
            "k",
            ");",
            "(err)"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &to_key,",
          "args": [
            "n",
            ", blk);",
            "err",
            "ub"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, inu",
          "args": [
            ",",
            "lk);",
            "bit",
            "ol"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, lnum, UBI",
          "args": [
            "S",
            "RUN_",
            "DE_SZ);\n\tif (err)"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, lnu",
          "args": [
            ",",
            "ffs,",
            "BIFS",
            "NO_N",
            "E_SZ);\n\tif (err)"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, inu",
          "args": [
            ")",
            "err",
            "ubi"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, lnu",
          "args": [
            ",",
            "z, d",
            "n);",
            "if",
            "err)"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, BASEHD);",
          "args": [
            "(dlen"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ino_nolock(&c->jheads[B",
          "args": [
            "SEHD].wbuf, inum);\n\trel",
            "se_h"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASEHD, i",
          "args": [
            "o",
            "len, &",
            "um,",
            "off",
            "sync",
            "if",
            "rr)"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_node(c, dn, dlen,",
          "args": [
            "1",
            "rr =",
            "r"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_node(c, trun, UBI",
          "args": [
            "S",
            "RUN_",
            "DE_SZ, dlen ? 0 :",
            ";\n\tif (dlen)"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino, inod",
          "args": [
            ",",
            ");",
            "bifs_",
            "e"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ion(c, BASEHD, l",
          "args": [
            "n",
            "if (",
            "r)"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_unused(dn);\n\t\t\t}",
          "args": [],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len);",
          "args": [
            "len"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(dn, &dlen);",
          "args": [
            "if (e"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->compr_ty",
          "args": [
            "e);\n\n\t\t\t\tif (c"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->size) <=",
          "args": [
            "dlen)"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup(c, &key, dn)",
          "args": [
            "if (",
            "r"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", \"last",
          "args": [
            "lock",
            "ey \");\n\t\terr = ub"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, inu",
          "args": [
            ",",
            "lk);",
            "dbg",
            "nlk"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_unused(trun);\n\n\tdle",
          "args": [
            "= n"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_size);",
          "args": [
            "ero_trun"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_size);",
          "args": [
            "run->new"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num);\n\ttrun",
          "args": [
            ">old"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FP_NOFS",
          "args": [
            ";",
            "f (!ino)"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&ui->ui_mutex));\n\n\tsz = UBI"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&ui->ui_mute",
          "args": [
            "));\n\n\tsz = UB"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG(inod",
          "args": [
            "->i_mode));\n\tubifs_ass"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->i_mod",
          "args": [
            "));\n\tubifs_as"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!ui->data_le",
          "args": [
            ");\n\tubifs_ass"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu, si",
          "args": [
            "e %lld -> %lld\",\n\t\t(unsigned",
            "g)inum, old_size, n",
            "_size);",
            "bifs_ass"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tino",
          "args": [
            "t inu"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tstr",
          "args": [
            "ct ub"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\n_truncate(struct ubifs_info *c, const struct inode *inode,\n\t\t       loff_t old_size, loff_t new_size)\n{\n\tunion ubifs_key key, to_key;\n\tstruct ubifs_ino_node *ino;\n\tstruct ubifs_trun_node *trun;\n\tstruct ubifs_data_node *uninitialized_var(dn);\n\tint err, dlen, len, lnum, offs, bit, sz, sync = IS_SYNC(inode);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tino_t inum = inode->i_ino;\n\tunsigned int blk;\n\n\tdbg_jnl(\"ino %lu, size %lld -> %lld\",\n\t\t(unsigned long)inum, old_size, new_size);\n\tubifs_assert(!ui->data_len);\n\tubifs_assert(S_ISREG(inode->i_mode));\n\tubifs_assert(mutex_is_locked(&ui->ui_mutex));\n\n\tsz = UBIFS_TRUN_NODE_SZ + UBIFS_INO_NODE_SZ +\n\t     UBIFS_MAX_DATA_NODE_SZ * WORST_COMPR_FACTOR;\n\tino = kmalloc(sz, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\ttrun = (void *)ino + UBIFS_INO_NODE_SZ;\n\ttrun->ch.node_type = UBIFS_TRUN_NODE;\n\ttrun->inum = cpu_to_le32(inum);\n\ttrun->old_size = cpu_to_le64(old_size);\n\ttrun->new_size = cpu_to_le64(new_size);\n\tzero_trun_node_unused(trun);\n\n\tdlen = new_size & (UBIFS_BLOCK_SIZE - 1);\n\tif (dlen) {\n\t\t/* Get last data block so it can be truncated */\n\t\tdn = (void *)trun + UBIFS_TRUN_NODE_SZ;\n\t\tblk = new_size >> UBIFS_BLOCK_SHIFT;\n\t\tdata_key_init(c, &key, inum, blk);\n\t\tdbg_jnlk(&key, \"last block key \");\n\t\terr = ubifs_tnc_lookup(c, &key, dn);\n\t\tif (err == -ENOENT)\n\t\t\tdlen = 0; /* Not found (so it is a hole) */\n\t\telse if (err)\n\t\t\tgoto out_free;\n\t\telse {\n\t\t\tif (le32_to_cpu(dn->size) <= dlen)\n\t\t\t\tdlen = 0; /* Nothing to do */\n\t\t\telse {\n\t\t\t\tint compr_type = le16_to_cpu(dn->compr_type);\n\n\t\t\t\tif (compr_type != UBIFS_COMPR_NONE) {\n\t\t\t\t\terr = recomp_data_node(dn, &dlen);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\tgoto out_free;\n\t\t\t\t} else {\n\t\t\t\t\tdn->size = cpu_to_le32(dlen);\n\t\t\t\t\tdlen += UBIFS_DATA_NODE_SZ;\n\t\t\t\t}\n\t\t\t\tzero_data_node_unused(dn);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Must make reservation before allocating sequence numbers */\n\tlen = UBIFS_TRUN_NODE_SZ + UBIFS_INO_NODE_SZ;\n\tif (dlen)\n\t\tlen += dlen;\n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n\t\tgoto out_free;\n\n\tpack_inode(c, ino, inode, 0);\n\tubifs_prep_grp_node(c, trun, UBIFS_TRUN_NODE_SZ, dlen ? 0 : 1);\n\tif (dlen)\n\t\tubifs_prep_grp_node(c, dn, dlen, 1);\n\n\terr = write_head(c, BASEHD, ino, len, &lnum, &offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync)\n\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf, inum);\n\trelease_head(c, BASEHD);\n\n\tif (dlen) {\n\t\tsz = offs + UBIFS_INO_NODE_SZ + UBIFS_TRUN_NODE_SZ;\n\t\terr = ubifs_tnc_add(c, &key, lnum, sz, dlen);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t}\n\n\tino_key_init(c, &key, inum);\n\terr = ubifs_tnc_add(c, &key, lnum, offs, UBIFS_INO_NODE_SZ);\n\tif (err)\n\t\tgoto out_ro;\n\n\terr = ubifs_add_dirt(c, lnum, UBIFS_TRUN_NODE_SZ);\n\tif (err)\n\t\tgoto out_ro;\n\n\tbit = new_size & (UBIFS_BLOCK_SIZE - 1);\n\tblk = (new_size >> UBIFS_BLOCK_SHIFT) + (bit ? 1 : 0);\n\tdata_key_init(c, &key, inum, blk);\n\n\tbit = old_size & (UBIFS_BLOCK_SIZE - 1);\n\tblk = (old_size >> UBIFS_BLOCK_SHIFT) - (bit ? 0 : 1);\n\tdata_key_init(c, &to_key, inum, blk);\n\n\terr = ubifs_tnc_remove_range(c, &key, &to_key);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&ui->ui_lock);\n\tui->synced_i_size = ui->ui_size;\n\tspin_unlock(&ui->ui_lock);\n\tmark_inode_clean(c, ui);\n\tkfree(ino);\n\treturn 0;\n\nout_release:\n\trelease_head(c, BASEHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tkfree(ino);\n\treturn err;\n}\n\n\n/**\n * ubi"
  },
  {
    "function_name": "ode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "1103-1127",
    "snippet": "comp_data_node(struct ubifs_data_node *dn, int *new_len)\n{\n\tvoid *buf;\n\tint err, len, compr_type, out_len;\n\n\tout_len = le32_to_cpu(dn->size);\n\tbuf = kmalloc(out_len * WORST_COMPR_FACTOR, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlen = le32_to_cpu(dn->ch.len) - UBIFS_DATA_NODE_SZ;\n\tcompr_type = le16_to_cpu(dn->compr_type);\n\terr = ubifs_decompress(&dn->data, len, buf, &out_len, compr_type);\n\tif (err)\n\t\tgoto out;\n\n\tubifs_compress(buf, *new_len, &dn->data, &out_len, &compr_type);\n\tubifs_assert(out_len <= UBIFS_BLOCK_SIZE);\n\tdn->compr_type = cpu_to_le16(compr_type);\n\tdn->size = cpu_to_le32(*new_len);\n\t*new_len = UBIFS_DATA_NODE_SZ + out_len;\nout:\n\tkfree(buf);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "er"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_len);",
          "args": [
            "new_len"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ompr_type);",
          "args": [
            "dn->size"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_len <= U",
          "args": [
            "IFS_BLOCK_SIZE);\n\tdn->compr"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s(buf, *new_le",
          "args": [
            ", &",
            "->data,",
            "ut_len, &",
            "mpr_type",
            "ubifs_ass"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ess(&dn->data, l",
          "args": [
            "n, buf, &",
            "t_l",
            ", c",
            "pr_type)",
            "if (err)"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->compr_ty",
          "args": [
            "e);\n\terr = ubi"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->ch.len)",
          "args": [
            "UBIFS_DAT"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en * WO",
          "args": [
            "ST_COMPR_FACTOR, GFP_NOFS);",
            "f (!buf)"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n->size);",
          "args": [
            "uf = kma"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\ncomp_data_node(struct ubifs_data_node *dn, int *new_len)\n{\n\tvoid *buf;\n\tint err, len, compr_type, out_len;\n\n\tout_len = le32_to_cpu(dn->size);\n\tbuf = kmalloc(out_len * WORST_COMPR_FACTOR, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlen = le32_to_cpu(dn->ch.len) - UBIFS_DATA_NODE_SZ;\n\tcompr_type = le16_to_cpu(dn->compr_type);\n\terr = ubifs_decompress(&dn->data, len, buf, &out_len, compr_type);\n\tif (err)\n\t\tgoto out;\n\n\tubifs_compress(buf, *new_len, &dn->data, &out_len, &compr_type);\n\tubifs_assert(out_len <= UBIFS_BLOCK_SIZE);\n\tdn->compr_type = cpu_to_le16(compr_type);\n\tdn->size = cpu_to_le32(*new_len);\n\t*new_len = UBIFS_DATA_NODE_SZ + out_len;\nout:\n\tkfree(buf);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ame(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "924-1093",
    "snippet": "_rename(struct ubifs_info *c, const struct inode *old_dir,\n\t\t     const struct dentry *old_dentry,\n\t\t     const struct inode *new_dir,\n\t\t     const struct dentry *new_dentry, int sync)\n{\n\tvoid *p;\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent, *dent2;\n\tint err, dlen1, dlen2, ilen, lnum, offs, len;\n\tconst struct inode *old_inode = old_dentry->d_inode;\n\tconst struct inode *new_inode = new_dentry->d_inode;\n\tint aligned_dlen1, aligned_dlen2, plen = UBIFS_INO_NODE_SZ;\n\tint last_reference = !!(new_inode && new_inode->i_nlink == 0);\n\tint move = (old_dir != new_dir);\n\tstruct ubifs_inode *uninitialized_var(new_ui);\n\n\tdbg_jnl(\"dent '%pd' in dir ino %lu to dent '%pd' in dir ino %lu\",\n\t\told_dentry, old_dir->i_ino, new_dentry, new_dir->i_ino);\n\tubifs_assert(ubifs_inode(old_dir)->data_len == 0);\n\tubifs_assert(ubifs_inode(new_dir)->data_len == 0);\n\tubifs_assert(mutex_is_locked(&ubifs_inode(old_dir)->ui_mutex));\n\tubifs_assert(mutex_is_locked(&ubifs_inode(new_dir)->ui_mutex));\n\n\tdlen1 = UBIFS_DENT_NODE_SZ + new_dentry->d_name.len + 1;\n\tdlen2 = UBIFS_DENT_NODE_SZ + old_dentry->d_name.len + 1;\n\tif (new_inode) {\n\t\tnew_ui = ubifs_inode(new_inode);\n\t\tubifs_assert(mutex_is_locked(&new_ui->ui_mutex));\n\t\tilen = UBIFS_INO_NODE_SZ;\n\t\tif (!last_reference)\n\t\t\tilen += new_ui->data_len;\n\t} else\n\t\tilen = 0;\n\n\taligned_dlen1 = ALIGN(dlen1, 8);\n\taligned_dlen2 = ALIGN(dlen2, 8);\n\tlen = aligned_dlen1 + aligned_dlen2 + ALIGN(ilen, 8) + ALIGN(plen, 8);\n\tif (old_dir != new_dir)\n\t\tlen += plen;\n\tdent = kmalloc(len, GFP_NOFS);\n\tif (!dent)\n\t\treturn -ENOMEM;\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n\t\tgoto out_free;\n\n\t/* Make new dent */\n\tdent->ch.node_type = UBIFS_DENT_NODE;\n\tdent_key_init_flash(c, &dent->key, new_dir->i_ino, &new_dentry->d_name);\n\tdent->inum = cpu_to_le64(old_inode->i_ino);\n\tdent->type = get_dent_type(old_inode->i_mode);\n\tdent->nlen = cpu_to_le16(new_dentry->d_name.len);\n\tmemcpy(dent->name, new_dentry->d_name.name, new_dentry->d_name.len);\n\tdent->name[new_dentry->d_name.len] = '\\0';\n\tzero_dent_node_unused(dent);\n\tubifs_prep_grp_node(c, dent, dlen1, 0);\n\n\t/* Make deletion dent */\n\tdent2 = (void *)dent + aligned_dlen1;\n\tdent2->ch.node_type = UBIFS_DENT_NODE;\n\tdent_key_init_flash(c, &dent2->key, old_dir->i_ino,\n\t\t\t    &old_dentry->d_name);\n\tdent2->inum = 0;\n\tdent2->type = DT_UNKNOWN;\n\tdent2->nlen = cpu_to_le16(old_dentry->d_name.len);\n\tmemcpy(dent2->name, old_dentry->d_name.name, old_dentry->d_name.len);\n\tdent2->name[old_dentry->d_name.len] = '\\0';\n\tzero_dent_node_unused(dent2);\n\tubifs_prep_grp_node(c, dent2, dlen2, 0);\n\n\tp = (void *)dent2 + aligned_dlen2;\n\tif (new_inode) {\n\t\tpack_inode(c, p, new_inode, 0);\n\t\tp += ALIGN(ilen, 8);\n\t}\n\n\tif (!move)\n\t\tpack_inode(c, p, old_dir, 1);\n\telse {\n\t\tpack_inode(c, p, old_dir, 0);\n\t\tp += ALIGN(plen, 8);\n\t\tpack_inode(c, p, new_dir, 1);\n\t}\n\n\tif (last_reference) {\n\t\terr = ubifs_add_orphan(c, new_inode->i_ino);\n\t\tif (err) {\n\t\t\trelease_head(c, BASEHD);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tnew_ui->del_cmtno = c->cmt_no;\n\t}\n\n\terr = write_head(c, BASEHD, dent, len, &lnum, &offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[BASEHD].wbuf;\n\n\t\tubifs_wbuf_add_ino_nolock(wbuf, new_dir->i_ino);\n\t\tubifs_wbuf_add_ino_nolock(wbuf, old_dir->i_ino);\n\t\tif (new_inode)\n\t\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf,\n\t\t\t\t\t\t  new_inode->i_ino);\n\t}\n\trelease_head(c, BASEHD);\n\n\tdent_key_init(c, &key, new_dir->i_ino, &new_dentry->d_name);\n\terr = ubifs_tnc_add_nm(c, &key, lnum, offs, dlen1, &new_dentry->d_name);\n\tif (err)\n\t\tgoto out_ro;\n\n\terr = ubifs_add_dirt(c, lnum, dlen2);\n\tif (err)\n\t\tgoto out_ro;\n\n\tdent_key_init(c, &key, old_dir->i_ino, &old_dentry->d_name);\n\terr = ubifs_tnc_remove_nm(c, &key, &old_dentry->d_name);\n\tif (err)\n\t\tgoto out_ro;\n\n\toffs += aligned_dlen1 + aligned_dlen2;\n\tif (new_inode) {\n\t\tino_key_init(c, &key, new_inode->i_ino);\n\t\terr = ubifs_tnc_add(c, &key, lnum, offs, ilen);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t\toffs += ALIGN(ilen, 8);\n\t}\n\n\tino_key_init(c, &key, old_dir->i_ino);\n\terr = ubifs_tnc_add(c, &key, lnum, offs, plen);\n\tif (err)\n\t\tgoto out_ro;\n\n\tif (old_dir != new_dir) {\n\t\toffs += ALIGN(plen, 8);\n\t\tino_key_init(c, &key, new_dir->i_ino);\n\t\terr = ubifs_tnc_add(c, &key, lnum, offs, plen);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t}\n\n\tfinish_reservation(c);\n\tif (new_inode) {\n\t\tmark_inode_clean(c, new_ui);\n\t\tspin_lock(&new_ui->ui_lock);\n\t\tnew_ui->synced_i_size = new_ui->ui_size;\n\t\tspin_unlock(&new_ui->ui_lock);\n\t}\n\tmark_inode_clean(c, ubifs_inode(old_dir));\n\tif (move)\n\t\tmark_inode_clean(c, ubifs_inode(new_dir));\n\tkfree(dent);\n\treturn 0;\n\nout_release:\n\trelease_head(c, BASEHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tif (last_reference)\n\t\tubifs_delete_orphan(c, new_inode->i_ino);\nout_finish:\n\tfinish_reservation(c);\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n/**\n * reco",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ation(c);\nout_free",
          "args": [],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan(c, new_inode",
          "args": [
            ">",
            "ino);\nout_finish"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\tif",
          "args": [
            "(",
            "st_"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, BASEHD);",
          "args": [
            "u",
            "ro:\n\tu"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ean(c, ubifs_ino",
          "args": [
            "e",
            "ew_dir));\n\tkfree(den"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_dir));",
          "args": [
            "free(de"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ean(c, ubifs_ino",
          "args": [
            "e",
            "ld_dir));\n\tif (move)"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_dir));",
          "args": [
            "f (move"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_ui->ui_",
          "args": [
            "ock);\n\t}\n\tmark_i"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "w_ui->ui_",
          "args": [
            "ock);\n\t\tnew_ui->"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ean(c, new_ui);",
          "args": [
            "in_loc"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ation(c);\n\tif (new",
          "args": [
            "i"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, lnu",
          "args": [
            ",",
            "ffs,",
            "len)",
            "if",
            "err)"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, new",
          "args": [
            "d",
            "->i_",
            "o);\n\t\terr = ub"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "no_k",
            "_"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, lnu",
          "args": [
            ",",
            "ffs,",
            "len)",
            "if",
            "rr)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, old",
          "args": [
            "d",
            "->i_",
            "o);\n\terr = ubi"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t}",
          "args": [
            "in",
            "k"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, lnu",
          "args": [
            ",",
            "ffs,",
            "len)",
            "if",
            "err)"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, new",
          "args": [
            "i",
            "de->",
            "ino);\n\t\terr = ub"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove_nm(c, &key, &ol",
          "args": [
            "_",
            "ntry",
            "d_name);\n\tif (err)"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, old",
          "args": [
            "d",
            "->i_",
            "o, &old_dentry",
            "d_name);\n\terr = ubi"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, lnum, dle",
          "args": [
            "2",
            "if",
            "err)"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_nm(c, &key, lnu",
          "args": [
            ",",
            "ffs,",
            "len1",
            "&new",
            "entry",
            "d_name);\n\tif (err)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, new",
          "args": [
            "d",
            "->i_",
            "o, &new_dentry",
            "d_name);\n\terr = ubi"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, BASEHD);",
          "args": [
            "nt_key"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ino_nolock(&c->jheads[B",
          "args": [
            "SEHD].wbuf,\n\t\t\t\t\t\t  new",
            "ino);\n\t}\n\treleas"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ino_nolock(wbuf, old_di",
          "args": [
            "->i_",
            "o);\n\t\tif (new_"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ino_nolock(wbuf, new_di",
          "args": [
            "->i_",
            "o);\n\t\tubifs_wb"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASEHD, d",
          "args": [
            "n",
            "len,",
            "num,",
            "off",
            "sync",
            "if",
            "rr)"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, BASEHD);",
          "args": [
            "oto ou"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "han(c, new_inode",
          "args": [
            ">",
            "ino);\n\t\tif (err)"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p, new_di",
          "args": [
            ",",
            ")",
            "}\n\n\tif",
            "l"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "ack_",
            "o"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p, old_di",
          "args": [
            ",",
            ")",
            "p +=",
            "I"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p, old_di",
          "args": [
            ",",
            ")",
            "else {"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t}",
          "args": [
            "if",
            "!"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p, new_in",
          "args": [
            "d",
            ";\n\t\tp +=",
            "I"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_node(c, dent2, dl",
          "args": [
            "n",
            "0);",
            "p = (",
            "i"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_unused(dent2);\n\tubi",
          "args": [
            "s_pre"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">name,",
          "args": [
            "old_dentry-",
            "_name.name, old_dentry-",
            "_name.len);\n\tdent2->na"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_dentry->",
          "args": [
            "_name.len);\n\tmemcpy(de"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "__fsnotify_update_child_dentry_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fsnotify.c",
          "lines": "52-87",
          "snippet": "void __fsnotify_update_child_dentry_flags(struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint watched;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t/* determine if the children should tell inode about their events */\n\twatched = fsnotify_inode_watches_children(inode);\n\n\tspin_lock(&inode->i_lock);\n\t/* run all of the dentries associated with this inode.  Since this is a\n\t * directory, there damn well better only be one item on this list */\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tstruct dentry *child;\n\n\t\t/* run all of the children of the original inode and fix their\n\t\t * d_flags to indicate parental interest (their parent is the\n\t\t * original inode) */\n\t\tspin_lock(&alias->d_lock);\n\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n\t\t\tif (!child->d_inode)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (watched)\n\t\t\t\tchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\telse\n\t\t\t\tchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\tspin_unlock(&child->d_lock);\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"../mount.h\"",
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/srcu.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/gfp.h>",
            "#include <linux/fs.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../mount.h\"\n#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/srcu.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/gfp.h>\n#include <linux/fs.h>\n#include <linux/dcache.h>\n\nvoid __fsnotify_update_child_dentry_flags(struct inode *inode)\n{\n\tstruct dentry *alias;\n\tint watched;\n\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn;\n\n\t/* determine if the children should tell inode about their events */\n\twatched = fsnotify_inode_watches_children(inode);\n\n\tspin_lock(&inode->i_lock);\n\t/* run all of the dentries associated with this inode.  Since this is a\n\t * directory, there damn well better only be one item on this list */\n\thlist_for_each_entry(alias, &inode->i_dentry, d_u.d_alias) {\n\t\tstruct dentry *child;\n\n\t\t/* run all of the children of the original inode and fix their\n\t\t * d_flags to indicate parental interest (their parent is the\n\t\t * original inode) */\n\t\tspin_lock(&alias->d_lock);\n\t\tlist_for_each_entry(child, &alias->d_subdirs, d_child) {\n\t\t\tif (!child->d_inode)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED);\n\t\t\tif (watched)\n\t\t\t\tchild->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\telse\n\t\t\t\tchild->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED;\n\t\t\tspin_unlock(&child->d_lock);\n\t\t}\n\t\tspin_unlock(&alias->d_lock);\n\t}\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_flash(c, &dent2->k",
          "args": [
            "y",
            "old_dir->i_",
            "o,\n\t\t\t    &old",
            "d_name);\n\tdent2->in"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_node(c, dent, dle",
          "args": [
            "1",
            "0);",
            "/* Ma"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_unused(dent);\n\tubif",
          "args": [
            "_pre"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name,",
          "args": [
            "ew_dentry-",
            "_name.name, new_dentry-",
            "_name.len);\n\tdent->nam"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_dentry->",
          "args": [
            "_name.len);\n\tmemcpy(de"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_new_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "181-185",
          "snippet": "static inline void\nncp_new_dentry(struct dentry* dentry)\n{\n\tdentry->d_time = jiffies;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void\nncp_new_dentry(struct dentry* dentry)\n{\n\tdentry->d_time = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "(old_inode->i",
          "args": [
            "mode);\n\tdent->nle"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_inode->i",
          "args": [
            "ino);\n\tdent->typ"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_flash(c, &dent->ke",
          "args": [
            ",",
            "ew_dir->i_",
            "o, &new_dentry",
            "d_name);\n\tdent->inu"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ion(c, BASEHD, l",
          "args": [
            "n",
            "if (",
            "r)"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFP_NOF",
          "args": [
            ");",
            "f (!dent"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\ti",
          "args": [
            "(ol",
            "d"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ") + A",
          "args": [
            "IGN(",
            "e"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "8);",
          "args": [
            "en =",
            "i"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "8);",
          "args": [
            "ligne",
            "d"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&new_ui->ui_mutex));\n\t\tilen = U"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&new_ui->ui_",
          "args": [
            "utex));\n\t\tilen ="
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_inode);",
          "args": [
            "ubifs_as"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&ubifs_inode(new_dir)->ui_mutex));\n\n\tdlen1 ="
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&ubifs_inode",
          "args": [
            "new_dir)->ui_mutex));\n\n\tdlen1 ="
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_dir)->ui",
          "args": [
            "mutex))"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&ubifs_inode(old_dir)->ui_mutex));\n\tubifs_ass"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&ubifs_inode",
          "args": [
            "old_dir)->ui_mutex));\n\tubifs_as"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_dir)->ui",
          "args": [
            "mutex))"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_inode(",
          "args": [
            "ew_dir)->data_len == 0);\n\tubifs_ass"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_dir)->da",
          "args": [
            "a_len ="
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_inode(",
          "args": [
            "ld_dir)->data_len == 0);\n\tubifs_ass"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ld_dir)->da",
          "args": [
            "a_len ="
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "'%pd'",
          "args": [
            "n dir ino %lu to dent '%pd' in dir ino %lu\",\n\t\told_dentr",
            "ld_dir->i_",
            "o, new_dentry,",
            "ew_dir->i_",
            "o);\n\tubifs_ass"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\n_rename(struct ubifs_info *c, const struct inode *old_dir,\n\t\t     const struct dentry *old_dentry,\n\t\t     const struct inode *new_dir,\n\t\t     const struct dentry *new_dentry, int sync)\n{\n\tvoid *p;\n\tunion ubifs_key key;\n\tstruct ubifs_dent_node *dent, *dent2;\n\tint err, dlen1, dlen2, ilen, lnum, offs, len;\n\tconst struct inode *old_inode = old_dentry->d_inode;\n\tconst struct inode *new_inode = new_dentry->d_inode;\n\tint aligned_dlen1, aligned_dlen2, plen = UBIFS_INO_NODE_SZ;\n\tint last_reference = !!(new_inode && new_inode->i_nlink == 0);\n\tint move = (old_dir != new_dir);\n\tstruct ubifs_inode *uninitialized_var(new_ui);\n\n\tdbg_jnl(\"dent '%pd' in dir ino %lu to dent '%pd' in dir ino %lu\",\n\t\told_dentry, old_dir->i_ino, new_dentry, new_dir->i_ino);\n\tubifs_assert(ubifs_inode(old_dir)->data_len == 0);\n\tubifs_assert(ubifs_inode(new_dir)->data_len == 0);\n\tubifs_assert(mutex_is_locked(&ubifs_inode(old_dir)->ui_mutex));\n\tubifs_assert(mutex_is_locked(&ubifs_inode(new_dir)->ui_mutex));\n\n\tdlen1 = UBIFS_DENT_NODE_SZ + new_dentry->d_name.len + 1;\n\tdlen2 = UBIFS_DENT_NODE_SZ + old_dentry->d_name.len + 1;\n\tif (new_inode) {\n\t\tnew_ui = ubifs_inode(new_inode);\n\t\tubifs_assert(mutex_is_locked(&new_ui->ui_mutex));\n\t\tilen = UBIFS_INO_NODE_SZ;\n\t\tif (!last_reference)\n\t\t\tilen += new_ui->data_len;\n\t} else\n\t\tilen = 0;\n\n\taligned_dlen1 = ALIGN(dlen1, 8);\n\taligned_dlen2 = ALIGN(dlen2, 8);\n\tlen = aligned_dlen1 + aligned_dlen2 + ALIGN(ilen, 8) + ALIGN(plen, 8);\n\tif (old_dir != new_dir)\n\t\tlen += plen;\n\tdent = kmalloc(len, GFP_NOFS);\n\tif (!dent)\n\t\treturn -ENOMEM;\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n\t\tgoto out_free;\n\n\t/* Make new dent */\n\tdent->ch.node_type = UBIFS_DENT_NODE;\n\tdent_key_init_flash(c, &dent->key, new_dir->i_ino, &new_dentry->d_name);\n\tdent->inum = cpu_to_le64(old_inode->i_ino);\n\tdent->type = get_dent_type(old_inode->i_mode);\n\tdent->nlen = cpu_to_le16(new_dentry->d_name.len);\n\tmemcpy(dent->name, new_dentry->d_name.name, new_dentry->d_name.len);\n\tdent->name[new_dentry->d_name.len] = '\\0';\n\tzero_dent_node_unused(dent);\n\tubifs_prep_grp_node(c, dent, dlen1, 0);\n\n\t/* Make deletion dent */\n\tdent2 = (void *)dent + aligned_dlen1;\n\tdent2->ch.node_type = UBIFS_DENT_NODE;\n\tdent_key_init_flash(c, &dent2->key, old_dir->i_ino,\n\t\t\t    &old_dentry->d_name);\n\tdent2->inum = 0;\n\tdent2->type = DT_UNKNOWN;\n\tdent2->nlen = cpu_to_le16(old_dentry->d_name.len);\n\tmemcpy(dent2->name, old_dentry->d_name.name, old_dentry->d_name.len);\n\tdent2->name[old_dentry->d_name.len] = '\\0';\n\tzero_dent_node_unused(dent2);\n\tubifs_prep_grp_node(c, dent2, dlen2, 0);\n\n\tp = (void *)dent2 + aligned_dlen2;\n\tif (new_inode) {\n\t\tpack_inode(c, p, new_inode, 0);\n\t\tp += ALIGN(ilen, 8);\n\t}\n\n\tif (!move)\n\t\tpack_inode(c, p, old_dir, 1);\n\telse {\n\t\tpack_inode(c, p, old_dir, 0);\n\t\tp += ALIGN(plen, 8);\n\t\tpack_inode(c, p, new_dir, 1);\n\t}\n\n\tif (last_reference) {\n\t\terr = ubifs_add_orphan(c, new_inode->i_ino);\n\t\tif (err) {\n\t\t\trelease_head(c, BASEHD);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tnew_ui->del_cmtno = c->cmt_no;\n\t}\n\n\terr = write_head(c, BASEHD, dent, len, &lnum, &offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[BASEHD].wbuf;\n\n\t\tubifs_wbuf_add_ino_nolock(wbuf, new_dir->i_ino);\n\t\tubifs_wbuf_add_ino_nolock(wbuf, old_dir->i_ino);\n\t\tif (new_inode)\n\t\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf,\n\t\t\t\t\t\t  new_inode->i_ino);\n\t}\n\trelease_head(c, BASEHD);\n\n\tdent_key_init(c, &key, new_dir->i_ino, &new_dentry->d_name);\n\terr = ubifs_tnc_add_nm(c, &key, lnum, offs, dlen1, &new_dentry->d_name);\n\tif (err)\n\t\tgoto out_ro;\n\n\terr = ubifs_add_dirt(c, lnum, dlen2);\n\tif (err)\n\t\tgoto out_ro;\n\n\tdent_key_init(c, &key, old_dir->i_ino, &old_dentry->d_name);\n\terr = ubifs_tnc_remove_nm(c, &key, &old_dentry->d_name);\n\tif (err)\n\t\tgoto out_ro;\n\n\toffs += aligned_dlen1 + aligned_dlen2;\n\tif (new_inode) {\n\t\tino_key_init(c, &key, new_inode->i_ino);\n\t\terr = ubifs_tnc_add(c, &key, lnum, offs, ilen);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t\toffs += ALIGN(ilen, 8);\n\t}\n\n\tino_key_init(c, &key, old_dir->i_ino);\n\terr = ubifs_tnc_add(c, &key, lnum, offs, plen);\n\tif (err)\n\t\tgoto out_ro;\n\n\tif (old_dir != new_dir) {\n\t\toffs += ALIGN(plen, 8);\n\t\tino_key_init(c, &key, new_dir->i_ino);\n\t\terr = ubifs_tnc_add(c, &key, lnum, offs, plen);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t}\n\n\tfinish_reservation(c);\n\tif (new_inode) {\n\t\tmark_inode_clean(c, new_ui);\n\t\tspin_lock(&new_ui->ui_lock);\n\t\tnew_ui->synced_i_size = new_ui->ui_size;\n\t\tspin_unlock(&new_ui->ui_lock);\n\t}\n\tmark_inode_clean(c, ubifs_inode(old_dir));\n\tif (move)\n\t\tmark_inode_clean(c, ubifs_inode(new_dir));\n\tkfree(dent);\n\treturn 0;\n\nout_release:\n\trelease_head(c, BASEHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tif (last_reference)\n\t\tubifs_delete_orphan(c, new_inode->i_ino);\nout_finish:\n\tfinish_reservation(c);\nout_free:\n\tkfree(dent);\n\treturn err;\n}\n\n/**\n * reco"
  },
  {
    "function_name": "ete_inode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "880-908",
    "snippet": "_delete_inode(struct ubifs_info *c, const struct inode *inode)\n{\n\tint err;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tubifs_assert(inode->i_nlink == 0);\n\n\tif (ui->del_cmtno != c->cmt_no)\n\t\t/* A commit happened for sure */\n\t\treturn ubifs_jnl_write_inode(c, inode);\n\n\tdown_read(&c->commit_sem);\n\t/*\n\t * Check commit number again, because the first test has been done\n\t * without @c->commit_sem, so a commit might have happened.\n\t */\n\tif (ui->del_cmtno != c->cmt_no) {\n\t\tup_read(&c->commit_sem);\n\t\treturn ubifs_jnl_write_inode(c, inode);\n\t}\n\n\terr = ubifs_tnc_remove_ino(c, inode->i_ino);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\telse\n\t\tubifs_delete_orphan(c, inode->i_ino);\n\tup_read(&c->commit_sem);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ommit_s",
          "args": [
            "m);\n\treturn er"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_commit_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "742-753",
          "snippet": "static void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);\n\nstatic void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "orphan(c, inode->i_",
          "args": [
            "n",
            ";\n\tup_read(&"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\tel",
          "args": [
            "e",
            "ub"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove_ino(c, inode->i_",
          "args": [
            "n",
            ";\n\tif (err)"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te_inode(c, inode);",
          "args": [
            "err ="
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">commit_s",
          "args": [
            "m);\n\t/*\n\t * Ch"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te_inode(c, inode);",
          "args": [
            "d",
            "n_rea"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode->i_nli",
          "args": [
            "k == 0);\n\n\tif (ui->"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tub",
          "args": [
            "fs_as"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\n_delete_inode(struct ubifs_info *c, const struct inode *inode)\n{\n\tint err;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tubifs_assert(inode->i_nlink == 0);\n\n\tif (ui->del_cmtno != c->cmt_no)\n\t\t/* A commit happened for sure */\n\t\treturn ubifs_jnl_write_inode(c, inode);\n\n\tdown_read(&c->commit_sem);\n\t/*\n\t * Check commit number again, because the first test has been done\n\t * without @c->commit_sem, so a commit might have happened.\n\t */\n\tif (ui->del_cmtno != c->cmt_no) {\n\t\tup_read(&c->commit_sem);\n\t\treturn ubifs_jnl_write_inode(c, inode);\n\t}\n\n\terr = ubifs_tnc_remove_ino(c, inode->i_ino);\n\tif (err)\n\t\tubifs_ro_mode(c, err);\n\telse\n\t\tubifs_delete_orphan(c, inode->i_ino);\n\tup_read(&c->commit_sem);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "te_inode(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "784-849",
    "snippet": "_write_inode(struct ubifs_info *c, const struct inode *inode)\n{\n\tint err, lnum, offs;\n\tstruct ubifs_ino_node *ino;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tint sync = 0, len = UBIFS_INO_NODE_SZ, last_reference = !inode->i_nlink;\n\n\tdbg_jnl(\"ino %lu, nlink %u\", inode->i_ino, inode->i_nlink);\n\n\t/*\n\t * If the inode is being deleted, do not write the attached data. No\n\t * need to synchronize the write-buffer either.\n\t */\n\tif (!last_reference) {\n\t\tlen += ui->data_len;\n\t\tsync = IS_SYNC(inode);\n\t}\n\tino = kmalloc(len, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n\t\tgoto out_free;\n\n\tpack_inode(c, ino, inode, 1);\n\terr = write_head(c, BASEHD, ino, len, &lnum, &offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync)\n\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf,\n\t\t\t\t\t  inode->i_ino);\n\trelease_head(c, BASEHD);\n\n\tif (last_reference) {\n\t\terr = ubifs_tnc_remove_ino(c, inode->i_ino);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t\tubifs_delete_orphan(c, inode->i_ino);\n\t\terr = ubifs_add_dirt(c, lnum, len);\n\t} else {\n\t\tunion ubifs_key key;\n\n\t\tino_key_init(c, &key, inode->i_ino);\n\t\terr = ubifs_tnc_add(c, &key, lnum, offs, len);\n\t}\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&ui->ui_lock);\n\tui->synced_i_size = ui->ui_size;\n\tspin_unlock(&ui->ui_lock);\n\tkfree(ino);\n\treturn 0;\n\nout_release:\n\trelease_head(c, BASEHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tkfree(ino);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "er"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ation(c);\nout_free",
          "args": [],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\tfi",
          "args": [
            "i",
            "_re"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, BASEHD);",
          "args": [
            "u",
            "ro:\n\tu"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->ui_lock",
          "args": [
            ";\n\tkfree(ino"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ui_lock",
          "args": [
            ";\n\tui->synce"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ation(c);\n\tspin_lo",
          "args": [
            "k"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &key, lnu",
          "args": [
            ",",
            "ffs,",
            "en);",
            "}\n\ti",
            "(er"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, ino",
          "args": [
            "e",
            "i_in",
            ";\n\t\terr = ub"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, lnum, len",
          "args": [
            ";",
            "} el",
            "{"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan(c, inode->i_",
          "args": [
            "n",
            ";\n\t\terr = ub"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove_ino(c, inode->i_",
          "args": [
            "n",
            ";\n\t\tif (err)"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, BASEHD);",
          "args": [
            "(last"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ino_nolock(&c->jheads[B",
          "args": [
            "SEHD].wbuf,\n\t\t\t\t\t  inod",
            ";\n\trelease_h"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASEHD, i",
          "args": [
            "o",
            "len, &",
            "um,",
            "off",
            "sync",
            "if",
            "rr)"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino, inod",
          "args": [
            ",",
            ");",
            "rr =",
            "i"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ion(c, BASEHD, l",
          "args": [
            "n",
            "if (",
            "r)"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFP_NOF",
          "args": [
            ");",
            "f (!ino)"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t}",
          "args": [
            "no ="
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu, nl",
          "args": [
            "nk %u\", inode->i_in",
            "inode->i_nl",
            "k);\n\n\t/*\n\t * I"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tint",
          "args": [
            "sync"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\n_write_inode(struct ubifs_info *c, const struct inode *inode)\n{\n\tint err, lnum, offs;\n\tstruct ubifs_ino_node *ino;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tint sync = 0, len = UBIFS_INO_NODE_SZ, last_reference = !inode->i_nlink;\n\n\tdbg_jnl(\"ino %lu, nlink %u\", inode->i_ino, inode->i_nlink);\n\n\t/*\n\t * If the inode is being deleted, do not write the attached data. No\n\t * need to synchronize the write-buffer either.\n\t */\n\tif (!last_reference) {\n\t\tlen += ui->data_len;\n\t\tsync = IS_SYNC(inode);\n\t}\n\tino = kmalloc(len, GFP_NOFS);\n\tif (!ino)\n\t\treturn -ENOMEM;\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n\t\tgoto out_free;\n\n\tpack_inode(c, ino, inode, 1);\n\terr = write_head(c, BASEHD, ino, len, &lnum, &offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync)\n\t\tubifs_wbuf_add_ino_nolock(&c->jheads[BASEHD].wbuf,\n\t\t\t\t\t  inode->i_ino);\n\trelease_head(c, BASEHD);\n\n\tif (last_reference) {\n\t\terr = ubifs_tnc_remove_ino(c, inode->i_ino);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t\tubifs_delete_orphan(c, inode->i_ino);\n\t\terr = ubifs_add_dirt(c, lnum, len);\n\t} else {\n\t\tunion ubifs_key key;\n\n\t\tino_key_init(c, &key, inode->i_ino);\n\t\terr = ubifs_tnc_add(c, &key, lnum, offs, len);\n\t}\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&ui->ui_lock);\n\tui->synced_i_size = ui->ui_size;\n\tspin_unlock(&ui->ui_lock);\n\tkfree(ino);\n\treturn 0;\n\nout_release:\n\trelease_head(c, BASEHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tkfree(ino);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "te_data(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "696-773",
    "snippet": "_write_data(struct ubifs_info *c, const struct inode *inode,\n\t\t\t const union ubifs_key *key, const void *buf, int len)\n{\n\tstruct ubifs_data_node *data;\n\tint err, lnum, offs, compr_type, out_len;\n\tint dlen = COMPRESSED_DATA_NODE_BUF_SZ, allocated = 1;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tdbg_jnlk(key, \"ino %lu, blk %u, len %d, key \",\n\t\t(unsigned long)key_inum(c, key), key_block(c, key), len);\n\tubifs_assert(len <= UBIFS_BLOCK_SIZE);\n\n\tdata = kmalloc(dlen, GFP_NOFS | __GFP_NOWARN);\n\tif (!data) {\n\t\t/*\n\t\t * Fall-back to the write reserve buffer. Note, we might be\n\t\t * currently on the memory reclaim path, when the kernel is\n\t\t * trying to free some memory by writing out dirty pages. The\n\t\t * write reserve buffer helps us to guarantee that we are\n\t\t * always able to write the data.\n\t\t */\n\t\tallocated = 0;\n\t\tmutex_lock(&c->write_reserve_mutex);\n\t\tdata = c->write_reserve_buf;\n\t}\n\n\tdata->ch.node_type = UBIFS_DATA_NODE;\n\tkey_write(c, key, &data->key);\n\tdata->size = cpu_to_le32(len);\n\tzero_data_node_unused(data);\n\n\tif (!(ui->flags & UBIFS_COMPR_FL))\n\t\t/* Compression is disabled for this inode */\n\t\tcompr_type = UBIFS_COMPR_NONE;\n\telse\n\t\tcompr_type = ui->compr_type;\n\n\tout_len = dlen - UBIFS_DATA_NODE_SZ;\n\tubifs_compress(buf, len, &data->data, &out_len, &compr_type);\n\tubifs_assert(out_len <= UBIFS_BLOCK_SIZE);\n\n\tdlen = UBIFS_DATA_NODE_SZ + out_len;\n\tdata->compr_type = cpu_to_le16(compr_type);\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, DATAHD, dlen);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = write_node(c, DATAHD, data, dlen, &lnum, &offs);\n\tif (err)\n\t\tgoto out_release;\n\tubifs_wbuf_add_ino_nolock(&c->jheads[DATAHD].wbuf, key_inum(c, key));\n\trelease_head(c, DATAHD);\n\n\terr = ubifs_tnc_add(c, key, lnum, offs, dlen);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tif (!allocated)\n\t\tmutex_unlock(&c->write_reserve_mutex);\n\telse\n\t\tkfree(data);\n\treturn 0;\n\nout_release:\n\trelease_head(c, DATAHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tif (!allocated)\n\t\tmutex_unlock(&c->write_reserve_mutex);\n\telse\n\t\tkfree(data);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "&c->write_re",
          "args": [
            "erve_mutex);\n\telse\n\t\tkf"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ation(c);\nout_free",
          "args": [],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\tfi",
          "args": [
            "i",
            "_re"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, DATAHD);",
          "args": [
            "u",
            "ro:\n\tu"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->write_re",
          "args": [
            "erve_mutex);\n\telse\n\t\tkf"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ation(c);\n\tif (!al",
          "args": [
            "o"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, key, lnum",
          "args": [
            "fs,",
            "len)",
            "if",
            "rr)"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, DATAHD);",
          "args": [
            "r = ub"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ino_nolock(&c->jheads[D",
          "args": [
            "TAHD].wbuf, key_inum(c,",
            "ey));\n\trelease_h"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey));\n\tr",
          "args": [
            "l",
            "se_"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DATAHD, d",
          "args": [
            "t",
            "dlen,",
            "lnum",
            "&off",
            ";\n\tif",
            "err)"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ion(c, DATAHD, d",
          "args": [
            "e",
            ";\n\tif",
            "rr)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ompr_type);",
          "args": [
            "/* Make"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_len <= U",
          "args": [
            "IFS_BLOCK_SIZE);\n\n\tdlen = U"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s(buf, len, &d",
          "args": [
            "ta-",
            "ata",
            "&out_len, &",
            "mpr_type",
            "ubifs_ass"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_unused(data);\n\n\tif",
          "args": [
            "!(ui"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en);\n\tzero_",
          "args": [
            "ata"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key, &dat",
          "args": [
            "-",
            "ey)",
            "data->siz"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->write_re",
          "args": [
            "erve_mutex);\n\t\tdata = c"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1400-1415",
          "snippet": "static int ocfs2_write_remove_suid(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = ocfs2_read_inode_block(inode, &bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret =  __ocfs2_write_remove_suid(inode, bh);\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_write_remove_suid(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = ocfs2_read_inode_block(inode, &bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret =  __ocfs2_write_remove_suid(inode, bh);\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GFP_NO",
          "args": [
            "S |",
            "GFP_NOWARN);\n\tif (!data"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len <= UBIFS",
          "args": [
            "BLOCK_SIZE);\n\n\tdata = k"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"ino %l",
          "args": [
            ", b",
            "%u, len %d, key \",\n\t\t(unsigned",
            "g)key_inum(c, key), key_block(c",
            "key), len);\n\tubif",
            "ass"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key), len",
          "args": [
            ";",
            "ubi"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey), key",
          "args": [
            "b",
            "ck("
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tdb",
          "args": [
            "_jnlk"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\n_write_data(struct ubifs_info *c, const struct inode *inode,\n\t\t\t const union ubifs_key *key, const void *buf, int len)\n{\n\tstruct ubifs_data_node *data;\n\tint err, lnum, offs, compr_type, out_len;\n\tint dlen = COMPRESSED_DATA_NODE_BUF_SZ, allocated = 1;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tdbg_jnlk(key, \"ino %lu, blk %u, len %d, key \",\n\t\t(unsigned long)key_inum(c, key), key_block(c, key), len);\n\tubifs_assert(len <= UBIFS_BLOCK_SIZE);\n\n\tdata = kmalloc(dlen, GFP_NOFS | __GFP_NOWARN);\n\tif (!data) {\n\t\t/*\n\t\t * Fall-back to the write reserve buffer. Note, we might be\n\t\t * currently on the memory reclaim path, when the kernel is\n\t\t * trying to free some memory by writing out dirty pages. The\n\t\t * write reserve buffer helps us to guarantee that we are\n\t\t * always able to write the data.\n\t\t */\n\t\tallocated = 0;\n\t\tmutex_lock(&c->write_reserve_mutex);\n\t\tdata = c->write_reserve_buf;\n\t}\n\n\tdata->ch.node_type = UBIFS_DATA_NODE;\n\tkey_write(c, key, &data->key);\n\tdata->size = cpu_to_le32(len);\n\tzero_data_node_unused(data);\n\n\tif (!(ui->flags & UBIFS_COMPR_FL))\n\t\t/* Compression is disabled for this inode */\n\t\tcompr_type = UBIFS_COMPR_NONE;\n\telse\n\t\tcompr_type = ui->compr_type;\n\n\tout_len = dlen - UBIFS_DATA_NODE_SZ;\n\tubifs_compress(buf, len, &data->data, &out_len, &compr_type);\n\tubifs_assert(out_len <= UBIFS_BLOCK_SIZE);\n\n\tdlen = UBIFS_DATA_NODE_SZ + out_len;\n\tdata->compr_type = cpu_to_le16(compr_type);\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, DATAHD, dlen);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = write_node(c, DATAHD, data, dlen, &lnum, &offs);\n\tif (err)\n\t\tgoto out_release;\n\tubifs_wbuf_add_ino_nolock(&c->jheads[DATAHD].wbuf, key_inum(c, key));\n\trelease_head(c, DATAHD);\n\n\terr = ubifs_tnc_add(c, key, lnum, offs, dlen);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tif (!allocated)\n\t\tmutex_unlock(&c->write_reserve_mutex);\n\telse\n\t\tkfree(data);\n\treturn 0;\n\nout_release:\n\trelease_head(c, DATAHD);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tfinish_reservation(c);\nout_free:\n\tif (!allocated)\n\t\tmutex_unlock(&c->write_reserve_mutex);\n\telse\n\t\tkfree(data);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ate(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "541-683",
    "snippet": "_update(struct ubifs_info *c, const struct inode *dir,\n\t\t     const struct qstr *nm, const struct inode *inode,\n\t\t     int deletion, int xent)\n{\n\tint err, dlen, ilen, len, lnum, ino_offs, dent_offs;\n\tint aligned_dlen, aligned_ilen, sync = IS_DIRSYNC(dir);\n\tint last_reference = !!(deletion && inode->i_nlink == 0);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_inode *host_ui = ubifs_inode(dir);\n\tstruct ubifs_dent_node *dent;\n\tstruct ubifs_ino_node *ino;\n\tunion ubifs_key dent_key, ino_key;\n\n\tdbg_jnl(\"ino %lu, dent '%.*s', data len %d in dir ino %lu\",\n\t\tinode->i_ino, nm->len, nm->name, ui->data_len, dir->i_ino);\n\tubifs_assert(mutex_is_locked(&host_ui->ui_mutex));\n\n\tdlen = UBIFS_DENT_NODE_SZ + nm->len + 1;\n\tilen = UBIFS_INO_NODE_SZ;\n\n\t/*\n\t * If the last reference to the inode is being deleted, then there is\n\t * no need to attach and write inode data, it is being deleted anyway.\n\t * And if the inode is being deleted, no need to synchronize\n\t * write-buffer even if the inode is synchronous.\n\t */\n\tif (!last_reference) {\n\t\tilen += ui->data_len;\n\t\tsync |= IS_SYNC(inode);\n\t}\n\n\taligned_dlen = ALIGN(dlen, 8);\n\taligned_ilen = ALIGN(ilen, 8);\n\n\tlen = aligned_dlen + aligned_ilen + UBIFS_INO_NODE_SZ;\n\t/* Make sure to also account for extended attributes */\n\tlen += host_ui->data_len;\n\n\tdent = kmalloc(len, GFP_NOFS);\n\tif (!dent)\n\t\treturn -ENOMEM;\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (!xent) {\n\t\tdent->ch.node_type = UBIFS_DENT_NODE;\n\t\tdent_key_init(c, &dent_key, dir->i_ino, nm);\n\t} else {\n\t\tdent->ch.node_type = UBIFS_XENT_NODE;\n\t\txent_key_init(c, &dent_key, dir->i_ino, nm);\n\t}\n\n\tkey_write(c, &dent_key, dent->key);\n\tdent->inum = deletion ? 0 : cpu_to_le64(inode->i_ino);\n\tdent->type = get_dent_type(inode->i_mode);\n\tdent->nlen = cpu_to_le16(nm->len);\n\tmemcpy(dent->name, nm->name, nm->len);\n\tdent->name[nm->len] = '\\0';\n\tzero_dent_node_unused(dent);\n\tubifs_prep_grp_node(c, dent, dlen, 0);\n\n\tino = (void *)dent + aligned_dlen;\n\tpack_inode(c, ino, inode, 0);\n\tino = (void *)ino + aligned_ilen;\n\tpack_inode(c, ino, dir, 1);\n\n\tif (last_reference) {\n\t\terr = ubifs_add_orphan(c, inode->i_ino);\n\t\tif (err) {\n\t\t\trelease_head(c, BASEHD);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tui->del_cmtno = c->cmt_no;\n\t}\n\n\terr = write_head(c, BASEHD, dent, len, &lnum, &dent_offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[BASEHD].wbuf;\n\n\t\tubifs_wbuf_add_ino_nolock(wbuf, inode->i_ino);\n\t\tubifs_wbuf_add_ino_nolock(wbuf, dir->i_ino);\n\t}\n\trelease_head(c, BASEHD);\n\tkfree(dent);\n\n\tif (deletion) {\n\t\terr = ubifs_tnc_remove_nm(c, &dent_key, nm);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t\terr = ubifs_add_dirt(c, lnum, dlen);\n\t} else\n\t\terr = ubifs_tnc_add_nm(c, &dent_key, lnum, dent_offs, dlen, nm);\n\tif (err)\n\t\tgoto out_ro;\n\n\t/*\n\t * Note, we do not remove the inode from TNC even if the last reference\n\t * to it has just been deleted, because the inode may still be opened.\n\t * Instead, the inode has been added to orphan lists and the orphan\n\t * subsystem will take further care about it.\n\t */\n\tino_key_init(c, &ino_key, inode->i_ino);\n\tino_offs = dent_offs + aligned_dlen;\n\terr = ubifs_tnc_add(c, &ino_key, lnum, ino_offs, ilen);\n\tif (err)\n\t\tgoto out_ro;\n\n\tino_key_init(c, &ino_key, dir->i_ino);\n\tino_offs += aligned_ilen;\n\terr = ubifs_tnc_add(c, &ino_key, lnum, ino_offs,\n\t\t\t    UBIFS_INO_NODE_SZ + host_ui->data_len);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&ui->ui_lock);\n\tui->synced_i_size = ui->ui_size;\n\tspin_unlock(&ui->ui_lock);\n\tmark_inode_clean(c, ui);\n\tmark_inode_clean(c, host_ui);\n\treturn 0;\n\nout_finish:\n\tfinish_reservation(c);\nout_free:\n\tkfree(dent);\n\treturn err;\n\nout_release:\n\trelease_head(c, BASEHD);\n\tkfree(dent);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tif (last_reference)\n\t\tubifs_delete_orphan(c, inode->i_ino);\n\tfinish_reservation(c);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ation(c);\n\treturn",
          "args": [
            "r"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphan(c, inode->i_",
          "args": [
            "n",
            ";\n\tfinish_re"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, err);\n\tif",
          "args": [
            "(",
            "st_"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "out_r",
          "args": [
            ":\n\tu"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cb_layout_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "638-650",
          "snippet": "static void\nnfsd4_cb_layout_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tLIST_HEAD(reaplist);\n\n\ttrace_layout_recall_release(&ls->ls_stid.sc_stateid);\n\n\tnfsd4_return_all_layouts(ls, &reaplist);\n\tnfsd4_free_layouts(&reaplist);\n\tnfs4_put_stid(&ls->ls_stid);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nstatic void\nnfsd4_cb_layout_release(struct nfsd4_callback *cb)\n{\n\tstruct nfs4_layout_stateid *ls =\n\t\tcontainer_of(cb, struct nfs4_layout_stateid, ls_recall);\n\tLIST_HEAD(reaplist);\n\n\ttrace_layout_recall_release(&ls->ls_stid.sc_stateid);\n\n\tnfsd4_return_all_layouts(ls, &reaplist);\n\tnfsd4_free_layouts(&reaplist);\n\tnfs4_put_stid(&ls->ls_stid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "c, BASEHD);",
          "args": [
            "k",
            "ee(den"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ation(c);\nout_free",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ean(c, host_ui);",
          "args": [
            "turn 0;"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ean(c, ui);\n\tmar",
          "args": [
            "_",
            "od"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->ui_lock",
          "args": [
            ";\n\tmark_inod"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->ui_lock",
          "args": [
            ";\n\tui->synce"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ation(c);\n\tspin_lo",
          "args": [
            "k"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &ino_key,",
          "args": [
            "l",
            "m, ino_o",
            "s,",
            "UBIF",
            "E_SZ + host_ui->data_len);\n\tif (err)"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &ino_key,",
          "args": [
            "d",
            "->i_ino)",
            "ino_offs"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &ino_key,",
          "args": [
            "l",
            "m, ino_o",
            "s, i",
            "n);\n\tif",
            "rr)"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &ino_key,",
          "args": [
            "i",
            "de->i_in",
            ";\n\tino_offs"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_nm(c, &dent_key",
          "args": [
            "um, dent_",
            "fs,",
            "en, nm);",
            "f (e",
            ")"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t(c, lnum, dle",
          "args": [
            ")",
            "} e",
            "e"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove_nm(c, &dent_key",
          "args": [
            ");\n\t\tif (",
            "r)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "dele"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "ation(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
          "lines": "418-421",
          "snippet": "inish_reservation(struct ubifs_info *c)\n{\n\tup_read(&c->commit_sem);\n}\n\n/**\n * get_",
          "includes": [
            "fs.h\"\n\n/**\n * zero_"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\ninish_reservation(struct ubifs_info *c)\n{\n\tup_read(&c->commit_sem);\n}\n\n/**\n * get_"
        }
      },
      {
        "call_info": {
          "callee": "c, BASEHD);",
          "args": [
            "k",
            "ee(den"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ino_nolock(wbuf, dir->i",
          "args": [
            "ino)",
            "}\n\treleas"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_ino_nolock(wbuf, inode-",
          "args": [
            "i_in",
            ";\n\t\tubifs_wb"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BASEHD, d",
          "args": [
            "n",
            "len,",
            "num,",
            "den",
            "offs,",
            "ync);\n\tif",
            "rr)"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, BASEHD);",
          "args": [
            "oto ou"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "han(c, inode->i_",
          "args": [
            "n",
            ";\n\t\tif (err)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino, dir,",
          "args": [
            "1",
            "(l",
            "t"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ino, inod",
          "args": [
            ",",
            ");",
            "no =",
            "o"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p_node(c, dent, dle",
          "args": [
            ",",
            ");",
            "no =",
            "v"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e_unused(dent);\n\tubif",
          "args": [
            "_pre"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name,",
          "args": [
            "m->name, n",
            ">len);",
            "nt->nam"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m->len);\n\tm",
          "args": [
            "mcpy(de"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(inode->i_mod",
          "args": [
            ");\n\tdent->nle"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->i_ino",
          "args": [
            ";\n\tdent->typ"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&dent_key",
          "args": [
            "nt->key);",
            "dent->inu"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &dent_key",
          "args": [
            "r->i_ino,",
            "m);\n\t}\n\n\tk",
            "_w"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, &dent_key",
          "args": [
            "r->i_ino,",
            "m);\n\t} els",
            "{"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ion(c, BASEHD, l",
          "args": [
            "n",
            "if (",
            "r)"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GFP_NOF",
          "args": [
            ");",
            "f (!dent"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "en =",
            "l"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\ta",
          "args": [
            "igne",
            "i"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\t}",
          "args": [
            "align"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_loc",
          "args": [
            "ed(&host_ui->ui_mutex));\n\n\tdlen = U"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ed(&host_ui->ui",
          "args": [
            "mutex));\n\n\tdlen ="
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%lu, de",
          "args": [
            "t '%.*s', data len %d in dir ino %lu\",\n\t\tinode->i_",
            "nm->len, nm",
            "name, u",
            ">data_le",
            "dir->i_ino)",
            "ubifs_ass"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ir);\n\tstruc",
          "args": [
            "ub"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\tstr",
          "args": [
            "ct ub"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r);\n\tint l",
          "args": [
            "st_"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\n_update(struct ubifs_info *c, const struct inode *dir,\n\t\t     const struct qstr *nm, const struct inode *inode,\n\t\t     int deletion, int xent)\n{\n\tint err, dlen, ilen, len, lnum, ino_offs, dent_offs;\n\tint aligned_dlen, aligned_ilen, sync = IS_DIRSYNC(dir);\n\tint last_reference = !!(deletion && inode->i_nlink == 0);\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\tstruct ubifs_inode *host_ui = ubifs_inode(dir);\n\tstruct ubifs_dent_node *dent;\n\tstruct ubifs_ino_node *ino;\n\tunion ubifs_key dent_key, ino_key;\n\n\tdbg_jnl(\"ino %lu, dent '%.*s', data len %d in dir ino %lu\",\n\t\tinode->i_ino, nm->len, nm->name, ui->data_len, dir->i_ino);\n\tubifs_assert(mutex_is_locked(&host_ui->ui_mutex));\n\n\tdlen = UBIFS_DENT_NODE_SZ + nm->len + 1;\n\tilen = UBIFS_INO_NODE_SZ;\n\n\t/*\n\t * If the last reference to the inode is being deleted, then there is\n\t * no need to attach and write inode data, it is being deleted anyway.\n\t * And if the inode is being deleted, no need to synchronize\n\t * write-buffer even if the inode is synchronous.\n\t */\n\tif (!last_reference) {\n\t\tilen += ui->data_len;\n\t\tsync |= IS_SYNC(inode);\n\t}\n\n\taligned_dlen = ALIGN(dlen, 8);\n\taligned_ilen = ALIGN(ilen, 8);\n\n\tlen = aligned_dlen + aligned_ilen + UBIFS_INO_NODE_SZ;\n\t/* Make sure to also account for extended attributes */\n\tlen += host_ui->data_len;\n\n\tdent = kmalloc(len, GFP_NOFS);\n\tif (!dent)\n\t\treturn -ENOMEM;\n\n\t/* Make reservation before allocating sequence numbers */\n\terr = make_reservation(c, BASEHD, len);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (!xent) {\n\t\tdent->ch.node_type = UBIFS_DENT_NODE;\n\t\tdent_key_init(c, &dent_key, dir->i_ino, nm);\n\t} else {\n\t\tdent->ch.node_type = UBIFS_XENT_NODE;\n\t\txent_key_init(c, &dent_key, dir->i_ino, nm);\n\t}\n\n\tkey_write(c, &dent_key, dent->key);\n\tdent->inum = deletion ? 0 : cpu_to_le64(inode->i_ino);\n\tdent->type = get_dent_type(inode->i_mode);\n\tdent->nlen = cpu_to_le16(nm->len);\n\tmemcpy(dent->name, nm->name, nm->len);\n\tdent->name[nm->len] = '\\0';\n\tzero_dent_node_unused(dent);\n\tubifs_prep_grp_node(c, dent, dlen, 0);\n\n\tino = (void *)dent + aligned_dlen;\n\tpack_inode(c, ino, inode, 0);\n\tino = (void *)ino + aligned_ilen;\n\tpack_inode(c, ino, dir, 1);\n\n\tif (last_reference) {\n\t\terr = ubifs_add_orphan(c, inode->i_ino);\n\t\tif (err) {\n\t\t\trelease_head(c, BASEHD);\n\t\t\tgoto out_finish;\n\t\t}\n\t\tui->del_cmtno = c->cmt_no;\n\t}\n\n\terr = write_head(c, BASEHD, dent, len, &lnum, &dent_offs, sync);\n\tif (err)\n\t\tgoto out_release;\n\tif (!sync) {\n\t\tstruct ubifs_wbuf *wbuf = &c->jheads[BASEHD].wbuf;\n\n\t\tubifs_wbuf_add_ino_nolock(wbuf, inode->i_ino);\n\t\tubifs_wbuf_add_ino_nolock(wbuf, dir->i_ino);\n\t}\n\trelease_head(c, BASEHD);\n\tkfree(dent);\n\n\tif (deletion) {\n\t\terr = ubifs_tnc_remove_nm(c, &dent_key, nm);\n\t\tif (err)\n\t\t\tgoto out_ro;\n\t\terr = ubifs_add_dirt(c, lnum, dlen);\n\t} else\n\t\terr = ubifs_tnc_add_nm(c, &dent_key, lnum, dent_offs, dlen, nm);\n\tif (err)\n\t\tgoto out_ro;\n\n\t/*\n\t * Note, we do not remove the inode from TNC even if the last reference\n\t * to it has just been deleted, because the inode may still be opened.\n\t * Instead, the inode has been added to orphan lists and the orphan\n\t * subsystem will take further care about it.\n\t */\n\tino_key_init(c, &ino_key, inode->i_ino);\n\tino_offs = dent_offs + aligned_dlen;\n\terr = ubifs_tnc_add(c, &ino_key, lnum, ino_offs, ilen);\n\tif (err)\n\t\tgoto out_ro;\n\n\tino_key_init(c, &ino_key, dir->i_ino);\n\tino_offs += aligned_ilen;\n\terr = ubifs_tnc_add(c, &ino_key, lnum, ino_offs,\n\t\t\t    UBIFS_INO_NODE_SZ + host_ui->data_len);\n\tif (err)\n\t\tgoto out_ro;\n\n\tfinish_reservation(c);\n\tspin_lock(&ui->ui_lock);\n\tui->synced_i_size = ui->ui_size;\n\tspin_unlock(&ui->ui_lock);\n\tmark_inode_clean(c, ui);\n\tmark_inode_clean(c, host_ui);\n\treturn 0;\n\nout_finish:\n\tfinish_reservation(c);\nout_free:\n\tkfree(dent);\n\treturn err;\n\nout_release:\n\trelease_head(c, BASEHD);\n\tkfree(dent);\nout_ro:\n\tubifs_ro_mode(c, err);\n\tif (last_reference)\n\t\tubifs_delete_orphan(c, inode->i_ino);\n\tfinish_reservation(c);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ean(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "507-512",
    "snippet": "ark_inode_clean(struct ubifs_info *c, struct ubifs_inode *ui)\n{\n\tif (ui->dirty)\n\t\tubifs_release_dirty_inode_budget(c, ui);\n\tui->dirty = 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_dirty_inode_budget(c, ui);\n\tui-",
          "args": [
            "d",
            "ty"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nark_inode_clean(struct ubifs_info *c, struct ubifs_inode *ui)\n{\n\tif (ui->dirty)\n\t\tubifs_release_dirty_inode_budget(c, ui);\n\tui->dirty = 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "457-495",
    "snippet": "ack_inode(struct ubifs_info *c, struct ubifs_ino_node *ino,\n\t\t       const struct inode *inode, int last)\n{\n\tint data_len = 0, last_reference = !inode->i_nlink;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tino->ch.node_type = UBIFS_INO_NODE;\n\tino_key_init_flash(c, &ino->key, inode->i_ino);\n\tino->creat_sqnum = cpu_to_le64(ui->creat_sqnum);\n\tino->atime_sec  = cpu_to_le64(inode->i_atime.tv_sec);\n\tino->atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tino->ctime_sec  = cpu_to_le64(inode->i_ctime.tv_sec);\n\tino->ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tino->mtime_sec  = cpu_to_le64(inode->i_mtime.tv_sec);\n\tino->mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tino->uid   = cpu_to_le32(i_uid_read(inode));\n\tino->gid   = cpu_to_le32(i_gid_read(inode));\n\tino->mode  = cpu_to_le32(inode->i_mode);\n\tino->flags = cpu_to_le32(ui->flags);\n\tino->size  = cpu_to_le64(ui->ui_size);\n\tino->nlink = cpu_to_le32(inode->i_nlink);\n\tino->compr_type  = cpu_to_le16(ui->compr_type);\n\tino->data_len    = cpu_to_le32(ui->data_len);\n\tino->xattr_cnt   = cpu_to_le32(ui->xattr_cnt);\n\tino->xattr_size  = cpu_to_le32(ui->xattr_size);\n\tino->xattr_names = cpu_to_le32(ui->xattr_names);\n\tzero_ino_node_unused(ino);\n\n\t/*\n\t * Drop the attached data if this is a deletion inode, the data is not\n\t * needed anymore.\n\t */\n\tif (!last_reference) {\n\t\tmemcpy(ino->data, ui->data, ui->data_len);\n\t\tdata_len = ui->data_len;\n\t}\n\n\tubifs_prep_grp_node(c, ino, UBIFS_INO_NODE_SZ + data_len, last);\n}\n\n/**\n * mark",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p_node(c, ino, UBIF",
          "args": [
            "_",
            "O_N",
            "E_SZ + data_len, last);\n}\n\n/",
            "*"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ata, u",
          "args": [
            "->data, u",
            ">data_le",
            ";\n\t\tdata_len"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_unused(ino);\n\n\t/*",
          "args": [
            "* D"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->xattr_na",
          "args": [
            "es);\n\tzero_ino_"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->xattr_si",
          "args": [
            "e);\n\tino->xatt"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->xattr_cn",
          "args": [
            ");\n\tino->xatt"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->data_len",
          "args": [
            ";\n\tino->xatt"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->compr_ty",
          "args": [
            "e);\n\tino->data"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->i_nli",
          "args": [
            "k);\n\tino->comp"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->ui_size)",
          "args": [
            "ino->nlin"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->flags);",
          "args": [
            "ino->size"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->i_mod",
          "args": [
            ");\n\tino->flag"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_gid_read(i",
          "args": [
            "ode));\n\tino->mode"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode));\n\tin",
          "args": [
            "->mod"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_uid_read(i",
          "args": [
            "ode));\n\tino->gid"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode));\n\tin",
          "args": [
            "->gid"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->i_mti",
          "args": [
            "e.tv_nsec);\n\tino->uid"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->i_mti",
          "args": [
            "e.tv_sec);\n\tino->mtim"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->i_cti",
          "args": [
            "e.tv_nsec);\n\tino->mtim"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->i_cti",
          "args": [
            "e.tv_sec);\n\tino->ctim"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->i_ati",
          "args": [
            "e.tv_nsec);\n\tino->ctim"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node->i_ati",
          "args": [
            "e.tv_sec);\n\tino->atim"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i->creat_sq",
          "args": [
            "um);\n\tino->atim"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flash(c, &ino->key",
          "args": [
            "ode->i_in",
            ";\n\tino->crea"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);\n\n\tin",
          "args": [
            "->ch."
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nack_inode(struct ubifs_info *c, struct ubifs_ino_node *ino,\n\t\t       const struct inode *inode, int last)\n{\n\tint data_len = 0, last_reference = !inode->i_nlink;\n\tstruct ubifs_inode *ui = ubifs_inode(inode);\n\n\tino->ch.node_type = UBIFS_INO_NODE;\n\tino_key_init_flash(c, &ino->key, inode->i_ino);\n\tino->creat_sqnum = cpu_to_le64(ui->creat_sqnum);\n\tino->atime_sec  = cpu_to_le64(inode->i_atime.tv_sec);\n\tino->atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tino->ctime_sec  = cpu_to_le64(inode->i_ctime.tv_sec);\n\tino->ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tino->mtime_sec  = cpu_to_le64(inode->i_mtime.tv_sec);\n\tino->mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tino->uid   = cpu_to_le32(i_uid_read(inode));\n\tino->gid   = cpu_to_le32(i_gid_read(inode));\n\tino->mode  = cpu_to_le32(inode->i_mode);\n\tino->flags = cpu_to_le32(ui->flags);\n\tino->size  = cpu_to_le64(ui->ui_size);\n\tino->nlink = cpu_to_le32(inode->i_nlink);\n\tino->compr_type  = cpu_to_le16(ui->compr_type);\n\tino->data_len    = cpu_to_le32(ui->data_len);\n\tino->xattr_cnt   = cpu_to_le32(ui->xattr_cnt);\n\tino->xattr_size  = cpu_to_le32(ui->xattr_size);\n\tino->xattr_names = cpu_to_le32(ui->xattr_names);\n\tzero_ino_node_unused(ino);\n\n\t/*\n\t * Drop the attached data if this is a deletion inode, the data is not\n\t * needed anymore.\n\t */\n\tif (!last_reference) {\n\t\tmemcpy(ino->data, ui->data, ui->data_len);\n\t\tdata_len = ui->data_len;\n\t}\n\n\tubifs_prep_grp_node(c, ino, UBIFS_INO_NODE_SZ + data_len, last);\n}\n\n/**\n * mark"
  },
  {
    "function_name": "(int mode)\n{",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "427-448",
    "snippet": "t_dent_type(int mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\treturn UBIFS_ITYPE_REG;\n\tcase S_IFDIR:\n\t\treturn UBIFS_ITYPE_DIR;\n\tcase S_IFLNK:\n\t\treturn UBIFS_ITYPE_LNK;\n\tcase S_IFBLK:\n\t\treturn UBIFS_ITYPE_BLK;\n\tcase S_IFCHR:\n\t\treturn UBIFS_ITYPE_CHR;\n\tcase S_IFIFO:\n\t\treturn UBIFS_ITYPE_FIFO;\n\tcase S_IFSOCK:\n\t\treturn UBIFS_ITYPE_SOCK;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\n/**\n * pack",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tur",
          "args": [],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "coda_return_EIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/dir.c",
          "lines": "32-35",
          "snippet": "static int coda_return_EIO(void)\n{\n\treturn -EIO;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/namei.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int coda_return_EIO(void)\n{\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nt_dent_type(int mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\t\treturn UBIFS_ITYPE_REG;\n\tcase S_IFDIR:\n\t\treturn UBIFS_ITYPE_DIR;\n\tcase S_IFLNK:\n\t\treturn UBIFS_ITYPE_LNK;\n\tcase S_IFBLK:\n\t\treturn UBIFS_ITYPE_BLK;\n\tcase S_IFCHR:\n\t\treturn UBIFS_ITYPE_CHR;\n\tcase S_IFIFO:\n\t\treturn UBIFS_ITYPE_FIFO;\n\tcase S_IFSOCK:\n\t\treturn UBIFS_ITYPE_SOCK;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn 0;\n}\n\n/**\n * pack"
  },
  {
    "function_name": "ation(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "418-421",
    "snippet": "inish_reservation(struct ubifs_info *c)\n{\n\tup_read(&c->commit_sem);\n}\n\n/**\n * get_",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ommit_s",
          "args": [
            "m);\n}\n\n/**\n *"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_commit_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "742-753",
          "snippet": "static void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);\n\nstatic void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\ninish_reservation(struct ubifs_info *c)\n{\n\tup_read(&c->commit_sem);\n}\n\n/**\n * get_"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "406-409",
    "snippet": "void release_head(struct ubifs_info *c, int jhead)\n{\n\tmutex_unlock(&c->jheads[jhead].wbuf.io_mutex);\n}\n\n/**\n * fini",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->jheads[j",
          "args": [
            "ead].wbuf.io_mutex);\n}\n\n/**\n *"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nvoid release_head(struct ubifs_info *c, int jhead)\n{\n\tmutex_unlock(&c->jheads[jhead].wbuf.io_mutex);\n}\n\n/**\n * fini"
  },
  {
    "function_name": "ion(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "323-395",
    "snippet": "ke_reservation(struct ubifs_info *c, int jhead, int len)\n{\n\tint err, cmt_retries = 0, nospc_retries = 0;\n\nagain:\n\tdown_read(&c->commit_sem);\n\terr = reserve_space(c, jhead, len);\n\tif (!err)\n\t\treturn 0;\n\tup_read(&c->commit_sem);\n\n\tif (err == -ENOSPC) {\n\t\t/*\n\t\t * GC could not make any progress. We should try to commit\n\t\t * once because it could make some dirty space and GC would\n\t\t * make progress, so make the error -EAGAIN so that the below\n\t\t * will commit and re-try.\n\t\t */\n\t\tif (nospc_retries++ < 2) {\n\t\t\tdbg_jnl(\"no space, retry\");\n\t\t\terr = -EAGAIN;\n\t\t}\n\n\t\t/*\n\t\t * This means that the budgeting is incorrect. We always have\n\t\t * to be able to write to the media, because all operations are\n\t\t * budgeted. Deletions are not budgeted, though, but we reserve\n\t\t * an extra LEB for them.\n\t\t */\n\t}\n\n\tif (err != -EAGAIN)\n\t\tgoto out;\n\n\t/*\n\t * -EAGAIN means that the journal is full or too large, or the above\n\t * code wants to do one commit. Do this and re-try.\n\t */\n\tif (cmt_retries > 128) {\n\t\t/*\n\t\t * This should not happen unless the journal size limitations\n\t\t * are too tough.\n\t\t */\n\t\tubifs_err(\"stuck in space allocation\");\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t} else if (cmt_retries > 32)\n\t\tubifs_warn(\"too many space allocation re-tries (%d)\",\n\t\t\t   cmt_retries);\n\n\tdbg_jnl(\"-EAGAIN, commit and retry (retried %d times)\",\n\t\tcmt_retries);\n\tcmt_retries += 1;\n\n\terr = ubifs_run_commit(c);\n\tif (err)\n\t\treturn err;\n\tgoto again;\n\nout:\n\tubifs_err(\"cannot reserve %d bytes in jhead %d, error %d\",\n\t\t  len, jhead, err);\n\tif (err == -ENOSPC) {\n\t\t/* This are some budgeting problems, print useful information */\n\t\tdown_write(&c->commit_sem);\n\t\tdump_stack();\n\t\tubifs_dump_budg(c, &c->bi);\n\t\tubifs_dump_lprops(c);\n\t\tcmt_retries = dbg_check_lprops(c);\n\t\tup_write(&c->commit_sem);\n\t}\n\treturn err;\n}\n\n/**\n * rele",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "commit_s",
          "args": [
            "m);\n\t}\n\treturn"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "nfs_direct_commit_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/direct.c",
          "lines": "742-753",
          "snippet": "static void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/slab.h>",
            "#include <linux/kref.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include <linux/atomic.h>\n#include <asm/uaccess.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/module.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/slab.h>\n#include <linux/kref.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void nfs_direct_write_complete(struct nfs_direct_req *dreq, struct inode *inode);\n\nstatic void nfs_direct_commit_schedule(struct nfs_direct_req *dreq)\n{\n\tint res;\n\tstruct nfs_commit_info cinfo;\n\tLIST_HEAD(mds_list);\n\n\tnfs_init_cinfo_from_dreq(&cinfo, dreq);\n\tnfs_scan_commit(dreq->inode, &mds_list, &cinfo);\n\tres = nfs_generic_commit_list(dreq->inode, &mds_list, 0, &cinfo);\n\tif (res < 0) /* res == -ENOMEM */\n\t\tnfs_direct_write_reschedule(dreq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ops(c);\n\t\tup_wri",
          "args": [
            "e"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c);\n\t\tcmt_re",
          "args": [
            "r"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dg(c, &c->bi);",
          "args": [
            "ifs_du"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubifs_d",
          "args": [],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nnot rese",
          "args": [
            "ve %d bytes in jhead %d, error %d\",\n\t\t  len, jh",
            "rr)",
            "if (",
            "r ="
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit(c);\n\tif (err",
          "args": [],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AIN, co",
          "args": [
            "mit and retry (retried %d times)\",\n\t\tcmt_retri",
            "cmt_retri"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oo many sp",
          "args": [
            "ce allocation re-tries (%d)\",\n\t\t\t   cmt_r",
            "dbg_jnl("
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uck in sp",
          "args": [
            "ce allocation\");\n\t\terr = -E"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pace, r",
          "args": [
            "try\");\n\t\t\terr = -"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, jhead, le",
          "args": [
            ")",
            "if (",
            "rr)"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">commit_s",
          "args": [
            "m);\n\terr = res"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nke_reservation(struct ubifs_info *c, int jhead, int len)\n{\n\tint err, cmt_retries = 0, nospc_retries = 0;\n\nagain:\n\tdown_read(&c->commit_sem);\n\terr = reserve_space(c, jhead, len);\n\tif (!err)\n\t\treturn 0;\n\tup_read(&c->commit_sem);\n\n\tif (err == -ENOSPC) {\n\t\t/*\n\t\t * GC could not make any progress. We should try to commit\n\t\t * once because it could make some dirty space and GC would\n\t\t * make progress, so make the error -EAGAIN so that the below\n\t\t * will commit and re-try.\n\t\t */\n\t\tif (nospc_retries++ < 2) {\n\t\t\tdbg_jnl(\"no space, retry\");\n\t\t\terr = -EAGAIN;\n\t\t}\n\n\t\t/*\n\t\t * This means that the budgeting is incorrect. We always have\n\t\t * to be able to write to the media, because all operations are\n\t\t * budgeted. Deletions are not budgeted, though, but we reserve\n\t\t * an extra LEB for them.\n\t\t */\n\t}\n\n\tif (err != -EAGAIN)\n\t\tgoto out;\n\n\t/*\n\t * -EAGAIN means that the journal is full or too large, or the above\n\t * code wants to do one commit. Do this and re-try.\n\t */\n\tif (cmt_retries > 128) {\n\t\t/*\n\t\t * This should not happen unless the journal size limitations\n\t\t * are too tough.\n\t\t */\n\t\tubifs_err(\"stuck in space allocation\");\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t} else if (cmt_retries > 32)\n\t\tubifs_warn(\"too many space allocation re-tries (%d)\",\n\t\t\t   cmt_retries);\n\n\tdbg_jnl(\"-EAGAIN, commit and retry (retried %d times)\",\n\t\tcmt_retries);\n\tcmt_retries += 1;\n\n\terr = ubifs_run_commit(c);\n\tif (err)\n\t\treturn err;\n\tgoto again;\n\nout:\n\tubifs_err(\"cannot reserve %d bytes in jhead %d, error %d\",\n\t\t  len, jhead, err);\n\tif (err == -ENOSPC) {\n\t\t/* This are some budgeting problems, print useful information */\n\t\tdown_write(&c->commit_sem);\n\t\tdump_stack();\n\t\tubifs_dump_budg(c, &c->bi);\n\t\tubifs_dump_lprops(c);\n\t\tcmt_retries = dbg_check_lprops(c);\n\t\tup_write(&c->commit_sem);\n\t}\n\treturn err;\n}\n\n/**\n * rele"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "286-305",
    "snippet": "ite_head(struct ubifs_info *c, int jhead, void *buf, int len,\n\t\t      int *lnum, int *offs, int sync)\n{\n\tint err;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[jhead].wbuf;\n\n\tubifs_assert(jhead != GCHD);\n\n\t*lnum = c->jheads[jhead].wbuf.lnum;\n\t*offs = c->jheads[jhead].wbuf.offs + c->jheads[jhead].wbuf.used;\n\tdbg_jnl(\"jhead %s, LEB %d:%d, len %d\",\n\t\tdbg_jhead(jhead), *lnum, *offs, len);\n\n\terr = ubifs_wbuf_write_nolock(wbuf, buf, len);\n\tif (err)\n\t\treturn err;\n\tif (sync)\n\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\treturn err;\n}\n\n/**\n * make",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nc_nolock(wbuf);\n\tretu",
          "args": [
            "n er"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ite_nolock(wbuf, buf, l",
          "args": [
            "n);",
            "f (",
            "r)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d %s, L",
          "args": [
            "B %d:%d, len %d\",\n\t\tdbg_jhead",
            "ad), *lnum, *off",
            "len)",
            "err",
            "ub"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad), *lnu",
          "args": [
            ", *of"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhead != GCH",
          "args": [
            ");\n\n\t*lnum ="
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nite_head(struct ubifs_info *c, int jhead, void *buf, int len,\n\t\t      int *lnum, int *offs, int sync)\n{\n\tint err;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[jhead].wbuf;\n\n\tubifs_assert(jhead != GCHD);\n\n\t*lnum = c->jheads[jhead].wbuf.lnum;\n\t*offs = c->jheads[jhead].wbuf.offs + c->jheads[jhead].wbuf.used;\n\tdbg_jnl(\"jhead %s, LEB %d:%d, len %d\",\n\t\tdbg_jhead(jhead), *lnum, *offs, len);\n\n\terr = ubifs_wbuf_write_nolock(wbuf, buf, len);\n\tif (err)\n\t\treturn err;\n\tif (sync)\n\t\terr = ubifs_wbuf_sync_nolock(wbuf);\n\treturn err;\n}\n\n/**\n * make"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "255-270",
    "snippet": "ite_node(struct ubifs_info *c, int jhead, void *node, int len,\n\t\t      int *lnum, int *offs)\n{\n\tstruct ubifs_wbuf *wbuf = &c->jheads[jhead].wbuf;\n\n\tubifs_assert(jhead != GCHD);\n\n\t*lnum = c->jheads[jhead].wbuf.lnum;\n\t*offs = c->jheads[jhead].wbuf.offs + c->jheads[jhead].wbuf.used;\n\n\tdbg_jnl(\"jhead %s, LEB %d:%d, len %d\",\n\t\tdbg_jhead(jhead), *lnum, *offs, len);\n\tubifs_prepare_node(c, node, len, 0);\n\n\treturn ubifs_wbuf_write_nolock(wbuf, node, len);\n}\n\n/**\n * writ",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ite_nolock(wbuf, node,",
          "args": [
            "en);",
            "/*",
            "*"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, node, len",
          "args": [
            ";",
            "tur",
            "u"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d %s, L",
          "args": [
            "B %d:%d, len %d\",\n\t\tdbg_jhead",
            "ad), *lnum, *off",
            "len)",
            "ubif",
            "pre"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad), *lnu",
          "args": [
            ", *of"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jhead != GCH",
          "args": [
            ");\n\n\t*lnum ="
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nite_node(struct ubifs_info *c, int jhead, void *node, int len,\n\t\t      int *lnum, int *offs)\n{\n\tstruct ubifs_wbuf *wbuf = &c->jheads[jhead].wbuf;\n\n\tubifs_assert(jhead != GCHD);\n\n\t*lnum = c->jheads[jhead].wbuf.lnum;\n\t*offs = c->jheads[jhead].wbuf.offs + c->jheads[jhead].wbuf.used;\n\n\tdbg_jnl(\"jhead %s, LEB %d:%d, len %d\",\n\t\tdbg_jhead(jhead), *lnum, *offs, len);\n\tubifs_prepare_node(c, node, len, 0);\n\n\treturn ubifs_wbuf_write_nolock(wbuf, node, len);\n}\n\n/**\n * writ"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "115-240",
    "snippet": "serve_space(struct ubifs_info *c, int jhead, int len)\n{\n\tint err = 0, err1, retries = 0, avail, lnum, offs, squeeze;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[jhead].wbuf;\n\n\t/*\n\t * Typically, the base head has smaller nodes written to it, so it is\n\t * better to try to allocate space at the ends of eraseblocks. This is\n\t * what the squeeze parameter does.\n\t */\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tsqueeze = (jhead == BASEHD);\nagain:\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_unlock;\n\t}\n\n\tavail = c->leb_size - wbuf->offs - wbuf->used;\n\tif (wbuf->lnum != -1 && avail >= len)\n\t\treturn 0;\n\n\t/*\n\t * Write buffer wasn't seek'ed or there is no enough space - look for an\n\t * LEB with some empty space.\n\t */\n\tlnum = ubifs_find_free_space(c, len, &offs, squeeze);\n\tif (lnum >= 0)\n\t\tgoto out;\n\n\terr = lnum;\n\tif (err != -ENOSPC)\n\t\tgoto out_unlock;\n\n\t/*\n\t * No free space, we have to run garbage collector to make\n\t * some. But the write-buffer mutex has to be unlocked because\n\t * GC also takes it.\n\t */\n\tdbg_jnl(\"no free space in jhead %s, run GC\", dbg_jhead(jhead));\n\tmutex_unlock(&wbuf->io_mutex);\n\n\tlnum = ubifs_garbage_collect(c, 0);\n\tif (lnum < 0) {\n\t\terr = lnum;\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\n\t\t/*\n\t\t * GC could not make a free LEB. But someone else may\n\t\t * have allocated new bud for this journal head,\n\t\t * because we dropped @wbuf->io_mutex, so try once\n\t\t * again.\n\t\t */\n\t\tdbg_jnl(\"GC couldn't make a free LEB for jhead %s\",\n\t\t\tdbg_jhead(jhead));\n\t\tif (retries++ < 2) {\n\t\t\tdbg_jnl(\"retry (%d)\", retries);\n\t\t\tgoto again;\n\t\t}\n\n\t\tdbg_jnl(\"return -ENOSPC\");\n\t\treturn err;\n\t}\n\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\tdbg_jnl(\"got LEB %d for jhead %s\", lnum, dbg_jhead(jhead));\n\tavail = c->leb_size - wbuf->offs - wbuf->used;\n\n\tif (wbuf->lnum != -1 && avail >= len) {\n\t\t/*\n\t\t * Someone else has switched the journal head and we have\n\t\t * enough space now. This happens when more than one process is\n\t\t * trying to write to the same journal head at the same time.\n\t\t */\n\t\tdbg_jnl(\"return LEB %d back, already have LEB %d:%d\",\n\t\t\tlnum, wbuf->lnum, wbuf->offs + wbuf->used);\n\t\terr = ubifs_return_leb(c, lnum);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\treturn 0;\n\t}\n\n\toffs = 0;\n\nout:\n\t/*\n\t * Make sure we synchronize the write-buffer before we add the new bud\n\t * to the log. Otherwise we may have a power cut after the log\n\t * reference node for the last bud (@lnum) is written but before the\n\t * write-buffer data are written to the next-to-last bud\n\t * (@wbuf->lnum). And the effect would be that the recovery would see\n\t * that there is corruption in the next-to-last bud.\n\t */\n\terr = ubifs_wbuf_sync_nolock(wbuf);\n\tif (err)\n\t\tgoto out_return;\n\terr = ubifs_add_bud_to_log(c, jhead, lnum, offs);\n\tif (err)\n\t\tgoto out_return;\n\terr = ubifs_wbuf_seek_nolock(wbuf, lnum, offs);\n\tif (err)\n\t\tgoto out_unlock;\n\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn err;\n\nout_return:\n\t/* An error occurred and the LEB has to be returned to lprops */\n\tubifs_assert(err < 0);\n\terr1 = ubifs_return_leb(c, lnum);\n\tif (err1 && err == -EAGAIN)\n\t\t/*\n\t\t * Return original error code only if it is not %-EAGAIN,\n\t\t * which is not really an error. Otherwise, return the error\n\t\t * code of 'ubifs_return_leb()'.\n\t\t */\n\t\terr = err1;\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn err;\n}\n\n/**\n * writ",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&wbuf->io_mu",
          "args": [
            "ex);\n\treturn er"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb(c, lnum);\n\ti",
          "args": [
            "rr1"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err < 0);\n\te",
          "args": [
            "r1 = ub"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&wbuf->io_mu",
          "args": [
            "ex);\n\treturn er"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ek_nolock(wbuf, lnum,",
          "args": [
            "ffs)",
            "if",
            "rr)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_to_log(c, jhead, ln",
          "args": [
            "m",
            "offs)",
            "if",
            "rr)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc_nolock(wbuf);\n\tif (",
          "args": [
            "rr)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb(c, lnum);",
          "args": [
            "f",
            "err)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rn LEB",
          "args": [
            "d back, already have LEB %d:%d\",\n\t\t\tlnum, wb",
            "num,",
            "buf->offs",
            "wbuf->used);\n\t\terr = ub"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LEB %d",
          "args": [
            "or jhead %s\", lnum, dbg_j",
            "ad(j",
            "ad));\n\tavail = c"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad));\n\tav",
          "args": [
            "il ="
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sted(&wbuf->io_mu",
          "args": [
            "ex, wbuf->jhead",
            "dbg_jnl(\""
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rn -ENO",
          "args": [
            "PC\");\n\t\treturn e"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "y (%d)\"",
          "args": [
            "retries);",
            "goto ag"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ouldn't",
          "args": [
            "make a free LEB for jhead %s\",\n\t\t\tdbg_jhea",
            "ad));\n\t\tif (retr"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad));\n\t\ti",
          "args": [
            "(ret"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_collect(c, 0);\n\tif (",
          "args": [
            "n"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&wbuf->io_mu",
          "args": [
            "ex);\n\n\tlnum = u"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree spa",
          "args": [
            "e in jhead %s, run GC\", dbg_jhead(j",
            "ad));\n\tmutex_unl"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ad));\n\tmu",
          "args": [
            "ex_un"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee_space(c, len, &off",
          "args": [
            ",",
            "que",
            "e);",
            "(lnum"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sted(&wbuf->io_mu",
          "args": [
            "ex, wbuf->jhead",
            "if (c->r"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\tsqueeze ="
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nserve_space(struct ubifs_info *c, int jhead, int len)\n{\n\tint err = 0, err1, retries = 0, avail, lnum, offs, squeeze;\n\tstruct ubifs_wbuf *wbuf = &c->jheads[jhead].wbuf;\n\n\t/*\n\t * Typically, the base head has smaller nodes written to it, so it is\n\t * better to try to allocate space at the ends of eraseblocks. This is\n\t * what the squeeze parameter does.\n\t */\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tsqueeze = (jhead == BASEHD);\nagain:\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_unlock;\n\t}\n\n\tavail = c->leb_size - wbuf->offs - wbuf->used;\n\tif (wbuf->lnum != -1 && avail >= len)\n\t\treturn 0;\n\n\t/*\n\t * Write buffer wasn't seek'ed or there is no enough space - look for an\n\t * LEB with some empty space.\n\t */\n\tlnum = ubifs_find_free_space(c, len, &offs, squeeze);\n\tif (lnum >= 0)\n\t\tgoto out;\n\n\terr = lnum;\n\tif (err != -ENOSPC)\n\t\tgoto out_unlock;\n\n\t/*\n\t * No free space, we have to run garbage collector to make\n\t * some. But the write-buffer mutex has to be unlocked because\n\t * GC also takes it.\n\t */\n\tdbg_jnl(\"no free space in jhead %s, run GC\", dbg_jhead(jhead));\n\tmutex_unlock(&wbuf->io_mutex);\n\n\tlnum = ubifs_garbage_collect(c, 0);\n\tif (lnum < 0) {\n\t\terr = lnum;\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\n\t\t/*\n\t\t * GC could not make a free LEB. But someone else may\n\t\t * have allocated new bud for this journal head,\n\t\t * because we dropped @wbuf->io_mutex, so try once\n\t\t * again.\n\t\t */\n\t\tdbg_jnl(\"GC couldn't make a free LEB for jhead %s\",\n\t\t\tdbg_jhead(jhead));\n\t\tif (retries++ < 2) {\n\t\t\tdbg_jnl(\"retry (%d)\", retries);\n\t\t\tgoto again;\n\t\t}\n\n\t\tdbg_jnl(\"return -ENOSPC\");\n\t\treturn err;\n\t}\n\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\tdbg_jnl(\"got LEB %d for jhead %s\", lnum, dbg_jhead(jhead));\n\tavail = c->leb_size - wbuf->offs - wbuf->used;\n\n\tif (wbuf->lnum != -1 && avail >= len) {\n\t\t/*\n\t\t * Someone else has switched the journal head and we have\n\t\t * enough space now. This happens when more than one process is\n\t\t * trying to write to the same journal head at the same time.\n\t\t */\n\t\tdbg_jnl(\"return LEB %d back, already have LEB %d:%d\",\n\t\t\tlnum, wbuf->lnum, wbuf->offs + wbuf->used);\n\t\terr = ubifs_return_leb(c, lnum);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\treturn 0;\n\t}\n\n\toffs = 0;\n\nout:\n\t/*\n\t * Make sure we synchronize the write-buffer before we add the new bud\n\t * to the log. Otherwise we may have a power cut after the log\n\t * reference node for the last bud (@lnum) is written but before the\n\t * write-buffer data are written to the next-to-last bud\n\t * (@wbuf->lnum). And the effect would be that the recovery would see\n\t * that there is corruption in the next-to-last bud.\n\t */\n\terr = ubifs_wbuf_sync_nolock(wbuf);\n\tif (err)\n\t\tgoto out_return;\n\terr = ubifs_add_bud_to_log(c, jhead, lnum, offs);\n\tif (err)\n\t\tgoto out_return;\n\terr = ubifs_wbuf_seek_nolock(wbuf, lnum, offs);\n\tif (err)\n\t\tgoto out_unlock;\n\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn err;\n\nout_return:\n\t/* An error occurred and the LEB has to be returned to lprops */\n\tubifs_assert(err < 0);\n\terr1 = ubifs_return_leb(c, lnum);\n\tif (err1 && err == -EAGAIN)\n\t\t/*\n\t\t * Return original error code only if it is not %-EAGAIN,\n\t\t * which is not really an error. Otherwise, return the error\n\t\t * code of 'ubifs_return_leb()'.\n\t\t */\n\t\terr = err1;\n\tmutex_unlock(&wbuf->io_mutex);\n\treturn err;\n}\n\n/**\n * writ"
  },
  {
    "function_name": "e_unused(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "98-101",
    "snippet": "void zero_trun_node_unused(struct ubifs_trun_node *trun)\n{\n\tmemset(trun->padding, 0, 12);\n}\n\n/**\n * rese",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "paddin",
          "args": [
            ", 0, 12);\n}",
            "*",
            "*"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nvoid zero_trun_node_unused(struct ubifs_trun_node *trun)\n{\n\tmemset(trun->padding, 0, 12);\n}\n\n/**\n * rese"
  },
  {
    "function_name": "e_unused(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "88-91",
    "snippet": "void zero_data_node_unused(struct ubifs_data_node *data)\n{\n\tmemset(data->padding, 0, 2);\n}\n\n/**\n * zero",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "paddin",
          "args": [
            ", 0, 2);\n}\n\n/"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nvoid zero_data_node_unused(struct ubifs_data_node *data)\n{\n\tmemset(data->padding, 0, 2);\n}\n\n/**\n * zero"
  },
  {
    "function_name": "e_unused(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "78-82",
    "snippet": "void zero_dent_node_unused(struct ubifs_dent_node *dent)\n{\n\tdent->padding1 = 0;\n\tmemset(dent->padding2, 0, 4);\n}\n\n/**\n * zero",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "paddin",
          "args": [
            "2, 0, 4);\n}\n\n/"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nvoid zero_dent_node_unused(struct ubifs_dent_node *dent)\n{\n\tdent->padding1 = 0;\n\tmemset(dent->padding2, 0, 4);\n}\n\n/**\n * zero"
  },
  {
    "function_name": "_unused(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/journal.c",
    "lines": "67-71",
    "snippet": "void zero_ino_node_unused(struct ubifs_ino_node *ino)\n{\n\tmemset(ino->padding1, 0, 4);\n\tmemset(ino->padding2, 0, 26);\n}\n\n/**\n * zero",
    "includes": [
      "fs.h\"\n\n/**\n * zero_"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "adding",
          "args": [
            ", 0, 26);\n}",
            "*",
            "*"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adding",
          "args": [
            ", 0, 4);\n\tmem",
            "t",
            "n"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * zero_\n\nvoid zero_ino_node_unused(struct ubifs_ino_node *ino)\n{\n\tmemset(ino->padding1, 0, 4);\n\tmemset(ino->padding2, 0, 26);\n}\n\n/**\n * zero"
  }
]