[
  {
    "function_name": "ecryptfs_release_messaging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
    "lines": "429-468",
    "snippet": "void ecryptfs_release_messaging(void)\n{\n\tif (ecryptfs_msg_ctx_arr) {\n\t\tint i;\n\n\t\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\t\tfor (i = 0; i < ecryptfs_message_buf_len; i++) {\n\t\t\tmutex_lock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\t\tkfree(ecryptfs_msg_ctx_arr[i].msg);\n\t\t\tmutex_unlock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\t}\n\t\tkfree(ecryptfs_msg_ctx_arr);\n\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t}\n\tif (ecryptfs_daemon_hash) {\n\t\tstruct ecryptfs_daemon *daemon;\n\t\tint i;\n\n\t\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\t\tfor (i = 0; i < (1 << ecryptfs_hash_bits); i++) {\n\t\t\tint rc;\n\n\t\t\thlist_for_each_entry(daemon,\n\t\t\t\t\t     &ecryptfs_daemon_hash[i],\n\t\t\t\t\t     euid_chain) {\n\t\t\t\trc = ecryptfs_exorcise_daemon(daemon);\n\t\t\t\tif (rc)\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error whilst \"\n\t\t\t\t\t       \"attempting to destroy daemon; \"\n\t\t\t\t\t       \"rc = [%d]. Dazed and confused, \"\n\t\t\t\t\t       \"but trying to continue.\\n\",\n\t\t\t\t\t       __func__, rc);\n\t\t\t}\n\t\t}\n\t\tkfree(ecryptfs_daemon_hash);\n\t\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\t}\n\tecryptfs_destroy_ecryptfs_miscdev();\n\treturn;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mutex ecryptfs_msg_ctx_lists_mux;",
      "static struct hlist_head *ecryptfs_daemon_hash;",
      "struct mutex ecryptfs_daemon_hash_mux;",
      "static int ecryptfs_hash_bits;",
      "static struct ecryptfs_msg_ctx *ecryptfs_msg_ctx_arr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_destroy_ecryptfs_miscdev",
          "args": [],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_destroy_ecryptfs_miscdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
          "lines": "507-511",
          "snippet": "void ecryptfs_destroy_ecryptfs_miscdev(void)\n{\n\tBUG_ON(atomic_read(&ecryptfs_num_miscdev_opens) != 0);\n\tmisc_deregister(&ecryptfs_miscdev);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/random.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t ecryptfs_num_miscdev_opens;",
            "static struct miscdevice ecryptfs_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name  = \"ecryptfs\",\n\t.fops  = &ecryptfs_miscdev_fops\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\nstatic atomic_t ecryptfs_num_miscdev_opens;\nstatic struct miscdevice ecryptfs_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name  = \"ecryptfs\",\n\t.fops  = &ecryptfs_miscdev_fops\n};\n\nvoid ecryptfs_destroy_ecryptfs_miscdev(void)\n{\n\tBUG_ON(atomic_read(&ecryptfs_num_miscdev_opens) != 0);\n\tmisc_deregister(&ecryptfs_miscdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_daemon_hash_mux"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ecryptfs_daemon_hash"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error whilst \"\n\t\t\t\t\t       \"attempting to destroy daemon; \"\n\t\t\t\t\t       \"rc = [%d]. Dazed and confused, \"\n\t\t\t\t\t       \"but trying to continue.\\n\"",
            "__func__",
            "rc"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_exorcise_daemon",
          "args": [
            "daemon"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_exorcise_daemon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "171-196",
          "snippet": "int ecryptfs_exorcise_daemon(struct ecryptfs_daemon *daemon)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx, *msg_ctx_tmp;\n\tint rc = 0;\n\n\tmutex_lock(&daemon->mux);\n\tif ((daemon->flags & ECRYPTFS_DAEMON_IN_READ)\n\t    || (daemon->flags & ECRYPTFS_DAEMON_IN_POLL)) {\n\t\trc = -EBUSY;\n\t\tmutex_unlock(&daemon->mux);\n\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(msg_ctx, msg_ctx_tmp,\n\t\t\t\t &daemon->msg_ctx_out_queue, daemon_out_list) {\n\t\tlist_del(&msg_ctx->daemon_out_list);\n\t\tdaemon->num_queued_msg_ctx--;\n\t\tprintk(KERN_WARNING \"%s: Warning: dropping message that is in \"\n\t\t       \"the out queue of a dying daemon\\n\", __func__);\n\t\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\n\t}\n\thlist_del(&daemon->euid_chain);\n\tmutex_unlock(&daemon->mux);\n\tkzfree(daemon);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint ecryptfs_exorcise_daemon(struct ecryptfs_daemon *daemon)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx, *msg_ctx_tmp;\n\tint rc = 0;\n\n\tmutex_lock(&daemon->mux);\n\tif ((daemon->flags & ECRYPTFS_DAEMON_IN_READ)\n\t    || (daemon->flags & ECRYPTFS_DAEMON_IN_POLL)) {\n\t\trc = -EBUSY;\n\t\tmutex_unlock(&daemon->mux);\n\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(msg_ctx, msg_ctx_tmp,\n\t\t\t\t &daemon->msg_ctx_out_queue, daemon_out_list) {\n\t\tlist_del(&msg_ctx->daemon_out_list);\n\t\tdaemon->num_queued_msg_ctx--;\n\t\tprintk(KERN_WARNING \"%s: Warning: dropping message that is in \"\n\t\t       \"the out queue of a dying daemon\\n\", __func__);\n\t\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\n\t}\n\thlist_del(&daemon->euid_chain);\n\tmutex_unlock(&daemon->mux);\n\tkzfree(daemon);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "daemon",
            "&ecryptfs_daemon_hash[i]",
            "euid_chain"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ecryptfs_daemon_hash_mux"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_msg_ctx_lists_mux"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ecryptfs_msg_ctx_arr"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_msg_ctx_arr[i].mux"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ecryptfs_msg_ctx_arr[i].msg"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ecryptfs_msg_ctx_arr[i].mux"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ecryptfs_msg_ctx_lists_mux"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct mutex ecryptfs_msg_ctx_lists_mux;\nstatic struct hlist_head *ecryptfs_daemon_hash;\nstruct mutex ecryptfs_daemon_hash_mux;\nstatic int ecryptfs_hash_bits;\nstatic struct ecryptfs_msg_ctx *ecryptfs_msg_ctx_arr;\n\nvoid ecryptfs_release_messaging(void)\n{\n\tif (ecryptfs_msg_ctx_arr) {\n\t\tint i;\n\n\t\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\t\tfor (i = 0; i < ecryptfs_message_buf_len; i++) {\n\t\t\tmutex_lock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\t\tkfree(ecryptfs_msg_ctx_arr[i].msg);\n\t\t\tmutex_unlock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\t}\n\t\tkfree(ecryptfs_msg_ctx_arr);\n\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t}\n\tif (ecryptfs_daemon_hash) {\n\t\tstruct ecryptfs_daemon *daemon;\n\t\tint i;\n\n\t\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\t\tfor (i = 0; i < (1 << ecryptfs_hash_bits); i++) {\n\t\t\tint rc;\n\n\t\t\thlist_for_each_entry(daemon,\n\t\t\t\t\t     &ecryptfs_daemon_hash[i],\n\t\t\t\t\t     euid_chain) {\n\t\t\t\trc = ecryptfs_exorcise_daemon(daemon);\n\t\t\t\tif (rc)\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error whilst \"\n\t\t\t\t\t       \"attempting to destroy daemon; \"\n\t\t\t\t\t       \"rc = [%d]. Dazed and confused, \"\n\t\t\t\t\t       \"but trying to continue.\\n\",\n\t\t\t\t\t       __func__, rc);\n\t\t\t}\n\t\t}\n\t\tkfree(ecryptfs_daemon_hash);\n\t\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\t}\n\tecryptfs_destroy_ecryptfs_miscdev();\n\treturn;\n}"
  },
  {
    "function_name": "ecryptfs_init_messaging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
    "lines": "368-427",
    "snippet": "int __init ecryptfs_init_messaging(void)\n{\n\tint i;\n\tint rc = 0;\n\n\tif (ecryptfs_number_of_users > ECRYPTFS_MAX_NUM_USERS) {\n\t\tecryptfs_number_of_users = ECRYPTFS_MAX_NUM_USERS;\n\t\tprintk(KERN_WARNING \"%s: Specified number of users is \"\n\t\t       \"too large, defaulting to [%d] users\\n\", __func__,\n\t\t       ecryptfs_number_of_users);\n\t}\n\tmutex_init(&ecryptfs_daemon_hash_mux);\n\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\tecryptfs_hash_bits = 1;\n\twhile (ecryptfs_number_of_users >> ecryptfs_hash_bits)\n\t\tecryptfs_hash_bits++;\n\tecryptfs_daemon_hash = kmalloc((sizeof(struct hlist_head)\n\t\t\t\t\t* (1 << ecryptfs_hash_bits)),\n\t\t\t\t       GFP_KERNEL);\n\tif (!ecryptfs_daemon_hash) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Failed to allocate memory\\n\", __func__);\n\t\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < (1 << ecryptfs_hash_bits); i++)\n\t\tINIT_HLIST_HEAD(&ecryptfs_daemon_hash[i]);\n\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\tecryptfs_msg_ctx_arr = kmalloc((sizeof(struct ecryptfs_msg_ctx)\n\t\t\t\t\t* ecryptfs_message_buf_len),\n\t\t\t\t       GFP_KERNEL);\n\tif (!ecryptfs_msg_ctx_arr) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Failed to allocate memory\\n\", __func__);\n\t\tgoto out;\n\t}\n\tmutex_init(&ecryptfs_msg_ctx_lists_mux);\n\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\tecryptfs_msg_counter = 0;\n\tfor (i = 0; i < ecryptfs_message_buf_len; i++) {\n\t\tINIT_LIST_HEAD(&ecryptfs_msg_ctx_arr[i].node);\n\t\tINIT_LIST_HEAD(&ecryptfs_msg_ctx_arr[i].daemon_out_list);\n\t\tmutex_init(&ecryptfs_msg_ctx_arr[i].mux);\n\t\tmutex_lock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\tecryptfs_msg_ctx_arr[i].index = i;\n\t\tecryptfs_msg_ctx_arr[i].state = ECRYPTFS_MSG_CTX_STATE_FREE;\n\t\tecryptfs_msg_ctx_arr[i].counter = 0;\n\t\tecryptfs_msg_ctx_arr[i].task = NULL;\n\t\tecryptfs_msg_ctx_arr[i].msg = NULL;\n\t\tlist_add_tail(&ecryptfs_msg_ctx_arr[i].node,\n\t\t\t      &ecryptfs_msg_ctx_free_list);\n\t\tmutex_unlock(&ecryptfs_msg_ctx_arr[i].mux);\n\t}\n\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_init_ecryptfs_miscdev();\n\tif (rc)\n\t\tecryptfs_release_messaging();\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ecryptfs_msg_ctx_free_list);",
      "static struct mutex ecryptfs_msg_ctx_lists_mux;",
      "static struct hlist_head *ecryptfs_daemon_hash;",
      "struct mutex ecryptfs_daemon_hash_mux;",
      "static int ecryptfs_hash_bits;",
      "static u32 ecryptfs_msg_counter;",
      "static struct ecryptfs_msg_ctx *ecryptfs_msg_ctx_arr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_release_messaging",
          "args": [],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_release_messaging",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "429-468",
          "snippet": "void ecryptfs_release_messaging(void)\n{\n\tif (ecryptfs_msg_ctx_arr) {\n\t\tint i;\n\n\t\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\t\tfor (i = 0; i < ecryptfs_message_buf_len; i++) {\n\t\t\tmutex_lock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\t\tkfree(ecryptfs_msg_ctx_arr[i].msg);\n\t\t\tmutex_unlock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\t}\n\t\tkfree(ecryptfs_msg_ctx_arr);\n\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t}\n\tif (ecryptfs_daemon_hash) {\n\t\tstruct ecryptfs_daemon *daemon;\n\t\tint i;\n\n\t\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\t\tfor (i = 0; i < (1 << ecryptfs_hash_bits); i++) {\n\t\t\tint rc;\n\n\t\t\thlist_for_each_entry(daemon,\n\t\t\t\t\t     &ecryptfs_daemon_hash[i],\n\t\t\t\t\t     euid_chain) {\n\t\t\t\trc = ecryptfs_exorcise_daemon(daemon);\n\t\t\t\tif (rc)\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error whilst \"\n\t\t\t\t\t       \"attempting to destroy daemon; \"\n\t\t\t\t\t       \"rc = [%d]. Dazed and confused, \"\n\t\t\t\t\t       \"but trying to continue.\\n\",\n\t\t\t\t\t       __func__, rc);\n\t\t\t}\n\t\t}\n\t\tkfree(ecryptfs_daemon_hash);\n\t\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\t}\n\tecryptfs_destroy_ecryptfs_miscdev();\n\treturn;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mutex ecryptfs_msg_ctx_lists_mux;",
            "static struct hlist_head *ecryptfs_daemon_hash;",
            "struct mutex ecryptfs_daemon_hash_mux;",
            "static int ecryptfs_hash_bits;",
            "static struct ecryptfs_msg_ctx *ecryptfs_msg_ctx_arr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct mutex ecryptfs_msg_ctx_lists_mux;\nstatic struct hlist_head *ecryptfs_daemon_hash;\nstruct mutex ecryptfs_daemon_hash_mux;\nstatic int ecryptfs_hash_bits;\nstatic struct ecryptfs_msg_ctx *ecryptfs_msg_ctx_arr;\n\nvoid ecryptfs_release_messaging(void)\n{\n\tif (ecryptfs_msg_ctx_arr) {\n\t\tint i;\n\n\t\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\t\tfor (i = 0; i < ecryptfs_message_buf_len; i++) {\n\t\t\tmutex_lock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\t\tkfree(ecryptfs_msg_ctx_arr[i].msg);\n\t\t\tmutex_unlock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\t}\n\t\tkfree(ecryptfs_msg_ctx_arr);\n\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t}\n\tif (ecryptfs_daemon_hash) {\n\t\tstruct ecryptfs_daemon *daemon;\n\t\tint i;\n\n\t\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\t\tfor (i = 0; i < (1 << ecryptfs_hash_bits); i++) {\n\t\t\tint rc;\n\n\t\t\thlist_for_each_entry(daemon,\n\t\t\t\t\t     &ecryptfs_daemon_hash[i],\n\t\t\t\t\t     euid_chain) {\n\t\t\t\trc = ecryptfs_exorcise_daemon(daemon);\n\t\t\t\tif (rc)\n\t\t\t\t\tprintk(KERN_ERR \"%s: Error whilst \"\n\t\t\t\t\t       \"attempting to destroy daemon; \"\n\t\t\t\t\t       \"rc = [%d]. Dazed and confused, \"\n\t\t\t\t\t       \"but trying to continue.\\n\",\n\t\t\t\t\t       __func__, rc);\n\t\t\t}\n\t\t}\n\t\tkfree(ecryptfs_daemon_hash);\n\t\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\t}\n\tecryptfs_destroy_ecryptfs_miscdev();\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_init_ecryptfs_miscdev",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_init_ecryptfs_miscdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
          "lines": "488-499",
          "snippet": "int __init ecryptfs_init_ecryptfs_miscdev(void)\n{\n\tint rc;\n\n\tatomic_set(&ecryptfs_num_miscdev_opens, 0);\n\trc = misc_register(&ecryptfs_miscdev);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Failed to register miscellaneous device \"\n\t\t       \"for communications with userspace daemons; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/random.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t ecryptfs_num_miscdev_opens;",
            "static struct miscdevice ecryptfs_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name  = \"ecryptfs\",\n\t.fops  = &ecryptfs_miscdev_fops\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\nstatic atomic_t ecryptfs_num_miscdev_opens;\nstatic struct miscdevice ecryptfs_miscdev = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name  = \"ecryptfs\",\n\t.fops  = &ecryptfs_miscdev_fops\n};\n\nint __init ecryptfs_init_ecryptfs_miscdev(void)\n{\n\tint rc;\n\n\tatomic_set(&ecryptfs_num_miscdev_opens, 0);\n\trc = misc_register(&ecryptfs_miscdev);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Failed to register miscellaneous device \"\n\t\t       \"for communications with userspace daemons; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_msg_ctx_lists_mux"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_msg_ctx_arr[i].mux"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ecryptfs_msg_ctx_arr[i].node",
            "&ecryptfs_msg_ctx_free_list"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ecryptfs_msg_ctx_arr[i].mux"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ecryptfs_msg_ctx_arr[i].mux"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ecryptfs_msg_ctx_arr[i].daemon_out_list"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ecryptfs_msg_ctx_arr[i].node"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ecryptfs_msg_ctx_lists_mux"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ecryptfs_msg_ctx_lists_mux"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Failed to allocate memory\\n\"",
            "__func__"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(sizeof(struct ecryptfs_msg_ctx)\n\t\t\t\t\t* ecryptfs_message_buf_len)",
            "GFP_KERNEL"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_daemon_hash_mux"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_HLIST_HEAD",
          "args": [
            "&ecryptfs_daemon_hash[i]"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_daemon_hash_mux"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ecryptfs_daemon_hash_mux"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ecryptfs_daemon_hash_mux"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(ecryptfs_msg_ctx_free_list);\nstatic struct mutex ecryptfs_msg_ctx_lists_mux;\nstatic struct hlist_head *ecryptfs_daemon_hash;\nstruct mutex ecryptfs_daemon_hash_mux;\nstatic int ecryptfs_hash_bits;\nstatic u32 ecryptfs_msg_counter;\nstatic struct ecryptfs_msg_ctx *ecryptfs_msg_ctx_arr;\n\nint __init ecryptfs_init_messaging(void)\n{\n\tint i;\n\tint rc = 0;\n\n\tif (ecryptfs_number_of_users > ECRYPTFS_MAX_NUM_USERS) {\n\t\tecryptfs_number_of_users = ECRYPTFS_MAX_NUM_USERS;\n\t\tprintk(KERN_WARNING \"%s: Specified number of users is \"\n\t\t       \"too large, defaulting to [%d] users\\n\", __func__,\n\t\t       ecryptfs_number_of_users);\n\t}\n\tmutex_init(&ecryptfs_daemon_hash_mux);\n\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\tecryptfs_hash_bits = 1;\n\twhile (ecryptfs_number_of_users >> ecryptfs_hash_bits)\n\t\tecryptfs_hash_bits++;\n\tecryptfs_daemon_hash = kmalloc((sizeof(struct hlist_head)\n\t\t\t\t\t* (1 << ecryptfs_hash_bits)),\n\t\t\t\t       GFP_KERNEL);\n\tif (!ecryptfs_daemon_hash) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Failed to allocate memory\\n\", __func__);\n\t\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < (1 << ecryptfs_hash_bits); i++)\n\t\tINIT_HLIST_HEAD(&ecryptfs_daemon_hash[i]);\n\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\tecryptfs_msg_ctx_arr = kmalloc((sizeof(struct ecryptfs_msg_ctx)\n\t\t\t\t\t* ecryptfs_message_buf_len),\n\t\t\t\t       GFP_KERNEL);\n\tif (!ecryptfs_msg_ctx_arr) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Failed to allocate memory\\n\", __func__);\n\t\tgoto out;\n\t}\n\tmutex_init(&ecryptfs_msg_ctx_lists_mux);\n\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\tecryptfs_msg_counter = 0;\n\tfor (i = 0; i < ecryptfs_message_buf_len; i++) {\n\t\tINIT_LIST_HEAD(&ecryptfs_msg_ctx_arr[i].node);\n\t\tINIT_LIST_HEAD(&ecryptfs_msg_ctx_arr[i].daemon_out_list);\n\t\tmutex_init(&ecryptfs_msg_ctx_arr[i].mux);\n\t\tmutex_lock(&ecryptfs_msg_ctx_arr[i].mux);\n\t\tecryptfs_msg_ctx_arr[i].index = i;\n\t\tecryptfs_msg_ctx_arr[i].state = ECRYPTFS_MSG_CTX_STATE_FREE;\n\t\tecryptfs_msg_ctx_arr[i].counter = 0;\n\t\tecryptfs_msg_ctx_arr[i].task = NULL;\n\t\tecryptfs_msg_ctx_arr[i].msg = NULL;\n\t\tlist_add_tail(&ecryptfs_msg_ctx_arr[i].node,\n\t\t\t      &ecryptfs_msg_ctx_free_list);\n\t\tmutex_unlock(&ecryptfs_msg_ctx_arr[i].mux);\n\t}\n\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_init_ecryptfs_miscdev();\n\tif (rc)\n\t\tecryptfs_release_messaging();\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_wait_for_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
    "lines": "341-366",
    "snippet": "int ecryptfs_wait_for_response(struct ecryptfs_msg_ctx *msg_ctx,\n\t\t\t       struct ecryptfs_message **msg)\n{\n\tsigned long timeout = ecryptfs_message_wait_timeout * HZ;\n\tint rc = 0;\n\nsleep:\n\ttimeout = schedule_timeout_interruptible(timeout);\n\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\tmutex_lock(&msg_ctx->mux);\n\tif (msg_ctx->state != ECRYPTFS_MSG_CTX_STATE_DONE) {\n\t\tif (timeout) {\n\t\t\tmutex_unlock(&msg_ctx->mux);\n\t\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t\t\tgoto sleep;\n\t\t}\n\t\trc = -ENOMSG;\n\t} else {\n\t\t*msg = msg_ctx->msg;\n\t\tmsg_ctx->msg = NULL;\n\t}\n\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\n\tmutex_unlock(&msg_ctx->mux);\n\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mutex ecryptfs_msg_ctx_lists_mux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_msg_ctx_lists_mux"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&msg_ctx->mux"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_msg_ctx_alloc_to_free",
          "args": [
            "msg_ctx"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_msg_ctx_alloc_to_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "97-103",
          "snippet": "void ecryptfs_msg_ctx_alloc_to_free(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&(msg_ctx->node), &ecryptfs_msg_ctx_free_list);\n\tkfree(msg_ctx->msg);\n\tmsg_ctx->msg = NULL;\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_FREE;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ecryptfs_msg_ctx_free_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(ecryptfs_msg_ctx_free_list);\n\nvoid ecryptfs_msg_ctx_alloc_to_free(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&(msg_ctx->node), &ecryptfs_msg_ctx_free_list);\n\tkfree(msg_ctx->msg);\n\tmsg_ctx->msg = NULL;\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_FREE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_msg_ctx_lists_mux"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&msg_ctx->mux"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&msg_ctx->mux"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ecryptfs_msg_ctx_lists_mux"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "timeout"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct mutex ecryptfs_msg_ctx_lists_mux;\n\nint ecryptfs_wait_for_response(struct ecryptfs_msg_ctx *msg_ctx,\n\t\t\t       struct ecryptfs_message **msg)\n{\n\tsigned long timeout = ecryptfs_message_wait_timeout * HZ;\n\tint rc = 0;\n\nsleep:\n\ttimeout = schedule_timeout_interruptible(timeout);\n\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\tmutex_lock(&msg_ctx->mux);\n\tif (msg_ctx->state != ECRYPTFS_MSG_CTX_STATE_DONE) {\n\t\tif (timeout) {\n\t\t\tmutex_unlock(&msg_ctx->mux);\n\t\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t\t\tgoto sleep;\n\t\t}\n\t\trc = -ENOMSG;\n\t} else {\n\t\t*msg = msg_ctx->msg;\n\t\tmsg_ctx->msg = NULL;\n\t}\n\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\n\tmutex_unlock(&msg_ctx->mux);\n\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_send_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
    "lines": "318-328",
    "snippet": "int ecryptfs_send_message(char *data, int data_len,\n\t\t\t  struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tint rc;\n\n\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\trc = ecryptfs_send_message_locked(data, data_len, ECRYPTFS_MSG_REQUEST,\n\t\t\t\t\t  msg_ctx);\n\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct mutex ecryptfs_daemon_hash_mux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_daemon_hash_mux"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_send_message_locked",
          "args": [
            "data",
            "data_len",
            "ECRYPTFS_MSG_REQUEST",
            "msg_ctx"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_send_message_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "276-306",
          "snippet": "static int\necryptfs_send_message_locked(char *data, int data_len, u8 msg_type,\n\t\t\t     struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tstruct ecryptfs_daemon *daemon;\n\tint rc;\n\n\trc = ecryptfs_find_daemon_by_euid(&daemon);\n\tif (rc) {\n\t\trc = -ENOTCONN;\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_acquire_free_msg_ctx(msg_ctx);\n\tif (rc) {\n\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t\tprintk(KERN_WARNING \"%s: Could not claim a free \"\n\t\t       \"context element\\n\", __func__);\n\t\tgoto out;\n\t}\n\tecryptfs_msg_ctx_free_to_alloc(*msg_ctx);\n\tmutex_unlock(&(*msg_ctx)->mux);\n\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_send_miscdev(data, data_len, *msg_ctx, msg_type, 0,\n\t\t\t\t   daemon);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error attempting to send message to \"\n\t\t       \"userspace daemon; rc = [%d]\\n\", __func__, rc);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct mutex ecryptfs_msg_ctx_lists_mux;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct mutex ecryptfs_msg_ctx_lists_mux;\n\nstatic int\necryptfs_send_message_locked(char *data, int data_len, u8 msg_type,\n\t\t\t     struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tstruct ecryptfs_daemon *daemon;\n\tint rc;\n\n\trc = ecryptfs_find_daemon_by_euid(&daemon);\n\tif (rc) {\n\t\trc = -ENOTCONN;\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_acquire_free_msg_ctx(msg_ctx);\n\tif (rc) {\n\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t\tprintk(KERN_WARNING \"%s: Could not claim a free \"\n\t\t       \"context element\\n\", __func__);\n\t\tgoto out;\n\t}\n\tecryptfs_msg_ctx_free_to_alloc(*msg_ctx);\n\tmutex_unlock(&(*msg_ctx)->mux);\n\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_send_miscdev(data, data_len, *msg_ctx, msg_type, 0,\n\t\t\t\t   daemon);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error attempting to send message to \"\n\t\t       \"userspace daemon; rc = [%d]\\n\", __func__, rc);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ecryptfs_daemon_hash_mux"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct mutex ecryptfs_daemon_hash_mux;\n\nint ecryptfs_send_message(char *data, int data_len,\n\t\t\t  struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tint rc;\n\n\tmutex_lock(&ecryptfs_daemon_hash_mux);\n\trc = ecryptfs_send_message_locked(data, data_len, ECRYPTFS_MSG_REQUEST,\n\t\t\t\t\t  msg_ctx);\n\tmutex_unlock(&ecryptfs_daemon_hash_mux);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_send_message_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
    "lines": "276-306",
    "snippet": "static int\necryptfs_send_message_locked(char *data, int data_len, u8 msg_type,\n\t\t\t     struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tstruct ecryptfs_daemon *daemon;\n\tint rc;\n\n\trc = ecryptfs_find_daemon_by_euid(&daemon);\n\tif (rc) {\n\t\trc = -ENOTCONN;\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_acquire_free_msg_ctx(msg_ctx);\n\tif (rc) {\n\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t\tprintk(KERN_WARNING \"%s: Could not claim a free \"\n\t\t       \"context element\\n\", __func__);\n\t\tgoto out;\n\t}\n\tecryptfs_msg_ctx_free_to_alloc(*msg_ctx);\n\tmutex_unlock(&(*msg_ctx)->mux);\n\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_send_miscdev(data, data_len, *msg_ctx, msg_type, 0,\n\t\t\t\t   daemon);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error attempting to send message to \"\n\t\t       \"userspace daemon; rc = [%d]\\n\", __func__, rc);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct mutex ecryptfs_msg_ctx_lists_mux;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error attempting to send message to \"\n\t\t       \"userspace daemon; rc = [%d]\\n\"",
            "__func__",
            "rc"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_send_miscdev",
          "args": [
            "data",
            "data_len",
            "*msg_ctx",
            "msg_type",
            "0",
            "daemon"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_send_miscdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/miscdev.c",
          "lines": "159-189",
          "snippet": "int ecryptfs_send_miscdev(char *data, size_t data_size,\n\t\t\t  struct ecryptfs_msg_ctx *msg_ctx, u8 msg_type,\n\t\t\t  u16 msg_flags, struct ecryptfs_daemon *daemon)\n{\n\tstruct ecryptfs_message *msg;\n\n\tmsg = kmalloc((sizeof(*msg) + data_size), GFP_KERNEL);\n\tif (!msg) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t       \"to kmalloc(%zd, GFP_KERNEL)\\n\", __func__,\n\t\t       (sizeof(*msg) + data_size));\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&msg_ctx->mux);\n\tmsg_ctx->msg = msg;\n\tmsg_ctx->msg->index = msg_ctx->index;\n\tmsg_ctx->msg->data_len = data_size;\n\tmsg_ctx->type = msg_type;\n\tmemcpy(msg_ctx->msg->data, data, data_size);\n\tmsg_ctx->msg_size = (sizeof(*msg_ctx->msg) + data_size);\n\tlist_add_tail(&msg_ctx->daemon_out_list, &daemon->msg_ctx_out_queue);\n\tmutex_unlock(&msg_ctx->mux);\n\n\tmutex_lock(&daemon->mux);\n\tdaemon->num_queued_msg_ctx++;\n\twake_up_interruptible(&daemon->wait);\n\tmutex_unlock(&daemon->mux);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/random.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/miscdevice.h>\n#include <linux/random.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n\nint ecryptfs_send_miscdev(char *data, size_t data_size,\n\t\t\t  struct ecryptfs_msg_ctx *msg_ctx, u8 msg_type,\n\t\t\t  u16 msg_flags, struct ecryptfs_daemon *daemon)\n{\n\tstruct ecryptfs_message *msg;\n\n\tmsg = kmalloc((sizeof(*msg) + data_size), GFP_KERNEL);\n\tif (!msg) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting \"\n\t\t       \"to kmalloc(%zd, GFP_KERNEL)\\n\", __func__,\n\t\t       (sizeof(*msg) + data_size));\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&msg_ctx->mux);\n\tmsg_ctx->msg = msg;\n\tmsg_ctx->msg->index = msg_ctx->index;\n\tmsg_ctx->msg->data_len = data_size;\n\tmsg_ctx->type = msg_type;\n\tmemcpy(msg_ctx->msg->data, data, data_size);\n\tmsg_ctx->msg_size = (sizeof(*msg_ctx->msg) + data_size);\n\tlist_add_tail(&msg_ctx->daemon_out_list, &daemon->msg_ctx_out_queue);\n\tmutex_unlock(&msg_ctx->mux);\n\n\tmutex_lock(&daemon->mux);\n\tdaemon->num_queued_msg_ctx++;\n\twake_up_interruptible(&daemon->wait);\n\tmutex_unlock(&daemon->mux);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_msg_ctx_lists_mux"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&(*msg_ctx)->mux"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_msg_ctx_free_to_alloc",
          "args": [
            "*msg_ctx"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_msg_ctx_free_to_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "84-89",
          "snippet": "static void ecryptfs_msg_ctx_free_to_alloc(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&msg_ctx->node, &ecryptfs_msg_ctx_alloc_list);\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_PENDING;\n\tmsg_ctx->counter = ++ecryptfs_msg_counter;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ecryptfs_msg_ctx_alloc_list);",
            "static u32 ecryptfs_msg_counter;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(ecryptfs_msg_ctx_alloc_list);\nstatic u32 ecryptfs_msg_counter;\n\nstatic void ecryptfs_msg_ctx_free_to_alloc(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&msg_ctx->node, &ecryptfs_msg_ctx_alloc_list);\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_PENDING;\n\tmsg_ctx->counter = ++ecryptfs_msg_counter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ecryptfs_msg_ctx_lists_mux"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_acquire_free_msg_ctx",
          "args": [
            "msg_ctx"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_acquire_free_msg_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "51-72",
          "snippet": "static int ecryptfs_acquire_free_msg_ctx(struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tstruct list_head *p;\n\tint rc;\n\n\tif (list_empty(&ecryptfs_msg_ctx_free_list)) {\n\t\tprintk(KERN_WARNING \"%s: The eCryptfs free \"\n\t\t       \"context list is empty.  It may be helpful to \"\n\t\t       \"specify the ecryptfs_message_buf_len \"\n\t\t       \"parameter to be greater than the current \"\n\t\t       \"value of [%d]\\n\", __func__, ecryptfs_message_buf_len);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tlist_for_each(p, &ecryptfs_msg_ctx_free_list) {\n\t\t*msg_ctx = list_entry(p, struct ecryptfs_msg_ctx, node);\n\t\tif (mutex_trylock(&(*msg_ctx)->mux)) {\n\t\t\t(*msg_ctx)->task = current;\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ecryptfs_msg_ctx_free_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(ecryptfs_msg_ctx_free_list);\n\nstatic int ecryptfs_acquire_free_msg_ctx(struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tstruct list_head *p;\n\tint rc;\n\n\tif (list_empty(&ecryptfs_msg_ctx_free_list)) {\n\t\tprintk(KERN_WARNING \"%s: The eCryptfs free \"\n\t\t       \"context list is empty.  It may be helpful to \"\n\t\t       \"specify the ecryptfs_message_buf_len \"\n\t\t       \"parameter to be greater than the current \"\n\t\t       \"value of [%d]\\n\", __func__, ecryptfs_message_buf_len);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tlist_for_each(p, &ecryptfs_msg_ctx_free_list) {\n\t\t*msg_ctx = list_entry(p, struct ecryptfs_msg_ctx, node);\n\t\tif (mutex_trylock(&(*msg_ctx)->mux)) {\n\t\t\t(*msg_ctx)->task = current;\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ecryptfs_msg_ctx_lists_mux"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_find_daemon_by_euid",
          "args": [
            "&daemon"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_find_daemon_by_euid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "115-130",
          "snippet": "int ecryptfs_find_daemon_by_euid(struct ecryptfs_daemon **daemon)\n{\n\tint rc;\n\n\thlist_for_each_entry(*daemon,\n\t\t\t    &ecryptfs_daemon_hash[ecryptfs_current_euid_hash()],\n\t\t\t    euid_chain) {\n\t\tif (uid_eq((*daemon)->file->f_cred->euid, current_euid())) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -EINVAL;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *ecryptfs_daemon_hash;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_head *ecryptfs_daemon_hash;\n\nint ecryptfs_find_daemon_by_euid(struct ecryptfs_daemon **daemon)\n{\n\tint rc;\n\n\thlist_for_each_entry(*daemon,\n\t\t\t    &ecryptfs_daemon_hash[ecryptfs_current_euid_hash()],\n\t\t\t    euid_chain) {\n\t\tif (uid_eq((*daemon)->file->f_cred->euid, current_euid())) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -EINVAL;\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct mutex ecryptfs_msg_ctx_lists_mux;\n\nstatic int\necryptfs_send_message_locked(char *data, int data_len, u8 msg_type,\n\t\t\t     struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tstruct ecryptfs_daemon *daemon;\n\tint rc;\n\n\trc = ecryptfs_find_daemon_by_euid(&daemon);\n\tif (rc) {\n\t\trc = -ENOTCONN;\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_acquire_free_msg_ctx(msg_ctx);\n\tif (rc) {\n\t\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\t\tprintk(KERN_WARNING \"%s: Could not claim a free \"\n\t\t       \"context element\\n\", __func__);\n\t\tgoto out;\n\t}\n\tecryptfs_msg_ctx_free_to_alloc(*msg_ctx);\n\tmutex_unlock(&(*msg_ctx)->mux);\n\tmutex_unlock(&ecryptfs_msg_ctx_lists_mux);\n\trc = ecryptfs_send_miscdev(data, data_len, *msg_ctx, msg_type, 0,\n\t\t\t\t   daemon);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error attempting to send message to \"\n\t\t       \"userspace daemon; rc = [%d]\\n\", __func__, rc);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_process_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
    "lines": "220-264",
    "snippet": "int ecryptfs_process_response(struct ecryptfs_daemon *daemon,\n\t\t\t      struct ecryptfs_message *msg, u32 seq)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tsize_t msg_size;\n\tint rc;\n\n\tif (msg->index >= ecryptfs_message_buf_len) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"%s: Attempt to reference \"\n\t\t       \"context buffer at index [%d]; maximum \"\n\t\t       \"allowable is [%d]\\n\", __func__, msg->index,\n\t\t       (ecryptfs_message_buf_len - 1));\n\t\tgoto out;\n\t}\n\tmsg_ctx = &ecryptfs_msg_ctx_arr[msg->index];\n\tmutex_lock(&msg_ctx->mux);\n\tif (msg_ctx->state != ECRYPTFS_MSG_CTX_STATE_PENDING) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"%s: Desired context element is not \"\n\t\t       \"pending a response\\n\", __func__);\n\t\tgoto unlock;\n\t} else if (msg_ctx->counter != seq) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"%s: Invalid message sequence; \"\n\t\t       \"expected [%d]; received [%d]\\n\", __func__,\n\t\t       msg_ctx->counter, seq);\n\t\tgoto unlock;\n\t}\n\tmsg_size = (sizeof(*msg) + msg->data_len);\n\tmsg_ctx->msg = kmemdup(msg, msg_size, GFP_KERNEL);\n\tif (!msg_ctx->msg) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Failed to allocate [%zd] bytes of \"\n\t\t       \"GFP_KERNEL memory\\n\", __func__, msg_size);\n\t\tgoto unlock;\n\t}\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_DONE;\n\twake_up_process(msg_ctx->task);\n\trc = 0;\nunlock:\n\tmutex_unlock(&msg_ctx->mux);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ecryptfs_msg_ctx *ecryptfs_msg_ctx_arr;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&msg_ctx->mux"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "msg_ctx->task"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Failed to allocate [%zd] bytes of \"\n\t\t       \"GFP_KERNEL memory\\n\"",
            "__func__",
            "msg_size"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "msg",
            "msg_size",
            "GFP_KERNEL"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&msg_ctx->mux"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct ecryptfs_msg_ctx *ecryptfs_msg_ctx_arr;\n\nint ecryptfs_process_response(struct ecryptfs_daemon *daemon,\n\t\t\t      struct ecryptfs_message *msg, u32 seq)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tsize_t msg_size;\n\tint rc;\n\n\tif (msg->index >= ecryptfs_message_buf_len) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_ERR \"%s: Attempt to reference \"\n\t\t       \"context buffer at index [%d]; maximum \"\n\t\t       \"allowable is [%d]\\n\", __func__, msg->index,\n\t\t       (ecryptfs_message_buf_len - 1));\n\t\tgoto out;\n\t}\n\tmsg_ctx = &ecryptfs_msg_ctx_arr[msg->index];\n\tmutex_lock(&msg_ctx->mux);\n\tif (msg_ctx->state != ECRYPTFS_MSG_CTX_STATE_PENDING) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"%s: Desired context element is not \"\n\t\t       \"pending a response\\n\", __func__);\n\t\tgoto unlock;\n\t} else if (msg_ctx->counter != seq) {\n\t\trc = -EINVAL;\n\t\tprintk(KERN_WARNING \"%s: Invalid message sequence; \"\n\t\t       \"expected [%d]; received [%d]\\n\", __func__,\n\t\t       msg_ctx->counter, seq);\n\t\tgoto unlock;\n\t}\n\tmsg_size = (sizeof(*msg) + msg->data_len);\n\tmsg_ctx->msg = kmemdup(msg, msg_size, GFP_KERNEL);\n\tif (!msg_ctx->msg) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Failed to allocate [%zd] bytes of \"\n\t\t       \"GFP_KERNEL memory\\n\", __func__, msg_size);\n\t\tgoto unlock;\n\t}\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_DONE;\n\twake_up_process(msg_ctx->task);\n\trc = 0;\nunlock:\n\tmutex_unlock(&msg_ctx->mux);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_exorcise_daemon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
    "lines": "171-196",
    "snippet": "int ecryptfs_exorcise_daemon(struct ecryptfs_daemon *daemon)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx, *msg_ctx_tmp;\n\tint rc = 0;\n\n\tmutex_lock(&daemon->mux);\n\tif ((daemon->flags & ECRYPTFS_DAEMON_IN_READ)\n\t    || (daemon->flags & ECRYPTFS_DAEMON_IN_POLL)) {\n\t\trc = -EBUSY;\n\t\tmutex_unlock(&daemon->mux);\n\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(msg_ctx, msg_ctx_tmp,\n\t\t\t\t &daemon->msg_ctx_out_queue, daemon_out_list) {\n\t\tlist_del(&msg_ctx->daemon_out_list);\n\t\tdaemon->num_queued_msg_ctx--;\n\t\tprintk(KERN_WARNING \"%s: Warning: dropping message that is in \"\n\t\t       \"the out queue of a dying daemon\\n\", __func__);\n\t\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\n\t}\n\thlist_del(&daemon->euid_chain);\n\tmutex_unlock(&daemon->mux);\n\tkzfree(daemon);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "daemon"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&daemon->mux"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&daemon->euid_chain"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_msg_ctx_alloc_to_free",
          "args": [
            "msg_ctx"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_msg_ctx_alloc_to_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
          "lines": "97-103",
          "snippet": "void ecryptfs_msg_ctx_alloc_to_free(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&(msg_ctx->node), &ecryptfs_msg_ctx_free_list);\n\tkfree(msg_ctx->msg);\n\tmsg_ctx->msg = NULL;\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_FREE;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ecryptfs_msg_ctx_free_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(ecryptfs_msg_ctx_free_list);\n\nvoid ecryptfs_msg_ctx_alloc_to_free(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&(msg_ctx->node), &ecryptfs_msg_ctx_free_list);\n\tkfree(msg_ctx->msg);\n\tmsg_ctx->msg = NULL;\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_FREE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: Warning: dropping message that is in \"\n\t\t       \"the out queue of a dying daemon\\n\"",
            "__func__"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&msg_ctx->daemon_out_list"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "msg_ctx",
            "msg_ctx_tmp",
            "&daemon->msg_ctx_out_queue",
            "daemon_out_list"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&daemon->mux"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&daemon->mux"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nint ecryptfs_exorcise_daemon(struct ecryptfs_daemon *daemon)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx, *msg_ctx_tmp;\n\tint rc = 0;\n\n\tmutex_lock(&daemon->mux);\n\tif ((daemon->flags & ECRYPTFS_DAEMON_IN_READ)\n\t    || (daemon->flags & ECRYPTFS_DAEMON_IN_POLL)) {\n\t\trc = -EBUSY;\n\t\tmutex_unlock(&daemon->mux);\n\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(msg_ctx, msg_ctx_tmp,\n\t\t\t\t &daemon->msg_ctx_out_queue, daemon_out_list) {\n\t\tlist_del(&msg_ctx->daemon_out_list);\n\t\tdaemon->num_queued_msg_ctx--;\n\t\tprintk(KERN_WARNING \"%s: Warning: dropping message that is in \"\n\t\t       \"the out queue of a dying daemon\\n\", __func__);\n\t\tecryptfs_msg_ctx_alloc_to_free(msg_ctx);\n\t}\n\thlist_del(&daemon->euid_chain);\n\tmutex_unlock(&daemon->mux);\n\tkzfree(daemon);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_spawn_daemon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
    "lines": "142-163",
    "snippet": "int\necryptfs_spawn_daemon(struct ecryptfs_daemon **daemon, struct file *file)\n{\n\tint rc = 0;\n\n\t(*daemon) = kzalloc(sizeof(**daemon), GFP_KERNEL);\n\tif (!(*daemon)) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Failed to allocate [%zd] bytes of \"\n\t\t       \"GFP_KERNEL memory\\n\", __func__, sizeof(**daemon));\n\t\tgoto out;\n\t}\n\t(*daemon)->file = file;\n\tmutex_init(&(*daemon)->mux);\n\tINIT_LIST_HEAD(&(*daemon)->msg_ctx_out_queue);\n\tinit_waitqueue_head(&(*daemon)->wait);\n\t(*daemon)->num_queued_msg_ctx = 0;\n\thlist_add_head(&(*daemon)->euid_chain,\n\t\t       &ecryptfs_daemon_hash[ecryptfs_current_euid_hash()]);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *ecryptfs_daemon_hash;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&(*daemon)->euid_chain",
            "&ecryptfs_daemon_hash[ecryptfs_current_euid_hash()]"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_current_euid_hash",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&(*daemon)->wait"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&(*daemon)->msg_ctx_out_queue"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&(*daemon)->mux"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Failed to allocate [%zd] bytes of \"\n\t\t       \"GFP_KERNEL memory\\n\"",
            "__func__",
            "sizeof(**daemon)"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(**daemon)",
            "GFP_KERNEL"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_head *ecryptfs_daemon_hash;\n\nint\necryptfs_spawn_daemon(struct ecryptfs_daemon **daemon, struct file *file)\n{\n\tint rc = 0;\n\n\t(*daemon) = kzalloc(sizeof(**daemon), GFP_KERNEL);\n\tif (!(*daemon)) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"%s: Failed to allocate [%zd] bytes of \"\n\t\t       \"GFP_KERNEL memory\\n\", __func__, sizeof(**daemon));\n\t\tgoto out;\n\t}\n\t(*daemon)->file = file;\n\tmutex_init(&(*daemon)->mux);\n\tINIT_LIST_HEAD(&(*daemon)->msg_ctx_out_queue);\n\tinit_waitqueue_head(&(*daemon)->wait);\n\t(*daemon)->num_queued_msg_ctx = 0;\n\thlist_add_head(&(*daemon)->euid_chain,\n\t\t       &ecryptfs_daemon_hash[ecryptfs_current_euid_hash()]);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_find_daemon_by_euid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
    "lines": "115-130",
    "snippet": "int ecryptfs_find_daemon_by_euid(struct ecryptfs_daemon **daemon)\n{\n\tint rc;\n\n\thlist_for_each_entry(*daemon,\n\t\t\t    &ecryptfs_daemon_hash[ecryptfs_current_euid_hash()],\n\t\t\t    euid_chain) {\n\t\tif (uid_eq((*daemon)->file->f_cred->euid, current_euid())) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -EINVAL;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hlist_head *ecryptfs_daemon_hash;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "(*daemon)->file->f_cred->euid",
            "current_euid()"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "*daemon",
            "&ecryptfs_daemon_hash[ecryptfs_current_euid_hash()]",
            "euid_chain"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_current_euid_hash",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_head *ecryptfs_daemon_hash;\n\nint ecryptfs_find_daemon_by_euid(struct ecryptfs_daemon **daemon)\n{\n\tint rc;\n\n\thlist_for_each_entry(*daemon,\n\t\t\t    &ecryptfs_daemon_hash[ecryptfs_current_euid_hash()],\n\t\t\t    euid_chain) {\n\t\tif (uid_eq((*daemon)->file->f_cred->euid, current_euid())) {\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\trc = -EINVAL;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_msg_ctx_alloc_to_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
    "lines": "97-103",
    "snippet": "void ecryptfs_msg_ctx_alloc_to_free(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&(msg_ctx->node), &ecryptfs_msg_ctx_free_list);\n\tkfree(msg_ctx->msg);\n\tmsg_ctx->msg = NULL;\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_FREE;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ecryptfs_msg_ctx_free_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "msg_ctx->msg"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&(msg_ctx->node)",
            "&ecryptfs_msg_ctx_free_list"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(ecryptfs_msg_ctx_free_list);\n\nvoid ecryptfs_msg_ctx_alloc_to_free(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&(msg_ctx->node), &ecryptfs_msg_ctx_free_list);\n\tkfree(msg_ctx->msg);\n\tmsg_ctx->msg = NULL;\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_FREE;\n}"
  },
  {
    "function_name": "ecryptfs_msg_ctx_free_to_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
    "lines": "84-89",
    "snippet": "static void ecryptfs_msg_ctx_free_to_alloc(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&msg_ctx->node, &ecryptfs_msg_ctx_alloc_list);\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_PENDING;\n\tmsg_ctx->counter = ++ecryptfs_msg_counter;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ecryptfs_msg_ctx_alloc_list);",
      "static u32 ecryptfs_msg_counter;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&msg_ctx->node",
            "&ecryptfs_msg_ctx_alloc_list"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(ecryptfs_msg_ctx_alloc_list);\nstatic u32 ecryptfs_msg_counter;\n\nstatic void ecryptfs_msg_ctx_free_to_alloc(struct ecryptfs_msg_ctx *msg_ctx)\n{\n\tlist_move(&msg_ctx->node, &ecryptfs_msg_ctx_alloc_list);\n\tmsg_ctx->state = ECRYPTFS_MSG_CTX_STATE_PENDING;\n\tmsg_ctx->counter = ++ecryptfs_msg_counter;\n}"
  },
  {
    "function_name": "ecryptfs_acquire_free_msg_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/messaging.c",
    "lines": "51-72",
    "snippet": "static int ecryptfs_acquire_free_msg_ctx(struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tstruct list_head *p;\n\tint rc;\n\n\tif (list_empty(&ecryptfs_msg_ctx_free_list)) {\n\t\tprintk(KERN_WARNING \"%s: The eCryptfs free \"\n\t\t       \"context list is empty.  It may be helpful to \"\n\t\t       \"specify the ecryptfs_message_buf_len \"\n\t\t       \"parameter to be greater than the current \"\n\t\t       \"value of [%d]\\n\", __func__, ecryptfs_message_buf_len);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tlist_for_each(p, &ecryptfs_msg_ctx_free_list) {\n\t\t*msg_ctx = list_entry(p, struct ecryptfs_msg_ctx, node);\n\t\tif (mutex_trylock(&(*msg_ctx)->mux)) {\n\t\t\t(*msg_ctx)->task = current;\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/nsproxy.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ecryptfs_msg_ctx_free_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&(*msg_ctx)->mux"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "p",
            "structecryptfs_msg_ctx",
            "node"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "p",
            "&ecryptfs_msg_ctx_free_list"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: The eCryptfs free \"\n\t\t       \"context list is empty.  It may be helpful to \"\n\t\t       \"specify the ecryptfs_message_buf_len \"\n\t\t       \"parameter to be greater than the current \"\n\t\t       \"value of [%d]\\n\"",
            "__func__",
            "ecryptfs_message_buf_len"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ecryptfs_msg_ctx_free_list"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(ecryptfs_msg_ctx_free_list);\n\nstatic int ecryptfs_acquire_free_msg_ctx(struct ecryptfs_msg_ctx **msg_ctx)\n{\n\tstruct list_head *p;\n\tint rc;\n\n\tif (list_empty(&ecryptfs_msg_ctx_free_list)) {\n\t\tprintk(KERN_WARNING \"%s: The eCryptfs free \"\n\t\t       \"context list is empty.  It may be helpful to \"\n\t\t       \"specify the ecryptfs_message_buf_len \"\n\t\t       \"parameter to be greater than the current \"\n\t\t       \"value of [%d]\\n\", __func__, ecryptfs_message_buf_len);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tlist_for_each(p, &ecryptfs_msg_ctx_free_list) {\n\t\t*msg_ctx = list_entry(p, struct ecryptfs_msg_ctx, node);\n\t\tif (mutex_trylock(&(*msg_ctx)->mux)) {\n\t\t\t(*msg_ctx)->task = current;\n\t\t\trc = 0;\n\t\t\tgoto out;\n\t\t}\n\t}"
  }
]