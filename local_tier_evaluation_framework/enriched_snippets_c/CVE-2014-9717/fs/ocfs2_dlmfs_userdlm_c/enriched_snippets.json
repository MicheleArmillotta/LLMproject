[
  {
    "function_name": "user_dlm_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "685-688",
    "snippet": "void user_dlm_unregister(struct ocfs2_cluster_connection *conn)\n{\n\tocfs2_cluster_disconnect(conn, 0);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cluster_disconnect",
          "args": [
            "conn",
            "0"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_disconnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "402-419",
          "snippet": "int ocfs2_cluster_disconnect(struct ocfs2_cluster_connection *conn,\n\t\t\t     int hangup_pending)\n{\n\tint ret;\n\n\tBUG_ON(conn == NULL);\n\n\tret = active_stack->sp_ops->disconnect(conn);\n\n\t/* XXX Should we free it anyway? */\n\tif (!ret) {\n\t\tkfree(conn);\n\t\tif (!hangup_pending)\n\t\t\tocfs2_stack_driver_put();\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_cluster_disconnect(struct ocfs2_cluster_connection *conn,\n\t\t\t     int hangup_pending)\n{\n\tint ret;\n\n\tBUG_ON(conn == NULL);\n\n\tret = active_stack->sp_ops->disconnect(conn);\n\n\t/* XXX Should we free it anyway? */\n\tif (!ret) {\n\t\tkfree(conn);\n\t\tif (!hangup_pending)\n\t\t\tocfs2_stack_driver_put();\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nvoid user_dlm_unregister(struct ocfs2_cluster_connection *conn)\n{\n\tocfs2_cluster_disconnect(conn, 0);\n}"
  },
  {
    "function_name": "user_dlm_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "670-683",
    "snippet": "struct ocfs2_cluster_connection *user_dlm_register(struct qstr *name)\n{\n\tint rc;\n\tstruct ocfs2_cluster_connection *conn;\n\n\trc = ocfs2_cluster_connect_agnostic(name->name, name->len,\n\t\t\t\t\t    &user_dlm_lproto,\n\t\t\t\t\t    user_dlm_recovery_handler_noop,\n\t\t\t\t\t    NULL, &conn);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\treturn rc ? ERR_PTR(rc) : conn;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_locking_protocol user_dlm_lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= user_ast,\n\t.lp_blocking_ast\t= user_bast,\n\t.lp_unlock_ast\t\t= user_unlock_ast,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cluster_connect_agnostic",
          "args": [
            "name->name",
            "name->len",
            "&user_dlm_lproto",
            "user_dlm_recovery_handler_noop",
            "NULL",
            "&conn"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cluster_connect_agnostic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "383-398",
          "snippet": "int ocfs2_cluster_connect_agnostic(const char *group,\n\t\t\t\t   int grouplen,\n\t\t\t\t   struct ocfs2_locking_protocol *lproto,\n\t\t\t\t   void (*recovery_handler)(int node_num,\n\t\t\t\t\t\t\t    void *recovery_data),\n\t\t\t\t   void *recovery_data,\n\t\t\t\t   struct ocfs2_cluster_connection **conn)\n{\n\tchar *stack_name = NULL;\n\n\tif (cluster_stack_name[0])\n\t\tstack_name = cluster_stack_name;\n\treturn ocfs2_cluster_connect(stack_name, NULL, 0, group, grouplen,\n\t\t\t\t     lproto, recovery_handler, recovery_data,\n\t\t\t\t     conn);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char cluster_stack_name[OCFS2_STACK_LABEL_LEN + 1];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char cluster_stack_name[OCFS2_STACK_LABEL_LEN + 1];\n\nint ocfs2_cluster_connect_agnostic(const char *group,\n\t\t\t\t   int grouplen,\n\t\t\t\t   struct ocfs2_locking_protocol *lproto,\n\t\t\t\t   void (*recovery_handler)(int node_num,\n\t\t\t\t\t\t\t    void *recovery_data),\n\t\t\t\t   void *recovery_data,\n\t\t\t\t   struct ocfs2_cluster_connection **conn)\n{\n\tchar *stack_name = NULL;\n\n\tif (cluster_stack_name[0])\n\t\tstack_name = cluster_stack_name;\n\treturn ocfs2_cluster_connect(stack_name, NULL, 0, group, grouplen,\n\t\t\t\t     lproto, recovery_handler, recovery_data,\n\t\t\t\t     conn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic struct ocfs2_locking_protocol user_dlm_lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= user_ast,\n\t.lp_blocking_ast\t= user_bast,\n\t.lp_unlock_ast\t\t= user_unlock_ast,\n};\n\nstruct ocfs2_cluster_connection *user_dlm_register(struct qstr *name)\n{\n\tint rc;\n\tstruct ocfs2_cluster_connection *conn;\n\n\trc = ocfs2_cluster_connect_agnostic(name->name, name->len,\n\t\t\t\t\t    &user_dlm_lproto,\n\t\t\t\t\t    user_dlm_recovery_handler_noop,\n\t\t\t\t\t    NULL, &conn);\n\tif (rc)\n\t\tmlog_errno(rc);\n\n\treturn rc ? ERR_PTR(rc) : conn;\n}"
  },
  {
    "function_name": "user_dlm_set_locking_protocol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "665-668",
    "snippet": "void user_dlm_set_locking_protocol(void)\n{\n\tocfs2_stack_glue_set_max_proto_version(&user_dlm_lproto.lp_max_version);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ocfs2_locking_protocol user_dlm_lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= user_ast,\n\t.lp_blocking_ast\t= user_bast,\n\t.lp_unlock_ast\t\t= user_unlock_ast,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_stack_glue_set_max_proto_version",
          "args": [
            "&user_dlm_lproto.lp_max_version"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_stack_glue_set_max_proto_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "216-231",
          "snippet": "void ocfs2_stack_glue_set_max_proto_version(struct ocfs2_protocol_version *max_proto)\n{\n\tstruct ocfs2_stack_plugin *p;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (memcmp(max_proto, &locking_max_version,\n\t\t   sizeof(struct ocfs2_protocol_version))) {\n\t\tBUG_ON(locking_max_version.pv_major != 0);\n\n\t\tlocking_max_version = *max_proto;\n\t\tlist_for_each_entry(p, &ocfs2_stack_list, sp_list) {\n\t\t\tp->sp_max_proto = locking_max_version;\n\t\t}\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_protocol_version locking_max_version;",
            "static DEFINE_SPINLOCK(ocfs2_stack_lock);",
            "static LIST_HEAD(ocfs2_stack_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_protocol_version locking_max_version;\nstatic DEFINE_SPINLOCK(ocfs2_stack_lock);\nstatic LIST_HEAD(ocfs2_stack_list);\n\nvoid ocfs2_stack_glue_set_max_proto_version(struct ocfs2_protocol_version *max_proto)\n{\n\tstruct ocfs2_stack_plugin *p;\n\n\tspin_lock(&ocfs2_stack_lock);\n\tif (memcmp(max_proto, &locking_max_version,\n\t\t   sizeof(struct ocfs2_protocol_version))) {\n\t\tBUG_ON(locking_max_version.pv_major != 0);\n\n\t\tlocking_max_version = *max_proto;\n\t\tlist_for_each_entry(p, &ocfs2_stack_list, sp_list) {\n\t\t\tp->sp_max_proto = locking_max_version;\n\t\t}\n\t}\n\tspin_unlock(&ocfs2_stack_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic struct ocfs2_locking_protocol user_dlm_lproto = {\n\t.lp_max_version = {\n\t\t.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,\n\t\t.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,\n\t},\n\t.lp_lock_ast\t\t= user_ast,\n\t.lp_blocking_ast\t= user_bast,\n\t.lp_unlock_ast\t\t= user_unlock_ast,\n};\n\nvoid user_dlm_set_locking_protocol(void)\n{\n\tocfs2_stack_glue_set_max_proto_version(&user_dlm_lproto.lp_max_version);\n}"
  },
  {
    "function_name": "user_dlm_recovery_handler_noop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "658-663",
    "snippet": "static void user_dlm_recovery_handler_noop(int node_num,\n\t\t\t\t\t   void *recovery_data)\n{\n\t/* We ignore recovery events */\n\treturn;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic void user_dlm_recovery_handler_noop(int node_num,\n\t\t\t\t\t   void *recovery_data)\n{\n\t/* We ignore recovery events */\n\treturn;\n}"
  },
  {
    "function_name": "user_dlm_destroy_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "606-656",
    "snippet": "int user_dlm_destroy_lock(struct user_lock_res *lockres)\n{\n\tint status = -EBUSY;\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tmlog(ML_BASTS, \"lockres %.*s\\n\", lockres->l_namelen, lockres->l_name);\n\n\tspin_lock(&lockres->l_lock);\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\treturn 0;\n\t}\n\n\tlockres->l_flags |= USER_LOCK_IN_TEARDOWN;\n\n\twhile (lockres->l_flags & USER_LOCK_BUSY) {\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_busy_lock(lockres);\n\n\t\tspin_lock(&lockres->l_lock);\n\t}\n\n\tif (lockres->l_ro_holders || lockres->l_ex_holders) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (!(lockres->l_flags & USER_LOCK_ATTACHED)) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_flags &= ~USER_LOCK_ATTACHED;\n\tlockres->l_flags |= USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n\n\tstatus = ocfs2_dlm_unlock(conn, &lockres->l_lksb, DLM_LKF_VALBLK);\n\tif (status) {\n\t\tuser_log_dlm_error(\"ocfs2_dlm_unlock\", status, lockres);\n\t\tgoto bail;\n\t}\n\n\tuser_wait_on_busy_lock(lockres);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_wait_on_busy_lock",
          "args": [
            "lockres"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "user_wait_on_busy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "62-67",
          "snippet": "static inline void user_wait_on_busy_lock(struct user_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !user_check_wait_flag(lockres, USER_LOCK_BUSY));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_wait_on_busy_lock(struct user_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !user_check_wait_flag(lockres, USER_LOCK_BUSY));\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_log_dlm_error",
          "args": [
            "\"ocfs2_dlm_unlock\"",
            "status",
            "lockres"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_unlock",
          "args": [
            "conn",
            "&lockres->l_lksb",
            "DLM_LKF_VALBLK"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "257-264",
          "snippet": "int ocfs2_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t     struct ocfs2_dlm_lksb *lksb,\n\t\t     u32 flags)\n{\n\tBUG_ON(lksb->lksb_conn == NULL);\n\n\treturn active_stack->sp_ops->dlm_unlock(conn, lksb, flags);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t     struct ocfs2_dlm_lksb *lksb,\n\t\t     u32 flags)\n{\n\tBUG_ON(lksb->lksb_conn == NULL);\n\n\treturn active_stack->sp_ops->dlm_unlock(conn, lksb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %.*s\\n\"",
            "lockres->l_namelen",
            "lockres->l_name"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_connection_from_user_lockres",
          "args": [
            "lockres"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_connection_from_user_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "77-86",
          "snippet": "static inline struct ocfs2_cluster_connection *\ncluster_connection_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn ip->ip_conn;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline struct ocfs2_cluster_connection *\ncluster_connection_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn ip->ip_conn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nint user_dlm_destroy_lock(struct user_lock_res *lockres)\n{\n\tint status = -EBUSY;\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tmlog(ML_BASTS, \"lockres %.*s\\n\", lockres->l_namelen, lockres->l_name);\n\n\tspin_lock(&lockres->l_lock);\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\treturn 0;\n\t}\n\n\tlockres->l_flags |= USER_LOCK_IN_TEARDOWN;\n\n\twhile (lockres->l_flags & USER_LOCK_BUSY) {\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_busy_lock(lockres);\n\n\t\tspin_lock(&lockres->l_lock);\n\t}\n\n\tif (lockres->l_ro_holders || lockres->l_ex_holders) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\n\tif (!(lockres->l_flags & USER_LOCK_ATTACHED)) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto bail;\n\t}\n\n\tlockres->l_flags &= ~USER_LOCK_ATTACHED;\n\tlockres->l_flags |= USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n\n\tstatus = ocfs2_dlm_unlock(conn, &lockres->l_lksb, DLM_LKF_VALBLK);\n\tif (status) {\n\t\tuser_log_dlm_error(\"ocfs2_dlm_unlock\", status, lockres);\n\t\tgoto bail;\n\t}\n\n\tuser_wait_on_busy_lock(lockres);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "user_dlm_lock_res_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "586-604",
    "snippet": "void user_dlm_lock_res_init(struct user_lock_res *lockres,\n\t\t\t    struct dentry *dentry)\n{\n\tmemset(lockres, 0, sizeof(*lockres));\n\n\tspin_lock_init(&lockres->l_lock);\n\tinit_waitqueue_head(&lockres->l_event);\n\tlockres->l_level = DLM_LOCK_IV;\n\tlockres->l_requested = DLM_LOCK_IV;\n\tlockres->l_blocking = DLM_LOCK_IV;\n\n\t/* should have been checked before getting here. */\n\tBUG_ON(dentry->d_name.len >= USER_DLM_LOCK_ID_MAX_LEN);\n\n\tmemcpy(lockres->l_name,\n\t       dentry->d_name.name,\n\t       dentry->d_name.len);\n\tlockres->l_namelen = dentry->d_name.len;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lockres->l_name",
            "dentry->d_name.name",
            "dentry->d_name.len"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dentry->d_name.len >= USER_DLM_LOCK_ID_MAX_LEN"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&lockres->l_event"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "lockres",
            "0",
            "sizeof(*lockres)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nvoid user_dlm_lock_res_init(struct user_lock_res *lockres,\n\t\t\t    struct dentry *dentry)\n{\n\tmemset(lockres, 0, sizeof(*lockres));\n\n\tspin_lock_init(&lockres->l_lock);\n\tinit_waitqueue_head(&lockres->l_event);\n\tlockres->l_level = DLM_LOCK_IV;\n\tlockres->l_requested = DLM_LOCK_IV;\n\tlockres->l_blocking = DLM_LOCK_IV;\n\n\t/* should have been checked before getting here. */\n\tBUG_ON(dentry->d_name.len >= USER_DLM_LOCK_ID_MAX_LEN);\n\n\tmemcpy(lockres->l_name,\n\t       dentry->d_name.name,\n\t       dentry->d_name.len);\n\tlockres->l_namelen = dentry->d_name.len;\n}"
  },
  {
    "function_name": "user_dlm_read_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "563-584",
    "snippet": "ssize_t user_dlm_read_lvb(struct inode *inode,\n\t\t\t  char *val,\n\t\t\t  unsigned int len)\n{\n\tstruct user_lock_res *lockres = &DLMFS_I(inode)->ip_lockres;\n\tchar *lvb;\n\tssize_t ret = len;\n\n\tBUG_ON(len > DLM_LVB_LEN);\n\n\tspin_lock(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_level < DLM_LOCK_PR);\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb)) {\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tmemcpy(val, lvb, len);\n\t} else\n\t\tret = 0;\n\n\tspin_unlock(&lockres->l_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "lvb",
            "len"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "279-282",
          "snippet": "void *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb_valid",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "273-276",
          "snippet": "int ocfs2_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lvb_valid(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_lvb_valid(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lvb_valid(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_level < DLM_LOCK_PR"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len > DLM_LVB_LEN"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLMFS_I",
          "args": [
            "inode"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "DLMFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.h",
          "lines": "99-105",
          "snippet": "static inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nssize_t user_dlm_read_lvb(struct inode *inode,\n\t\t\t  char *val,\n\t\t\t  unsigned int len)\n{\n\tstruct user_lock_res *lockres = &DLMFS_I(inode)->ip_lockres;\n\tchar *lvb;\n\tssize_t ret = len;\n\n\tBUG_ON(len > DLM_LVB_LEN);\n\n\tspin_lock(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_level < DLM_LOCK_PR);\n\tif (ocfs2_dlm_lvb_valid(&lockres->l_lksb)) {\n\t\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\t\tmemcpy(val, lvb, len);\n\t} else\n\t\tret = 0;\n\n\tspin_unlock(&lockres->l_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "user_dlm_write_lvb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "545-561",
    "snippet": "void user_dlm_write_lvb(struct inode *inode,\n\t\t\tconst char *val,\n\t\t\tunsigned int len)\n{\n\tstruct user_lock_res *lockres = &DLMFS_I(inode)->ip_lockres;\n\tchar *lvb;\n\n\tBUG_ON(len > DLM_LVB_LEN);\n\n\tspin_lock(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_level < DLM_LOCK_EX);\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tmemcpy(lvb, val, len);\n\n\tspin_unlock(&lockres->l_lock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lvb",
            "val",
            "len"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lvb",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lvb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "279-282",
          "snippet": "void *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nvoid *ocfs2_dlm_lvb(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_lvb(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockres->l_level < DLM_LOCK_EX"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len > DLM_LVB_LEN"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DLMFS_I",
          "args": [
            "inode"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "DLMFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.h",
          "lines": "99-105",
          "snippet": "static inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct dlmfs_inode_private *\nDLMFS_I(struct inode *inode)\n{\n        return container_of(inode,\n\t\t\t    struct dlmfs_inode_private,\n\t\t\t    ip_vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nvoid user_dlm_write_lvb(struct inode *inode,\n\t\t\tconst char *val,\n\t\t\tunsigned int len)\n{\n\tstruct user_lock_res *lockres = &DLMFS_I(inode)->ip_lockres;\n\tchar *lvb;\n\n\tBUG_ON(len > DLM_LVB_LEN);\n\n\tspin_lock(&lockres->l_lock);\n\n\tBUG_ON(lockres->l_level < DLM_LOCK_EX);\n\tlvb = ocfs2_dlm_lvb(&lockres->l_lksb);\n\tmemcpy(lvb, val, len);\n\n\tspin_unlock(&lockres->l_lock);\n}"
  },
  {
    "function_name": "user_dlm_cluster_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "529-543",
    "snippet": "void user_dlm_cluster_unlock(struct user_lock_res *lockres,\n\t\t\t     int level)\n{\n\tif (level != DLM_LOCK_EX &&\n\t    level != DLM_LOCK_PR) {\n\t\tmlog(ML_ERROR, \"lockres %.*s: invalid request!\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\treturn;\n\t}\n\n\tspin_lock(&lockres->l_lock);\n\tuser_dlm_dec_holders(lockres, level);\n\t__user_dlm_cond_queue_lockres(lockres);\n\tspin_unlock(&lockres->l_lock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__user_dlm_cond_queue_lockres",
          "args": [
            "lockres"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "__user_dlm_cond_queue_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "190-212",
          "snippet": "static void __user_dlm_cond_queue_lockres(struct user_lock_res *lockres)\n{\n\tint queue = 0;\n\n\tif (!(lockres->l_flags & USER_LOCK_BLOCKED))\n\t\treturn;\n\n\tswitch (lockres->l_blocking) {\n\tcase DLM_LOCK_EX:\n\t\tif (!lockres->l_ex_holders && !lockres->l_ro_holders)\n\t\t\tqueue = 1;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tif (!lockres->l_ex_holders)\n\t\t\tqueue = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (queue)\n\t\t__user_dlm_queue_lockres(lockres);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic void __user_dlm_cond_queue_lockres(struct user_lock_res *lockres)\n{\n\tint queue = 0;\n\n\tif (!(lockres->l_flags & USER_LOCK_BLOCKED))\n\t\treturn;\n\n\tswitch (lockres->l_blocking) {\n\tcase DLM_LOCK_EX:\n\t\tif (!lockres->l_ex_holders && !lockres->l_ro_holders)\n\t\t\tqueue = 1;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tif (!lockres->l_ex_holders)\n\t\t\tqueue = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (queue)\n\t\t__user_dlm_queue_lockres(lockres);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_dlm_dec_holders",
          "args": [
            "lockres",
            "level"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_dec_holders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "512-527",
          "snippet": "static inline void user_dlm_dec_holders(struct user_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tBUG_ON(!lockres->l_ex_holders);\n\t\tlockres->l_ex_holders--;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tBUG_ON(!lockres->l_ro_holders);\n\t\tlockres->l_ro_holders--;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_dlm_dec_holders(struct user_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tBUG_ON(!lockres->l_ex_holders);\n\t\tlockres->l_ex_holders--;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tBUG_ON(!lockres->l_ro_holders);\n\t\tlockres->l_ro_holders--;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"lockres %.*s: invalid request!\\n\"",
            "lockres->l_namelen",
            "lockres->l_name"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nvoid user_dlm_cluster_unlock(struct user_lock_res *lockres,\n\t\t\t     int level)\n{\n\tif (level != DLM_LOCK_EX &&\n\t    level != DLM_LOCK_PR) {\n\t\tmlog(ML_ERROR, \"lockres %.*s: invalid request!\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\treturn;\n\t}\n\n\tspin_lock(&lockres->l_lock);\n\tuser_dlm_dec_holders(lockres, level);\n\t__user_dlm_cond_queue_lockres(lockres);\n\tspin_unlock(&lockres->l_lock);\n}"
  },
  {
    "function_name": "user_dlm_dec_holders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "512-527",
    "snippet": "static inline void user_dlm_dec_holders(struct user_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tBUG_ON(!lockres->l_ex_holders);\n\t\tlockres->l_ex_holders--;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tBUG_ON(!lockres->l_ro_holders);\n\t\tlockres->l_ro_holders--;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lockres->l_ro_holders"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lockres->l_ex_holders"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_dlm_dec_holders(struct user_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tBUG_ON(!lockres->l_ex_holders);\n\t\tlockres->l_ex_holders--;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tBUG_ON(!lockres->l_ro_holders);\n\t\tlockres->l_ro_holders--;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "user_dlm_cluster_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "425-510",
    "snippet": "int user_dlm_cluster_lock(struct user_lock_res *lockres,\n\t\t\t  int level,\n\t\t\t  int lkm_flags)\n{\n\tint status, local_flags;\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tif (level != DLM_LOCK_EX &&\n\t    level != DLM_LOCK_PR) {\n\t\tmlog(ML_ERROR, \"lockres %.*s: invalid request!\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tmlog(ML_BASTS, \"lockres %.*s, level %d, flags = 0x%x\\n\",\n\t     lockres->l_namelen, lockres->l_name, level, lkm_flags);\n\nagain:\n\tif (signal_pending(current)) {\n\t\tstatus = -ERESTARTSYS;\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&lockres->l_lock);\n\n\t/* We only compare against the currently granted level\n\t * here. If the lock is blocked waiting on a downconvert,\n\t * we'll get caught below. */\n\tif ((lockres->l_flags & USER_LOCK_BUSY) &&\n\t    (level > lockres->l_level)) {\n\t\t/* is someone sitting in dlm_lock? If so, wait on\n\t\t * them. */\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_busy_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tif ((lockres->l_flags & USER_LOCK_BLOCKED) &&\n\t    (!user_may_continue_on_blocked_lock(lockres, level))) {\n\t\t/* is the lock is currently blocked on behalf of\n\t\t * another node */\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_blocked_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tif (level > lockres->l_level) {\n\t\tlocal_flags = lkm_flags | DLM_LKF_VALBLK;\n\t\tif (lockres->l_level != DLM_LOCK_IV)\n\t\t\tlocal_flags |= DLM_LKF_CONVERT;\n\n\t\tlockres->l_requested = level;\n\t\tlockres->l_flags |= USER_LOCK_BUSY;\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tBUG_ON(level == DLM_LOCK_IV);\n\t\tBUG_ON(level == DLM_LOCK_NL);\n\n\t\t/* call dlm_lock to upgrade lock now */\n\t\tstatus = ocfs2_dlm_lock(conn, level, &lockres->l_lksb,\n\t\t\t\t\tlocal_flags, lockres->l_name,\n\t\t\t\t\tlockres->l_namelen);\n\t\tif (status) {\n\t\t\tif ((lkm_flags & DLM_LKF_NOQUEUE) &&\n\t\t\t    (status != -EAGAIN))\n\t\t\t\tuser_log_dlm_error(\"ocfs2_dlm_lock\",\n\t\t\t\t\t\t   status, lockres);\n\t\t\tuser_recover_from_dlm_error(lockres);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tuser_wait_on_busy_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tuser_dlm_inc_holders(lockres, level);\n\tspin_unlock(&lockres->l_lock);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_dlm_inc_holders",
          "args": [
            "lockres",
            "level"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_inc_holders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "398-411",
          "snippet": "static inline void user_dlm_inc_holders(struct user_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tlockres->l_ex_holders++;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tlockres->l_ro_holders++;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_dlm_inc_holders(struct user_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tlockres->l_ex_holders++;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tlockres->l_ro_holders++;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_wait_on_busy_lock",
          "args": [
            "lockres"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "user_wait_on_busy_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "62-67",
          "snippet": "static inline void user_wait_on_busy_lock(struct user_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !user_check_wait_flag(lockres, USER_LOCK_BUSY));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_wait_on_busy_lock(struct user_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !user_check_wait_flag(lockres, USER_LOCK_BUSY));\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_recover_from_dlm_error",
          "args": [
            "lockres"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_log_dlm_error",
          "args": [
            "\"ocfs2_dlm_lock\"",
            "status",
            "lockres"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lock",
          "args": [
            "conn",
            "level",
            "&lockres->l_lksb",
            "local_flags",
            "lockres->l_name",
            "lockres->l_namelen"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "241-254",
          "snippet": "int ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level == DLM_LOCK_NL"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level == DLM_LOCK_IV"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_wait_on_blocked_lock",
          "args": [
            "lockres"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "user_wait_on_blocked_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "69-74",
          "snippet": "static inline void user_wait_on_blocked_lock(struct user_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !user_check_wait_flag(lockres, USER_LOCK_BLOCKED));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_wait_on_blocked_lock(struct user_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !user_check_wait_flag(lockres, USER_LOCK_BLOCKED));\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_may_continue_on_blocked_lock",
          "args": [
            "lockres",
            "level"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "user_may_continue_on_blocked_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "416-423",
          "snippet": "static inline int\nuser_may_continue_on_blocked_lock(struct user_lock_res *lockres,\n\t\t\t\t  int wanted)\n{\n\tBUG_ON(!(lockres->l_flags & USER_LOCK_BLOCKED));\n\n\treturn wanted <= user_highest_compat_lock_level(lockres->l_blocking);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline int\nuser_may_continue_on_blocked_lock(struct user_lock_res *lockres,\n\t\t\t\t  int wanted)\n{\n\tBUG_ON(!(lockres->l_flags & USER_LOCK_BLOCKED));\n\n\treturn wanted <= user_highest_compat_lock_level(lockres->l_blocking);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %.*s, level %d, flags = 0x%x\\n\"",
            "lockres->l_namelen",
            "lockres->l_name",
            "level",
            "lkm_flags"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"lockres %.*s: invalid request!\\n\"",
            "lockres->l_namelen",
            "lockres->l_name"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_connection_from_user_lockres",
          "args": [
            "lockres"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_connection_from_user_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "77-86",
          "snippet": "static inline struct ocfs2_cluster_connection *\ncluster_connection_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn ip->ip_conn;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline struct ocfs2_cluster_connection *\ncluster_connection_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn ip->ip_conn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nint user_dlm_cluster_lock(struct user_lock_res *lockres,\n\t\t\t  int level,\n\t\t\t  int lkm_flags)\n{\n\tint status, local_flags;\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tif (level != DLM_LOCK_EX &&\n\t    level != DLM_LOCK_PR) {\n\t\tmlog(ML_ERROR, \"lockres %.*s: invalid request!\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\tstatus = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tmlog(ML_BASTS, \"lockres %.*s, level %d, flags = 0x%x\\n\",\n\t     lockres->l_namelen, lockres->l_name, level, lkm_flags);\n\nagain:\n\tif (signal_pending(current)) {\n\t\tstatus = -ERESTARTSYS;\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&lockres->l_lock);\n\n\t/* We only compare against the currently granted level\n\t * here. If the lock is blocked waiting on a downconvert,\n\t * we'll get caught below. */\n\tif ((lockres->l_flags & USER_LOCK_BUSY) &&\n\t    (level > lockres->l_level)) {\n\t\t/* is someone sitting in dlm_lock? If so, wait on\n\t\t * them. */\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_busy_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tif ((lockres->l_flags & USER_LOCK_BLOCKED) &&\n\t    (!user_may_continue_on_blocked_lock(lockres, level))) {\n\t\t/* is the lock is currently blocked on behalf of\n\t\t * another node */\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tuser_wait_on_blocked_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tif (level > lockres->l_level) {\n\t\tlocal_flags = lkm_flags | DLM_LKF_VALBLK;\n\t\tif (lockres->l_level != DLM_LOCK_IV)\n\t\t\tlocal_flags |= DLM_LKF_CONVERT;\n\n\t\tlockres->l_requested = level;\n\t\tlockres->l_flags |= USER_LOCK_BUSY;\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tBUG_ON(level == DLM_LOCK_IV);\n\t\tBUG_ON(level == DLM_LOCK_NL);\n\n\t\t/* call dlm_lock to upgrade lock now */\n\t\tstatus = ocfs2_dlm_lock(conn, level, &lockres->l_lksb,\n\t\t\t\t\tlocal_flags, lockres->l_name,\n\t\t\t\t\tlockres->l_namelen);\n\t\tif (status) {\n\t\t\tif ((lkm_flags & DLM_LKF_NOQUEUE) &&\n\t\t\t    (status != -EAGAIN))\n\t\t\t\tuser_log_dlm_error(\"ocfs2_dlm_lock\",\n\t\t\t\t\t\t   status, lockres);\n\t\t\tuser_recover_from_dlm_error(lockres);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tuser_wait_on_busy_lock(lockres);\n\t\tgoto again;\n\t}\n\n\tuser_dlm_inc_holders(lockres, level);\n\tspin_unlock(&lockres->l_lock);\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "user_may_continue_on_blocked_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "416-423",
    "snippet": "static inline int\nuser_may_continue_on_blocked_lock(struct user_lock_res *lockres,\n\t\t\t\t  int wanted)\n{\n\tBUG_ON(!(lockres->l_flags & USER_LOCK_BLOCKED));\n\n\treturn wanted <= user_highest_compat_lock_level(lockres->l_blocking);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_highest_compat_lock_level",
          "args": [
            "lockres->l_blocking"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "user_highest_compat_lock_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "115-124",
          "snippet": "static inline int user_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline int user_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(lockres->l_flags & USER_LOCK_BLOCKED)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline int\nuser_may_continue_on_blocked_lock(struct user_lock_res *lockres,\n\t\t\t\t  int wanted)\n{\n\tBUG_ON(!(lockres->l_flags & USER_LOCK_BLOCKED));\n\n\treturn wanted <= user_highest_compat_lock_level(lockres->l_blocking);\n}"
  },
  {
    "function_name": "user_dlm_inc_holders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "398-411",
    "snippet": "static inline void user_dlm_inc_holders(struct user_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tlockres->l_ex_holders++;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tlockres->l_ro_holders++;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_dlm_inc_holders(struct user_lock_res *lockres,\n\t\t\t\t\tint level)\n{\n\tswitch(level) {\n\tcase DLM_LOCK_EX:\n\t\tlockres->l_ex_holders++;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tlockres->l_ro_holders++;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "user_dlm_unblock_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "298-396",
    "snippet": "static void user_dlm_unblock_lock(struct work_struct *work)\n{\n\tint new_level, status;\n\tstruct user_lock_res *lockres =\n\t\tcontainer_of(work, struct user_lock_res, l_work);\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tmlog(0, \"lockres %.*s\\n\", lockres->l_namelen, lockres->l_name);\n\n\tspin_lock(&lockres->l_lock);\n\n\tmlog_bug_on_msg(!(lockres->l_flags & USER_LOCK_QUEUED),\n\t\t\t\"Lockres %.*s, flags 0x%x\\n\",\n\t\t\tlockres->l_namelen, lockres->l_name, lockres->l_flags);\n\n\t/* notice that we don't clear USER_LOCK_BLOCKED here. If it's\n\t * set, we want user_ast clear it. */\n\tlockres->l_flags &= ~USER_LOCK_QUEUED;\n\n\t/* It's valid to get here and no longer be blocked - if we get\n\t * several basts in a row, we might be queued by the first\n\t * one, the unblock thread might run and clear the queued\n\t * flag, and finally we might get another bast which re-queues\n\t * us before our ast for the downconvert is called. */\n\tif (!(lockres->l_flags & USER_LOCK_BLOCKED)) {\n\t\tmlog(ML_BASTS, \"lockres %.*s USER_LOCK_BLOCKED\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto drop_ref;\n\t}\n\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN) {\n\t\tmlog(ML_BASTS, \"lockres %.*s USER_LOCK_IN_TEARDOWN\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto drop_ref;\n\t}\n\n\tif (lockres->l_flags & USER_LOCK_BUSY) {\n\t\tif (lockres->l_flags & USER_LOCK_IN_CANCEL) {\n\t\t\tmlog(ML_BASTS, \"lockres %.*s USER_LOCK_IN_CANCEL\\n\",\n\t\t\t     lockres->l_namelen, lockres->l_name);\n\t\t\tspin_unlock(&lockres->l_lock);\n\t\t\tgoto drop_ref;\n\t\t}\n\n\t\tlockres->l_flags |= USER_LOCK_IN_CANCEL;\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tstatus = ocfs2_dlm_unlock(conn, &lockres->l_lksb,\n\t\t\t\t\t  DLM_LKF_CANCEL);\n\t\tif (status)\n\t\t\tuser_log_dlm_error(\"ocfs2_dlm_unlock\", status, lockres);\n\t\tgoto drop_ref;\n\t}\n\n\t/* If there are still incompat holders, we can exit safely\n\t * without worrying about re-queueing this lock as that will\n\t * happen on the last call to user_cluster_unlock. */\n\tif ((lockres->l_blocking == DLM_LOCK_EX)\n\t    && (lockres->l_ex_holders || lockres->l_ro_holders)) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tmlog(ML_BASTS, \"lockres %.*s, EX/PR Holders %u,%u\\n\",\n\t\t     lockres->l_namelen, lockres->l_name,\n\t\t     lockres->l_ex_holders, lockres->l_ro_holders);\n\t\tgoto drop_ref;\n\t}\n\n\tif ((lockres->l_blocking == DLM_LOCK_PR)\n\t    && lockres->l_ex_holders) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tmlog(ML_BASTS, \"lockres %.*s, EX Holders %u\\n\",\n\t\t     lockres->l_namelen, lockres->l_name,\n\t\t     lockres->l_ex_holders);\n\t\tgoto drop_ref;\n\t}\n\n\t/* yay, we can downconvert now. */\n\tnew_level = user_highest_compat_lock_level(lockres->l_blocking);\n\tlockres->l_requested = new_level;\n\tlockres->l_flags |= USER_LOCK_BUSY;\n\tmlog(ML_BASTS, \"lockres %.*s, downconvert %d => %d\\n\",\n\t     lockres->l_namelen, lockres->l_name, lockres->l_level, new_level);\n\tspin_unlock(&lockres->l_lock);\n\n\t/* need lock downconvert request now... */\n\tstatus = ocfs2_dlm_lock(conn, new_level, &lockres->l_lksb,\n\t\t\t\tDLM_LKF_CONVERT|DLM_LKF_VALBLK,\n\t\t\t\tlockres->l_name,\n\t\t\t\tlockres->l_namelen);\n\tif (status) {\n\t\tuser_log_dlm_error(\"ocfs2_dlm_lock\", status, lockres);\n\t\tuser_recover_from_dlm_error(lockres);\n\t}\n\ndrop_ref:\n\tuser_dlm_drop_inode_ref(lockres);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void user_dlm_unblock_lock(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_dlm_drop_inode_ref",
          "args": [
            "lockres"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_drop_inode_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "291-296",
          "snippet": "static inline void user_dlm_drop_inode_ref(struct user_lock_res *lockres)\n{\n\tstruct inode *inode;\n\tinode = user_dlm_inode_from_user_lockres(lockres);\n\tiput(inode);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_dlm_drop_inode_ref(struct user_lock_res *lockres)\n{\n\tstruct inode *inode;\n\tinode = user_dlm_inode_from_user_lockres(lockres);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_recover_from_dlm_error",
          "args": [
            "lockres"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_log_dlm_error",
          "args": [
            "\"ocfs2_dlm_lock\"",
            "status",
            "lockres"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lock",
          "args": [
            "conn",
            "new_level",
            "&lockres->l_lksb",
            "DLM_LKF_CONVERT|DLM_LKF_VALBLK",
            "lockres->l_name",
            "lockres->l_namelen"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "241-254",
          "snippet": "int ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_lock(struct ocfs2_cluster_connection *conn,\n\t\t   int mode,\n\t\t   struct ocfs2_dlm_lksb *lksb,\n\t\t   u32 flags,\n\t\t   void *name,\n\t\t   unsigned int namelen)\n{\n\tif (!lksb->lksb_conn)\n\t\tlksb->lksb_conn = conn;\n\telse\n\t\tBUG_ON(lksb->lksb_conn != conn);\n\treturn active_stack->sp_ops->dlm_lock(conn, mode, lksb, flags,\n\t\t\t\t\t      name, namelen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %.*s, downconvert %d => %d\\n\"",
            "lockres->l_namelen",
            "lockres->l_name",
            "lockres->l_level",
            "new_level"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_highest_compat_lock_level",
          "args": [
            "lockres->l_blocking"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "user_highest_compat_lock_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "115-124",
          "snippet": "static inline int user_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline int user_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %.*s, EX Holders %u\\n\"",
            "lockres->l_namelen",
            "lockres->l_name",
            "lockres->l_ex_holders"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %.*s, EX/PR Holders %u,%u\\n\"",
            "lockres->l_namelen",
            "lockres->l_name",
            "lockres->l_ex_holders",
            "lockres->l_ro_holders"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_log_dlm_error",
          "args": [
            "\"ocfs2_dlm_unlock\"",
            "status",
            "lockres"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_unlock",
          "args": [
            "conn",
            "&lockres->l_lksb",
            "DLM_LKF_CANCEL"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "257-264",
          "snippet": "int ocfs2_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t     struct ocfs2_dlm_lksb *lksb,\n\t\t     u32 flags)\n{\n\tBUG_ON(lksb->lksb_conn == NULL);\n\n\treturn active_stack->sp_ops->dlm_unlock(conn, lksb, flags);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_unlock(struct ocfs2_cluster_connection *conn,\n\t\t     struct ocfs2_dlm_lksb *lksb,\n\t\t     u32 flags)\n{\n\tBUG_ON(lksb->lksb_conn == NULL);\n\n\treturn active_stack->sp_ops->dlm_unlock(conn, lksb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"lockres %.*s USER_LOCK_IN_CANCEL\\n\"",
            "lockres->l_namelen",
            "lockres->l_name"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!(lockres->l_flags & USER_LOCK_QUEUED)",
            "\"Lockres %.*s, flags 0x%x\\n\"",
            "lockres->l_namelen",
            "lockres->l_name",
            "lockres->l_flags"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cluster_connection_from_user_lockres",
          "args": [
            "lockres"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "cluster_connection_from_user_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "77-86",
          "snippet": "static inline struct ocfs2_cluster_connection *\ncluster_connection_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn ip->ip_conn;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline struct ocfs2_cluster_connection *\ncluster_connection_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn ip->ip_conn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structuser_lock_res",
            "l_work"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic void user_dlm_unblock_lock(struct work_struct *work);\n\nstatic void user_dlm_unblock_lock(struct work_struct *work)\n{\n\tint new_level, status;\n\tstruct user_lock_res *lockres =\n\t\tcontainer_of(work, struct user_lock_res, l_work);\n\tstruct ocfs2_cluster_connection *conn =\n\t\tcluster_connection_from_user_lockres(lockres);\n\n\tmlog(0, \"lockres %.*s\\n\", lockres->l_namelen, lockres->l_name);\n\n\tspin_lock(&lockres->l_lock);\n\n\tmlog_bug_on_msg(!(lockres->l_flags & USER_LOCK_QUEUED),\n\t\t\t\"Lockres %.*s, flags 0x%x\\n\",\n\t\t\tlockres->l_namelen, lockres->l_name, lockres->l_flags);\n\n\t/* notice that we don't clear USER_LOCK_BLOCKED here. If it's\n\t * set, we want user_ast clear it. */\n\tlockres->l_flags &= ~USER_LOCK_QUEUED;\n\n\t/* It's valid to get here and no longer be blocked - if we get\n\t * several basts in a row, we might be queued by the first\n\t * one, the unblock thread might run and clear the queued\n\t * flag, and finally we might get another bast which re-queues\n\t * us before our ast for the downconvert is called. */\n\tif (!(lockres->l_flags & USER_LOCK_BLOCKED)) {\n\t\tmlog(ML_BASTS, \"lockres %.*s USER_LOCK_BLOCKED\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto drop_ref;\n\t}\n\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN) {\n\t\tmlog(ML_BASTS, \"lockres %.*s USER_LOCK_IN_TEARDOWN\\n\",\n\t\t     lockres->l_namelen, lockres->l_name);\n\t\tspin_unlock(&lockres->l_lock);\n\t\tgoto drop_ref;\n\t}\n\n\tif (lockres->l_flags & USER_LOCK_BUSY) {\n\t\tif (lockres->l_flags & USER_LOCK_IN_CANCEL) {\n\t\t\tmlog(ML_BASTS, \"lockres %.*s USER_LOCK_IN_CANCEL\\n\",\n\t\t\t     lockres->l_namelen, lockres->l_name);\n\t\t\tspin_unlock(&lockres->l_lock);\n\t\t\tgoto drop_ref;\n\t\t}\n\n\t\tlockres->l_flags |= USER_LOCK_IN_CANCEL;\n\t\tspin_unlock(&lockres->l_lock);\n\n\t\tstatus = ocfs2_dlm_unlock(conn, &lockres->l_lksb,\n\t\t\t\t\t  DLM_LKF_CANCEL);\n\t\tif (status)\n\t\t\tuser_log_dlm_error(\"ocfs2_dlm_unlock\", status, lockres);\n\t\tgoto drop_ref;\n\t}\n\n\t/* If there are still incompat holders, we can exit safely\n\t * without worrying about re-queueing this lock as that will\n\t * happen on the last call to user_cluster_unlock. */\n\tif ((lockres->l_blocking == DLM_LOCK_EX)\n\t    && (lockres->l_ex_holders || lockres->l_ro_holders)) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tmlog(ML_BASTS, \"lockres %.*s, EX/PR Holders %u,%u\\n\",\n\t\t     lockres->l_namelen, lockres->l_name,\n\t\t     lockres->l_ex_holders, lockres->l_ro_holders);\n\t\tgoto drop_ref;\n\t}\n\n\tif ((lockres->l_blocking == DLM_LOCK_PR)\n\t    && lockres->l_ex_holders) {\n\t\tspin_unlock(&lockres->l_lock);\n\t\tmlog(ML_BASTS, \"lockres %.*s, EX Holders %u\\n\",\n\t\t     lockres->l_namelen, lockres->l_name,\n\t\t     lockres->l_ex_holders);\n\t\tgoto drop_ref;\n\t}\n\n\t/* yay, we can downconvert now. */\n\tnew_level = user_highest_compat_lock_level(lockres->l_blocking);\n\tlockres->l_requested = new_level;\n\tlockres->l_flags |= USER_LOCK_BUSY;\n\tmlog(ML_BASTS, \"lockres %.*s, downconvert %d => %d\\n\",\n\t     lockres->l_namelen, lockres->l_name, lockres->l_level, new_level);\n\tspin_unlock(&lockres->l_lock);\n\n\t/* need lock downconvert request now... */\n\tstatus = ocfs2_dlm_lock(conn, new_level, &lockres->l_lksb,\n\t\t\t\tDLM_LKF_CONVERT|DLM_LKF_VALBLK,\n\t\t\t\tlockres->l_name,\n\t\t\t\tlockres->l_namelen);\n\tif (status) {\n\t\tuser_log_dlm_error(\"ocfs2_dlm_lock\", status, lockres);\n\t\tuser_recover_from_dlm_error(lockres);\n\t}\n\ndrop_ref:\n\tuser_dlm_drop_inode_ref(lockres);\n}"
  },
  {
    "function_name": "user_dlm_drop_inode_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "291-296",
    "snippet": "static inline void user_dlm_drop_inode_ref(struct user_lock_res *lockres)\n{\n\tstruct inode *inode;\n\tinode = user_dlm_inode_from_user_lockres(lockres);\n\tiput(inode);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_dlm_inode_from_user_lockres",
          "args": [
            "lockres"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_inode_from_user_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "88-97",
          "snippet": "static struct inode *\nuser_dlm_inode_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn &ip->ip_vfs_inode;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic struct inode *\nuser_dlm_inode_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn &ip->ip_vfs_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_dlm_drop_inode_ref(struct user_lock_res *lockres)\n{\n\tstruct inode *inode;\n\tinode = user_dlm_inode_from_user_lockres(lockres);\n\tiput(inode);\n}"
  },
  {
    "function_name": "user_unlock_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "232-274",
    "snippet": "static void user_unlock_ast(struct ocfs2_dlm_lksb *lksb, int status)\n{\n\tstruct user_lock_res *lockres = user_lksb_to_lock_res(lksb);\n\n\tmlog(ML_BASTS, \"UNLOCK AST fired for lockres %.*s, flags 0x%x\\n\",\n\t     lockres->l_namelen, lockres->l_name, lockres->l_flags);\n\n\tif (status)\n\t\tmlog(ML_ERROR, \"dlm returns status %d\\n\", status);\n\n\tspin_lock(&lockres->l_lock);\n\t/* The teardown flag gets set early during the unlock process,\n\t * so test the cancel flag to make sure that this ast isn't\n\t * for a concurrent cancel. */\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN\n\t    && !(lockres->l_flags & USER_LOCK_IN_CANCEL)) {\n\t\tlockres->l_level = DLM_LOCK_IV;\n\t} else if (status == DLM_CANCELGRANT) {\n\t\t/* We tried to cancel a convert request, but it was\n\t\t * already granted. Don't clear the busy flag - the\n\t\t * ast should've done this already. */\n\t\tBUG_ON(!(lockres->l_flags & USER_LOCK_IN_CANCEL));\n\t\tlockres->l_flags &= ~USER_LOCK_IN_CANCEL;\n\t\tgoto out_noclear;\n\t} else {\n\t\tBUG_ON(!(lockres->l_flags & USER_LOCK_IN_CANCEL));\n\t\t/* Cancel succeeded, we want to re-queue */\n\t\tlockres->l_requested = DLM_LOCK_IV; /* cancel an\n\t\t\t\t\t\t    * upconvert\n\t\t\t\t\t\t    * request. */\n\t\tlockres->l_flags &= ~USER_LOCK_IN_CANCEL;\n\t\t/* we want the unblock thread to look at it again\n\t\t * now. */\n\t\tif (lockres->l_flags & USER_LOCK_BLOCKED)\n\t\t\t__user_dlm_queue_lockres(lockres);\n\t}\n\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\nout_noclear:\n\tspin_unlock(&lockres->l_lock);\n\n\twake_up(&lockres->l_event);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&lockres->l_event"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__user_dlm_queue_lockres",
          "args": [
            "lockres"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "__user_dlm_queue_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "178-188",
          "snippet": "static void __user_dlm_queue_lockres(struct user_lock_res *lockres)\n{\n\tif (!(lockres->l_flags & USER_LOCK_QUEUED)) {\n\t\tuser_dlm_grab_inode_ref(lockres);\n\n\t\tINIT_WORK(&lockres->l_work, user_dlm_unblock_lock);\n\n\t\tqueue_work(user_dlm_worker, &lockres->l_work);\n\t\tlockres->l_flags |= USER_LOCK_QUEUED;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic void __user_dlm_queue_lockres(struct user_lock_res *lockres)\n{\n\tif (!(lockres->l_flags & USER_LOCK_QUEUED)) {\n\t\tuser_dlm_grab_inode_ref(lockres);\n\n\t\tINIT_WORK(&lockres->l_work, user_dlm_unblock_lock);\n\n\t\tqueue_work(user_dlm_worker, &lockres->l_work);\n\t\tlockres->l_flags |= USER_LOCK_QUEUED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(lockres->l_flags & USER_LOCK_IN_CANCEL)"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(lockres->l_flags & USER_LOCK_IN_CANCEL)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"dlm returns status %d\\n\"",
            "status"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"UNLOCK AST fired for lockres %.*s, flags 0x%x\\n\"",
            "lockres->l_namelen",
            "lockres->l_name",
            "lockres->l_flags"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_lksb_to_lock_res",
          "args": [
            "lksb"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "user_lksb_to_lock_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "45-48",
          "snippet": "static inline struct user_lock_res *user_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct user_lock_res, l_lksb);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline struct user_lock_res *user_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct user_lock_res, l_lksb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic void user_unlock_ast(struct ocfs2_dlm_lksb *lksb, int status)\n{\n\tstruct user_lock_res *lockres = user_lksb_to_lock_res(lksb);\n\n\tmlog(ML_BASTS, \"UNLOCK AST fired for lockres %.*s, flags 0x%x\\n\",\n\t     lockres->l_namelen, lockres->l_name, lockres->l_flags);\n\n\tif (status)\n\t\tmlog(ML_ERROR, \"dlm returns status %d\\n\", status);\n\n\tspin_lock(&lockres->l_lock);\n\t/* The teardown flag gets set early during the unlock process,\n\t * so test the cancel flag to make sure that this ast isn't\n\t * for a concurrent cancel. */\n\tif (lockres->l_flags & USER_LOCK_IN_TEARDOWN\n\t    && !(lockres->l_flags & USER_LOCK_IN_CANCEL)) {\n\t\tlockres->l_level = DLM_LOCK_IV;\n\t} else if (status == DLM_CANCELGRANT) {\n\t\t/* We tried to cancel a convert request, but it was\n\t\t * already granted. Don't clear the busy flag - the\n\t\t * ast should've done this already. */\n\t\tBUG_ON(!(lockres->l_flags & USER_LOCK_IN_CANCEL));\n\t\tlockres->l_flags &= ~USER_LOCK_IN_CANCEL;\n\t\tgoto out_noclear;\n\t} else {\n\t\tBUG_ON(!(lockres->l_flags & USER_LOCK_IN_CANCEL));\n\t\t/* Cancel succeeded, we want to re-queue */\n\t\tlockres->l_requested = DLM_LOCK_IV; /* cancel an\n\t\t\t\t\t\t    * upconvert\n\t\t\t\t\t\t    * request. */\n\t\tlockres->l_flags &= ~USER_LOCK_IN_CANCEL;\n\t\t/* we want the unblock thread to look at it again\n\t\t * now. */\n\t\tif (lockres->l_flags & USER_LOCK_BLOCKED)\n\t\t\t__user_dlm_queue_lockres(lockres);\n\t}\n\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\nout_noclear:\n\tspin_unlock(&lockres->l_lock);\n\n\twake_up(&lockres->l_event);\n}"
  },
  {
    "function_name": "user_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "214-230",
    "snippet": "static void user_bast(struct ocfs2_dlm_lksb *lksb, int level)\n{\n\tstruct user_lock_res *lockres = user_lksb_to_lock_res(lksb);\n\n\tmlog(ML_BASTS, \"BAST fired for lockres %.*s, blocking %d, level %d\\n\",\n\t     lockres->l_namelen, lockres->l_name, level, lockres->l_level);\n\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags |= USER_LOCK_BLOCKED;\n\tif (level > lockres->l_blocking)\n\t\tlockres->l_blocking = level;\n\n\t__user_dlm_queue_lockres(lockres);\n\tspin_unlock(&lockres->l_lock);\n\n\twake_up(&lockres->l_event);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&lockres->l_event"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__user_dlm_queue_lockres",
          "args": [
            "lockres"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "__user_dlm_queue_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "178-188",
          "snippet": "static void __user_dlm_queue_lockres(struct user_lock_res *lockres)\n{\n\tif (!(lockres->l_flags & USER_LOCK_QUEUED)) {\n\t\tuser_dlm_grab_inode_ref(lockres);\n\n\t\tINIT_WORK(&lockres->l_work, user_dlm_unblock_lock);\n\n\t\tqueue_work(user_dlm_worker, &lockres->l_work);\n\t\tlockres->l_flags |= USER_LOCK_QUEUED;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic void __user_dlm_queue_lockres(struct user_lock_res *lockres)\n{\n\tif (!(lockres->l_flags & USER_LOCK_QUEUED)) {\n\t\tuser_dlm_grab_inode_ref(lockres);\n\n\t\tINIT_WORK(&lockres->l_work, user_dlm_unblock_lock);\n\n\t\tqueue_work(user_dlm_worker, &lockres->l_work);\n\t\tlockres->l_flags |= USER_LOCK_QUEUED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"BAST fired for lockres %.*s, blocking %d, level %d\\n\"",
            "lockres->l_namelen",
            "lockres->l_name",
            "level",
            "lockres->l_level"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_lksb_to_lock_res",
          "args": [
            "lksb"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "user_lksb_to_lock_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "45-48",
          "snippet": "static inline struct user_lock_res *user_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct user_lock_res, l_lksb);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline struct user_lock_res *user_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct user_lock_res, l_lksb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic void user_bast(struct ocfs2_dlm_lksb *lksb, int level)\n{\n\tstruct user_lock_res *lockres = user_lksb_to_lock_res(lksb);\n\n\tmlog(ML_BASTS, \"BAST fired for lockres %.*s, blocking %d, level %d\\n\",\n\t     lockres->l_namelen, lockres->l_name, level, lockres->l_level);\n\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags |= USER_LOCK_BLOCKED;\n\tif (level > lockres->l_blocking)\n\t\tlockres->l_blocking = level;\n\n\t__user_dlm_queue_lockres(lockres);\n\tspin_unlock(&lockres->l_lock);\n\n\twake_up(&lockres->l_event);\n}"
  },
  {
    "function_name": "__user_dlm_cond_queue_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "190-212",
    "snippet": "static void __user_dlm_cond_queue_lockres(struct user_lock_res *lockres)\n{\n\tint queue = 0;\n\n\tif (!(lockres->l_flags & USER_LOCK_BLOCKED))\n\t\treturn;\n\n\tswitch (lockres->l_blocking) {\n\tcase DLM_LOCK_EX:\n\t\tif (!lockres->l_ex_holders && !lockres->l_ro_holders)\n\t\t\tqueue = 1;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tif (!lockres->l_ex_holders)\n\t\t\tqueue = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (queue)\n\t\t__user_dlm_queue_lockres(lockres);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__user_dlm_queue_lockres",
          "args": [
            "lockres"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "__user_dlm_queue_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "178-188",
          "snippet": "static void __user_dlm_queue_lockres(struct user_lock_res *lockres)\n{\n\tif (!(lockres->l_flags & USER_LOCK_QUEUED)) {\n\t\tuser_dlm_grab_inode_ref(lockres);\n\n\t\tINIT_WORK(&lockres->l_work, user_dlm_unblock_lock);\n\n\t\tqueue_work(user_dlm_worker, &lockres->l_work);\n\t\tlockres->l_flags |= USER_LOCK_QUEUED;\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic void __user_dlm_queue_lockres(struct user_lock_res *lockres)\n{\n\tif (!(lockres->l_flags & USER_LOCK_QUEUED)) {\n\t\tuser_dlm_grab_inode_ref(lockres);\n\n\t\tINIT_WORK(&lockres->l_work, user_dlm_unblock_lock);\n\n\t\tqueue_work(user_dlm_worker, &lockres->l_work);\n\t\tlockres->l_flags |= USER_LOCK_QUEUED;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic void __user_dlm_cond_queue_lockres(struct user_lock_res *lockres)\n{\n\tint queue = 0;\n\n\tif (!(lockres->l_flags & USER_LOCK_BLOCKED))\n\t\treturn;\n\n\tswitch (lockres->l_blocking) {\n\tcase DLM_LOCK_EX:\n\t\tif (!lockres->l_ex_holders && !lockres->l_ro_holders)\n\t\t\tqueue = 1;\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tif (!lockres->l_ex_holders)\n\t\t\tqueue = 1;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tif (queue)\n\t\t__user_dlm_queue_lockres(lockres);\n}"
  },
  {
    "function_name": "__user_dlm_queue_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "178-188",
    "snippet": "static void __user_dlm_queue_lockres(struct user_lock_res *lockres)\n{\n\tif (!(lockres->l_flags & USER_LOCK_QUEUED)) {\n\t\tuser_dlm_grab_inode_ref(lockres);\n\n\t\tINIT_WORK(&lockres->l_work, user_dlm_unblock_lock);\n\n\t\tqueue_work(user_dlm_worker, &lockres->l_work);\n\t\tlockres->l_flags |= USER_LOCK_QUEUED;\n\t}\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "user_dlm_worker",
            "&lockres->l_work"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&lockres->l_work",
            "user_dlm_unblock_lock"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_dlm_grab_inode_ref",
          "args": [
            "lockres"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_grab_inode_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "168-174",
          "snippet": "static inline void user_dlm_grab_inode_ref(struct user_lock_res *lockres)\n{\n\tstruct inode *inode;\n\tinode = user_dlm_inode_from_user_lockres(lockres);\n\tif (!igrab(inode))\n\t\tBUG();\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_dlm_grab_inode_ref(struct user_lock_res *lockres)\n{\n\tstruct inode *inode;\n\tinode = user_dlm_inode_from_user_lockres(lockres);\n\tif (!igrab(inode))\n\t\tBUG();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic void __user_dlm_queue_lockres(struct user_lock_res *lockres)\n{\n\tif (!(lockres->l_flags & USER_LOCK_QUEUED)) {\n\t\tuser_dlm_grab_inode_ref(lockres);\n\n\t\tINIT_WORK(&lockres->l_work, user_dlm_unblock_lock);\n\n\t\tqueue_work(user_dlm_worker, &lockres->l_work);\n\t\tlockres->l_flags |= USER_LOCK_QUEUED;\n\t}\n}"
  },
  {
    "function_name": "user_dlm_grab_inode_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "168-174",
    "snippet": "static inline void user_dlm_grab_inode_ref(struct user_lock_res *lockres)\n{\n\tstruct inode *inode;\n\tinode = user_dlm_inode_from_user_lockres(lockres);\n\tif (!igrab(inode))\n\t\tBUG();\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "igrab",
          "args": [
            "inode"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "igrab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1173-1189",
          "snippet": "struct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *igrab(struct inode *inode)\n{\n\tspin_lock(&inode->i_lock);\n\tif (!(inode->i_state & (I_FREEING|I_WILL_FREE))) {\n\t\t__iget(inode);\n\t\tspin_unlock(&inode->i_lock);\n\t} else {\n\t\tspin_unlock(&inode->i_lock);\n\t\t/*\n\t\t * Handle the case where s_op->clear_inode is not been\n\t\t * called yet, and somebody is calling igrab\n\t\t * while the inode is getting freed.\n\t\t */\n\t\tinode = NULL;\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_dlm_inode_from_user_lockres",
          "args": [
            "lockres"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "user_dlm_inode_from_user_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "88-97",
          "snippet": "static struct inode *\nuser_dlm_inode_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn &ip->ip_vfs_inode;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic struct inode *\nuser_dlm_inode_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn &ip->ip_vfs_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_dlm_grab_inode_ref(struct user_lock_res *lockres)\n{\n\tstruct inode *inode;\n\tinode = user_dlm_inode_from_user_lockres(lockres);\n\tif (!igrab(inode))\n\t\tBUG();\n}"
  },
  {
    "function_name": "user_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "126-166",
    "snippet": "static void user_ast(struct ocfs2_dlm_lksb *lksb)\n{\n\tstruct user_lock_res *lockres = user_lksb_to_lock_res(lksb);\n\tint status;\n\n\tmlog(ML_BASTS, \"AST fired for lockres %.*s, level %d => %d\\n\",\n\t     lockres->l_namelen, lockres->l_name, lockres->l_level,\n\t     lockres->l_requested);\n\n\tspin_lock(&lockres->l_lock);\n\n\tstatus = ocfs2_dlm_lock_status(&lockres->l_lksb);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"lksb status value of %u on lockres %.*s\\n\",\n\t\t     status, lockres->l_namelen, lockres->l_name);\n\t\tspin_unlock(&lockres->l_lock);\n\t\treturn;\n\t}\n\n\tmlog_bug_on_msg(lockres->l_requested == DLM_LOCK_IV,\n\t\t\t\"Lockres %.*s, requested ivmode. flags 0x%x\\n\",\n\t\t\tlockres->l_namelen, lockres->l_name, lockres->l_flags);\n\n\t/* we're downconverting. */\n\tif (lockres->l_requested < lockres->l_level) {\n\t\tif (lockres->l_requested <=\n\t\t    user_highest_compat_lock_level(lockres->l_blocking)) {\n\t\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\t\tlockres->l_flags &= ~USER_LOCK_BLOCKED;\n\t\t}\n\t}\n\n\tlockres->l_level = lockres->l_requested;\n\tlockres->l_requested = DLM_LOCK_IV;\n\tlockres->l_flags |= USER_LOCK_ATTACHED;\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\n\tspin_unlock(&lockres->l_lock);\n\n\twake_up(&lockres->l_event);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&lockres->l_event"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_highest_compat_lock_level",
          "args": [
            "lockres->l_blocking"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "user_highest_compat_lock_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "115-124",
          "snippet": "static inline int user_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline int user_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "lockres->l_requested == DLM_LOCK_IV",
            "\"Lockres %.*s, requested ivmode. flags 0x%x\\n\"",
            "lockres->l_namelen",
            "lockres->l_name",
            "lockres->l_flags"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"lksb status value of %u on lockres %.*s\\n\"",
            "status",
            "lockres->l_namelen",
            "lockres->l_name"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_dlm_lock_status",
          "args": [
            "&lockres->l_lksb"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dlm_lock_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "267-270",
          "snippet": "int ocfs2_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_status(lksb);\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_stack_plugin *active_stack;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic struct ocfs2_stack_plugin *active_stack;\n\nint ocfs2_dlm_lock_status(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn active_stack->sp_ops->lock_status(lksb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_BASTS",
            "\"AST fired for lockres %.*s, level %d => %d\\n\"",
            "lockres->l_namelen",
            "lockres->l_name",
            "lockres->l_level",
            "lockres->l_requested"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_lksb_to_lock_res",
          "args": [
            "lksb"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "user_lksb_to_lock_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "45-48",
          "snippet": "static inline struct user_lock_res *user_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct user_lock_res, l_lksb);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline struct user_lock_res *user_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct user_lock_res, l_lksb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic void user_ast(struct ocfs2_dlm_lksb *lksb)\n{\n\tstruct user_lock_res *lockres = user_lksb_to_lock_res(lksb);\n\tint status;\n\n\tmlog(ML_BASTS, \"AST fired for lockres %.*s, level %d => %d\\n\",\n\t     lockres->l_namelen, lockres->l_name, lockres->l_level,\n\t     lockres->l_requested);\n\n\tspin_lock(&lockres->l_lock);\n\n\tstatus = ocfs2_dlm_lock_status(&lockres->l_lksb);\n\tif (status) {\n\t\tmlog(ML_ERROR, \"lksb status value of %u on lockres %.*s\\n\",\n\t\t     status, lockres->l_namelen, lockres->l_name);\n\t\tspin_unlock(&lockres->l_lock);\n\t\treturn;\n\t}\n\n\tmlog_bug_on_msg(lockres->l_requested == DLM_LOCK_IV,\n\t\t\t\"Lockres %.*s, requested ivmode. flags 0x%x\\n\",\n\t\t\tlockres->l_namelen, lockres->l_name, lockres->l_flags);\n\n\t/* we're downconverting. */\n\tif (lockres->l_requested < lockres->l_level) {\n\t\tif (lockres->l_requested <=\n\t\t    user_highest_compat_lock_level(lockres->l_blocking)) {\n\t\t\tlockres->l_blocking = DLM_LOCK_NL;\n\t\t\tlockres->l_flags &= ~USER_LOCK_BLOCKED;\n\t\t}\n\t}\n\n\tlockres->l_level = lockres->l_requested;\n\tlockres->l_requested = DLM_LOCK_IV;\n\tlockres->l_flags |= USER_LOCK_ATTACHED;\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\n\tspin_unlock(&lockres->l_lock);\n\n\twake_up(&lockres->l_event);\n}"
  },
  {
    "function_name": "user_highest_compat_lock_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "115-124",
    "snippet": "static inline int user_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline int user_highest_compat_lock_level(int level)\n{\n\tint new_level = DLM_LOCK_EX;\n\n\tif (level == DLM_LOCK_EX)\n\t\tnew_level = DLM_LOCK_NL;\n\telse if (level == DLM_LOCK_PR)\n\t\tnew_level = DLM_LOCK_PR;\n\treturn new_level;\n}"
  },
  {
    "function_name": "user_recover_from_dlm_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "99-104",
    "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
  },
  {
    "function_name": "user_dlm_inode_from_user_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "88-97",
    "snippet": "static struct inode *\nuser_dlm_inode_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn &ip->ip_vfs_inode;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lockres",
            "structdlmfs_inode_private",
            "ip_lockres"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic struct inode *\nuser_dlm_inode_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn &ip->ip_vfs_inode;\n}"
  },
  {
    "function_name": "cluster_connection_from_user_lockres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "77-86",
    "snippet": "static inline struct ocfs2_cluster_connection *\ncluster_connection_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn ip->ip_conn;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lockres",
            "structdlmfs_inode_private",
            "ip_lockres"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline struct ocfs2_cluster_connection *\ncluster_connection_from_user_lockres(struct user_lock_res *lockres)\n{\n\tstruct dlmfs_inode_private *ip;\n\n\tip = container_of(lockres,\n\t\t\t  struct dlmfs_inode_private,\n\t\t\t  ip_lockres);\n\treturn ip->ip_conn;\n}"
  },
  {
    "function_name": "user_wait_on_blocked_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "69-74",
    "snippet": "static inline void user_wait_on_blocked_lock(struct user_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !user_check_wait_flag(lockres, USER_LOCK_BLOCKED));\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "lockres->l_event",
            "!user_check_wait_flag(lockres, USER_LOCK_BLOCKED)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_check_wait_flag",
          "args": [
            "lockres",
            "USER_LOCK_BLOCKED"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "user_check_wait_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "50-60",
          "snippet": "static inline int user_check_wait_flag(struct user_lock_res *lockres,\n\t\t\t\t       int flag)\n{\n\tint ret;\n\n\tspin_lock(&lockres->l_lock);\n\tret = lockres->l_flags & flag;\n\tspin_unlock(&lockres->l_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline int user_check_wait_flag(struct user_lock_res *lockres,\n\t\t\t\t       int flag)\n{\n\tint ret;\n\n\tspin_lock(&lockres->l_lock);\n\tret = lockres->l_flags & flag;\n\tspin_unlock(&lockres->l_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_wait_on_blocked_lock(struct user_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !user_check_wait_flag(lockres, USER_LOCK_BLOCKED));\n}"
  },
  {
    "function_name": "user_wait_on_busy_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "62-67",
    "snippet": "static inline void user_wait_on_busy_lock(struct user_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !user_check_wait_flag(lockres, USER_LOCK_BUSY));\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "lockres->l_event",
            "!user_check_wait_flag(lockres, USER_LOCK_BUSY)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_check_wait_flag",
          "args": [
            "lockres",
            "USER_LOCK_BUSY"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "user_check_wait_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "50-60",
          "snippet": "static inline int user_check_wait_flag(struct user_lock_res *lockres,\n\t\t\t\t       int flag)\n{\n\tint ret;\n\n\tspin_lock(&lockres->l_lock);\n\tret = lockres->l_flags & flag;\n\tspin_unlock(&lockres->l_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline int user_check_wait_flag(struct user_lock_res *lockres,\n\t\t\t\t       int flag)\n{\n\tint ret;\n\n\tspin_lock(&lockres->l_lock);\n\tret = lockres->l_flags & flag;\n\tspin_unlock(&lockres->l_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_wait_on_busy_lock(struct user_lock_res *lockres)\n\n{\n\twait_event(lockres->l_event,\n\t\t   !user_check_wait_flag(lockres, USER_LOCK_BUSY));\n}"
  },
  {
    "function_name": "user_check_wait_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "50-60",
    "snippet": "static inline int user_check_wait_flag(struct user_lock_res *lockres,\n\t\t\t\t       int flag)\n{\n\tint ret;\n\n\tspin_lock(&lockres->l_lock);\n\tret = lockres->l_flags & flag;\n\tspin_unlock(&lockres->l_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lockres->l_lock"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline int user_check_wait_flag(struct user_lock_res *lockres,\n\t\t\t\t       int flag)\n{\n\tint ret;\n\n\tspin_lock(&lockres->l_lock);\n\tret = lockres->l_flags & flag;\n\tspin_unlock(&lockres->l_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "user_lksb_to_lock_res",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
    "lines": "45-48",
    "snippet": "static inline struct user_lock_res *user_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct user_lock_res, l_lksb);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"userdlm.h\"",
      "#include \"stackglue.h\"",
      "#include \"ocfs2_lockingver.h\"",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/signal.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "lksb",
            "structuser_lock_res",
            "l_lksb"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline struct user_lock_res *user_lksb_to_lock_res(struct ocfs2_dlm_lksb *lksb)\n{\n\treturn container_of(lksb, struct user_lock_res, l_lksb);\n}"
  }
]