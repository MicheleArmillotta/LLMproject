[
  {
    "function_name": "btrfs_test_extent_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/extent-io-tests.c",
    "lines": "271-275",
    "snippet": "int btrfs_test_extent_io(void)\n{\n\ttest_msg(\"Running find delalloc tests\\n\");\n\treturn test_find_delalloc();\n}",
    "includes": [
      "#include \"../extent_io.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_find_delalloc",
          "args": [],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "test_find_delalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/extent-io-tests.c",
          "lines": "66-269",
          "snippet": "static int test_find_delalloc(void)\n{\n\tstruct inode *inode;\n\tstruct extent_io_tree tmp;\n\tstruct page *page;\n\tstruct page *locked_page = NULL;\n\tunsigned long index = 0;\n\tu64 total_dirty = 256 * 1024 * 1024;\n\tu64 max_bytes = 128 * 1024 * 1024;\n\tu64 start, end, test_start;\n\tu64 found;\n\tint ret = -EINVAL;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Failed to allocate test inode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\textent_io_tree_init(&tmp, &inode->i_data);\n\n\t/*\n\t * First go through and create and mark all of our pages dirty, we pin\n\t * everything to make sure our pages don't get evicted and screw up our\n\t * test.\n\t */\n\tfor (index = 0; index < (total_dirty >> PAGE_CACHE_SHIFT); index++) {\n\t\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\ttest_msg(\"Failed to allocate test page\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tSetPageDirty(page);\n\t\tif (index) {\n\t\t\tunlock_page(page);\n\t\t} else {\n\t\t\tpage_cache_get(page);\n\t\t\tlocked_page = page;\n\t\t}\n\t}\n\n\t/* Test this scenario\n\t * |--- delalloc ---|\n\t * |---  search  ---|\n\t */\n\tset_extent_delalloc(&tmp, 0, 4095, NULL, GFP_NOFS);\n\tstart = 0;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Should have found at least one delalloc\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != 0 || end != 4095) {\n\t\ttest_msg(\"Expected start 0 end 4095, got start %Lu end %Lu\\n\",\n\t\t\t start, end);\n\t\tgoto out_bits;\n\t}\n\tunlock_extent(&tmp, start, end);\n\tunlock_page(locked_page);\n\tpage_cache_release(locked_page);\n\n\t/*\n\t * Test this scenario\n\t *\n\t * |--- delalloc ---|\n\t *           |--- search ---|\n\t */\n\ttest_start = 64 * 1024 * 1024;\n\tlocked_page = find_lock_page(inode->i_mapping,\n\t\t\t\t     test_start >> PAGE_CACHE_SHIFT);\n\tif (!locked_page) {\n\t\ttest_msg(\"Couldn't find the locked page\\n\");\n\t\tgoto out_bits;\n\t}\n\tset_extent_delalloc(&tmp, 4096, max_bytes - 1, NULL, GFP_NOFS);\n\tstart = test_start;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Couldn't find delalloc in our range\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != test_start || end != max_bytes - 1) {\n\t\ttest_msg(\"Expected start %Lu end %Lu, got start %Lu, end \"\n\t\t\t \"%Lu\\n\", test_start, max_bytes - 1, start, end);\n\t\tgoto out_bits;\n\t}\n\tif (process_page_range(inode, start, end,\n\t\t\t       PROCESS_TEST_LOCKED | PROCESS_UNLOCK)) {\n\t\ttest_msg(\"There were unlocked pages in the range\\n\");\n\t\tgoto out_bits;\n\t}\n\tunlock_extent(&tmp, start, end);\n\t/* locked_page was unlocked above */\n\tpage_cache_release(locked_page);\n\n\t/*\n\t * Test this scenario\n\t * |--- delalloc ---|\n\t *                    |--- search ---|\n\t */\n\ttest_start = max_bytes + 4096;\n\tlocked_page = find_lock_page(inode->i_mapping, test_start >>\n\t\t\t\t     PAGE_CACHE_SHIFT);\n\tif (!locked_page) {\n\t\ttest_msg(\"Could'nt find the locked page\\n\");\n\t\tgoto out_bits;\n\t}\n\tstart = test_start;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (found) {\n\t\ttest_msg(\"Found range when we shouldn't have\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (end != (u64)-1) {\n\t\ttest_msg(\"Did not return the proper end offset\\n\");\n\t\tgoto out_bits;\n\t}\n\n\t/*\n\t * Test this scenario\n\t * [------- delalloc -------|\n\t * [max_bytes]|-- search--|\n\t *\n\t * We are re-using our test_start from above since it works out well.\n\t */\n\tset_extent_delalloc(&tmp, max_bytes, total_dirty - 1, NULL, GFP_NOFS);\n\tstart = test_start;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Didn't find our range\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != test_start || end != total_dirty - 1) {\n\t\ttest_msg(\"Expected start %Lu end %Lu, got start %Lu end %Lu\\n\",\n\t\t\t test_start, total_dirty - 1, start, end);\n\t\tgoto out_bits;\n\t}\n\tif (process_page_range(inode, start, end,\n\t\t\t       PROCESS_TEST_LOCKED | PROCESS_UNLOCK)) {\n\t\ttest_msg(\"Pages in range were not all locked\\n\");\n\t\tgoto out_bits;\n\t}\n\tunlock_extent(&tmp, start, end);\n\n\t/*\n\t * Now to test where we run into a page that is no longer dirty in the\n\t * range we want to find.\n\t */\n\tpage = find_get_page(inode->i_mapping, (max_bytes + (1 * 1024 * 1024))\n\t\t\t     >> PAGE_CACHE_SHIFT);\n\tif (!page) {\n\t\ttest_msg(\"Couldn't find our page\\n\");\n\t\tgoto out_bits;\n\t}\n\tClearPageDirty(page);\n\tpage_cache_release(page);\n\n\t/* We unlocked it in the previous test */\n\tlock_page(locked_page);\n\tstart = test_start;\n\tend = 0;\n\t/*\n\t * Currently if we fail to find dirty pages in the delalloc range we\n\t * will adjust max_bytes down to PAGE_CACHE_SIZE and then re-search.  If\n\t * this changes at any point in the future we will need to fix this\n\t * tests expected behavior.\n\t */\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Didn't find our range\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != test_start && end != test_start + PAGE_CACHE_SIZE - 1) {\n\t\ttest_msg(\"Expected start %Lu end %Lu, got start %Lu end %Lu\\n\",\n\t\t\t test_start, test_start + PAGE_CACHE_SIZE - 1, start,\n\t\t\t end);\n\t\tgoto out_bits;\n\t}\n\tif (process_page_range(inode, start, end, PROCESS_TEST_LOCKED |\n\t\t\t       PROCESS_UNLOCK)) {\n\t\ttest_msg(\"Pages in range were not all locked\\n\");\n\t\tgoto out_bits;\n\t}\n\tret = 0;\nout_bits:\n\tclear_extent_bits(&tmp, 0, total_dirty - 1, (unsigned)-1, GFP_NOFS);\nout:\n\tif (locked_page)\n\t\tpage_cache_release(locked_page);\n\tprocess_page_range(inode, 0, total_dirty - 1,\n\t\t\t   PROCESS_UNLOCK | PROCESS_RELEASE);\n\tiput(inode);\n\treturn ret;\n}",
          "includes": [
            "#include \"../extent_io.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define PROCESS_TEST_LOCKED\t(1 << 2)",
            "#define PROCESS_RELEASE\t\t(1 << 1)",
            "#define PROCESS_UNLOCK\t\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../extent_io.h\"\n#include \"btrfs-tests.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define PROCESS_TEST_LOCKED\t(1 << 2)\n#define PROCESS_RELEASE\t\t(1 << 1)\n#define PROCESS_UNLOCK\t\t(1 << 0)\n\nstatic int test_find_delalloc(void)\n{\n\tstruct inode *inode;\n\tstruct extent_io_tree tmp;\n\tstruct page *page;\n\tstruct page *locked_page = NULL;\n\tunsigned long index = 0;\n\tu64 total_dirty = 256 * 1024 * 1024;\n\tu64 max_bytes = 128 * 1024 * 1024;\n\tu64 start, end, test_start;\n\tu64 found;\n\tint ret = -EINVAL;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Failed to allocate test inode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\textent_io_tree_init(&tmp, &inode->i_data);\n\n\t/*\n\t * First go through and create and mark all of our pages dirty, we pin\n\t * everything to make sure our pages don't get evicted and screw up our\n\t * test.\n\t */\n\tfor (index = 0; index < (total_dirty >> PAGE_CACHE_SHIFT); index++) {\n\t\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\ttest_msg(\"Failed to allocate test page\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tSetPageDirty(page);\n\t\tif (index) {\n\t\t\tunlock_page(page);\n\t\t} else {\n\t\t\tpage_cache_get(page);\n\t\t\tlocked_page = page;\n\t\t}\n\t}\n\n\t/* Test this scenario\n\t * |--- delalloc ---|\n\t * |---  search  ---|\n\t */\n\tset_extent_delalloc(&tmp, 0, 4095, NULL, GFP_NOFS);\n\tstart = 0;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Should have found at least one delalloc\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != 0 || end != 4095) {\n\t\ttest_msg(\"Expected start 0 end 4095, got start %Lu end %Lu\\n\",\n\t\t\t start, end);\n\t\tgoto out_bits;\n\t}\n\tunlock_extent(&tmp, start, end);\n\tunlock_page(locked_page);\n\tpage_cache_release(locked_page);\n\n\t/*\n\t * Test this scenario\n\t *\n\t * |--- delalloc ---|\n\t *           |--- search ---|\n\t */\n\ttest_start = 64 * 1024 * 1024;\n\tlocked_page = find_lock_page(inode->i_mapping,\n\t\t\t\t     test_start >> PAGE_CACHE_SHIFT);\n\tif (!locked_page) {\n\t\ttest_msg(\"Couldn't find the locked page\\n\");\n\t\tgoto out_bits;\n\t}\n\tset_extent_delalloc(&tmp, 4096, max_bytes - 1, NULL, GFP_NOFS);\n\tstart = test_start;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Couldn't find delalloc in our range\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != test_start || end != max_bytes - 1) {\n\t\ttest_msg(\"Expected start %Lu end %Lu, got start %Lu, end \"\n\t\t\t \"%Lu\\n\", test_start, max_bytes - 1, start, end);\n\t\tgoto out_bits;\n\t}\n\tif (process_page_range(inode, start, end,\n\t\t\t       PROCESS_TEST_LOCKED | PROCESS_UNLOCK)) {\n\t\ttest_msg(\"There were unlocked pages in the range\\n\");\n\t\tgoto out_bits;\n\t}\n\tunlock_extent(&tmp, start, end);\n\t/* locked_page was unlocked above */\n\tpage_cache_release(locked_page);\n\n\t/*\n\t * Test this scenario\n\t * |--- delalloc ---|\n\t *                    |--- search ---|\n\t */\n\ttest_start = max_bytes + 4096;\n\tlocked_page = find_lock_page(inode->i_mapping, test_start >>\n\t\t\t\t     PAGE_CACHE_SHIFT);\n\tif (!locked_page) {\n\t\ttest_msg(\"Could'nt find the locked page\\n\");\n\t\tgoto out_bits;\n\t}\n\tstart = test_start;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (found) {\n\t\ttest_msg(\"Found range when we shouldn't have\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (end != (u64)-1) {\n\t\ttest_msg(\"Did not return the proper end offset\\n\");\n\t\tgoto out_bits;\n\t}\n\n\t/*\n\t * Test this scenario\n\t * [------- delalloc -------|\n\t * [max_bytes]|-- search--|\n\t *\n\t * We are re-using our test_start from above since it works out well.\n\t */\n\tset_extent_delalloc(&tmp, max_bytes, total_dirty - 1, NULL, GFP_NOFS);\n\tstart = test_start;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Didn't find our range\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != test_start || end != total_dirty - 1) {\n\t\ttest_msg(\"Expected start %Lu end %Lu, got start %Lu end %Lu\\n\",\n\t\t\t test_start, total_dirty - 1, start, end);\n\t\tgoto out_bits;\n\t}\n\tif (process_page_range(inode, start, end,\n\t\t\t       PROCESS_TEST_LOCKED | PROCESS_UNLOCK)) {\n\t\ttest_msg(\"Pages in range were not all locked\\n\");\n\t\tgoto out_bits;\n\t}\n\tunlock_extent(&tmp, start, end);\n\n\t/*\n\t * Now to test where we run into a page that is no longer dirty in the\n\t * range we want to find.\n\t */\n\tpage = find_get_page(inode->i_mapping, (max_bytes + (1 * 1024 * 1024))\n\t\t\t     >> PAGE_CACHE_SHIFT);\n\tif (!page) {\n\t\ttest_msg(\"Couldn't find our page\\n\");\n\t\tgoto out_bits;\n\t}\n\tClearPageDirty(page);\n\tpage_cache_release(page);\n\n\t/* We unlocked it in the previous test */\n\tlock_page(locked_page);\n\tstart = test_start;\n\tend = 0;\n\t/*\n\t * Currently if we fail to find dirty pages in the delalloc range we\n\t * will adjust max_bytes down to PAGE_CACHE_SIZE and then re-search.  If\n\t * this changes at any point in the future we will need to fix this\n\t * tests expected behavior.\n\t */\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Didn't find our range\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != test_start && end != test_start + PAGE_CACHE_SIZE - 1) {\n\t\ttest_msg(\"Expected start %Lu end %Lu, got start %Lu end %Lu\\n\",\n\t\t\t test_start, test_start + PAGE_CACHE_SIZE - 1, start,\n\t\t\t end);\n\t\tgoto out_bits;\n\t}\n\tif (process_page_range(inode, start, end, PROCESS_TEST_LOCKED |\n\t\t\t       PROCESS_UNLOCK)) {\n\t\ttest_msg(\"Pages in range were not all locked\\n\");\n\t\tgoto out_bits;\n\t}\n\tret = 0;\nout_bits:\n\tclear_extent_bits(&tmp, 0, total_dirty - 1, (unsigned)-1, GFP_NOFS);\nout:\n\tif (locked_page)\n\t\tpage_cache_release(locked_page);\n\tprocess_page_range(inode, 0, total_dirty - 1,\n\t\t\t   PROCESS_UNLOCK | PROCESS_RELEASE);\n\tiput(inode);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Running find delalloc tests\\n\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../extent_io.h\"\n#include \"btrfs-tests.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nint btrfs_test_extent_io(void)\n{\n\ttest_msg(\"Running find delalloc tests\\n\");\n\treturn test_find_delalloc();\n}"
  },
  {
    "function_name": "test_find_delalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/extent-io-tests.c",
    "lines": "66-269",
    "snippet": "static int test_find_delalloc(void)\n{\n\tstruct inode *inode;\n\tstruct extent_io_tree tmp;\n\tstruct page *page;\n\tstruct page *locked_page = NULL;\n\tunsigned long index = 0;\n\tu64 total_dirty = 256 * 1024 * 1024;\n\tu64 max_bytes = 128 * 1024 * 1024;\n\tu64 start, end, test_start;\n\tu64 found;\n\tint ret = -EINVAL;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Failed to allocate test inode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\textent_io_tree_init(&tmp, &inode->i_data);\n\n\t/*\n\t * First go through and create and mark all of our pages dirty, we pin\n\t * everything to make sure our pages don't get evicted and screw up our\n\t * test.\n\t */\n\tfor (index = 0; index < (total_dirty >> PAGE_CACHE_SHIFT); index++) {\n\t\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\ttest_msg(\"Failed to allocate test page\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tSetPageDirty(page);\n\t\tif (index) {\n\t\t\tunlock_page(page);\n\t\t} else {\n\t\t\tpage_cache_get(page);\n\t\t\tlocked_page = page;\n\t\t}\n\t}\n\n\t/* Test this scenario\n\t * |--- delalloc ---|\n\t * |---  search  ---|\n\t */\n\tset_extent_delalloc(&tmp, 0, 4095, NULL, GFP_NOFS);\n\tstart = 0;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Should have found at least one delalloc\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != 0 || end != 4095) {\n\t\ttest_msg(\"Expected start 0 end 4095, got start %Lu end %Lu\\n\",\n\t\t\t start, end);\n\t\tgoto out_bits;\n\t}\n\tunlock_extent(&tmp, start, end);\n\tunlock_page(locked_page);\n\tpage_cache_release(locked_page);\n\n\t/*\n\t * Test this scenario\n\t *\n\t * |--- delalloc ---|\n\t *           |--- search ---|\n\t */\n\ttest_start = 64 * 1024 * 1024;\n\tlocked_page = find_lock_page(inode->i_mapping,\n\t\t\t\t     test_start >> PAGE_CACHE_SHIFT);\n\tif (!locked_page) {\n\t\ttest_msg(\"Couldn't find the locked page\\n\");\n\t\tgoto out_bits;\n\t}\n\tset_extent_delalloc(&tmp, 4096, max_bytes - 1, NULL, GFP_NOFS);\n\tstart = test_start;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Couldn't find delalloc in our range\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != test_start || end != max_bytes - 1) {\n\t\ttest_msg(\"Expected start %Lu end %Lu, got start %Lu, end \"\n\t\t\t \"%Lu\\n\", test_start, max_bytes - 1, start, end);\n\t\tgoto out_bits;\n\t}\n\tif (process_page_range(inode, start, end,\n\t\t\t       PROCESS_TEST_LOCKED | PROCESS_UNLOCK)) {\n\t\ttest_msg(\"There were unlocked pages in the range\\n\");\n\t\tgoto out_bits;\n\t}\n\tunlock_extent(&tmp, start, end);\n\t/* locked_page was unlocked above */\n\tpage_cache_release(locked_page);\n\n\t/*\n\t * Test this scenario\n\t * |--- delalloc ---|\n\t *                    |--- search ---|\n\t */\n\ttest_start = max_bytes + 4096;\n\tlocked_page = find_lock_page(inode->i_mapping, test_start >>\n\t\t\t\t     PAGE_CACHE_SHIFT);\n\tif (!locked_page) {\n\t\ttest_msg(\"Could'nt find the locked page\\n\");\n\t\tgoto out_bits;\n\t}\n\tstart = test_start;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (found) {\n\t\ttest_msg(\"Found range when we shouldn't have\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (end != (u64)-1) {\n\t\ttest_msg(\"Did not return the proper end offset\\n\");\n\t\tgoto out_bits;\n\t}\n\n\t/*\n\t * Test this scenario\n\t * [------- delalloc -------|\n\t * [max_bytes]|-- search--|\n\t *\n\t * We are re-using our test_start from above since it works out well.\n\t */\n\tset_extent_delalloc(&tmp, max_bytes, total_dirty - 1, NULL, GFP_NOFS);\n\tstart = test_start;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Didn't find our range\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != test_start || end != total_dirty - 1) {\n\t\ttest_msg(\"Expected start %Lu end %Lu, got start %Lu end %Lu\\n\",\n\t\t\t test_start, total_dirty - 1, start, end);\n\t\tgoto out_bits;\n\t}\n\tif (process_page_range(inode, start, end,\n\t\t\t       PROCESS_TEST_LOCKED | PROCESS_UNLOCK)) {\n\t\ttest_msg(\"Pages in range were not all locked\\n\");\n\t\tgoto out_bits;\n\t}\n\tunlock_extent(&tmp, start, end);\n\n\t/*\n\t * Now to test where we run into a page that is no longer dirty in the\n\t * range we want to find.\n\t */\n\tpage = find_get_page(inode->i_mapping, (max_bytes + (1 * 1024 * 1024))\n\t\t\t     >> PAGE_CACHE_SHIFT);\n\tif (!page) {\n\t\ttest_msg(\"Couldn't find our page\\n\");\n\t\tgoto out_bits;\n\t}\n\tClearPageDirty(page);\n\tpage_cache_release(page);\n\n\t/* We unlocked it in the previous test */\n\tlock_page(locked_page);\n\tstart = test_start;\n\tend = 0;\n\t/*\n\t * Currently if we fail to find dirty pages in the delalloc range we\n\t * will adjust max_bytes down to PAGE_CACHE_SIZE and then re-search.  If\n\t * this changes at any point in the future we will need to fix this\n\t * tests expected behavior.\n\t */\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Didn't find our range\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != test_start && end != test_start + PAGE_CACHE_SIZE - 1) {\n\t\ttest_msg(\"Expected start %Lu end %Lu, got start %Lu end %Lu\\n\",\n\t\t\t test_start, test_start + PAGE_CACHE_SIZE - 1, start,\n\t\t\t end);\n\t\tgoto out_bits;\n\t}\n\tif (process_page_range(inode, start, end, PROCESS_TEST_LOCKED |\n\t\t\t       PROCESS_UNLOCK)) {\n\t\ttest_msg(\"Pages in range were not all locked\\n\");\n\t\tgoto out_bits;\n\t}\n\tret = 0;\nout_bits:\n\tclear_extent_bits(&tmp, 0, total_dirty - 1, (unsigned)-1, GFP_NOFS);\nout:\n\tif (locked_page)\n\t\tpage_cache_release(locked_page);\n\tprocess_page_range(inode, 0, total_dirty - 1,\n\t\t\t   PROCESS_UNLOCK | PROCESS_RELEASE);\n\tiput(inode);\n\treturn ret;\n}",
    "includes": [
      "#include \"../extent_io.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define PROCESS_TEST_LOCKED\t(1 << 2)",
      "#define PROCESS_RELEASE\t\t(1 << 1)",
      "#define PROCESS_UNLOCK\t\t(1 << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_page_range",
          "args": [
            "inode",
            "0",
            "total_dirty - 1",
            "PROCESS_UNLOCK | PROCESS_RELEASE"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "process_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/extent-io-tests.c",
          "lines": "28-64",
          "snippet": "static noinline int process_page_range(struct inode *inode, u64 start, u64 end,\n\t\t\t\t       unsigned long flags)\n{\n\tint ret;\n\tstruct page *pages[16];\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\tint count = 0;\n\tint loops = 0;\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long, nr_pages,\n\t\t\t\t     ARRAY_SIZE(pages)), pages);\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (flags & PROCESS_TEST_LOCKED &&\n\t\t\t    !PageLocked(pages[i]))\n\t\t\t\tcount++;\n\t\t\tif (flags & PROCESS_UNLOCK && PageLocked(pages[i]))\n\t\t\t\tunlock_page(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t\tif (flags & PROCESS_RELEASE)\n\t\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t\tloops++;\n\t\tif (loops > 100000) {\n\t\t\tprintk(KERN_ERR \"stuck in a loop, start %Lu, end %Lu, nr_pages %lu, ret %d\\n\", start, end, nr_pages, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"../extent_io.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [
            "#define PROCESS_TEST_LOCKED\t(1 << 2)",
            "#define PROCESS_RELEASE\t\t(1 << 1)",
            "#define PROCESS_UNLOCK\t\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../extent_io.h\"\n#include \"btrfs-tests.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define PROCESS_TEST_LOCKED\t(1 << 2)\n#define PROCESS_RELEASE\t\t(1 << 1)\n#define PROCESS_UNLOCK\t\t(1 << 0)\n\nstatic noinline int process_page_range(struct inode *inode, u64 start, u64 end,\n\t\t\t\t       unsigned long flags)\n{\n\tint ret;\n\tstruct page *pages[16];\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\tint count = 0;\n\tint loops = 0;\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long, nr_pages,\n\t\t\t\t     ARRAY_SIZE(pages)), pages);\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (flags & PROCESS_TEST_LOCKED &&\n\t\t\t    !PageLocked(pages[i]))\n\t\t\t\tcount++;\n\t\t\tif (flags & PROCESS_UNLOCK && PageLocked(pages[i]))\n\t\t\t\tunlock_page(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t\tif (flags & PROCESS_RELEASE)\n\t\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t\tloops++;\n\t\tif (loops > 100000) {\n\t\t\tprintk(KERN_ERR \"stuck in a loop, start %Lu, end %Lu, nr_pages %lu, ret %d\\n\", start, end, nr_pages, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "locked_page"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_extent_bits",
          "args": [
            "&tmp",
            "0",
            "total_dirty - 1",
            "(unsigned)-1",
            "GFP_NOFS"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "clear_extent_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1277-1281",
          "snippet": "int clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nint clear_extent_bits(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t      unsigned bits, gfp_t mask)\n{\n\treturn clear_extent_bit(tree, start, end, bits, 0, 0, NULL, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Pages in range were not all locked\\n\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected start %Lu end %Lu, got start %Lu end %Lu\\n\"",
            "test_start",
            "test_start + PAGE_CACHE_SIZE - 1",
            "start",
            "end"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Didn't find our range\\n\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_delalloc_range",
          "args": [
            "inode",
            "&tmp",
            "locked_page",
            "&start",
            "&end",
            "max_bytes"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "find_lock_delalloc_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1675-1753",
          "snippet": "STATIC u64 find_lock_delalloc_range(struct inode *inode,\n\t\t\t\t    struct extent_io_tree *tree,\n\t\t\t\t    struct page *locked_page, u64 *start,\n\t\t\t\t    u64 *end, u64 max_bytes)\n{\n\tu64 delalloc_start;\n\tu64 delalloc_end;\n\tu64 found;\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\tint loops = 0;\n\nagain:\n\t/* step one, find a bunch of delalloc bytes starting at start */\n\tdelalloc_start = *start;\n\tdelalloc_end = 0;\n\tfound = find_delalloc_range(tree, &delalloc_start, &delalloc_end,\n\t\t\t\t    max_bytes, &cached_state);\n\tif (!found || delalloc_end <= *start) {\n\t\t*start = delalloc_start;\n\t\t*end = delalloc_end;\n\t\tfree_extent_state(cached_state);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * start comes from the offset of locked_page.  We have to lock\n\t * pages in order, so we can't process delalloc bytes before\n\t * locked_page\n\t */\n\tif (delalloc_start < *start)\n\t\tdelalloc_start = *start;\n\n\t/*\n\t * make sure to limit the number of pages we try to lock down\n\t */\n\tif (delalloc_end + 1 - delalloc_start > max_bytes)\n\t\tdelalloc_end = delalloc_start + max_bytes - 1;\n\n\t/* step two, lock all the pages after the page that has start */\n\tret = lock_delalloc_pages(inode, locked_page,\n\t\t\t\t  delalloc_start, delalloc_end);\n\tif (ret == -EAGAIN) {\n\t\t/* some of the pages are gone, lets avoid looping by\n\t\t * shortening the size of the delalloc range we're searching\n\t\t */\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tif (!loops) {\n\t\t\tmax_bytes = PAGE_CACHE_SIZE;\n\t\t\tloops = 1;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tfound = 0;\n\t\t\tgoto out_failed;\n\t\t}\n\t}\n\tBUG_ON(ret); /* Only valid values are 0 and -EAGAIN */\n\n\t/* step three, lock the state bits for the whole range */\n\tlock_extent_bits(tree, delalloc_start, delalloc_end, 0, &cached_state);\n\n\t/* then test to make sure it is all still delalloc */\n\tret = test_range_bit(tree, delalloc_start, delalloc_end,\n\t\t\t     EXTENT_DELALLOC, 1, cached_state);\n\tif (!ret) {\n\t\tunlock_extent_cached(tree, delalloc_start, delalloc_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\t__unlock_for_delalloc(inode, locked_page,\n\t\t\t      delalloc_start, delalloc_end);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\n\tfree_extent_state(cached_state);\n\t*start = delalloc_start;\n\t*end = delalloc_end;\nout_failed:\n\treturn found;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void set_state_bits(struct extent_io_tree *tree,\n\t\t\t   struct extent_state *state, unsigned *bits);\n\nSTATIC u64 find_lock_delalloc_range(struct inode *inode,\n\t\t\t\t    struct extent_io_tree *tree,\n\t\t\t\t    struct page *locked_page, u64 *start,\n\t\t\t\t    u64 *end, u64 max_bytes)\n{\n\tu64 delalloc_start;\n\tu64 delalloc_end;\n\tu64 found;\n\tstruct extent_state *cached_state = NULL;\n\tint ret;\n\tint loops = 0;\n\nagain:\n\t/* step one, find a bunch of delalloc bytes starting at start */\n\tdelalloc_start = *start;\n\tdelalloc_end = 0;\n\tfound = find_delalloc_range(tree, &delalloc_start, &delalloc_end,\n\t\t\t\t    max_bytes, &cached_state);\n\tif (!found || delalloc_end <= *start) {\n\t\t*start = delalloc_start;\n\t\t*end = delalloc_end;\n\t\tfree_extent_state(cached_state);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * start comes from the offset of locked_page.  We have to lock\n\t * pages in order, so we can't process delalloc bytes before\n\t * locked_page\n\t */\n\tif (delalloc_start < *start)\n\t\tdelalloc_start = *start;\n\n\t/*\n\t * make sure to limit the number of pages we try to lock down\n\t */\n\tif (delalloc_end + 1 - delalloc_start > max_bytes)\n\t\tdelalloc_end = delalloc_start + max_bytes - 1;\n\n\t/* step two, lock all the pages after the page that has start */\n\tret = lock_delalloc_pages(inode, locked_page,\n\t\t\t\t  delalloc_start, delalloc_end);\n\tif (ret == -EAGAIN) {\n\t\t/* some of the pages are gone, lets avoid looping by\n\t\t * shortening the size of the delalloc range we're searching\n\t\t */\n\t\tfree_extent_state(cached_state);\n\t\tcached_state = NULL;\n\t\tif (!loops) {\n\t\t\tmax_bytes = PAGE_CACHE_SIZE;\n\t\t\tloops = 1;\n\t\t\tgoto again;\n\t\t} else {\n\t\t\tfound = 0;\n\t\t\tgoto out_failed;\n\t\t}\n\t}\n\tBUG_ON(ret); /* Only valid values are 0 and -EAGAIN */\n\n\t/* step three, lock the state bits for the whole range */\n\tlock_extent_bits(tree, delalloc_start, delalloc_end, 0, &cached_state);\n\n\t/* then test to make sure it is all still delalloc */\n\tret = test_range_bit(tree, delalloc_start, delalloc_end,\n\t\t\t     EXTENT_DELALLOC, 1, cached_state);\n\tif (!ret) {\n\t\tunlock_extent_cached(tree, delalloc_start, delalloc_end,\n\t\t\t\t     &cached_state, GFP_NOFS);\n\t\t__unlock_for_delalloc(inode, locked_page,\n\t\t\t      delalloc_start, delalloc_end);\n\t\tcond_resched();\n\t\tgoto again;\n\t}\n\tfree_extent_state(cached_state);\n\t*start = delalloc_start;\n\t*end = delalloc_end;\nout_failed:\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "locked_page"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageDirty",
          "args": [
            "page"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't find our page\\n\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "inode->i_mapping",
            "(max_bytes + (1 * 1024 * 1024))\n\t\t\t     >> PAGE_CACHE_SHIFT"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_extent",
          "args": [
            "&tmp",
            "start",
            "end"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1380-1384",
          "snippet": "int unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint unlock_extent(struct extent_io_tree *tree, u64 start, u64 end)\n{\n\treturn clear_extent_bit(tree, start, end, EXTENT_LOCKED, 1, 0, NULL,\n\t\t\t\tGFP_NOFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Pages in range were not all locked\\n\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected start %Lu end %Lu, got start %Lu end %Lu\\n\"",
            "test_start",
            "total_dirty - 1",
            "start",
            "end"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Didn't find our range\\n\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_extent_delalloc",
          "args": [
            "&tmp",
            "max_bytes",
            "total_dirty - 1",
            "NULL",
            "GFP_NOFS"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "set_extent_delalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "1283-1289",
          "snippet": "int set_extent_delalloc(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\tstruct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end,\n\t\t\t      EXTENT_DELALLOC | EXTENT_UPTODATE,\n\t\t\t      NULL, cached_state, mask);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint set_extent_delalloc(struct extent_io_tree *tree, u64 start, u64 end,\n\t\t\tstruct extent_state **cached_state, gfp_t mask)\n{\n\treturn set_extent_bit(tree, start, end,\n\t\t\t      EXTENT_DELALLOC | EXTENT_UPTODATE,\n\t\t\t      NULL, cached_state, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Did not return the proper end offset\\n\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Found range when we shouldn't have\\n\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Could'nt find the locked page\\n\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "inode->i_mapping",
            "test_start >>\n\t\t\t\t     PAGE_CACHE_SHIFT"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "locked_page"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"There were unlocked pages in the range\\n\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected start %Lu end %Lu, got start %Lu, end \"\n\t\t\t \"%Lu\\n\"",
            "test_start",
            "max_bytes - 1",
            "start",
            "end"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't find delalloc in our range\\n\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Couldn't find the locked page\\n\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "inode->i_mapping",
            "test_start >> PAGE_CACHE_SHIFT"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "locked_page"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Expected start 0 end 4095, got start %Lu end %Lu\\n\"",
            "start",
            "end"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "nlm4svc_proc_test_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/lockd/svc4proc.c",
          "lines": "276-281",
          "snippet": "static __be32 nlm4svc_proc_test_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: TEST_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_TEST_RES, argp, nlm4svc_proc_test);\n}",
          "includes": [
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/lockd/share.h>",
            "#include <linux/lockd/lockd.h>",
            "#include <linux/time.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sunrpc/svc_xprt.h>\n#include <linux/lockd/share.h>\n#include <linux/lockd/lockd.h>\n#include <linux/time.h>\n#include <linux/types.h>\n\nstatic __be32 nlm4svc_proc_test_msg(struct svc_rqst *rqstp, struct nlm_args *argp,\n\t\t\t\t\t     void\t     *resp)\n{\n\tdprintk(\"lockd: TEST_MSG      called\\n\");\n\treturn nlm4svc_callback(rqstp, NLMPROC_TEST_RES, argp, nlm4svc_proc_test);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Should have found at least one delalloc\\n\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_get",
          "args": [
            "page"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageDirty",
          "args": [
            "page"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Failed to allocate test page\\n\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_io_tree_init",
          "args": [
            "&tmp",
            "&inode->i_data"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "198-206",
          "snippet": "void extent_io_tree_init(struct extent_io_tree *tree,\n\t\t\t struct address_space *mapping)\n{\n\ttree->state = RB_ROOT;\n\ttree->ops = NULL;\n\ttree->dirty_bytes = 0;\n\tspin_lock_init(&tree->lock);\n\ttree->mapping = mapping;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid extent_io_tree_init(struct extent_io_tree *tree,\n\t\t\t struct address_space *mapping)\n{\n\ttree->state = RB_ROOT;\n\ttree->ops = NULL;\n\ttree->dirty_bytes = 0;\n\tspin_lock_init(&tree->lock);\n\ttree->mapping = mapping;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_msg",
          "args": [
            "\"Failed to allocate test inode\\n\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_new_test_inode",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_new_test_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "49-52",
          "snippet": "struct inode *btrfs_new_test_inode(void)\n{\n\treturn new_inode(test_mnt->mnt_sb);\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *test_mnt = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *test_mnt = NULL;\n\nstruct inode *btrfs_new_test_inode(void)\n{\n\treturn new_inode(test_mnt->mnt_sb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"../extent_io.h\"\n#include \"btrfs-tests.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define PROCESS_TEST_LOCKED\t(1 << 2)\n#define PROCESS_RELEASE\t\t(1 << 1)\n#define PROCESS_UNLOCK\t\t(1 << 0)\n\nstatic int test_find_delalloc(void)\n{\n\tstruct inode *inode;\n\tstruct extent_io_tree tmp;\n\tstruct page *page;\n\tstruct page *locked_page = NULL;\n\tunsigned long index = 0;\n\tu64 total_dirty = 256 * 1024 * 1024;\n\tu64 max_bytes = 128 * 1024 * 1024;\n\tu64 start, end, test_start;\n\tu64 found;\n\tint ret = -EINVAL;\n\n\tinode = btrfs_new_test_inode();\n\tif (!inode) {\n\t\ttest_msg(\"Failed to allocate test inode\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\textent_io_tree_init(&tmp, &inode->i_data);\n\n\t/*\n\t * First go through and create and mark all of our pages dirty, we pin\n\t * everything to make sure our pages don't get evicted and screw up our\n\t * test.\n\t */\n\tfor (index = 0; index < (total_dirty >> PAGE_CACHE_SHIFT); index++) {\n\t\tpage = find_or_create_page(inode->i_mapping, index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\ttest_msg(\"Failed to allocate test page\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tSetPageDirty(page);\n\t\tif (index) {\n\t\t\tunlock_page(page);\n\t\t} else {\n\t\t\tpage_cache_get(page);\n\t\t\tlocked_page = page;\n\t\t}\n\t}\n\n\t/* Test this scenario\n\t * |--- delalloc ---|\n\t * |---  search  ---|\n\t */\n\tset_extent_delalloc(&tmp, 0, 4095, NULL, GFP_NOFS);\n\tstart = 0;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Should have found at least one delalloc\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != 0 || end != 4095) {\n\t\ttest_msg(\"Expected start 0 end 4095, got start %Lu end %Lu\\n\",\n\t\t\t start, end);\n\t\tgoto out_bits;\n\t}\n\tunlock_extent(&tmp, start, end);\n\tunlock_page(locked_page);\n\tpage_cache_release(locked_page);\n\n\t/*\n\t * Test this scenario\n\t *\n\t * |--- delalloc ---|\n\t *           |--- search ---|\n\t */\n\ttest_start = 64 * 1024 * 1024;\n\tlocked_page = find_lock_page(inode->i_mapping,\n\t\t\t\t     test_start >> PAGE_CACHE_SHIFT);\n\tif (!locked_page) {\n\t\ttest_msg(\"Couldn't find the locked page\\n\");\n\t\tgoto out_bits;\n\t}\n\tset_extent_delalloc(&tmp, 4096, max_bytes - 1, NULL, GFP_NOFS);\n\tstart = test_start;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Couldn't find delalloc in our range\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != test_start || end != max_bytes - 1) {\n\t\ttest_msg(\"Expected start %Lu end %Lu, got start %Lu, end \"\n\t\t\t \"%Lu\\n\", test_start, max_bytes - 1, start, end);\n\t\tgoto out_bits;\n\t}\n\tif (process_page_range(inode, start, end,\n\t\t\t       PROCESS_TEST_LOCKED | PROCESS_UNLOCK)) {\n\t\ttest_msg(\"There were unlocked pages in the range\\n\");\n\t\tgoto out_bits;\n\t}\n\tunlock_extent(&tmp, start, end);\n\t/* locked_page was unlocked above */\n\tpage_cache_release(locked_page);\n\n\t/*\n\t * Test this scenario\n\t * |--- delalloc ---|\n\t *                    |--- search ---|\n\t */\n\ttest_start = max_bytes + 4096;\n\tlocked_page = find_lock_page(inode->i_mapping, test_start >>\n\t\t\t\t     PAGE_CACHE_SHIFT);\n\tif (!locked_page) {\n\t\ttest_msg(\"Could'nt find the locked page\\n\");\n\t\tgoto out_bits;\n\t}\n\tstart = test_start;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (found) {\n\t\ttest_msg(\"Found range when we shouldn't have\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (end != (u64)-1) {\n\t\ttest_msg(\"Did not return the proper end offset\\n\");\n\t\tgoto out_bits;\n\t}\n\n\t/*\n\t * Test this scenario\n\t * [------- delalloc -------|\n\t * [max_bytes]|-- search--|\n\t *\n\t * We are re-using our test_start from above since it works out well.\n\t */\n\tset_extent_delalloc(&tmp, max_bytes, total_dirty - 1, NULL, GFP_NOFS);\n\tstart = test_start;\n\tend = 0;\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Didn't find our range\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != test_start || end != total_dirty - 1) {\n\t\ttest_msg(\"Expected start %Lu end %Lu, got start %Lu end %Lu\\n\",\n\t\t\t test_start, total_dirty - 1, start, end);\n\t\tgoto out_bits;\n\t}\n\tif (process_page_range(inode, start, end,\n\t\t\t       PROCESS_TEST_LOCKED | PROCESS_UNLOCK)) {\n\t\ttest_msg(\"Pages in range were not all locked\\n\");\n\t\tgoto out_bits;\n\t}\n\tunlock_extent(&tmp, start, end);\n\n\t/*\n\t * Now to test where we run into a page that is no longer dirty in the\n\t * range we want to find.\n\t */\n\tpage = find_get_page(inode->i_mapping, (max_bytes + (1 * 1024 * 1024))\n\t\t\t     >> PAGE_CACHE_SHIFT);\n\tif (!page) {\n\t\ttest_msg(\"Couldn't find our page\\n\");\n\t\tgoto out_bits;\n\t}\n\tClearPageDirty(page);\n\tpage_cache_release(page);\n\n\t/* We unlocked it in the previous test */\n\tlock_page(locked_page);\n\tstart = test_start;\n\tend = 0;\n\t/*\n\t * Currently if we fail to find dirty pages in the delalloc range we\n\t * will adjust max_bytes down to PAGE_CACHE_SIZE and then re-search.  If\n\t * this changes at any point in the future we will need to fix this\n\t * tests expected behavior.\n\t */\n\tfound = find_lock_delalloc_range(inode, &tmp, locked_page, &start,\n\t\t\t\t\t &end, max_bytes);\n\tif (!found) {\n\t\ttest_msg(\"Didn't find our range\\n\");\n\t\tgoto out_bits;\n\t}\n\tif (start != test_start && end != test_start + PAGE_CACHE_SIZE - 1) {\n\t\ttest_msg(\"Expected start %Lu end %Lu, got start %Lu end %Lu\\n\",\n\t\t\t test_start, test_start + PAGE_CACHE_SIZE - 1, start,\n\t\t\t end);\n\t\tgoto out_bits;\n\t}\n\tif (process_page_range(inode, start, end, PROCESS_TEST_LOCKED |\n\t\t\t       PROCESS_UNLOCK)) {\n\t\ttest_msg(\"Pages in range were not all locked\\n\");\n\t\tgoto out_bits;\n\t}\n\tret = 0;\nout_bits:\n\tclear_extent_bits(&tmp, 0, total_dirty - 1, (unsigned)-1, GFP_NOFS);\nout:\n\tif (locked_page)\n\t\tpage_cache_release(locked_page);\n\tprocess_page_range(inode, 0, total_dirty - 1,\n\t\t\t   PROCESS_UNLOCK | PROCESS_RELEASE);\n\tiput(inode);\n\treturn ret;\n}"
  },
  {
    "function_name": "process_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/extent-io-tests.c",
    "lines": "28-64",
    "snippet": "static noinline int process_page_range(struct inode *inode, u64 start, u64 end,\n\t\t\t\t       unsigned long flags)\n{\n\tint ret;\n\tstruct page *pages[16];\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\tint count = 0;\n\tint loops = 0;\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long, nr_pages,\n\t\t\t\t     ARRAY_SIZE(pages)), pages);\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (flags & PROCESS_TEST_LOCKED &&\n\t\t\t    !PageLocked(pages[i]))\n\t\t\t\tcount++;\n\t\t\tif (flags & PROCESS_UNLOCK && PageLocked(pages[i]))\n\t\t\t\tunlock_page(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t\tif (flags & PROCESS_RELEASE)\n\t\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t\tloops++;\n\t\tif (loops > 100000) {\n\t\t\tprintk(KERN_ERR \"stuck in a loop, start %Lu, end %Lu, nr_pages %lu, ret %d\\n\", start, end, nr_pages, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"../extent_io.h\"",
      "#include \"btrfs-tests.h\"",
      "#include <linux/sched.h>",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [
      "#define PROCESS_TEST_LOCKED\t(1 << 2)",
      "#define PROCESS_RELEASE\t\t(1 << 1)",
      "#define PROCESS_UNLOCK\t\t(1 << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"stuck in a loop, start %Lu, end %Lu, nr_pages %lu, ret %d\\n\"",
            "start",
            "end",
            "nr_pages",
            "ret"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[i]"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pages[i]"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "pages[i]"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "pages[i]"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages_contig",
          "args": [
            "inode->i_mapping",
            "index",
            "min_t(unsigned long, nr_pages,\n\t\t\t\t     ARRAY_SIZE(pages))",
            "pages"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "nr_pages",
            "ARRAY_SIZE(pages)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "pages"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"../extent_io.h\"\n#include \"btrfs-tests.h\"\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\n#define PROCESS_TEST_LOCKED\t(1 << 2)\n#define PROCESS_RELEASE\t\t(1 << 1)\n#define PROCESS_UNLOCK\t\t(1 << 0)\n\nstatic noinline int process_page_range(struct inode *inode, u64 start, u64 end,\n\t\t\t\t       unsigned long flags)\n{\n\tint ret;\n\tstruct page *pages[16];\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tunsigned long end_index = end >> PAGE_CACHE_SHIFT;\n\tunsigned long nr_pages = end_index - index + 1;\n\tint i;\n\tint count = 0;\n\tint loops = 0;\n\n\twhile (nr_pages > 0) {\n\t\tret = find_get_pages_contig(inode->i_mapping, index,\n\t\t\t\t     min_t(unsigned long, nr_pages,\n\t\t\t\t     ARRAY_SIZE(pages)), pages);\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (flags & PROCESS_TEST_LOCKED &&\n\t\t\t    !PageLocked(pages[i]))\n\t\t\t\tcount++;\n\t\t\tif (flags & PROCESS_UNLOCK && PageLocked(pages[i]))\n\t\t\t\tunlock_page(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t\tif (flags & PROCESS_RELEASE)\n\t\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t\tnr_pages -= ret;\n\t\tindex += ret;\n\t\tcond_resched();\n\t\tloops++;\n\t\tif (loops > 100000) {\n\t\t\tprintk(KERN_ERR \"stuck in a loop, start %Lu, end %Lu, nr_pages %lu, ret %d\\n\", start, end, nr_pages, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}"
  }
]