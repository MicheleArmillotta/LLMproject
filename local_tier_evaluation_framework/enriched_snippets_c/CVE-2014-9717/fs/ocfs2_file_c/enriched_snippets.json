[
  {
    "function_name": "ocfs2_file_llseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "2605-2652",
    "snippet": "static loff_t ocfs2_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_END:\n\t\t/* SEEK_END requires the OCFS2 inode lock for the file\n\t\t * because it references the file's size.\n\t\t */\n\t\tret = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\toffset += i_size_read(inode);\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tif (offset == 0) {\n\t\t\toffset = file->f_pos;\n\t\t\tgoto out;\n\t\t}\n\t\toffset += file->f_pos;\n\t\tbreak;\n\tcase SEEK_DATA:\n\tcase SEEK_HOLE:\n\t\tret = ocfs2_seek_data_hole_offset(file, &offset, whence);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\toffset = vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret)\n\t\treturn ret;\n\treturn offset;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_setpos",
          "args": [
            "file",
            "offset",
            "inode->i_sb->s_maxbytes"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_setpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "57-69",
          "snippet": "loff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_setpos(struct file *file, loff_t offset, loff_t maxsize)\n{\n\tif (offset < 0 && !unsigned_offsets(file))\n\t\treturn -EINVAL;\n\tif (offset > maxsize)\n\t\treturn -EINVAL;\n\n\tif (offset != file->f_pos) {\n\t\tfile->f_pos = offset;\n\t\tfile->f_version = 0;\n\t}\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_seek_data_hole_offset",
          "args": [
            "file",
            "&offset",
            "whence"
          ],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_seek_data_hole_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "833-925",
          "snippet": "int ocfs2_seek_data_hole_offset(struct file *file, loff_t *offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\tunsigned int is_last = 0, is_data = 0;\n\tu16 cs_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 cpos, cend, clen, hole_size;\n\tu64 extoff, extlen;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tBUG_ON(whence != SEEK_DATA && whence != SEEK_HOLE);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tif (*offset >= i_size_read(inode)) {\n\t\tret = -ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tif (whence == SEEK_HOLE)\n\t\t\t*offset = i_size_read(inode);\n\t\tgoto out_unlock;\n\t}\n\n\tclen = 0;\n\tcpos = *offset >> cs_bits;\n\tcend = ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode));\n\n\twhile (cpos < cend && !is_last) {\n\t\tret = ocfs2_get_clusters_nocache(inode, di_bh, cpos, &hole_size,\n\t\t\t\t\t\t &rec, &is_last);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\textoff = cpos;\n\t\textoff <<= cs_bits;\n\n\t\tif (rec.e_blkno == 0ULL) {\n\t\t\tclen = hole_size;\n\t\t\tis_data = 0;\n\t\t} else {\n\t\t\tclen = le16_to_cpu(rec.e_leaf_clusters) -\n\t\t\t\t(cpos - le32_to_cpu(rec.e_cpos));\n\t\t\tis_data = (rec.e_flags & OCFS2_EXT_UNWRITTEN) ?  0 : 1;\n\t\t}\n\n\t\tif ((!is_data && whence == SEEK_HOLE) ||\n\t\t    (is_data && whence == SEEK_DATA)) {\n\t\t\tif (extoff > *offset)\n\t\t\t\t*offset = extoff;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (!is_last)\n\t\t\tcpos += clen;\n\t}\n\n\tif (whence == SEEK_HOLE) {\n\t\textoff = cpos;\n\t\textoff <<= cs_bits;\n\t\textlen = clen;\n\t\textlen <<=  cs_bits;\n\n\t\tif ((extoff + extlen) > i_size_read(inode))\n\t\t\textlen = i_size_read(inode) - extoff;\n\t\textoff += extlen;\n\t\tif (extoff > *offset)\n\t\t\t*offset = extoff;\n\t\tgoto out_unlock;\n\t}\n\n\tret = -ENXIO;\n\nout_unlock:\n\n\tbrelse(di_bh);\n\n\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_inode_unlock(inode, 0);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_seek_data_hole_offset(struct file *file, loff_t *offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret;\n\tunsigned int is_last = 0, is_data = 0;\n\tu16 cs_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 cpos, cend, clen, hole_size;\n\tu64 extoff, extlen;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tBUG_ON(whence != SEEK_DATA && whence != SEEK_HOLE);\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tdown_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tif (*offset >= i_size_read(inode)) {\n\t\tret = -ENXIO;\n\t\tgoto out_unlock;\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tif (whence == SEEK_HOLE)\n\t\t\t*offset = i_size_read(inode);\n\t\tgoto out_unlock;\n\t}\n\n\tclen = 0;\n\tcpos = *offset >> cs_bits;\n\tcend = ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode));\n\n\twhile (cpos < cend && !is_last) {\n\t\tret = ocfs2_get_clusters_nocache(inode, di_bh, cpos, &hole_size,\n\t\t\t\t\t\t &rec, &is_last);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\textoff = cpos;\n\t\textoff <<= cs_bits;\n\n\t\tif (rec.e_blkno == 0ULL) {\n\t\t\tclen = hole_size;\n\t\t\tis_data = 0;\n\t\t} else {\n\t\t\tclen = le16_to_cpu(rec.e_leaf_clusters) -\n\t\t\t\t(cpos - le32_to_cpu(rec.e_cpos));\n\t\t\tis_data = (rec.e_flags & OCFS2_EXT_UNWRITTEN) ?  0 : 1;\n\t\t}\n\n\t\tif ((!is_data && whence == SEEK_HOLE) ||\n\t\t    (is_data && whence == SEEK_DATA)) {\n\t\t\tif (extoff > *offset)\n\t\t\t\t*offset = extoff;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (!is_last)\n\t\t\tcpos += clen;\n\t}\n\n\tif (whence == SEEK_HOLE) {\n\t\textoff = cpos;\n\t\textoff <<= cs_bits;\n\t\textlen = clen;\n\t\textlen <<=  cs_bits;\n\n\t\tif ((extoff + extlen) > i_size_read(inode))\n\t\t\textlen = i_size_read(inode) - extoff;\n\t\textoff += extlen;\n\t\tif (extoff > *offset)\n\t\t\t*offset = extoff;\n\t\tgoto out_unlock;\n\t}\n\n\tret = -ENXIO;\n\nout_unlock:\n\n\tbrelse(di_bh);\n\n\tup_read(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_inode_unlock(inode, 0);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "0"
          ],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "NULL",
            "0"
          ],
          "line": 2619
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic loff_t ocfs2_file_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file->f_mapping->host;\n\tint ret = 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tswitch (whence) {\n\tcase SEEK_SET:\n\t\tbreak;\n\tcase SEEK_END:\n\t\t/* SEEK_END requires the OCFS2 inode lock for the file\n\t\t * because it references the file's size.\n\t\t */\n\t\tret = ocfs2_inode_lock(inode, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\toffset += i_size_read(inode);\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tif (offset == 0) {\n\t\t\toffset = file->f_pos;\n\t\t\tgoto out;\n\t\t}\n\t\toffset += file->f_pos;\n\t\tbreak;\n\tcase SEEK_DATA:\n\tcase SEEK_HOLE:\n\t\tret = ocfs2_seek_data_hole_offset(file, &offset, whence);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\toffset = vfs_setpos(file, offset, inode->i_sb->s_maxbytes);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret)\n\t\treturn ret;\n\treturn offset;\n}"
  },
  {
    "function_name": "ocfs2_file_read_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "2526-2602",
    "snippet": "static ssize_t ocfs2_file_read_iter(struct kiocb *iocb,\n\t\t\t\t   struct iov_iter *to)\n{\n\tint ret = 0, rw_level = -1, have_alloc_sem = 0, lock_level = 0;\n\tstruct file *filp = iocb->ki_filp;\n\tstruct inode *inode = file_inode(filp);\n\n\ttrace_ocfs2_file_aio_read(inode, filp, filp->f_path.dentry,\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tfilp->f_path.dentry->d_name.len,\n\t\t\tfilp->f_path.dentry->d_name.name,\n\t\t\tto->nr_segs);\t/* GRRRRR */\n\n\n\tif (!inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tocfs2_iocb_clear_sem_locked(iocb);\n\n\t/*\n\t * buffered reads protect themselves in ->readpage().  O_DIRECT reads\n\t * need locks to protect pending reads from racing with truncate.\n\t */\n\tif (filp->f_flags & O_DIRECT) {\n\t\thave_alloc_sem = 1;\n\t\tocfs2_iocb_set_sem_locked(iocb);\n\n\t\tret = ocfs2_rw_lock(inode, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t\trw_level = 0;\n\t\t/* communicate with ocfs2_dio_end_io */\n\t\tocfs2_iocb_set_rw_locked(iocb, rw_level);\n\t}\n\n\t/*\n\t * We're fine letting folks race truncates and extending\n\t * writes with read across the cluster, just like they can\n\t * locally. Hence no rw_lock during read.\n\t *\n\t * Take and drop the meta data lock to update inode fields\n\t * like i_size. This allows the checks down below\n\t * generic_file_aio_read() a chance of actually working.\n\t */\n\tret = ocfs2_inode_lock_atime(inode, filp->f_path.mnt, &lock_level);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\tocfs2_inode_unlock(inode, lock_level);\n\n\tret = generic_file_read_iter(iocb, to);\n\ttrace_generic_file_aio_read_ret(ret);\n\n\t/* buffered aio wouldn't have proper lock coverage today */\n\tBUG_ON(ret == -EIOCBQUEUED && !(filp->f_flags & O_DIRECT));\n\n\t/* see ocfs2_file_write_iter */\n\tif (ret == -EIOCBQUEUED || !ocfs2_iocb_is_rw_locked(iocb)) {\n\t\trw_level = -1;\n\t\thave_alloc_sem = 0;\n\t}\n\nbail:\n\tif (have_alloc_sem)\n\t\tocfs2_iocb_clear_sem_locked(iocb);\n\n\tif (rw_level != -1)\n\t\tocfs2_rw_unlock(inode, rw_level);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_rw_unlock",
          "args": [
            "inode",
            "rw_level"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1692-1704",
          "snippet": "void ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_iocb_clear_sem_locked",
          "args": [
            "iocb"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iocb_is_rw_locked",
          "args": [
            "iocb"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == -EIOCBQUEUED && !(filp->f_flags & O_DIRECT)"
          ],
          "line": 2586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_generic_file_aio_read_ret",
          "args": [
            "ret"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_read_iter",
          "args": [
            "iocb",
            "to"
          ],
          "line": 2582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "lock_level"
          ],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_atime",
          "args": [
            "inode",
            "filp->f_path.mnt",
            "&lock_level"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_iocb_set_rw_locked",
          "args": [
            "iocb",
            "rw_level"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iocb_set_rw_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.h",
          "lines": "65-72",
          "snippet": "static inline void ocfs2_iocb_set_rw_locked(struct kiocb *iocb, int level)\n{\n\tset_bit(0, (unsigned long *)&iocb->private);\n\tif (level)\n\t\tset_bit(1, (unsigned long *)&iocb->private);\n\telse\n\t\tclear_bit(1, (unsigned long *)&iocb->private);\n}",
          "includes": [
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n\nstatic inline void ocfs2_iocb_set_rw_locked(struct kiocb *iocb, int level)\n{\n\tset_bit(0, (unsigned long *)&iocb->private);\n\tif (level)\n\t\tset_bit(1, (unsigned long *)&iocb->private);\n\telse\n\t\tclear_bit(1, (unsigned long *)&iocb->private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_lock",
          "args": [
            "inode",
            "0"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1665-1690",
          "snippet": "int ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_iocb_set_sem_locked",
          "args": [
            "iocb"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iocb_clear_sem_locked",
          "args": [
            "iocb"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_file_aio_read",
          "args": [
            "inode",
            "filp",
            "filp->f_path.dentry",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "filp->f_path.dentry->d_name.len",
            "filp->f_path.dentry->d_name.name",
            "to->nr_segs"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic ssize_t ocfs2_file_read_iter(struct kiocb *iocb,\n\t\t\t\t   struct iov_iter *to)\n{\n\tint ret = 0, rw_level = -1, have_alloc_sem = 0, lock_level = 0;\n\tstruct file *filp = iocb->ki_filp;\n\tstruct inode *inode = file_inode(filp);\n\n\ttrace_ocfs2_file_aio_read(inode, filp, filp->f_path.dentry,\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tfilp->f_path.dentry->d_name.len,\n\t\t\tfilp->f_path.dentry->d_name.name,\n\t\t\tto->nr_segs);\t/* GRRRRR */\n\n\n\tif (!inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tocfs2_iocb_clear_sem_locked(iocb);\n\n\t/*\n\t * buffered reads protect themselves in ->readpage().  O_DIRECT reads\n\t * need locks to protect pending reads from racing with truncate.\n\t */\n\tif (filp->f_flags & O_DIRECT) {\n\t\thave_alloc_sem = 1;\n\t\tocfs2_iocb_set_sem_locked(iocb);\n\n\t\tret = ocfs2_rw_lock(inode, 0);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t\trw_level = 0;\n\t\t/* communicate with ocfs2_dio_end_io */\n\t\tocfs2_iocb_set_rw_locked(iocb, rw_level);\n\t}\n\n\t/*\n\t * We're fine letting folks race truncates and extending\n\t * writes with read across the cluster, just like they can\n\t * locally. Hence no rw_lock during read.\n\t *\n\t * Take and drop the meta data lock to update inode fields\n\t * like i_size. This allows the checks down below\n\t * generic_file_aio_read() a chance of actually working.\n\t */\n\tret = ocfs2_inode_lock_atime(inode, filp->f_path.mnt, &lock_level);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\tocfs2_inode_unlock(inode, lock_level);\n\n\tret = generic_file_read_iter(iocb, to);\n\ttrace_generic_file_aio_read_ret(ret);\n\n\t/* buffered aio wouldn't have proper lock coverage today */\n\tBUG_ON(ret == -EIOCBQUEUED && !(filp->f_flags & O_DIRECT));\n\n\t/* see ocfs2_file_write_iter */\n\tif (ret == -EIOCBQUEUED || !ocfs2_iocb_is_rw_locked(iocb)) {\n\t\trw_level = -1;\n\t\thave_alloc_sem = 0;\n\t}\n\nbail:\n\tif (have_alloc_sem)\n\t\tocfs2_iocb_clear_sem_locked(iocb);\n\n\tif (rw_level != -1)\n\t\tocfs2_rw_unlock(inode, rw_level);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_file_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "2496-2524",
    "snippet": "static ssize_t ocfs2_file_splice_read(struct file *in,\n\t\t\t\t      loff_t *ppos,\n\t\t\t\t      struct pipe_inode_info *pipe,\n\t\t\t\t      size_t len,\n\t\t\t\t      unsigned int flags)\n{\n\tint ret = 0, lock_level = 0;\n\tstruct inode *inode = file_inode(in);\n\n\ttrace_ocfs2_file_splice_read(inode, in, in->f_path.dentry,\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tin->f_path.dentry->d_name.len,\n\t\t\tin->f_path.dentry->d_name.name, len);\n\n\t/*\n\t * See the comment in ocfs2_file_read_iter()\n\t */\n\tret = ocfs2_inode_lock_atime(inode, in->f_path.mnt, &lock_level);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\tocfs2_inode_unlock(inode, lock_level);\n\n\tret = generic_file_splice_read(in, ppos, pipe, len, flags);\n\nbail:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_splice_read",
          "args": [
            "in",
            "ppos",
            "pipe",
            "len",
            "flags"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_splice_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "520-542",
          "snippet": "ssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tloff_t isize, left;\n\tint ret;\n\n\tisize = i_size_read(in->f_mapping->host);\n\tif (unlikely(*ppos >= isize))\n\t\treturn 0;\n\n\tleft = isize - *ppos;\n\tif (unlikely(left < len))\n\t\tlen = left;\n\n\tret = __generic_file_splice_read(in, ppos, pipe, len, flags);\n\tif (ret > 0) {\n\t\t*ppos += ret;\n\t\tfile_accessed(in);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tloff_t isize, left;\n\tint ret;\n\n\tisize = i_size_read(in->f_mapping->host);\n\tif (unlikely(*ppos >= isize))\n\t\treturn 0;\n\n\tleft = isize - *ppos;\n\tif (unlikely(left < len))\n\t\tlen = left;\n\n\tret = __generic_file_splice_read(in, ppos, pipe, len, flags);\n\tif (ret > 0) {\n\t\t*ppos += ret;\n\t\tfile_accessed(in);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "lock_level"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_atime",
          "args": [
            "inode",
            "in->f_path.mnt",
            "&lock_level"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_file_splice_read",
          "args": [
            "inode",
            "in",
            "in->f_path.dentry",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "in->f_path.dentry->d_name.len",
            "in->f_path.dentry->d_name.name",
            "len"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "in"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic ssize_t ocfs2_file_splice_read(struct file *in,\n\t\t\t\t      loff_t *ppos,\n\t\t\t\t      struct pipe_inode_info *pipe,\n\t\t\t\t      size_t len,\n\t\t\t\t      unsigned int flags)\n{\n\tint ret = 0, lock_level = 0;\n\tstruct inode *inode = file_inode(in);\n\n\ttrace_ocfs2_file_splice_read(inode, in, in->f_path.dentry,\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tin->f_path.dentry->d_name.len,\n\t\t\tin->f_path.dentry->d_name.name, len);\n\n\t/*\n\t * See the comment in ocfs2_file_read_iter()\n\t */\n\tret = ocfs2_inode_lock_atime(inode, in->f_path.mnt, &lock_level);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\tocfs2_inode_unlock(inode, lock_level);\n\n\tret = generic_file_splice_read(in, ppos, pipe, len, flags);\n\nbail:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_file_write_iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "2260-2494",
    "snippet": "static ssize_t ocfs2_file_write_iter(struct kiocb *iocb,\n\t\t\t\t    struct iov_iter *from)\n{\n\tint ret, direct_io, appending, rw_level, have_alloc_sem  = 0;\n\tint can_do_direct, has_refcount = 0;\n\tssize_t written = 0;\n\tsize_t count = iov_iter_count(from);\n\tloff_t old_size, *ppos = &iocb->ki_pos;\n\tu32 old_clusters;\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint full_coherency = !(osb->s_mount_opt &\n\t\t\t       OCFS2_MOUNT_COHERENCY_BUFFERED);\n\tint unaligned_dio = 0;\n\n\ttrace_ocfs2_file_aio_write(inode, file, file->f_path.dentry,\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tfile->f_path.dentry->d_name.len,\n\t\tfile->f_path.dentry->d_name.name,\n\t\t(unsigned int)from->nr_segs);\t/* GRRRRR */\n\n\tif (iocb->ki_nbytes == 0)\n\t\treturn 0;\n\n\tappending = file->f_flags & O_APPEND ? 1 : 0;\n\tdirect_io = file->f_flags & O_DIRECT ? 1 : 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tocfs2_iocb_clear_sem_locked(iocb);\n\nrelock:\n\t/* to match setattr's i_mutex -> rw_lock ordering */\n\tif (direct_io) {\n\t\thave_alloc_sem = 1;\n\t\t/* communicate with ocfs2_dio_end_io */\n\t\tocfs2_iocb_set_sem_locked(iocb);\n\t}\n\n\t/*\n\t * Concurrent O_DIRECT writes are allowed with\n\t * mount_option \"coherency=buffered\".\n\t */\n\trw_level = (!direct_io || full_coherency);\n\n\tret = ocfs2_rw_lock(inode, rw_level);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_sems;\n\t}\n\n\t/*\n\t * O_DIRECT writes with \"coherency=full\" need to take EX cluster\n\t * inode_lock to guarantee coherency.\n\t */\n\tif (direct_io && full_coherency) {\n\t\t/*\n\t\t * We need to take and drop the inode lock to force\n\t\t * other nodes to drop their caches.  Buffered I/O\n\t\t * already does this in write_begin().\n\t\t */\n\t\tret = ocfs2_inode_lock(inode, NULL, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_inode_unlock(inode, 1);\n\t}\n\n\tcan_do_direct = direct_io;\n\tret = ocfs2_prepare_inode_for_write(file, ppos,\n\t\t\t\t\t    iocb->ki_nbytes, appending,\n\t\t\t\t\t    &can_do_direct, &has_refcount);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (direct_io && !is_sync_kiocb(iocb))\n\t\tunaligned_dio = ocfs2_is_io_unaligned(inode, iocb->ki_nbytes,\n\t\t\t\t\t\t      *ppos);\n\n\t/*\n\t * We can't complete the direct I/O as requested, fall back to\n\t * buffered I/O.\n\t */\n\tif (direct_io && !can_do_direct) {\n\t\tocfs2_rw_unlock(inode, rw_level);\n\n\t\thave_alloc_sem = 0;\n\t\trw_level = -1;\n\n\t\tdirect_io = 0;\n\t\tgoto relock;\n\t}\n\n\tif (unaligned_dio) {\n\t\t/*\n\t\t * Wait on previous unaligned aio to complete before\n\t\t * proceeding.\n\t\t */\n\t\tmutex_lock(&OCFS2_I(inode)->ip_unaligned_aio);\n\t\t/* Mark the iocb as needing an unlock in ocfs2_dio_end_io */\n\t\tocfs2_iocb_set_unaligned_aio(iocb);\n\t}\n\n\t/*\n\t * To later detect whether a journal commit for sync writes is\n\t * necessary, we sample i_size, and cluster count here.\n\t */\n\told_size = i_size_read(inode);\n\told_clusters = OCFS2_I(inode)->ip_clusters;\n\n\t/* communicate with ocfs2_dio_end_io */\n\tocfs2_iocb_set_rw_locked(iocb, rw_level);\n\n\tret = generic_write_checks(file, ppos, &count,\n\t\t\t\t   S_ISBLK(inode->i_mode));\n\tif (ret)\n\t\tgoto out_dio;\n\n\tiov_iter_truncate(from, count);\n\tif (direct_io) {\n\t\tloff_t endbyte;\n\t\tssize_t written_buffered;\n\t\twritten = generic_file_direct_write(iocb, from, *ppos);\n\t\tif (written < 0 || written == count) {\n\t\t\tret = written;\n\t\t\tgoto out_dio;\n\t\t}\n\n\t\t/*\n\t\t * for completing the rest of the request.\n\t\t */\n\t\t*ppos += written;\n\t\tcount -= written;\n\t\twritten_buffered = generic_perform_write(file, from, *ppos);\n\t\t/*\n\t\t * If generic_file_buffered_write() returned a synchronous error\n\t\t * then we want to return the number of bytes which were\n\t\t * direct-written, or the error code if that was zero. Note\n\t\t * that this differs from normal direct-io semantics, which\n\t\t * will return -EFOO even if some bytes were written.\n\t\t */\n\t\tif (written_buffered < 0) {\n\t\t\tret = written_buffered;\n\t\t\tgoto out_dio;\n\t\t}\n\n\t\tiocb->ki_pos = *ppos + written_buffered;\n\t\t/* We need to ensure that the page cache pages are written to\n\t\t * disk and invalidated to preserve the expected O_DIRECT\n\t\t * semantics.\n\t\t */\n\t\tendbyte = *ppos + written_buffered - 1;\n\t\tret = filemap_write_and_wait_range(file->f_mapping, *ppos,\n\t\t\t\tendbyte);\n\t\tif (ret == 0) {\n\t\t\twritten += written_buffered;\n\t\t\tinvalidate_mapping_pages(mapping,\n\t\t\t\t\t*ppos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\tendbyte >> PAGE_CACHE_SHIFT);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We don't know how much we wrote, so just return\n\t\t\t * the number of bytes which were direct-written\n\t\t\t */\n\t\t}\n\t} else {\n\t\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\t\twritten = generic_perform_write(file, from, *ppos);\n\t\tif (likely(written >= 0))\n\t\t\tiocb->ki_pos = *ppos + written;\n\t\tcurrent->backing_dev_info = NULL;\n\t}\n\nout_dio:\n\t/* buffered aio wouldn't have proper lock coverage today */\n\tBUG_ON(ret == -EIOCBQUEUED && !(file->f_flags & O_DIRECT));\n\n\tif (((file->f_flags & O_DSYNC) && !direct_io) || IS_SYNC(inode) ||\n\t    ((file->f_flags & O_DIRECT) && !direct_io)) {\n\t\tret = filemap_fdatawrite_range(file->f_mapping, *ppos,\n\t\t\t\t\t       *ppos + count - 1);\n\t\tif (ret < 0)\n\t\t\twritten = ret;\n\n\t\tif (!ret) {\n\t\t\tret = jbd2_journal_force_commit(osb->journal->j_journal);\n\t\t\tif (ret < 0)\n\t\t\t\twritten = ret;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tret = filemap_fdatawait_range(file->f_mapping, *ppos,\n\t\t\t\t\t\t      *ppos + count - 1);\n\t}\n\n\t/*\n\t * deep in g_f_a_w_n()->ocfs2_direct_IO we pass in a ocfs2_dio_end_io\n\t * function pointer which is called when o_direct io completes so that\n\t * it can unlock our rw lock.\n\t * Unfortunately there are error cases which call end_io and others\n\t * that don't.  so we don't have to unlock the rw_lock if either an\n\t * async dio is going to do it in the future or an end_io after an\n\t * error has already done it.\n\t */\n\tif ((ret == -EIOCBQUEUED) || (!ocfs2_iocb_is_rw_locked(iocb))) {\n\t\trw_level = -1;\n\t\thave_alloc_sem = 0;\n\t\tunaligned_dio = 0;\n\t}\n\n\tif (unaligned_dio) {\n\t\tocfs2_iocb_clear_unaligned_aio(iocb);\n\t\tmutex_unlock(&OCFS2_I(inode)->ip_unaligned_aio);\n\t}\n\nout:\n\tif (rw_level != -1)\n\t\tocfs2_rw_unlock(inode, rw_level);\n\nout_sems:\n\tif (have_alloc_sem)\n\t\tocfs2_iocb_clear_sem_locked(iocb);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (written)\n\t\tret = written;\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iocb_clear_sem_locked",
          "args": [
            "iocb"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_unlock",
          "args": [
            "inode",
            "rw_level"
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1692-1704",
          "snippet": "void ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&OCFS2_I(inode)->ip_unaligned_aio"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_iocb_clear_unaligned_aio",
          "args": [
            "iocb"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iocb_is_rw_locked",
          "args": [
            "iocb"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait_range",
          "args": [
            "file->f_mapping",
            "*ppos",
            "*ppos + count - 1"
          ],
          "line": 2457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_force_commit",
          "args": [
            "osb->journal->j_journal"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_force_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "610-619",
          "snippet": "int jbd2_journal_force_commit(journal_t *journal)\n{\n\tint ret;\n\n\tJ_ASSERT(!current->journal_info);\n\tret = __jbd2_journal_force_commit(journal);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_force_commit(journal_t *journal)\n{\n\tint ret;\n\n\tJ_ASSERT(!current->journal_info);\n\tret = __jbd2_journal_force_commit(journal);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "file->f_mapping",
            "*ppos",
            "*ppos + count - 1"
          ],
          "line": 2445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == -EIOCBQUEUED && !(file->f_flags & O_DIRECT)"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "written >= 0"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_perform_write",
          "args": [
            "file",
            "from",
            "*ppos"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_mapping_pages",
          "args": [
            "mapping",
            "*ppos >> PAGE_CACHE_SHIFT",
            "endbyte >> PAGE_CACHE_SHIFT"
          ],
          "line": 2422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "file->f_mapping",
            "*ppos",
            "endbyte"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_perform_write",
          "args": [
            "file",
            "from",
            "*ppos"
          ],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_file_direct_write",
          "args": [
            "iocb",
            "from",
            "*ppos"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_truncate",
          "args": [
            "from",
            "count"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_write_checks",
          "args": [
            "file",
            "ppos",
            "&count",
            "S_ISBLK(inode->i_mode)"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iocb_set_rw_locked",
          "args": [
            "iocb",
            "rw_level"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_iocb_set_rw_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.h",
          "lines": "65-72",
          "snippet": "static inline void ocfs2_iocb_set_rw_locked(struct kiocb *iocb, int level)\n{\n\tset_bit(0, (unsigned long *)&iocb->private);\n\tif (level)\n\t\tset_bit(1, (unsigned long *)&iocb->private);\n\telse\n\t\tclear_bit(1, (unsigned long *)&iocb->private);\n}",
          "includes": [
            "#include <linux/aio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n\nstatic inline void ocfs2_iocb_set_rw_locked(struct kiocb *iocb, int level)\n{\n\tset_bit(0, (unsigned long *)&iocb->private);\n\tif (level)\n\t\tset_bit(1, (unsigned long *)&iocb->private);\n\telse\n\t\tclear_bit(1, (unsigned long *)&iocb->private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iocb_set_unaligned_aio",
          "args": [
            "iocb"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&OCFS2_I(inode)->ip_unaligned_aio"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_io_unaligned",
          "args": [
            "inode",
            "iocb->ki_nbytes",
            "*ppos"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_io_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "2071-2079",
          "snippet": "static int ocfs2_is_io_unaligned(struct inode *inode, size_t count, loff_t pos)\n{\n\tint blockmask = inode->i_sb->s_blocksize - 1;\n\tloff_t final_size = pos + count;\n\n\tif ((pos & blockmask) || (final_size & blockmask))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_is_io_unaligned(struct inode *inode, size_t count, loff_t pos)\n{\n\tint blockmask = inode->i_sb->s_blocksize - 1;\n\tloff_t final_size = pos + count;\n\n\tif ((pos & blockmask) || (final_size & blockmask))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_sync_kiocb",
          "args": [
            "iocb"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_inode_for_write",
          "args": [
            "file",
            "ppos",
            "iocb->ki_nbytes",
            "appending",
            "&can_do_direct",
            "&has_refcount"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_inode_for_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "2108-2258",
          "snippet": "static int ocfs2_prepare_inode_for_write(struct file *file,\n\t\t\t\t\t loff_t *ppos,\n\t\t\t\t\t size_t count,\n\t\t\t\t\t int appending,\n\t\t\t\t\t int *direct_io,\n\t\t\t\t\t int *has_refcount)\n{\n\tint ret = 0, meta_level = 0;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tloff_t saved_pos = 0, end;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint full_coherency = !(osb->s_mount_opt &\n\t\tOCFS2_MOUNT_COHERENCY_BUFFERED);\n\n\t/*\n\t * We start with a read level meta lock and only jump to an ex\n\t * if we need to make modifications here.\n\t */\n\tfor(;;) {\n\t\tret = ocfs2_inode_lock(inode, NULL, meta_level);\n\t\tif (ret < 0) {\n\t\t\tmeta_level = -1;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Clear suid / sgid if necessary. We do this here\n\t\t * instead of later in the write path because\n\t\t * remove_suid() calls ->setattr without any hint that\n\t\t * we may have already done our cluster locking. Since\n\t\t * ocfs2_setattr() *must* take cluster locks to\n\t\t * proceed, this will lead us to recursively lock the\n\t\t * inode. There's also the dinode i_size state which\n\t\t * can be lost via setattr during extending writes (we\n\t\t * set inode->i_size at the end of a write. */\n\t\tif (should_remove_suid(dentry)) {\n\t\t\tif (meta_level == 0) {\n\t\t\t\tocfs2_inode_unlock(inode, meta_level);\n\t\t\t\tmeta_level = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = ocfs2_write_remove_suid(inode);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\t/* work on a copy of ppos until we're sure that we won't have\n\t\t * to recalculate it due to relocking. */\n\t\tif (appending)\n\t\t\tsaved_pos = i_size_read(inode);\n\t\telse\n\t\t\tsaved_pos = *ppos;\n\n\t\tend = saved_pos + count;\n\n\t\tret = ocfs2_check_range_for_refcount(inode, saved_pos, count);\n\t\tif (ret == 1) {\n\t\t\tocfs2_inode_unlock(inode, meta_level);\n\t\t\tmeta_level = -1;\n\n\t\t\tret = ocfs2_prepare_inode_for_refcount(inode,\n\t\t\t\t\t\t\t       file,\n\t\t\t\t\t\t\t       saved_pos,\n\t\t\t\t\t\t\t       count,\n\t\t\t\t\t\t\t       &meta_level);\n\t\t\tif (has_refcount)\n\t\t\t\t*has_refcount = 1;\n\t\t\tif (direct_io)\n\t\t\t\t*direct_io = 0;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Skip the O_DIRECT checks if we don't need\n\t\t * them.\n\t\t */\n\t\tif (!direct_io || !(*direct_io))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * There's no sane way to do direct writes to an inode\n\t\t * with inline data.\n\t\t */\n\t\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t\t*direct_io = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Allowing concurrent direct writes means\n\t\t * i_size changes wouldn't be synchronized, so\n\t\t * one node could wind up truncating another\n\t\t * nodes writes.\n\t\t */\n\t\tif (end > i_size_read(inode) && !full_coherency) {\n\t\t\t*direct_io = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Fallback to old way if the feature bit is not set.\n\t\t */\n\t\tif (end > i_size_read(inode) &&\n\t\t\t\t!ocfs2_supports_append_dio(osb)) {\n\t\t\t*direct_io = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We don't fill holes during direct io, so\n\t\t * check for them here. If any are found, the\n\t\t * caller will have to retake some cluster\n\t\t * locks and initiate the io as buffered.\n\t\t */\n\t\tret = ocfs2_check_range_for_holes(inode, saved_pos, count);\n\t\tif (ret == 1) {\n\t\t\t/*\n\t\t\t * Fallback to old way if the feature bit is not set.\n\t\t\t * Otherwise try dio first and then complete the rest\n\t\t\t * request through buffer io.\n\t\t\t */\n\t\t\tif (!ocfs2_supports_append_dio(osb))\n\t\t\t\t*direct_io = 0;\n\t\t\tret = 0;\n\t\t} else if (ret < 0)\n\t\t\tmlog_errno(ret);\n\t\tbreak;\n\t}\n\n\tif (appending)\n\t\t*ppos = saved_pos;\n\nout_unlock:\n\ttrace_ocfs2_prepare_inode_for_write(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\t    saved_pos, appending, count,\n\t\t\t\t\t    direct_io, has_refcount);\n\n\tif (meta_level >= 0)\n\t\tocfs2_inode_unlock(inode, meta_level);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_inode_for_write(struct file *file,\n\t\t\t\t\t loff_t *ppos,\n\t\t\t\t\t size_t count,\n\t\t\t\t\t int appending,\n\t\t\t\t\t int *direct_io,\n\t\t\t\t\t int *has_refcount)\n{\n\tint ret = 0, meta_level = 0;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tloff_t saved_pos = 0, end;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint full_coherency = !(osb->s_mount_opt &\n\t\tOCFS2_MOUNT_COHERENCY_BUFFERED);\n\n\t/*\n\t * We start with a read level meta lock and only jump to an ex\n\t * if we need to make modifications here.\n\t */\n\tfor(;;) {\n\t\tret = ocfs2_inode_lock(inode, NULL, meta_level);\n\t\tif (ret < 0) {\n\t\t\tmeta_level = -1;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Clear suid / sgid if necessary. We do this here\n\t\t * instead of later in the write path because\n\t\t * remove_suid() calls ->setattr without any hint that\n\t\t * we may have already done our cluster locking. Since\n\t\t * ocfs2_setattr() *must* take cluster locks to\n\t\t * proceed, this will lead us to recursively lock the\n\t\t * inode. There's also the dinode i_size state which\n\t\t * can be lost via setattr during extending writes (we\n\t\t * set inode->i_size at the end of a write. */\n\t\tif (should_remove_suid(dentry)) {\n\t\t\tif (meta_level == 0) {\n\t\t\t\tocfs2_inode_unlock(inode, meta_level);\n\t\t\t\tmeta_level = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = ocfs2_write_remove_suid(inode);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\t/* work on a copy of ppos until we're sure that we won't have\n\t\t * to recalculate it due to relocking. */\n\t\tif (appending)\n\t\t\tsaved_pos = i_size_read(inode);\n\t\telse\n\t\t\tsaved_pos = *ppos;\n\n\t\tend = saved_pos + count;\n\n\t\tret = ocfs2_check_range_for_refcount(inode, saved_pos, count);\n\t\tif (ret == 1) {\n\t\t\tocfs2_inode_unlock(inode, meta_level);\n\t\t\tmeta_level = -1;\n\n\t\t\tret = ocfs2_prepare_inode_for_refcount(inode,\n\t\t\t\t\t\t\t       file,\n\t\t\t\t\t\t\t       saved_pos,\n\t\t\t\t\t\t\t       count,\n\t\t\t\t\t\t\t       &meta_level);\n\t\t\tif (has_refcount)\n\t\t\t\t*has_refcount = 1;\n\t\t\tif (direct_io)\n\t\t\t\t*direct_io = 0;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Skip the O_DIRECT checks if we don't need\n\t\t * them.\n\t\t */\n\t\tif (!direct_io || !(*direct_io))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * There's no sane way to do direct writes to an inode\n\t\t * with inline data.\n\t\t */\n\t\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t\t*direct_io = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Allowing concurrent direct writes means\n\t\t * i_size changes wouldn't be synchronized, so\n\t\t * one node could wind up truncating another\n\t\t * nodes writes.\n\t\t */\n\t\tif (end > i_size_read(inode) && !full_coherency) {\n\t\t\t*direct_io = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Fallback to old way if the feature bit is not set.\n\t\t */\n\t\tif (end > i_size_read(inode) &&\n\t\t\t\t!ocfs2_supports_append_dio(osb)) {\n\t\t\t*direct_io = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We don't fill holes during direct io, so\n\t\t * check for them here. If any are found, the\n\t\t * caller will have to retake some cluster\n\t\t * locks and initiate the io as buffered.\n\t\t */\n\t\tret = ocfs2_check_range_for_holes(inode, saved_pos, count);\n\t\tif (ret == 1) {\n\t\t\t/*\n\t\t\t * Fallback to old way if the feature bit is not set.\n\t\t\t * Otherwise try dio first and then complete the rest\n\t\t\t * request through buffer io.\n\t\t\t */\n\t\t\tif (!ocfs2_supports_append_dio(osb))\n\t\t\t\t*direct_io = 0;\n\t\t\tret = 0;\n\t\t} else if (ret < 0)\n\t\t\tmlog_errno(ret);\n\t\tbreak;\n\t}\n\n\tif (appending)\n\t\t*ppos = saved_pos;\n\nout_unlock:\n\ttrace_ocfs2_prepare_inode_for_write(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\t    saved_pos, appending, count,\n\t\t\t\t\t    direct_io, has_refcount);\n\n\tif (meta_level >= 0)\n\t\tocfs2_inode_unlock(inode, meta_level);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "NULL",
            "1"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_lock",
          "args": [
            "inode",
            "rw_level"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1665-1690",
          "snippet": "int ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_iocb_set_sem_locked",
          "args": [
            "iocb"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_iocb_clear_sem_locked",
          "args": [
            "iocb"
          ],
          "line": 2291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_file_aio_write",
          "args": [
            "inode",
            "file",
            "file->f_path.dentry",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "file->f_path.dentry->d_name.len",
            "file->f_path.dentry->d_name.name",
            "(unsigned int)from->nr_segs"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic ssize_t ocfs2_file_write_iter(struct kiocb *iocb,\n\t\t\t\t    struct iov_iter *from)\n{\n\tint ret, direct_io, appending, rw_level, have_alloc_sem  = 0;\n\tint can_do_direct, has_refcount = 0;\n\tssize_t written = 0;\n\tsize_t count = iov_iter_count(from);\n\tloff_t old_size, *ppos = &iocb->ki_pos;\n\tu32 old_clusters;\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint full_coherency = !(osb->s_mount_opt &\n\t\t\t       OCFS2_MOUNT_COHERENCY_BUFFERED);\n\tint unaligned_dio = 0;\n\n\ttrace_ocfs2_file_aio_write(inode, file, file->f_path.dentry,\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tfile->f_path.dentry->d_name.len,\n\t\tfile->f_path.dentry->d_name.name,\n\t\t(unsigned int)from->nr_segs);\t/* GRRRRR */\n\n\tif (iocb->ki_nbytes == 0)\n\t\treturn 0;\n\n\tappending = file->f_flags & O_APPEND ? 1 : 0;\n\tdirect_io = file->f_flags & O_DIRECT ? 1 : 0;\n\n\tmutex_lock(&inode->i_mutex);\n\n\tocfs2_iocb_clear_sem_locked(iocb);\n\nrelock:\n\t/* to match setattr's i_mutex -> rw_lock ordering */\n\tif (direct_io) {\n\t\thave_alloc_sem = 1;\n\t\t/* communicate with ocfs2_dio_end_io */\n\t\tocfs2_iocb_set_sem_locked(iocb);\n\t}\n\n\t/*\n\t * Concurrent O_DIRECT writes are allowed with\n\t * mount_option \"coherency=buffered\".\n\t */\n\trw_level = (!direct_io || full_coherency);\n\n\tret = ocfs2_rw_lock(inode, rw_level);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_sems;\n\t}\n\n\t/*\n\t * O_DIRECT writes with \"coherency=full\" need to take EX cluster\n\t * inode_lock to guarantee coherency.\n\t */\n\tif (direct_io && full_coherency) {\n\t\t/*\n\t\t * We need to take and drop the inode lock to force\n\t\t * other nodes to drop their caches.  Buffered I/O\n\t\t * already does this in write_begin().\n\t\t */\n\t\tret = ocfs2_inode_lock(inode, NULL, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tocfs2_inode_unlock(inode, 1);\n\t}\n\n\tcan_do_direct = direct_io;\n\tret = ocfs2_prepare_inode_for_write(file, ppos,\n\t\t\t\t\t    iocb->ki_nbytes, appending,\n\t\t\t\t\t    &can_do_direct, &has_refcount);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (direct_io && !is_sync_kiocb(iocb))\n\t\tunaligned_dio = ocfs2_is_io_unaligned(inode, iocb->ki_nbytes,\n\t\t\t\t\t\t      *ppos);\n\n\t/*\n\t * We can't complete the direct I/O as requested, fall back to\n\t * buffered I/O.\n\t */\n\tif (direct_io && !can_do_direct) {\n\t\tocfs2_rw_unlock(inode, rw_level);\n\n\t\thave_alloc_sem = 0;\n\t\trw_level = -1;\n\n\t\tdirect_io = 0;\n\t\tgoto relock;\n\t}\n\n\tif (unaligned_dio) {\n\t\t/*\n\t\t * Wait on previous unaligned aio to complete before\n\t\t * proceeding.\n\t\t */\n\t\tmutex_lock(&OCFS2_I(inode)->ip_unaligned_aio);\n\t\t/* Mark the iocb as needing an unlock in ocfs2_dio_end_io */\n\t\tocfs2_iocb_set_unaligned_aio(iocb);\n\t}\n\n\t/*\n\t * To later detect whether a journal commit for sync writes is\n\t * necessary, we sample i_size, and cluster count here.\n\t */\n\told_size = i_size_read(inode);\n\told_clusters = OCFS2_I(inode)->ip_clusters;\n\n\t/* communicate with ocfs2_dio_end_io */\n\tocfs2_iocb_set_rw_locked(iocb, rw_level);\n\n\tret = generic_write_checks(file, ppos, &count,\n\t\t\t\t   S_ISBLK(inode->i_mode));\n\tif (ret)\n\t\tgoto out_dio;\n\n\tiov_iter_truncate(from, count);\n\tif (direct_io) {\n\t\tloff_t endbyte;\n\t\tssize_t written_buffered;\n\t\twritten = generic_file_direct_write(iocb, from, *ppos);\n\t\tif (written < 0 || written == count) {\n\t\t\tret = written;\n\t\t\tgoto out_dio;\n\t\t}\n\n\t\t/*\n\t\t * for completing the rest of the request.\n\t\t */\n\t\t*ppos += written;\n\t\tcount -= written;\n\t\twritten_buffered = generic_perform_write(file, from, *ppos);\n\t\t/*\n\t\t * If generic_file_buffered_write() returned a synchronous error\n\t\t * then we want to return the number of bytes which were\n\t\t * direct-written, or the error code if that was zero. Note\n\t\t * that this differs from normal direct-io semantics, which\n\t\t * will return -EFOO even if some bytes were written.\n\t\t */\n\t\tif (written_buffered < 0) {\n\t\t\tret = written_buffered;\n\t\t\tgoto out_dio;\n\t\t}\n\n\t\tiocb->ki_pos = *ppos + written_buffered;\n\t\t/* We need to ensure that the page cache pages are written to\n\t\t * disk and invalidated to preserve the expected O_DIRECT\n\t\t * semantics.\n\t\t */\n\t\tendbyte = *ppos + written_buffered - 1;\n\t\tret = filemap_write_and_wait_range(file->f_mapping, *ppos,\n\t\t\t\tendbyte);\n\t\tif (ret == 0) {\n\t\t\twritten += written_buffered;\n\t\t\tinvalidate_mapping_pages(mapping,\n\t\t\t\t\t*ppos >> PAGE_CACHE_SHIFT,\n\t\t\t\t\tendbyte >> PAGE_CACHE_SHIFT);\n\t\t} else {\n\t\t\t/*\n\t\t\t * We don't know how much we wrote, so just return\n\t\t\t * the number of bytes which were direct-written\n\t\t\t */\n\t\t}\n\t} else {\n\t\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\t\twritten = generic_perform_write(file, from, *ppos);\n\t\tif (likely(written >= 0))\n\t\t\tiocb->ki_pos = *ppos + written;\n\t\tcurrent->backing_dev_info = NULL;\n\t}\n\nout_dio:\n\t/* buffered aio wouldn't have proper lock coverage today */\n\tBUG_ON(ret == -EIOCBQUEUED && !(file->f_flags & O_DIRECT));\n\n\tif (((file->f_flags & O_DSYNC) && !direct_io) || IS_SYNC(inode) ||\n\t    ((file->f_flags & O_DIRECT) && !direct_io)) {\n\t\tret = filemap_fdatawrite_range(file->f_mapping, *ppos,\n\t\t\t\t\t       *ppos + count - 1);\n\t\tif (ret < 0)\n\t\t\twritten = ret;\n\n\t\tif (!ret) {\n\t\t\tret = jbd2_journal_force_commit(osb->journal->j_journal);\n\t\t\tif (ret < 0)\n\t\t\t\twritten = ret;\n\t\t}\n\n\t\tif (!ret)\n\t\t\tret = filemap_fdatawait_range(file->f_mapping, *ppos,\n\t\t\t\t\t\t      *ppos + count - 1);\n\t}\n\n\t/*\n\t * deep in g_f_a_w_n()->ocfs2_direct_IO we pass in a ocfs2_dio_end_io\n\t * function pointer which is called when o_direct io completes so that\n\t * it can unlock our rw lock.\n\t * Unfortunately there are error cases which call end_io and others\n\t * that don't.  so we don't have to unlock the rw_lock if either an\n\t * async dio is going to do it in the future or an end_io after an\n\t * error has already done it.\n\t */\n\tif ((ret == -EIOCBQUEUED) || (!ocfs2_iocb_is_rw_locked(iocb))) {\n\t\trw_level = -1;\n\t\thave_alloc_sem = 0;\n\t\tunaligned_dio = 0;\n\t}\n\n\tif (unaligned_dio) {\n\t\tocfs2_iocb_clear_unaligned_aio(iocb);\n\t\tmutex_unlock(&OCFS2_I(inode)->ip_unaligned_aio);\n\t}\n\nout:\n\tif (rw_level != -1)\n\t\tocfs2_rw_unlock(inode, rw_level);\n\nout_sems:\n\tif (have_alloc_sem)\n\t\tocfs2_iocb_clear_sem_locked(iocb);\n\n\tmutex_unlock(&inode->i_mutex);\n\n\tif (written)\n\t\tret = written;\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_prepare_inode_for_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "2108-2258",
    "snippet": "static int ocfs2_prepare_inode_for_write(struct file *file,\n\t\t\t\t\t loff_t *ppos,\n\t\t\t\t\t size_t count,\n\t\t\t\t\t int appending,\n\t\t\t\t\t int *direct_io,\n\t\t\t\t\t int *has_refcount)\n{\n\tint ret = 0, meta_level = 0;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tloff_t saved_pos = 0, end;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint full_coherency = !(osb->s_mount_opt &\n\t\tOCFS2_MOUNT_COHERENCY_BUFFERED);\n\n\t/*\n\t * We start with a read level meta lock and only jump to an ex\n\t * if we need to make modifications here.\n\t */\n\tfor(;;) {\n\t\tret = ocfs2_inode_lock(inode, NULL, meta_level);\n\t\tif (ret < 0) {\n\t\t\tmeta_level = -1;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Clear suid / sgid if necessary. We do this here\n\t\t * instead of later in the write path because\n\t\t * remove_suid() calls ->setattr without any hint that\n\t\t * we may have already done our cluster locking. Since\n\t\t * ocfs2_setattr() *must* take cluster locks to\n\t\t * proceed, this will lead us to recursively lock the\n\t\t * inode. There's also the dinode i_size state which\n\t\t * can be lost via setattr during extending writes (we\n\t\t * set inode->i_size at the end of a write. */\n\t\tif (should_remove_suid(dentry)) {\n\t\t\tif (meta_level == 0) {\n\t\t\t\tocfs2_inode_unlock(inode, meta_level);\n\t\t\t\tmeta_level = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = ocfs2_write_remove_suid(inode);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\t/* work on a copy of ppos until we're sure that we won't have\n\t\t * to recalculate it due to relocking. */\n\t\tif (appending)\n\t\t\tsaved_pos = i_size_read(inode);\n\t\telse\n\t\t\tsaved_pos = *ppos;\n\n\t\tend = saved_pos + count;\n\n\t\tret = ocfs2_check_range_for_refcount(inode, saved_pos, count);\n\t\tif (ret == 1) {\n\t\t\tocfs2_inode_unlock(inode, meta_level);\n\t\t\tmeta_level = -1;\n\n\t\t\tret = ocfs2_prepare_inode_for_refcount(inode,\n\t\t\t\t\t\t\t       file,\n\t\t\t\t\t\t\t       saved_pos,\n\t\t\t\t\t\t\t       count,\n\t\t\t\t\t\t\t       &meta_level);\n\t\t\tif (has_refcount)\n\t\t\t\t*has_refcount = 1;\n\t\t\tif (direct_io)\n\t\t\t\t*direct_io = 0;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Skip the O_DIRECT checks if we don't need\n\t\t * them.\n\t\t */\n\t\tif (!direct_io || !(*direct_io))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * There's no sane way to do direct writes to an inode\n\t\t * with inline data.\n\t\t */\n\t\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t\t*direct_io = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Allowing concurrent direct writes means\n\t\t * i_size changes wouldn't be synchronized, so\n\t\t * one node could wind up truncating another\n\t\t * nodes writes.\n\t\t */\n\t\tif (end > i_size_read(inode) && !full_coherency) {\n\t\t\t*direct_io = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Fallback to old way if the feature bit is not set.\n\t\t */\n\t\tif (end > i_size_read(inode) &&\n\t\t\t\t!ocfs2_supports_append_dio(osb)) {\n\t\t\t*direct_io = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We don't fill holes during direct io, so\n\t\t * check for them here. If any are found, the\n\t\t * caller will have to retake some cluster\n\t\t * locks and initiate the io as buffered.\n\t\t */\n\t\tret = ocfs2_check_range_for_holes(inode, saved_pos, count);\n\t\tif (ret == 1) {\n\t\t\t/*\n\t\t\t * Fallback to old way if the feature bit is not set.\n\t\t\t * Otherwise try dio first and then complete the rest\n\t\t\t * request through buffer io.\n\t\t\t */\n\t\t\tif (!ocfs2_supports_append_dio(osb))\n\t\t\t\t*direct_io = 0;\n\t\t\tret = 0;\n\t\t} else if (ret < 0)\n\t\t\tmlog_errno(ret);\n\t\tbreak;\n\t}\n\n\tif (appending)\n\t\t*ppos = saved_pos;\n\nout_unlock:\n\ttrace_ocfs2_prepare_inode_for_write(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\t    saved_pos, appending, count,\n\t\t\t\t\t    direct_io, has_refcount);\n\n\tif (meta_level >= 0)\n\t\tocfs2_inode_unlock(inode, meta_level);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "meta_level"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_prepare_inode_for_write",
          "args": [
            "OCFS2_I(inode)->ip_blkno",
            "saved_pos",
            "appending",
            "count",
            "direct_io",
            "has_refcount"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_supports_append_dio",
          "args": [
            "osb"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_supports_append_dio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "503-508",
          "snippet": "static inline int ocfs2_supports_append_dio(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_APPEND_DIO)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_supports_append_dio(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_APPEND_DIO)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_range_for_holes",
          "args": [
            "inode",
            "saved_pos",
            "count"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_range_for_holes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1366-1398",
          "snippet": "static int ocfs2_check_range_for_holes(struct inode *inode, loff_t pos,\n\t\t\t\t       size_t count)\n{\n\tint ret = 0;\n\tunsigned int extent_flags;\n\tu32 cpos, clusters, extent_len, phys_cpos;\n\tstruct super_block *sb = inode->i_sb;\n\n\tcpos = pos >> OCFS2_SB(sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(sb, pos + count) - cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &extent_len,\n\t\t\t\t\t &extent_flags);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (phys_cpos == 0 || (extent_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (extent_len > clusters)\n\t\t\textent_len = clusters;\n\n\t\tclusters -= extent_len;\n\t\tcpos += extent_len;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_check_range_for_holes(struct inode *inode, loff_t pos,\n\t\t\t\t       size_t count)\n{\n\tint ret = 0;\n\tunsigned int extent_flags;\n\tu32 cpos, clusters, extent_len, phys_cpos;\n\tstruct super_block *sb = inode->i_sb;\n\n\tcpos = pos >> OCFS2_SB(sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(sb, pos + count) - cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &extent_len,\n\t\t\t\t\t &extent_flags);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (phys_cpos == 0 || (extent_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (extent_len > clusters)\n\t\t\textent_len = clusters;\n\n\t\tclusters -= extent_len;\n\t\tcpos += extent_len;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_prepare_inode_for_refcount",
          "args": [
            "inode",
            "file",
            "saved_pos",
            "count",
            "&meta_level"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_prepare_inode_for_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "2081-2106",
          "snippet": "static int ocfs2_prepare_inode_for_refcount(struct inode *inode,\n\t\t\t\t\t    struct file *file,\n\t\t\t\t\t    loff_t pos, size_t count,\n\t\t\t\t\t    int *meta_level)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tu32 cpos = pos >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 clusters =\n\t\tocfs2_clusters_for_bytes(inode->i_sb, pos + count) - cpos;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*meta_level = 1;\n\n\tret = ocfs2_refcount_cow(inode, di_bh, cpos, clusters, UINT_MAX);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_inode_for_refcount(struct inode *inode,\n\t\t\t\t\t    struct file *file,\n\t\t\t\t\t    loff_t pos, size_t count,\n\t\t\t\t\t    int *meta_level)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tu32 cpos = pos >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 clusters =\n\t\tocfs2_clusters_for_bytes(inode->i_sb, pos + count) - cpos;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*meta_level = 1;\n\n\tret = ocfs2_refcount_cow(inode, di_bh, cpos, clusters, UINT_MAX);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_range_for_refcount",
          "args": [
            "inode",
            "saved_pos",
            "count"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_range_for_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "2032-2069",
          "snippet": "int ocfs2_check_range_for_refcount(struct inode *inode, loff_t pos,\n\t\t\t\t   size_t count)\n{\n\tint ret = 0;\n\tunsigned int extent_flags;\n\tu32 cpos, clusters, extent_len, phys_cpos;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)) ||\n\t    !(OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL) ||\n\t    OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tcpos = pos >> OCFS2_SB(sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(sb, pos + count) - cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &extent_len,\n\t\t\t\t\t &extent_flags);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (phys_cpos && (extent_flags & OCFS2_EXT_REFCOUNTED)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (extent_len > clusters)\n\t\t\textent_len = clusters;\n\n\t\tclusters -= extent_len;\n\t\tcpos += extent_len;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_check_range_for_refcount(struct inode *inode, loff_t pos,\n\t\t\t\t   size_t count)\n{\n\tint ret = 0;\n\tunsigned int extent_flags;\n\tu32 cpos, clusters, extent_len, phys_cpos;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)) ||\n\t    !(OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL) ||\n\t    OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tcpos = pos >> OCFS2_SB(sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(sb, pos + count) - cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &extent_len,\n\t\t\t\t\t &extent_flags);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (phys_cpos && (extent_flags & OCFS2_EXT_REFCOUNTED)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (extent_len > clusters)\n\t\t\textent_len = clusters;\n\n\t\tclusters -= extent_len;\n\t\tcpos += extent_len;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_write_remove_suid",
          "args": [
            "inode"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1400-1415",
          "snippet": "static int ocfs2_write_remove_suid(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = ocfs2_read_inode_block(inode, &bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret =  __ocfs2_write_remove_suid(inode, bh);\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_write_remove_suid(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = ocfs2_read_inode_block(inode, &bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret =  __ocfs2_write_remove_suid(inode, bh);\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "should_remove_suid",
          "args": [
            "dentry"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "should_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1640-1660",
          "snippet": "int should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = dentry->d_inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nint should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = dentry->d_inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "NULL",
            "meta_level"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_inode_for_write(struct file *file,\n\t\t\t\t\t loff_t *ppos,\n\t\t\t\t\t size_t count,\n\t\t\t\t\t int appending,\n\t\t\t\t\t int *direct_io,\n\t\t\t\t\t int *has_refcount)\n{\n\tint ret = 0, meta_level = 0;\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tloff_t saved_pos = 0, end;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint full_coherency = !(osb->s_mount_opt &\n\t\tOCFS2_MOUNT_COHERENCY_BUFFERED);\n\n\t/*\n\t * We start with a read level meta lock and only jump to an ex\n\t * if we need to make modifications here.\n\t */\n\tfor(;;) {\n\t\tret = ocfs2_inode_lock(inode, NULL, meta_level);\n\t\tif (ret < 0) {\n\t\t\tmeta_level = -1;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* Clear suid / sgid if necessary. We do this here\n\t\t * instead of later in the write path because\n\t\t * remove_suid() calls ->setattr without any hint that\n\t\t * we may have already done our cluster locking. Since\n\t\t * ocfs2_setattr() *must* take cluster locks to\n\t\t * proceed, this will lead us to recursively lock the\n\t\t * inode. There's also the dinode i_size state which\n\t\t * can be lost via setattr during extending writes (we\n\t\t * set inode->i_size at the end of a write. */\n\t\tif (should_remove_suid(dentry)) {\n\t\t\tif (meta_level == 0) {\n\t\t\t\tocfs2_inode_unlock(inode, meta_level);\n\t\t\t\tmeta_level = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = ocfs2_write_remove_suid(inode);\n\t\t\tif (ret < 0) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\t/* work on a copy of ppos until we're sure that we won't have\n\t\t * to recalculate it due to relocking. */\n\t\tif (appending)\n\t\t\tsaved_pos = i_size_read(inode);\n\t\telse\n\t\t\tsaved_pos = *ppos;\n\n\t\tend = saved_pos + count;\n\n\t\tret = ocfs2_check_range_for_refcount(inode, saved_pos, count);\n\t\tif (ret == 1) {\n\t\t\tocfs2_inode_unlock(inode, meta_level);\n\t\t\tmeta_level = -1;\n\n\t\t\tret = ocfs2_prepare_inode_for_refcount(inode,\n\t\t\t\t\t\t\t       file,\n\t\t\t\t\t\t\t       saved_pos,\n\t\t\t\t\t\t\t       count,\n\t\t\t\t\t\t\t       &meta_level);\n\t\t\tif (has_refcount)\n\t\t\t\t*has_refcount = 1;\n\t\t\tif (direct_io)\n\t\t\t\t*direct_io = 0;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t/*\n\t\t * Skip the O_DIRECT checks if we don't need\n\t\t * them.\n\t\t */\n\t\tif (!direct_io || !(*direct_io))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * There's no sane way to do direct writes to an inode\n\t\t * with inline data.\n\t\t */\n\t\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t\t*direct_io = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Allowing concurrent direct writes means\n\t\t * i_size changes wouldn't be synchronized, so\n\t\t * one node could wind up truncating another\n\t\t * nodes writes.\n\t\t */\n\t\tif (end > i_size_read(inode) && !full_coherency) {\n\t\t\t*direct_io = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Fallback to old way if the feature bit is not set.\n\t\t */\n\t\tif (end > i_size_read(inode) &&\n\t\t\t\t!ocfs2_supports_append_dio(osb)) {\n\t\t\t*direct_io = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We don't fill holes during direct io, so\n\t\t * check for them here. If any are found, the\n\t\t * caller will have to retake some cluster\n\t\t * locks and initiate the io as buffered.\n\t\t */\n\t\tret = ocfs2_check_range_for_holes(inode, saved_pos, count);\n\t\tif (ret == 1) {\n\t\t\t/*\n\t\t\t * Fallback to old way if the feature bit is not set.\n\t\t\t * Otherwise try dio first and then complete the rest\n\t\t\t * request through buffer io.\n\t\t\t */\n\t\t\tif (!ocfs2_supports_append_dio(osb))\n\t\t\t\t*direct_io = 0;\n\t\t\tret = 0;\n\t\t} else if (ret < 0)\n\t\t\tmlog_errno(ret);\n\t\tbreak;\n\t}\n\n\tif (appending)\n\t\t*ppos = saved_pos;\n\nout_unlock:\n\ttrace_ocfs2_prepare_inode_for_write(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\t    saved_pos, appending, count,\n\t\t\t\t\t    direct_io, has_refcount);\n\n\tif (meta_level >= 0)\n\t\tocfs2_inode_unlock(inode, meta_level);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_prepare_inode_for_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "2081-2106",
    "snippet": "static int ocfs2_prepare_inode_for_refcount(struct inode *inode,\n\t\t\t\t\t    struct file *file,\n\t\t\t\t\t    loff_t pos, size_t count,\n\t\t\t\t\t    int *meta_level)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tu32 cpos = pos >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 clusters =\n\t\tocfs2_clusters_for_bytes(inode->i_sb, pos + count) - cpos;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*meta_level = 1;\n\n\tret = ocfs2_refcount_cow(inode, di_bh, cpos, clusters, UINT_MAX);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_cow",
          "args": [
            "inode",
            "di_bh",
            "cpos",
            "clusters",
            "UINT_MAX"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_cow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3504-3537",
          "snippet": "int ocfs2_refcount_cow(struct inode *inode,\n\t\t       struct buffer_head *di_bh,\n\t\t       u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\twhile (write_len) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write_len < num_clusters)\n\t\t\tnum_clusters = write_len;\n\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED) {\n\t\t\tret = ocfs2_refcount_cow_hunk(inode, di_bh, cpos,\n\t\t\t\t\t\t      num_clusters, max_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twrite_len -= num_clusters;\n\t\tcpos += num_clusters;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_refcount_cow(struct inode *inode,\n\t\t       struct buffer_head *di_bh,\n\t\t       u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\twhile (write_len) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write_len < num_clusters)\n\t\t\tnum_clusters = write_len;\n\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED) {\n\t\t\tret = ocfs2_refcount_cow_hunk(inode, di_bh, cpos,\n\t\t\t\t\t\t      num_clusters, max_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twrite_len -= num_clusters;\n\t\tcpos += num_clusters;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "1"
          ],
          "line": 2092
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "inode->i_sb",
            "pos + count"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_prepare_inode_for_refcount(struct inode *inode,\n\t\t\t\t\t    struct file *file,\n\t\t\t\t\t    loff_t pos, size_t count,\n\t\t\t\t\t    int *meta_level)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tu32 cpos = pos >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 clusters =\n\t\tocfs2_clusters_for_bytes(inode->i_sb, pos + count) - cpos;\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*meta_level = 1;\n\n\tret = ocfs2_refcount_cow(inode, di_bh, cpos, clusters, UINT_MAX);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_is_io_unaligned",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "2071-2079",
    "snippet": "static int ocfs2_is_io_unaligned(struct inode *inode, size_t count, loff_t pos)\n{\n\tint blockmask = inode->i_sb->s_blocksize - 1;\n\tloff_t final_size = pos + count;\n\n\tif ((pos & blockmask) || (final_size & blockmask))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_is_io_unaligned(struct inode *inode, size_t count, loff_t pos)\n{\n\tint blockmask = inode->i_sb->s_blocksize - 1;\n\tloff_t final_size = pos + count;\n\n\tif ((pos & blockmask) || (final_size & blockmask))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_check_range_for_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "2032-2069",
    "snippet": "int ocfs2_check_range_for_refcount(struct inode *inode, loff_t pos,\n\t\t\t\t   size_t count)\n{\n\tint ret = 0;\n\tunsigned int extent_flags;\n\tu32 cpos, clusters, extent_len, phys_cpos;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)) ||\n\t    !(OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL) ||\n\t    OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tcpos = pos >> OCFS2_SB(sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(sb, pos + count) - cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &extent_len,\n\t\t\t\t\t &extent_flags);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (phys_cpos && (extent_flags & OCFS2_EXT_REFCOUNTED)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (extent_len > clusters)\n\t\t\textent_len = clusters;\n\n\t\tclusters -= extent_len;\n\t\tcpos += extent_len;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&phys_cpos",
            "&extent_len",
            "&extent_flags"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "608-665",
          "snippet": "int ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "sb",
            "pos + count"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_tree",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "584-589",
          "snippet": "static inline int ocfs2_refcount_tree(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_REFCOUNT_TREE)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_refcount_tree(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_REFCOUNT_TREE)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_check_range_for_refcount(struct inode *inode, loff_t pos,\n\t\t\t\t   size_t count)\n{\n\tint ret = 0;\n\tunsigned int extent_flags;\n\tu32 cpos, clusters, extent_len, phys_cpos;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)) ||\n\t    !(OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL) ||\n\t    OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\tcpos = pos >> OCFS2_SB(sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(sb, pos + count) - cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &extent_len,\n\t\t\t\t\t &extent_flags);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (phys_cpos && (extent_flags & OCFS2_EXT_REFCOUNTED)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (extent_len > clusters)\n\t\t\textent_len = clusters;\n\n\t\tclusters -= extent_len;\n\t\tcpos += extent_len;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "2004-2030",
    "snippet": "static long ocfs2_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t    loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_space_resv sr;\n\tint change_size = 1;\n\tint cmd = OCFS2_IOC_RESVSP64;\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\tif (!ocfs2_writes_unwritten_extents(osb))\n\t\treturn -EOPNOTSUPP;\n\n\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\tchange_size = 0;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\tcmd = OCFS2_IOC_UNRESVSP64;\n\n\tsr.l_whence = 0;\n\tsr.l_start = (s64)offset;\n\tsr.l_len = (s64)len;\n\n\treturn __ocfs2_change_file_space(NULL, inode, offset, cmd, &sr,\n\t\t\t\t\t change_size);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_change_file_space",
          "args": [
            "NULL",
            "inode",
            "offset",
            "cmd",
            "&sr",
            "change_size"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_change_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1837-1974",
          "snippet": "static int __ocfs2_change_file_space(struct file *file, struct inode *inode,\n\t\t\t\t     loff_t f_pos, unsigned int cmd,\n\t\t\t\t     struct ocfs2_space_resv *sr,\n\t\t\t\t     int change_size)\n{\n\tint ret;\n\ts64 llen;\n\tloff_t size;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *di_bh = NULL;\n\thandle_t *handle;\n\tunsigned long long max_off = inode->i_sb->s_maxbytes;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * This prevents concurrent writes on other nodes\n\t */\n\tret = ocfs2_rw_lock(inode, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_rw_unlock;\n\t}\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tret = -EPERM;\n\t\tgoto out_inode_unlock;\n\t}\n\n\tswitch (sr->l_whence) {\n\tcase 0: /*SEEK_SET*/\n\t\tbreak;\n\tcase 1: /*SEEK_CUR*/\n\t\tsr->l_start += f_pos;\n\t\tbreak;\n\tcase 2: /*SEEK_END*/\n\t\tsr->l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_inode_unlock;\n\t}\n\tsr->l_whence = 0;\n\n\tllen = sr->l_len > 0 ? sr->l_len - 1 : sr->l_len;\n\n\tif (sr->l_start < 0\n\t    || sr->l_start > max_off\n\t    || (sr->l_start + llen) < 0\n\t    || (sr->l_start + llen) > max_off) {\n\t\tret = -EINVAL;\n\t\tgoto out_inode_unlock;\n\t}\n\tsize = sr->l_start + sr->l_len;\n\n\tif (cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64 ||\n\t    cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) {\n\t\tif (sr->l_len <= 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_inode_unlock;\n\t\t}\n\t}\n\n\tif (file && should_remove_suid(file->f_path.dentry)) {\n\t\tret = __ocfs2_write_remove_suid(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_inode_unlock;\n\t\t}\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tswitch (cmd) {\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\t\t/*\n\t\t * This takes unsigned offsets, but the signed ones we\n\t\t * pass have been checked against overflow above.\n\t\t */\n\t\tret = ocfs2_allocate_unwritten_extents(inode, sr->l_start,\n\t\t\t\t\t\t       sr->l_len);\n\t\tbreak;\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\t\tret = ocfs2_remove_inode_range(inode, di_bh, sr->l_start,\n\t\t\t\t\t       sr->l_len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t/*\n\t * We update c/mtime for these changes\n\t */\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_inode_unlock;\n\t}\n\n\tif (change_size && i_size_read(inode) < size)\n\t\ti_size_write(inode, size);\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\tret = ocfs2_mark_inode_dirty(handle, inode, di_bh);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (file && (file->f_flags & O_SYNC))\n\t\thandle->h_sync = 1;\n\n\tocfs2_commit_trans(osb, handle);\n\nout_inode_unlock:\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\nout_rw_unlock:\n\tocfs2_rw_unlock(inode, 1);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __ocfs2_change_file_space(struct file *file, struct inode *inode,\n\t\t\t\t     loff_t f_pos, unsigned int cmd,\n\t\t\t\t     struct ocfs2_space_resv *sr,\n\t\t\t\t     int change_size)\n{\n\tint ret;\n\ts64 llen;\n\tloff_t size;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *di_bh = NULL;\n\thandle_t *handle;\n\tunsigned long long max_off = inode->i_sb->s_maxbytes;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * This prevents concurrent writes on other nodes\n\t */\n\tret = ocfs2_rw_lock(inode, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_rw_unlock;\n\t}\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tret = -EPERM;\n\t\tgoto out_inode_unlock;\n\t}\n\n\tswitch (sr->l_whence) {\n\tcase 0: /*SEEK_SET*/\n\t\tbreak;\n\tcase 1: /*SEEK_CUR*/\n\t\tsr->l_start += f_pos;\n\t\tbreak;\n\tcase 2: /*SEEK_END*/\n\t\tsr->l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_inode_unlock;\n\t}\n\tsr->l_whence = 0;\n\n\tllen = sr->l_len > 0 ? sr->l_len - 1 : sr->l_len;\n\n\tif (sr->l_start < 0\n\t    || sr->l_start > max_off\n\t    || (sr->l_start + llen) < 0\n\t    || (sr->l_start + llen) > max_off) {\n\t\tret = -EINVAL;\n\t\tgoto out_inode_unlock;\n\t}\n\tsize = sr->l_start + sr->l_len;\n\n\tif (cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64 ||\n\t    cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) {\n\t\tif (sr->l_len <= 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_inode_unlock;\n\t\t}\n\t}\n\n\tif (file && should_remove_suid(file->f_path.dentry)) {\n\t\tret = __ocfs2_write_remove_suid(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_inode_unlock;\n\t\t}\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tswitch (cmd) {\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\t\t/*\n\t\t * This takes unsigned offsets, but the signed ones we\n\t\t * pass have been checked against overflow above.\n\t\t */\n\t\tret = ocfs2_allocate_unwritten_extents(inode, sr->l_start,\n\t\t\t\t\t\t       sr->l_len);\n\t\tbreak;\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\t\tret = ocfs2_remove_inode_range(inode, di_bh, sr->l_start,\n\t\t\t\t\t       sr->l_len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t/*\n\t * We update c/mtime for these changes\n\t */\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_inode_unlock;\n\t}\n\n\tif (change_size && i_size_read(inode) < size)\n\t\ti_size_write(inode, size);\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\tret = ocfs2_mark_inode_dirty(handle, inode, di_bh);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (file && (file->f_flags & O_SYNC))\n\t\thandle->h_sync = 1;\n\n\tocfs2_commit_trans(osb, handle);\n\nout_inode_unlock:\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\nout_rw_unlock:\n\tocfs2_rw_unlock(inode, 1);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_writes_unwritten_extents",
          "args": [
            "osb"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_writes_unwritten_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "490-501",
          "snippet": "static inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)\n{\n\t/*\n\t * Support for sparse files is a pre-requisite\n\t */\n\tif (!ocfs2_sparse_alloc(osb))\n\t\treturn 0;\n\n\tif (osb->s_feature_ro_compat & OCFS2_FEATURE_RO_COMPAT_UNWRITTEN)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)\n{\n\t/*\n\t * Support for sparse files is a pre-requisite\n\t */\n\tif (!ocfs2_sparse_alloc(osb))\n\t\treturn 0;\n\n\tif (osb->s_feature_ro_compat & OCFS2_FEATURE_RO_COMPAT_UNWRITTEN)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic long ocfs2_fallocate(struct file *file, int mode, loff_t offset,\n\t\t\t    loff_t len)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_space_resv sr;\n\tint change_size = 1;\n\tint cmd = OCFS2_IOC_RESVSP64;\n\n\tif (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))\n\t\treturn -EOPNOTSUPP;\n\tif (!ocfs2_writes_unwritten_extents(osb))\n\t\treturn -EOPNOTSUPP;\n\n\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\tchange_size = 0;\n\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\tcmd = OCFS2_IOC_UNRESVSP64;\n\n\tsr.l_whence = 0;\n\tsr.l_start = (s64)offset;\n\tsr.l_len = (s64)len;\n\n\treturn __ocfs2_change_file_space(NULL, inode, offset, cmd, &sr,\n\t\t\t\t\t change_size);\n}"
  },
  {
    "function_name": "ocfs2_change_file_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1976-2002",
    "snippet": "int ocfs2_change_file_space(struct file *file, unsigned int cmd,\n\t\t\t    struct ocfs2_space_resv *sr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint ret;\n\n\tif ((cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64) &&\n\t    !ocfs2_writes_unwritten_extents(osb))\n\t\treturn -ENOTTY;\n\telse if ((cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) &&\n\t\t !ocfs2_sparse_alloc(osb))\n\t\treturn -ENOTTY;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\tret = __ocfs2_change_file_space(file, inode, file->f_pos, cmd, sr, 0);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "file"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_change_file_space",
          "args": [
            "file",
            "inode",
            "file->f_pos",
            "cmd",
            "sr",
            "0"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_change_file_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1837-1974",
          "snippet": "static int __ocfs2_change_file_space(struct file *file, struct inode *inode,\n\t\t\t\t     loff_t f_pos, unsigned int cmd,\n\t\t\t\t     struct ocfs2_space_resv *sr,\n\t\t\t\t     int change_size)\n{\n\tint ret;\n\ts64 llen;\n\tloff_t size;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *di_bh = NULL;\n\thandle_t *handle;\n\tunsigned long long max_off = inode->i_sb->s_maxbytes;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * This prevents concurrent writes on other nodes\n\t */\n\tret = ocfs2_rw_lock(inode, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_rw_unlock;\n\t}\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tret = -EPERM;\n\t\tgoto out_inode_unlock;\n\t}\n\n\tswitch (sr->l_whence) {\n\tcase 0: /*SEEK_SET*/\n\t\tbreak;\n\tcase 1: /*SEEK_CUR*/\n\t\tsr->l_start += f_pos;\n\t\tbreak;\n\tcase 2: /*SEEK_END*/\n\t\tsr->l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_inode_unlock;\n\t}\n\tsr->l_whence = 0;\n\n\tllen = sr->l_len > 0 ? sr->l_len - 1 : sr->l_len;\n\n\tif (sr->l_start < 0\n\t    || sr->l_start > max_off\n\t    || (sr->l_start + llen) < 0\n\t    || (sr->l_start + llen) > max_off) {\n\t\tret = -EINVAL;\n\t\tgoto out_inode_unlock;\n\t}\n\tsize = sr->l_start + sr->l_len;\n\n\tif (cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64 ||\n\t    cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) {\n\t\tif (sr->l_len <= 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_inode_unlock;\n\t\t}\n\t}\n\n\tif (file && should_remove_suid(file->f_path.dentry)) {\n\t\tret = __ocfs2_write_remove_suid(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_inode_unlock;\n\t\t}\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tswitch (cmd) {\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\t\t/*\n\t\t * This takes unsigned offsets, but the signed ones we\n\t\t * pass have been checked against overflow above.\n\t\t */\n\t\tret = ocfs2_allocate_unwritten_extents(inode, sr->l_start,\n\t\t\t\t\t\t       sr->l_len);\n\t\tbreak;\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\t\tret = ocfs2_remove_inode_range(inode, di_bh, sr->l_start,\n\t\t\t\t\t       sr->l_len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t/*\n\t * We update c/mtime for these changes\n\t */\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_inode_unlock;\n\t}\n\n\tif (change_size && i_size_read(inode) < size)\n\t\ti_size_write(inode, size);\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\tret = ocfs2_mark_inode_dirty(handle, inode, di_bh);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (file && (file->f_flags & O_SYNC))\n\t\thandle->h_sync = 1;\n\n\tocfs2_commit_trans(osb, handle);\n\nout_inode_unlock:\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\nout_rw_unlock:\n\tocfs2_rw_unlock(inode, 1);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __ocfs2_change_file_space(struct file *file, struct inode *inode,\n\t\t\t\t     loff_t f_pos, unsigned int cmd,\n\t\t\t\t     struct ocfs2_space_resv *sr,\n\t\t\t\t     int change_size)\n{\n\tint ret;\n\ts64 llen;\n\tloff_t size;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *di_bh = NULL;\n\thandle_t *handle;\n\tunsigned long long max_off = inode->i_sb->s_maxbytes;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * This prevents concurrent writes on other nodes\n\t */\n\tret = ocfs2_rw_lock(inode, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_rw_unlock;\n\t}\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tret = -EPERM;\n\t\tgoto out_inode_unlock;\n\t}\n\n\tswitch (sr->l_whence) {\n\tcase 0: /*SEEK_SET*/\n\t\tbreak;\n\tcase 1: /*SEEK_CUR*/\n\t\tsr->l_start += f_pos;\n\t\tbreak;\n\tcase 2: /*SEEK_END*/\n\t\tsr->l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_inode_unlock;\n\t}\n\tsr->l_whence = 0;\n\n\tllen = sr->l_len > 0 ? sr->l_len - 1 : sr->l_len;\n\n\tif (sr->l_start < 0\n\t    || sr->l_start > max_off\n\t    || (sr->l_start + llen) < 0\n\t    || (sr->l_start + llen) > max_off) {\n\t\tret = -EINVAL;\n\t\tgoto out_inode_unlock;\n\t}\n\tsize = sr->l_start + sr->l_len;\n\n\tif (cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64 ||\n\t    cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) {\n\t\tif (sr->l_len <= 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_inode_unlock;\n\t\t}\n\t}\n\n\tif (file && should_remove_suid(file->f_path.dentry)) {\n\t\tret = __ocfs2_write_remove_suid(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_inode_unlock;\n\t\t}\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tswitch (cmd) {\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\t\t/*\n\t\t * This takes unsigned offsets, but the signed ones we\n\t\t * pass have been checked against overflow above.\n\t\t */\n\t\tret = ocfs2_allocate_unwritten_extents(inode, sr->l_start,\n\t\t\t\t\t\t       sr->l_len);\n\t\tbreak;\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\t\tret = ocfs2_remove_inode_range(inode, di_bh, sr->l_start,\n\t\t\t\t\t       sr->l_len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t/*\n\t * We update c/mtime for these changes\n\t */\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_inode_unlock;\n\t}\n\n\tif (change_size && i_size_read(inode) < size)\n\t\ti_size_write(inode, size);\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\tret = ocfs2_mark_inode_dirty(handle, inode, di_bh);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (file && (file->f_flags & O_SYNC))\n\t\thandle->h_sync = 1;\n\n\tocfs2_commit_trans(osb, handle);\n\nout_inode_unlock:\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\nout_rw_unlock:\n\tocfs2_rw_unlock(inode, 1);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "file"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "osb"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "483-488",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_writes_unwritten_extents",
          "args": [
            "osb"
          ],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_writes_unwritten_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "490-501",
          "snippet": "static inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)\n{\n\t/*\n\t * Support for sparse files is a pre-requisite\n\t */\n\tif (!ocfs2_sparse_alloc(osb))\n\t\treturn 0;\n\n\tif (osb->s_feature_ro_compat & OCFS2_FEATURE_RO_COMPAT_UNWRITTEN)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_writes_unwritten_extents(struct ocfs2_super *osb)\n{\n\t/*\n\t * Support for sparse files is a pre-requisite\n\t */\n\tif (!ocfs2_sparse_alloc(osb))\n\t\treturn 0;\n\n\tif (osb->s_feature_ro_compat & OCFS2_FEATURE_RO_COMPAT_UNWRITTEN)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_change_file_space(struct file *file, unsigned int cmd,\n\t\t\t    struct ocfs2_space_resv *sr)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tint ret;\n\n\tif ((cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64) &&\n\t    !ocfs2_writes_unwritten_extents(osb))\n\t\treturn -ENOTTY;\n\telse if ((cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) &&\n\t\t !ocfs2_sparse_alloc(osb))\n\t\treturn -ENOTTY;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\tret = __ocfs2_change_file_space(file, inode, file->f_pos, cmd, sr, 0);\n\tmnt_drop_write_file(file);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_change_file_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1837-1974",
    "snippet": "static int __ocfs2_change_file_space(struct file *file, struct inode *inode,\n\t\t\t\t     loff_t f_pos, unsigned int cmd,\n\t\t\t\t     struct ocfs2_space_resv *sr,\n\t\t\t\t     int change_size)\n{\n\tint ret;\n\ts64 llen;\n\tloff_t size;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *di_bh = NULL;\n\thandle_t *handle;\n\tunsigned long long max_off = inode->i_sb->s_maxbytes;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * This prevents concurrent writes on other nodes\n\t */\n\tret = ocfs2_rw_lock(inode, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_rw_unlock;\n\t}\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tret = -EPERM;\n\t\tgoto out_inode_unlock;\n\t}\n\n\tswitch (sr->l_whence) {\n\tcase 0: /*SEEK_SET*/\n\t\tbreak;\n\tcase 1: /*SEEK_CUR*/\n\t\tsr->l_start += f_pos;\n\t\tbreak;\n\tcase 2: /*SEEK_END*/\n\t\tsr->l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_inode_unlock;\n\t}\n\tsr->l_whence = 0;\n\n\tllen = sr->l_len > 0 ? sr->l_len - 1 : sr->l_len;\n\n\tif (sr->l_start < 0\n\t    || sr->l_start > max_off\n\t    || (sr->l_start + llen) < 0\n\t    || (sr->l_start + llen) > max_off) {\n\t\tret = -EINVAL;\n\t\tgoto out_inode_unlock;\n\t}\n\tsize = sr->l_start + sr->l_len;\n\n\tif (cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64 ||\n\t    cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) {\n\t\tif (sr->l_len <= 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_inode_unlock;\n\t\t}\n\t}\n\n\tif (file && should_remove_suid(file->f_path.dentry)) {\n\t\tret = __ocfs2_write_remove_suid(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_inode_unlock;\n\t\t}\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tswitch (cmd) {\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\t\t/*\n\t\t * This takes unsigned offsets, but the signed ones we\n\t\t * pass have been checked against overflow above.\n\t\t */\n\t\tret = ocfs2_allocate_unwritten_extents(inode, sr->l_start,\n\t\t\t\t\t\t       sr->l_len);\n\t\tbreak;\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\t\tret = ocfs2_remove_inode_range(inode, di_bh, sr->l_start,\n\t\t\t\t\t       sr->l_len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t/*\n\t * We update c/mtime for these changes\n\t */\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_inode_unlock;\n\t}\n\n\tif (change_size && i_size_read(inode) < size)\n\t\ti_size_write(inode, size);\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\tret = ocfs2_mark_inode_dirty(handle, inode, di_bh);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (file && (file->f_flags & O_SYNC))\n\t\thandle->h_sync = 1;\n\n\tocfs2_commit_trans(osb, handle);\n\nout_inode_unlock:\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\nout_rw_unlock:\n\tocfs2_rw_unlock(inode, 1);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1692-1704",
          "snippet": "void ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "inode",
            "di_bh"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1250-1289",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "size"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_inode_range",
          "args": [
            "inode",
            "di_bh",
            "sr->l_start",
            "sr->l_len"
          ],
          "line": 1930
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_inode_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1672-1832",
          "snippet": "static int ocfs2_remove_inode_range(struct inode *inode,\n\t\t\t\t    struct buffer_head *di_bh, u64 byte_start,\n\t\t\t\t    u64 byte_len)\n{\n\tint ret = 0, flags = 0, done = 0, i;\n\tu32 trunc_start, trunc_len, trunc_end, trunc_cpos, phys_cpos;\n\tu32 cluster_in_el;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tu64 blkno, refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\ttrace_ocfs2_remove_inode_range(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)byte_start,\n\t\t\t(unsigned long long)byte_len);\n\n\tif (byte_len == 0)\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_truncate_inline(inode, di_bh, byte_start,\n\t\t\t\t\t    byte_start + byte_len, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * There's no need to get fancy with the page cache\n\t\t * truncate of an inline-data inode. We're talking\n\t\t * about less than a page here, which will be cached\n\t\t * in the dinode buffer anyway.\n\t\t */\n\t\tunmap_mapping_range(mapping, 0, 0, 0);\n\t\ttruncate_inode_pages(mapping, 0);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * For reflinks, we may need to CoW 2 clusters which might be\n\t * partially zero'd later, if hole's start and end offset were\n\t * within one cluster(means is not exactly aligned to clustersize).\n\t */\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL) {\n\n\t\tret = ocfs2_cow_file_pos(inode, di_bh, byte_start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_cow_file_pos(inode, di_bh, byte_start + byte_len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttrunc_start = ocfs2_clusters_for_bytes(osb->sb, byte_start);\n\ttrunc_end = (byte_start + byte_len) >> osb->s_clustersize_bits;\n\tcluster_in_el = trunc_end;\n\n\tret = ocfs2_zero_partial_clusters(inode, byte_start, byte_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tpath = ocfs2_new_path_from_et(&et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (trunc_end > trunc_start) {\n\n\t\tret = ocfs2_find_path(INODE_CACHE(inode), path,\n\t\t\t\t      cluster_in_el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\n\t\ti = ocfs2_find_rec(el, trunc_end);\n\t\t/*\n\t\t * Need to go to previous extent block.\n\t\t */\n\t\tif (i < 0) {\n\t\t\tif (path->p_tree_depth == 0)\n\t\t\t\tbreak;\n\n\t\t\tret = ocfs2_find_cpos_for_left_leaf(inode->i_sb,\n\t\t\t\t\t\t\t    path,\n\t\t\t\t\t\t\t    &cluster_in_el);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We've reached the leftmost extent block,\n\t\t\t * it's safe to leave.\n\t\t\t */\n\t\t\tif (cluster_in_el == 0)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * The 'pos' searched for previous extent block is\n\t\t\t * always one cluster less than actual trunc_end.\n\t\t\t */\n\t\t\ttrunc_end = cluster_in_el + 1;\n\n\t\t\tocfs2_reinit_path(path, 1);\n\n\t\t\tcontinue;\n\n\t\t} else\n\t\t\trec = &el->l_recs[i];\n\n\t\tocfs2_calc_trunc_pos(inode, el, rec, trunc_start, &trunc_cpos,\n\t\t\t\t     &trunc_len, &trunc_end, &blkno, &done);\n\t\tif (done)\n\t\t\tbreak;\n\n\t\tflags = rec->e_flags;\n\t\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\t\tret = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t       phys_cpos, trunc_len, flags,\n\t\t\t\t\t       &dealloc, refcount_loc, false);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcluster_in_el = trunc_end;\n\n\t\tocfs2_reinit_path(path, 1);\n\t}\n\n\tocfs2_truncate_cluster_pages(inode, byte_start, byte_len);\n\nout:\n\tocfs2_free_path(path);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_remove_inode_range(struct inode *inode,\n\t\t\t\t    struct buffer_head *di_bh, u64 byte_start,\n\t\t\t\t    u64 byte_len)\n{\n\tint ret = 0, flags = 0, done = 0, i;\n\tu32 trunc_start, trunc_len, trunc_end, trunc_cpos, phys_cpos;\n\tu32 cluster_in_el;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tu64 blkno, refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\ttrace_ocfs2_remove_inode_range(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)byte_start,\n\t\t\t(unsigned long long)byte_len);\n\n\tif (byte_len == 0)\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_truncate_inline(inode, di_bh, byte_start,\n\t\t\t\t\t    byte_start + byte_len, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * There's no need to get fancy with the page cache\n\t\t * truncate of an inline-data inode. We're talking\n\t\t * about less than a page here, which will be cached\n\t\t * in the dinode buffer anyway.\n\t\t */\n\t\tunmap_mapping_range(mapping, 0, 0, 0);\n\t\ttruncate_inode_pages(mapping, 0);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * For reflinks, we may need to CoW 2 clusters which might be\n\t * partially zero'd later, if hole's start and end offset were\n\t * within one cluster(means is not exactly aligned to clustersize).\n\t */\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL) {\n\n\t\tret = ocfs2_cow_file_pos(inode, di_bh, byte_start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_cow_file_pos(inode, di_bh, byte_start + byte_len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttrunc_start = ocfs2_clusters_for_bytes(osb->sb, byte_start);\n\ttrunc_end = (byte_start + byte_len) >> osb->s_clustersize_bits;\n\tcluster_in_el = trunc_end;\n\n\tret = ocfs2_zero_partial_clusters(inode, byte_start, byte_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tpath = ocfs2_new_path_from_et(&et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (trunc_end > trunc_start) {\n\n\t\tret = ocfs2_find_path(INODE_CACHE(inode), path,\n\t\t\t\t      cluster_in_el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\n\t\ti = ocfs2_find_rec(el, trunc_end);\n\t\t/*\n\t\t * Need to go to previous extent block.\n\t\t */\n\t\tif (i < 0) {\n\t\t\tif (path->p_tree_depth == 0)\n\t\t\t\tbreak;\n\n\t\t\tret = ocfs2_find_cpos_for_left_leaf(inode->i_sb,\n\t\t\t\t\t\t\t    path,\n\t\t\t\t\t\t\t    &cluster_in_el);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We've reached the leftmost extent block,\n\t\t\t * it's safe to leave.\n\t\t\t */\n\t\t\tif (cluster_in_el == 0)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * The 'pos' searched for previous extent block is\n\t\t\t * always one cluster less than actual trunc_end.\n\t\t\t */\n\t\t\ttrunc_end = cluster_in_el + 1;\n\n\t\t\tocfs2_reinit_path(path, 1);\n\n\t\t\tcontinue;\n\n\t\t} else\n\t\t\trec = &el->l_recs[i];\n\n\t\tocfs2_calc_trunc_pos(inode, el, rec, trunc_start, &trunc_cpos,\n\t\t\t\t     &trunc_len, &trunc_end, &blkno, &done);\n\t\tif (done)\n\t\t\tbreak;\n\n\t\tflags = rec->e_flags;\n\t\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\t\tret = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t       phys_cpos, trunc_len, flags,\n\t\t\t\t\t       &dealloc, refcount_loc, false);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcluster_in_el = trunc_end;\n\n\t\tocfs2_reinit_path(path, 1);\n\t}\n\n\tocfs2_truncate_cluster_pages(inode, byte_start, byte_len);\n\nout:\n\tocfs2_free_path(path);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_allocate_unwritten_extents",
          "args": [
            "inode",
            "sr->l_start",
            "sr->l_len"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_allocate_unwritten_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1422-1498",
          "snippet": "static int ocfs2_allocate_unwritten_extents(struct inode *inode,\n\t\t\t\t\t    u64 start, u64 len)\n{\n\tint ret;\n\tu32 cpos, phys_cpos, clusters, alloc_size;\n\tu64 end = start + len;\n\tstruct buffer_head *di_bh = NULL;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_read_inode_block(inode, &di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Nothing to do if the requested reservation range\n\t\t * fits within the inode.\n\t\t */\n\t\tif (ocfs2_size_fits_inline_data(di_bh, end))\n\t\t\tgoto out;\n\n\t\tret = ocfs2_convert_inline_data_to_extents(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We consider both start and len to be inclusive.\n\t */\n\tcpos = start >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(inode->i_sb, start + len);\n\tclusters -= cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos,\n\t\t\t\t\t &alloc_size, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Hole or existing extent len can be arbitrary, so\n\t\t * cap it to our own allocation request.\n\t\t */\n\t\tif (alloc_size > clusters)\n\t\t\talloc_size = clusters;\n\n\t\tif (phys_cpos) {\n\t\t\t/*\n\t\t\t * We already have an allocation at this\n\t\t\t * region so we can safely skip it.\n\t\t\t */\n\t\t\tgoto next;\n\t\t}\n\n\t\tret = __ocfs2_extend_allocation(inode, cpos, alloc_size, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\nnext:\n\t\tcpos += alloc_size;\n\t\tclusters -= alloc_size;\n\t}\n\n\tret = 0;\nout:\n\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_allocate_unwritten_extents(struct inode *inode,\n\t\t\t\t\t    u64 start, u64 len)\n{\n\tint ret;\n\tu32 cpos, phys_cpos, clusters, alloc_size;\n\tu64 end = start + len;\n\tstruct buffer_head *di_bh = NULL;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_read_inode_block(inode, &di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Nothing to do if the requested reservation range\n\t\t * fits within the inode.\n\t\t */\n\t\tif (ocfs2_size_fits_inline_data(di_bh, end))\n\t\t\tgoto out;\n\n\t\tret = ocfs2_convert_inline_data_to_extents(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We consider both start and len to be inclusive.\n\t */\n\tcpos = start >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(inode->i_sb, start + len);\n\tclusters -= cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos,\n\t\t\t\t\t &alloc_size, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Hole or existing extent len can be arbitrary, so\n\t\t * cap it to our own allocation request.\n\t\t */\n\t\tif (alloc_size > clusters)\n\t\t\talloc_size = clusters;\n\n\t\tif (phys_cpos) {\n\t\t\t/*\n\t\t\t * We already have an allocation at this\n\t\t\t * region so we can safely skip it.\n\t\t\t */\n\t\t\tgoto next;\n\t\t}\n\n\t\tret = __ocfs2_extend_allocation(inode, cpos, alloc_size, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\nnext:\n\t\tcpos += alloc_size;\n\t\tclusters -= alloc_size;\n\t}\n\n\tret = 0;\nout:\n\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_write_remove_suid",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_write_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1320-1360",
          "snippet": "static int __ocfs2_write_remove_suid(struct inode *inode,\n\t\t\t\t     struct buffer_head *bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di;\n\n\ttrace_ocfs2_write_remove_suid(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tinode->i_mode);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_trans;\n\t}\n\n\tinode->i_mode &= ~S_ISUID;\n\tif ((inode->i_mode & S_ISGID) && (inode->i_mode & S_IXGRP))\n\t\tinode->i_mode &= ~S_ISGID;\n\n\tdi = (struct ocfs2_dinode *) bh->b_data;\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, bh);\n\nout_trans:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __ocfs2_write_remove_suid(struct inode *inode,\n\t\t\t\t     struct buffer_head *bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di;\n\n\ttrace_ocfs2_write_remove_suid(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tinode->i_mode);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_trans;\n\t}\n\n\tinode->i_mode &= ~S_ISUID;\n\tif ((inode->i_mode & S_ISGID) && (inode->i_mode & S_IXGRP))\n\t\tinode->i_mode &= ~S_ISGID;\n\n\tdi = (struct ocfs2_dinode *) bh->b_data;\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, bh);\n\nout_trans:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "should_remove_suid",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "should_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1640-1660",
          "snippet": "int should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = dentry->d_inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nint should_remove_suid(struct dentry *dentry)\n{\n\tumode_t mode = dentry->d_inode->i_mode;\n\tint kill = 0;\n\n\t/* suid always must be killed */\n\tif (unlikely(mode & S_ISUID))\n\t\tkill = ATTR_KILL_SUID;\n\n\t/*\n\t * sgid without any exec bits is just a mandatory locking mark; leave\n\t * it alone.  If some exec bits are set, it's a real sgid; kill it.\n\t */\n\tif (unlikely((mode & S_ISGID) && (mode & S_IXGRP)))\n\t\tkill |= ATTR_KILL_SGID;\n\n\tif (unlikely(kill && !capable(CAP_FSETID) && S_ISREG(mode)))\n\t\treturn kill;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&di_bh",
            "1"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_lock",
          "args": [
            "inode",
            "1"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1665-1690",
          "snippet": "int ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_soft_readonly",
          "args": [
            "osb"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_soft_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "626-635",
          "snippet": "static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_SOFT_RO\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_SOFT_RO\t0x0001\n\nstatic inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __ocfs2_change_file_space(struct file *file, struct inode *inode,\n\t\t\t\t     loff_t f_pos, unsigned int cmd,\n\t\t\t\t     struct ocfs2_space_resv *sr,\n\t\t\t\t     int change_size)\n{\n\tint ret;\n\ts64 llen;\n\tloff_t size;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *di_bh = NULL;\n\thandle_t *handle;\n\tunsigned long long max_off = inode->i_sb->s_maxbytes;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * This prevents concurrent writes on other nodes\n\t */\n\tret = ocfs2_rw_lock(inode, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_inode_lock(inode, &di_bh, 1);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_rw_unlock;\n\t}\n\n\tif (inode->i_flags & (S_IMMUTABLE|S_APPEND)) {\n\t\tret = -EPERM;\n\t\tgoto out_inode_unlock;\n\t}\n\n\tswitch (sr->l_whence) {\n\tcase 0: /*SEEK_SET*/\n\t\tbreak;\n\tcase 1: /*SEEK_CUR*/\n\t\tsr->l_start += f_pos;\n\t\tbreak;\n\tcase 2: /*SEEK_END*/\n\t\tsr->l_start += i_size_read(inode);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_inode_unlock;\n\t}\n\tsr->l_whence = 0;\n\n\tllen = sr->l_len > 0 ? sr->l_len - 1 : sr->l_len;\n\n\tif (sr->l_start < 0\n\t    || sr->l_start > max_off\n\t    || (sr->l_start + llen) < 0\n\t    || (sr->l_start + llen) > max_off) {\n\t\tret = -EINVAL;\n\t\tgoto out_inode_unlock;\n\t}\n\tsize = sr->l_start + sr->l_len;\n\n\tif (cmd == OCFS2_IOC_RESVSP || cmd == OCFS2_IOC_RESVSP64 ||\n\t    cmd == OCFS2_IOC_UNRESVSP || cmd == OCFS2_IOC_UNRESVSP64) {\n\t\tif (sr->l_len <= 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_inode_unlock;\n\t\t}\n\t}\n\n\tif (file && should_remove_suid(file->f_path.dentry)) {\n\t\tret = __ocfs2_write_remove_suid(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_inode_unlock;\n\t\t}\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tswitch (cmd) {\n\tcase OCFS2_IOC_RESVSP:\n\tcase OCFS2_IOC_RESVSP64:\n\t\t/*\n\t\t * This takes unsigned offsets, but the signed ones we\n\t\t * pass have been checked against overflow above.\n\t\t */\n\t\tret = ocfs2_allocate_unwritten_extents(inode, sr->l_start,\n\t\t\t\t\t\t       sr->l_len);\n\t\tbreak;\n\tcase OCFS2_IOC_UNRESVSP:\n\tcase OCFS2_IOC_UNRESVSP64:\n\t\tret = ocfs2_remove_inode_range(inode, di_bh, sr->l_start,\n\t\t\t\t\t       sr->l_len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_inode_unlock;\n\t}\n\n\t/*\n\t * We update c/mtime for these changes\n\t */\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_inode_unlock;\n\t}\n\n\tif (change_size && i_size_read(inode) < size)\n\t\ti_size_write(inode, size);\n\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\tret = ocfs2_mark_inode_dirty(handle, inode, di_bh);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (file && (file->f_flags & O_SYNC))\n\t\thandle->h_sync = 1;\n\n\tocfs2_commit_trans(osb, handle);\n\nout_inode_unlock:\n\tbrelse(di_bh);\n\tocfs2_inode_unlock(inode, 1);\nout_rw_unlock:\n\tocfs2_rw_unlock(inode, 1);\n\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_remove_inode_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1672-1832",
    "snippet": "static int ocfs2_remove_inode_range(struct inode *inode,\n\t\t\t\t    struct buffer_head *di_bh, u64 byte_start,\n\t\t\t\t    u64 byte_len)\n{\n\tint ret = 0, flags = 0, done = 0, i;\n\tu32 trunc_start, trunc_len, trunc_end, trunc_cpos, phys_cpos;\n\tu32 cluster_in_el;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tu64 blkno, refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\ttrace_ocfs2_remove_inode_range(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)byte_start,\n\t\t\t(unsigned long long)byte_len);\n\n\tif (byte_len == 0)\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_truncate_inline(inode, di_bh, byte_start,\n\t\t\t\t\t    byte_start + byte_len, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * There's no need to get fancy with the page cache\n\t\t * truncate of an inline-data inode. We're talking\n\t\t * about less than a page here, which will be cached\n\t\t * in the dinode buffer anyway.\n\t\t */\n\t\tunmap_mapping_range(mapping, 0, 0, 0);\n\t\ttruncate_inode_pages(mapping, 0);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * For reflinks, we may need to CoW 2 clusters which might be\n\t * partially zero'd later, if hole's start and end offset were\n\t * within one cluster(means is not exactly aligned to clustersize).\n\t */\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL) {\n\n\t\tret = ocfs2_cow_file_pos(inode, di_bh, byte_start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_cow_file_pos(inode, di_bh, byte_start + byte_len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttrunc_start = ocfs2_clusters_for_bytes(osb->sb, byte_start);\n\ttrunc_end = (byte_start + byte_len) >> osb->s_clustersize_bits;\n\tcluster_in_el = trunc_end;\n\n\tret = ocfs2_zero_partial_clusters(inode, byte_start, byte_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tpath = ocfs2_new_path_from_et(&et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (trunc_end > trunc_start) {\n\n\t\tret = ocfs2_find_path(INODE_CACHE(inode), path,\n\t\t\t\t      cluster_in_el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\n\t\ti = ocfs2_find_rec(el, trunc_end);\n\t\t/*\n\t\t * Need to go to previous extent block.\n\t\t */\n\t\tif (i < 0) {\n\t\t\tif (path->p_tree_depth == 0)\n\t\t\t\tbreak;\n\n\t\t\tret = ocfs2_find_cpos_for_left_leaf(inode->i_sb,\n\t\t\t\t\t\t\t    path,\n\t\t\t\t\t\t\t    &cluster_in_el);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We've reached the leftmost extent block,\n\t\t\t * it's safe to leave.\n\t\t\t */\n\t\t\tif (cluster_in_el == 0)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * The 'pos' searched for previous extent block is\n\t\t\t * always one cluster less than actual trunc_end.\n\t\t\t */\n\t\t\ttrunc_end = cluster_in_el + 1;\n\n\t\t\tocfs2_reinit_path(path, 1);\n\n\t\t\tcontinue;\n\n\t\t} else\n\t\t\trec = &el->l_recs[i];\n\n\t\tocfs2_calc_trunc_pos(inode, el, rec, trunc_start, &trunc_cpos,\n\t\t\t\t     &trunc_len, &trunc_end, &blkno, &done);\n\t\tif (done)\n\t\t\tbreak;\n\n\t\tflags = rec->e_flags;\n\t\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\t\tret = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t       phys_cpos, trunc_len, flags,\n\t\t\t\t\t       &dealloc, refcount_loc, false);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcluster_in_el = trunc_end;\n\n\t\tocfs2_reinit_path(path, 1);\n\t}\n\n\tocfs2_truncate_cluster_pages(inode, byte_start, byte_len);\n\nout:\n\tocfs2_free_path(path);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "osb",
            "&dealloc"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6472-6513",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "1"
          ],
          "line": 1828
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "path"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_cluster_pages",
          "args": [
            "inode",
            "byte_start",
            "byte_len"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_cluster_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1504-1519",
          "snippet": "static void ocfs2_truncate_cluster_pages(struct inode *inode, u64 byte_start,\n\t\t\t\t\t u64 byte_len)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tloff_t start, end;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\tstart = (loff_t)ocfs2_align_bytes_to_clusters(inode->i_sb, byte_start);\n\tend = byte_start + byte_len;\n\tend = end & ~(osb->s_clustersize - 1);\n\n\tif (start < end) {\n\t\tunmap_mapping_range(mapping, start, end - start, 0);\n\t\ttruncate_inode_pages_range(mapping, start, end - 1);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_truncate_cluster_pages(struct inode *inode, u64 byte_start,\n\t\t\t\t\t u64 byte_len)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tloff_t start, end;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\tstart = (loff_t)ocfs2_align_bytes_to_clusters(inode->i_sb, byte_start);\n\tend = byte_start + byte_len;\n\tend = end & ~(osb->s_clustersize - 1);\n\n\tif (start < end) {\n\t\tunmap_mapping_range(mapping, start, end - start, 0);\n\t\ttruncate_inode_pages_range(mapping, start, end - 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_reinit_path",
          "args": [
            "path",
            "1"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reinit_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "580-607",
          "snippet": "void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)\n{\n\tint i, start = 0, depth = 0;\n\tstruct ocfs2_path_item *node;\n\n\tif (keep_root)\n\t\tstart = 1;\n\n\tfor(i = start; i < path_num_items(path); i++) {\n\t\tnode = &path->p_node[i];\n\n\t\tbrelse(node->bh);\n\t\tnode->bh = NULL;\n\t\tnode->el = NULL;\n\t}\n\n\t/*\n\t * Tree depth may change during truncate, or insert. If we're\n\t * keeping the root extent list, then make sure that our path\n\t * structure reflects the proper depth.\n\t */\n\tif (keep_root)\n\t\tdepth = le16_to_cpu(path_root_el(path)->l_tree_depth);\n\telse\n\t\tpath_root_access(path) = NULL;\n\n\tpath->p_tree_depth = depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_btree_range",
          "args": [
            "inode",
            "&et",
            "trunc_cpos",
            "phys_cpos",
            "trunc_len",
            "flags",
            "&dealloc",
            "refcount_loc",
            "false"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_btree_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5661-5773",
          "snippet": "int ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tmutex_unlock(&tl_inode->i_mutex);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_btree_range(struct inode *inode,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 phys_cpos, u32 len, int flags,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     u64 refcount_loc, bool refcount_tree_locked)\n{\n\tint ret, credits = 0, extra_blocks = 0;\n\tu64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct inode *tl_inode = osb->osb_tl_inode;\n\thandle_t *handle;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && len) {\n\t\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features &\n\t\t\t OCFS2_HAS_REFCOUNT_FL));\n\n\t\tif (!refcount_tree_locked) {\n\t\t\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t\t\t       &ref_tree, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tret = ocfs2_prepare_refcount_change_for_del(inode,\n\t\t\t\t\t\t\t    refcount_loc,\n\t\t\t\t\t\t\t    phys_blkno,\n\t\t\t\t\t\t\t    len,\n\t\t\t\t\t\t\t    &credits,\n\t\t\t\t\t\t\t    &extra_blocks);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = ocfs2_reserve_blocks_for_rec_trunc(inode, et, 1, &meta_ac,\n\t\t\t\t\t\t extra_blocks);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto bail;\n\t}\n\n\tmutex_lock(&tl_inode->i_mutex);\n\n\tif (ocfs2_truncate_log_needs_flush(osb)) {\n\t\tret = __ocfs2_flush_truncate_log(osb);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\tocfs2_remove_extent_credits(osb->sb) + credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tdquot_free_space_nodirty(inode,\n\t\t\t\t  ocfs2_clusters_to_bytes(inode->i_sb, len));\n\n\tret = ocfs2_remove_extent(handle, et, cpos, len, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_et_update_clusters(et, -len);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tif (phys_blkno) {\n\t\tif (flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tret = ocfs2_decrease_refcount(inode, handle,\n\t\t\t\t\tocfs2_blocks_to_clusters(osb->sb,\n\t\t\t\t\t\t\t\t phys_blkno),\n\t\t\t\t\tlen, meta_ac,\n\t\t\t\t\tdealloc, 1);\n\t\telse\n\t\t\tret = ocfs2_truncate_log_append(osb, handle,\n\t\t\t\t\t\t\tphys_blkno, len);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tmutex_unlock(&tl_inode->i_mutex);\nbail:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "blkno"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_trunc_pos",
          "args": [
            "inode",
            "el",
            "rec",
            "trunc_start",
            "&trunc_cpos",
            "&trunc_len",
            "&trunc_end",
            "&blkno",
            "&done"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_trunc_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1616-1670",
          "snippet": "static void ocfs2_calc_trunc_pos(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_extent_rec *rec,\n\t\t\t\t u32 trunc_start, u32 *trunc_cpos,\n\t\t\t\t u32 *trunc_len, u32 *trunc_end,\n\t\t\t\t u64 *blkno, int *done)\n{\n\tint ret = 0;\n\tu32 coff, range;\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (le32_to_cpu(rec->e_cpos) >= trunc_start) {\n\t\t/*\n\t\t * remove an entire extent record.\n\t\t */\n\t\t*trunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\t/*\n\t\t * Skip holes if any.\n\t\t */\n\t\tif (range < *trunc_end)\n\t\t\t*trunc_end = range;\n\t\t*trunc_len = *trunc_end - le32_to_cpu(rec->e_cpos);\n\t\t*blkno = le64_to_cpu(rec->e_blkno);\n\t\t*trunc_end = le32_to_cpu(rec->e_cpos);\n\t} else if (range > trunc_start) {\n\t\t/*\n\t\t * remove a partial extent record, which means we're\n\t\t * removing the last extent record.\n\t\t */\n\t\t*trunc_cpos = trunc_start;\n\t\t/*\n\t\t * skip hole if any.\n\t\t */\n\t\tif (range < *trunc_end)\n\t\t\t*trunc_end = range;\n\t\t*trunc_len = *trunc_end - trunc_start;\n\t\tcoff = trunc_start - le32_to_cpu(rec->e_cpos);\n\t\t*blkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t\t*trunc_end = trunc_start;\n\t} else {\n\t\t/*\n\t\t * It may have two following possibilities:\n\t\t *\n\t\t * - last record has been removed\n\t\t * - trunc_start was within a hole\n\t\t *\n\t\t * both two cases mean the completion of hole punching.\n\t\t */\n\t\tret = 1;\n\t}\n\n\t*done = ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_calc_trunc_pos(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_extent_rec *rec,\n\t\t\t\t u32 trunc_start, u32 *trunc_cpos,\n\t\t\t\t u32 *trunc_len, u32 *trunc_end,\n\t\t\t\t u64 *blkno, int *done)\n{\n\tint ret = 0;\n\tu32 coff, range;\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (le32_to_cpu(rec->e_cpos) >= trunc_start) {\n\t\t/*\n\t\t * remove an entire extent record.\n\t\t */\n\t\t*trunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\t/*\n\t\t * Skip holes if any.\n\t\t */\n\t\tif (range < *trunc_end)\n\t\t\t*trunc_end = range;\n\t\t*trunc_len = *trunc_end - le32_to_cpu(rec->e_cpos);\n\t\t*blkno = le64_to_cpu(rec->e_blkno);\n\t\t*trunc_end = le32_to_cpu(rec->e_cpos);\n\t} else if (range > trunc_start) {\n\t\t/*\n\t\t * remove a partial extent record, which means we're\n\t\t * removing the last extent record.\n\t\t */\n\t\t*trunc_cpos = trunc_start;\n\t\t/*\n\t\t * skip hole if any.\n\t\t */\n\t\tif (range < *trunc_end)\n\t\t\t*trunc_end = range;\n\t\t*trunc_len = *trunc_end - trunc_start;\n\t\tcoff = trunc_start - le32_to_cpu(rec->e_cpos);\n\t\t*blkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t\t*trunc_end = trunc_start;\n\t} else {\n\t\t/*\n\t\t * It may have two following possibilities:\n\t\t *\n\t\t * - last record has been removed\n\t\t * - trunc_start was within a hole\n\t\t *\n\t\t * both two cases mean the completion of hole punching.\n\t\t */\n\t\tret = 1;\n\t}\n\n\t*done = ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_left_leaf",
          "args": [
            "inode->i_sb",
            "path",
            "&cluster_in_el"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_left_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2205-2272",
          "snippet": "int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_left_leaf(struct super_block *sb,\n\t\t\t\t  struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\tBUG_ON(path->p_tree_depth == 0);\n\n\t*cpos = 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just before the one in our\n\t\t * path.\n\t\t */\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the leftmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The leftmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);\n\t\t\t\t*cpos = *cpos + ocfs2_rec_clusters(el,\n\t\t\t\t\t\t\t   &el->l_recs[j - 1]);\n\t\t\t\t*cpos = *cpos - 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_rec",
          "args": [
            "el",
            "trunc_end"
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1592-1606",
          "snippet": "static int ocfs2_find_rec(struct ocfs2_extent_list *el, u32 pos)\n{\n\tint i;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) < pos)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_find_rec(struct ocfs2_extent_list *el, u32 pos)\n{\n\tint i;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) < pos)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "INODE_CACHE(inode)",
            "path",
            "cluster_in_el"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "&et"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "713-717",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_partial_clusters",
          "args": [
            "inode",
            "byte_start",
            "byte_len"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_partial_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1521-1590",
          "snippet": "static int ocfs2_zero_partial_clusters(struct inode *inode,\n\t\t\t\t       u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 tmpend, end = start + len;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tunsigned int csize = osb->s_clustersize;\n\thandle_t *handle;\n\n\t/*\n\t * The \"start\" and \"end\" values are NOT necessarily part of\n\t * the range whose allocation is being deleted. Rather, this\n\t * is what the user passed in with the request. We must zero\n\t * partial clusters here. There's no need to worry about\n\t * physical allocation - the zeroing code knows to skip holes.\n\t */\n\ttrace_ocfs2_zero_partial_clusters(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)start, (unsigned long long)end);\n\n\t/*\n\t * If both edges are on a cluster boundary then there's no\n\t * zeroing required as the region is part of the allocation to\n\t * be truncated.\n\t */\n\tif ((start & (csize - 1)) == 0 && (end & (csize - 1)) == 0)\n\t\tgoto out;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We want to get the byte offset of the end of the 1st cluster.\n\t */\n\ttmpend = (u64)osb->s_clustersize + (start & ~(osb->s_clustersize - 1));\n\tif (tmpend > end)\n\t\ttmpend = end;\n\n\ttrace_ocfs2_zero_partial_clusters_range1((unsigned long long)start,\n\t\t\t\t\t\t (unsigned long long)tmpend);\n\n\tret = ocfs2_zero_range_for_truncate(inode, handle, start, tmpend);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (tmpend < end) {\n\t\t/*\n\t\t * This may make start and end equal, but the zeroing\n\t\t * code will skip any work in that case so there's no\n\t\t * need to catch it up here.\n\t\t */\n\t\tstart = end & ~(osb->s_clustersize - 1);\n\n\t\ttrace_ocfs2_zero_partial_clusters_range2(\n\t\t\t(unsigned long long)start, (unsigned long long)end);\n\n\t\tret = ocfs2_zero_range_for_truncate(inode, handle, start, end);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_zero_partial_clusters(struct inode *inode,\n\t\t\t\t       u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 tmpend, end = start + len;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tunsigned int csize = osb->s_clustersize;\n\thandle_t *handle;\n\n\t/*\n\t * The \"start\" and \"end\" values are NOT necessarily part of\n\t * the range whose allocation is being deleted. Rather, this\n\t * is what the user passed in with the request. We must zero\n\t * partial clusters here. There's no need to worry about\n\t * physical allocation - the zeroing code knows to skip holes.\n\t */\n\ttrace_ocfs2_zero_partial_clusters(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)start, (unsigned long long)end);\n\n\t/*\n\t * If both edges are on a cluster boundary then there's no\n\t * zeroing required as the region is part of the allocation to\n\t * be truncated.\n\t */\n\tif ((start & (csize - 1)) == 0 && (end & (csize - 1)) == 0)\n\t\tgoto out;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We want to get the byte offset of the end of the 1st cluster.\n\t */\n\ttmpend = (u64)osb->s_clustersize + (start & ~(osb->s_clustersize - 1));\n\tif (tmpend > end)\n\t\ttmpend = end;\n\n\ttrace_ocfs2_zero_partial_clusters_range1((unsigned long long)start,\n\t\t\t\t\t\t (unsigned long long)tmpend);\n\n\tret = ocfs2_zero_range_for_truncate(inode, handle, start, tmpend);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (tmpend < end) {\n\t\t/*\n\t\t * This may make start and end equal, but the zeroing\n\t\t * code will skip any work in that case so there's no\n\t\t * need to catch it up here.\n\t\t */\n\t\tstart = end & ~(osb->s_clustersize - 1);\n\n\t\ttrace_ocfs2_zero_partial_clusters_range2(\n\t\t\t(unsigned long long)start, (unsigned long long)end);\n\n\t\tret = ocfs2_zero_range_for_truncate(inode, handle, start, end);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "osb->sb",
            "byte_start"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cow_file_pos",
          "args": [
            "inode",
            "di_bh",
            "byte_start + byte_len"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_file_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "345-376",
          "snippet": "static int ocfs2_cow_file_pos(struct inode *inode,\n\t\t\t      struct buffer_head *fe_bh,\n\t\t\t      u64 offset)\n{\n\tint status;\n\tu32 phys, cpos = offset >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\n\t/*\n\t * If the new offset is aligned to the range of the cluster, there is\n\t * no space for ocfs2_zero_range_for_truncate to fill, so no need to\n\t * CoW either.\n\t */\n\tif ((offset & (OCFS2_SB(inode->i_sb)->s_clustersize - 1)) == 0)\n\t\treturn 0;\n\n\tstatus = ocfs2_get_clusters(inode, cpos, &phys,\n\t\t\t\t    &num_clusters, &ext_flags);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\treturn ocfs2_refcount_cow(inode, fe_bh, cpos, 1, cpos+1);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_cow_file_pos(struct inode *inode,\n\t\t\t      struct buffer_head *fe_bh,\n\t\t\t      u64 offset)\n{\n\tint status;\n\tu32 phys, cpos = offset >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\n\t/*\n\t * If the new offset is aligned to the range of the cluster, there is\n\t * no space for ocfs2_zero_range_for_truncate to fill, so no need to\n\t * CoW either.\n\t */\n\tif ((offset & (OCFS2_SB(inode->i_sb)->s_clustersize - 1)) == 0)\n\t\treturn 0;\n\n\tstatus = ocfs2_get_clusters(inode, cpos, &phys,\n\t\t\t\t    &num_clusters, &ext_flags);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\treturn ocfs2_refcount_cow(inode, fe_bh, cpos, 1, cpos+1);\n\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "mapping",
            "0"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_range",
          "args": [
            "mapping",
            "0",
            "0",
            "0"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_inline",
          "args": [
            "inode",
            "di_bh",
            "byte_start",
            "byte_start + byte_len",
            "0"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "7177-7248",
          "snippet": "int ocfs2_truncate_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  unsigned int start, unsigned int end, int trunc)\n{\n\tint ret;\n\tunsigned int numbytes;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\tBUG_ON(start > end);\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    !(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL) ||\n\t    !ocfs2_supports_inline_data(osb)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inline data flags for inode %llu don't agree! \"\n\t\t\t    \"Disk: 0x%x, Memory: 0x%x, Superblock: 0x%x\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    le16_to_cpu(di->i_dyn_features),\n\t\t\t    OCFS2_I(inode)->ip_dyn_features,\n\t\t\t    osb->s_feature_incompat);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnumbytes = end - start;\n\tmemset(idata->id_data + start, 0, numbytes);\n\n\t/*\n\t * No need to worry about the data page here - it's been\n\t * truncated already and inline data doesn't need it for\n\t * pushing zero's to disk, so we'll let readpage pick it up\n\t * later.\n\t */\n\tif (trunc) {\n\t\ti_size_write(inode, start);\n\t\tdi->i_size = cpu_to_le64(start);\n\t}\n\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  unsigned int start, unsigned int end, int trunc)\n{\n\tint ret;\n\tunsigned int numbytes;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\tBUG_ON(start > end);\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    !(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL) ||\n\t    !ocfs2_supports_inline_data(osb)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inline data flags for inode %llu don't agree! \"\n\t\t\t    \"Disk: 0x%x, Memory: 0x%x, Superblock: 0x%x\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    le16_to_cpu(di->i_dyn_features),\n\t\t\t    OCFS2_I(inode)->ip_dyn_features,\n\t\t\t    osb->s_feature_incompat);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnumbytes = end - start;\n\tmemset(idata->id_data + start, 0, numbytes);\n\n\t/*\n\t * No need to worry about the data page here - it's been\n\t * truncated already and inline data doesn't need it for\n\t * pushing zero's to disk, so we'll let readpage pick it up\n\t * later.\n\t */\n\tif (trunc) {\n\t\ti_size_write(inode, start);\n\t\tdi->i_size = cpu_to_le64(start);\n\t}\n\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_remove_inode_range",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)byte_start",
            "(unsigned long long)byte_len"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&dealloc"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "205-209",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "di_bh"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "458-464",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_refcount_loc"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_remove_inode_range(struct inode *inode,\n\t\t\t\t    struct buffer_head *di_bh, u64 byte_start,\n\t\t\t\t    u64 byte_len)\n{\n\tint ret = 0, flags = 0, done = 0, i;\n\tu32 trunc_start, trunc_len, trunc_end, trunc_cpos, phys_cpos;\n\tu32 cluster_in_el;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tu64 blkno, refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\ttrace_ocfs2_remove_inode_range(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)byte_start,\n\t\t\t(unsigned long long)byte_len);\n\n\tif (byte_len == 0)\n\t\treturn 0;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_truncate_inline(inode, di_bh, byte_start,\n\t\t\t\t\t    byte_start + byte_len, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * There's no need to get fancy with the page cache\n\t\t * truncate of an inline-data inode. We're talking\n\t\t * about less than a page here, which will be cached\n\t\t * in the dinode buffer anyway.\n\t\t */\n\t\tunmap_mapping_range(mapping, 0, 0, 0);\n\t\ttruncate_inode_pages(mapping, 0);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * For reflinks, we may need to CoW 2 clusters which might be\n\t * partially zero'd later, if hole's start and end offset were\n\t * within one cluster(means is not exactly aligned to clustersize).\n\t */\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL) {\n\n\t\tret = ocfs2_cow_file_pos(inode, di_bh, byte_start);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_cow_file_pos(inode, di_bh, byte_start + byte_len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttrunc_start = ocfs2_clusters_for_bytes(osb->sb, byte_start);\n\ttrunc_end = (byte_start + byte_len) >> osb->s_clustersize_bits;\n\tcluster_in_el = trunc_end;\n\n\tret = ocfs2_zero_partial_clusters(inode, byte_start, byte_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tpath = ocfs2_new_path_from_et(&et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\twhile (trunc_end > trunc_start) {\n\n\t\tret = ocfs2_find_path(INODE_CACHE(inode), path,\n\t\t\t\t      cluster_in_el);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\n\t\ti = ocfs2_find_rec(el, trunc_end);\n\t\t/*\n\t\t * Need to go to previous extent block.\n\t\t */\n\t\tif (i < 0) {\n\t\t\tif (path->p_tree_depth == 0)\n\t\t\t\tbreak;\n\n\t\t\tret = ocfs2_find_cpos_for_left_leaf(inode->i_sb,\n\t\t\t\t\t\t\t    path,\n\t\t\t\t\t\t\t    &cluster_in_el);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We've reached the leftmost extent block,\n\t\t\t * it's safe to leave.\n\t\t\t */\n\t\t\tif (cluster_in_el == 0)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * The 'pos' searched for previous extent block is\n\t\t\t * always one cluster less than actual trunc_end.\n\t\t\t */\n\t\t\ttrunc_end = cluster_in_el + 1;\n\n\t\t\tocfs2_reinit_path(path, 1);\n\n\t\t\tcontinue;\n\n\t\t} else\n\t\t\trec = &el->l_recs[i];\n\n\t\tocfs2_calc_trunc_pos(inode, el, rec, trunc_start, &trunc_cpos,\n\t\t\t\t     &trunc_len, &trunc_end, &blkno, &done);\n\t\tif (done)\n\t\t\tbreak;\n\n\t\tflags = rec->e_flags;\n\t\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\t\tret = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t       phys_cpos, trunc_len, flags,\n\t\t\t\t\t       &dealloc, refcount_loc, false);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcluster_in_el = trunc_end;\n\n\t\tocfs2_reinit_path(path, 1);\n\t}\n\n\tocfs2_truncate_cluster_pages(inode, byte_start, byte_len);\n\nout:\n\tocfs2_free_path(path);\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_calc_trunc_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1616-1670",
    "snippet": "static void ocfs2_calc_trunc_pos(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_extent_rec *rec,\n\t\t\t\t u32 trunc_start, u32 *trunc_cpos,\n\t\t\t\t u32 *trunc_len, u32 *trunc_end,\n\t\t\t\t u64 *blkno, int *done)\n{\n\tint ret = 0;\n\tu32 coff, range;\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (le32_to_cpu(rec->e_cpos) >= trunc_start) {\n\t\t/*\n\t\t * remove an entire extent record.\n\t\t */\n\t\t*trunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\t/*\n\t\t * Skip holes if any.\n\t\t */\n\t\tif (range < *trunc_end)\n\t\t\t*trunc_end = range;\n\t\t*trunc_len = *trunc_end - le32_to_cpu(rec->e_cpos);\n\t\t*blkno = le64_to_cpu(rec->e_blkno);\n\t\t*trunc_end = le32_to_cpu(rec->e_cpos);\n\t} else if (range > trunc_start) {\n\t\t/*\n\t\t * remove a partial extent record, which means we're\n\t\t * removing the last extent record.\n\t\t */\n\t\t*trunc_cpos = trunc_start;\n\t\t/*\n\t\t * skip hole if any.\n\t\t */\n\t\tif (range < *trunc_end)\n\t\t\t*trunc_end = range;\n\t\t*trunc_len = *trunc_end - trunc_start;\n\t\tcoff = trunc_start - le32_to_cpu(rec->e_cpos);\n\t\t*blkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t\t*trunc_end = trunc_start;\n\t} else {\n\t\t/*\n\t\t * It may have two following possibilities:\n\t\t *\n\t\t * - last record has been removed\n\t\t * - trunc_start was within a hole\n\t\t *\n\t\t * both two cases mean the completion of hole punching.\n\t\t */\n\t\tret = 1;\n\t}\n\n\t*done = ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "coff"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->e_blkno"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 1653
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rec_clusters",
          "args": [
            "el",
            "rec"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rec_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "246-260",
          "snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int ocfs2_rec_clusters(struct ocfs2_extent_list *el,\n\t\t\t\t\t      struct ocfs2_extent_rec *rec)\n{\n\t/*\n\t * Cluster count in extent records is slightly different\n\t * between interior nodes and leaf nodes. This is to support\n\t * unwritten extents which need a flags field in leaf node\n\t * records, thus shrinking the available space for a clusters\n\t * field.\n\t */\n\tif (el->l_tree_depth)\n\t\treturn le32_to_cpu(rec->e_int_clusters);\n\telse\n\t\treturn le16_to_cpu(rec->e_leaf_clusters);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_calc_trunc_pos(struct inode *inode,\n\t\t\t\t struct ocfs2_extent_list *el,\n\t\t\t\t struct ocfs2_extent_rec *rec,\n\t\t\t\t u32 trunc_start, u32 *trunc_cpos,\n\t\t\t\t u32 *trunc_len, u32 *trunc_end,\n\t\t\t\t u64 *blkno, int *done)\n{\n\tint ret = 0;\n\tu32 coff, range;\n\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (le32_to_cpu(rec->e_cpos) >= trunc_start) {\n\t\t/*\n\t\t * remove an entire extent record.\n\t\t */\n\t\t*trunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\t/*\n\t\t * Skip holes if any.\n\t\t */\n\t\tif (range < *trunc_end)\n\t\t\t*trunc_end = range;\n\t\t*trunc_len = *trunc_end - le32_to_cpu(rec->e_cpos);\n\t\t*blkno = le64_to_cpu(rec->e_blkno);\n\t\t*trunc_end = le32_to_cpu(rec->e_cpos);\n\t} else if (range > trunc_start) {\n\t\t/*\n\t\t * remove a partial extent record, which means we're\n\t\t * removing the last extent record.\n\t\t */\n\t\t*trunc_cpos = trunc_start;\n\t\t/*\n\t\t * skip hole if any.\n\t\t */\n\t\tif (range < *trunc_end)\n\t\t\t*trunc_end = range;\n\t\t*trunc_len = *trunc_end - trunc_start;\n\t\tcoff = trunc_start - le32_to_cpu(rec->e_cpos);\n\t\t*blkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t\t*trunc_end = trunc_start;\n\t} else {\n\t\t/*\n\t\t * It may have two following possibilities:\n\t\t *\n\t\t * - last record has been removed\n\t\t * - trunc_start was within a hole\n\t\t *\n\t\t * both two cases mean the completion of hole punching.\n\t\t */\n\t\tret = 1;\n\t}\n\n\t*done = ret;\n}"
  },
  {
    "function_name": "ocfs2_find_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1592-1606",
    "snippet": "static int ocfs2_find_rec(struct ocfs2_extent_list *el, u32 pos)\n{\n\tint i;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) < pos)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_find_rec(struct ocfs2_extent_list *el, u32 pos)\n{\n\tint i;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) < pos)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}"
  },
  {
    "function_name": "ocfs2_zero_partial_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1521-1590",
    "snippet": "static int ocfs2_zero_partial_clusters(struct inode *inode,\n\t\t\t\t       u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 tmpend, end = start + len;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tunsigned int csize = osb->s_clustersize;\n\thandle_t *handle;\n\n\t/*\n\t * The \"start\" and \"end\" values are NOT necessarily part of\n\t * the range whose allocation is being deleted. Rather, this\n\t * is what the user passed in with the request. We must zero\n\t * partial clusters here. There's no need to worry about\n\t * physical allocation - the zeroing code knows to skip holes.\n\t */\n\ttrace_ocfs2_zero_partial_clusters(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)start, (unsigned long long)end);\n\n\t/*\n\t * If both edges are on a cluster boundary then there's no\n\t * zeroing required as the region is part of the allocation to\n\t * be truncated.\n\t */\n\tif ((start & (csize - 1)) == 0 && (end & (csize - 1)) == 0)\n\t\tgoto out;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We want to get the byte offset of the end of the 1st cluster.\n\t */\n\ttmpend = (u64)osb->s_clustersize + (start & ~(osb->s_clustersize - 1));\n\tif (tmpend > end)\n\t\ttmpend = end;\n\n\ttrace_ocfs2_zero_partial_clusters_range1((unsigned long long)start,\n\t\t\t\t\t\t (unsigned long long)tmpend);\n\n\tret = ocfs2_zero_range_for_truncate(inode, handle, start, tmpend);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (tmpend < end) {\n\t\t/*\n\t\t * This may make start and end equal, but the zeroing\n\t\t * code will skip any work in that case so there's no\n\t\t * need to catch it up here.\n\t\t */\n\t\tstart = end & ~(osb->s_clustersize - 1);\n\n\t\ttrace_ocfs2_zero_partial_clusters_range2(\n\t\t\t(unsigned long long)start, (unsigned long long)end);\n\n\t\tret = ocfs2_zero_range_for_truncate(inode, handle, start, end);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_range_for_truncate",
          "args": [
            "inode",
            "handle",
            "start",
            "end"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_range_for_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6723-6789",
          "snippet": "int ocfs2_zero_range_for_truncate(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 range_start, u64 range_end)\n{\n\tint ret = 0, numpages;\n\tstruct page **pages = NULL;\n\tu64 phys;\n\tunsigned int ext_flags;\n\tstruct super_block *sb = inode->i_sb;\n\n\t/*\n\t * File systems which don't support sparse files zero on every\n\t * extend.\n\t */\n\tif (!ocfs2_sparse_alloc(OCFS2_SB(sb)))\n\t\treturn 0;\n\n\tpages = kcalloc(ocfs2_pages_per_cluster(sb),\n\t\t\tsizeof(struct page *), GFP_NOFS);\n\tif (pages == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (range_start == range_end)\n\t\tgoto out;\n\n\tret = ocfs2_extent_map_get_blocks(inode,\n\t\t\t\t\t  range_start >> sb->s_blocksize_bits,\n\t\t\t\t\t  &phys, NULL, &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Tail is a hole, or is marked unwritten. In either case, we\n\t * can count on read and write to return/push zero's.\n\t */\n\tif (phys == 0 || ext_flags & OCFS2_EXT_UNWRITTEN)\n\t\tgoto out;\n\n\tret = ocfs2_grab_eof_pages(inode, range_start, range_end, pages,\n\t\t\t\t   &numpages);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_zero_cluster_pages(inode, range_start, range_end, pages,\n\t\t\t\t numpages, phys, handle);\n\n\t/*\n\t * Initiate writeout of the pages we zero'd here. We don't\n\t * wait on them - the truncate_inode_pages() call later will\n\t * do that for us.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, range_start,\n\t\t\t\t       range_end - 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(pages);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_zero_range_for_truncate(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 range_start, u64 range_end)\n{\n\tint ret = 0, numpages;\n\tstruct page **pages = NULL;\n\tu64 phys;\n\tunsigned int ext_flags;\n\tstruct super_block *sb = inode->i_sb;\n\n\t/*\n\t * File systems which don't support sparse files zero on every\n\t * extend.\n\t */\n\tif (!ocfs2_sparse_alloc(OCFS2_SB(sb)))\n\t\treturn 0;\n\n\tpages = kcalloc(ocfs2_pages_per_cluster(sb),\n\t\t\tsizeof(struct page *), GFP_NOFS);\n\tif (pages == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (range_start == range_end)\n\t\tgoto out;\n\n\tret = ocfs2_extent_map_get_blocks(inode,\n\t\t\t\t\t  range_start >> sb->s_blocksize_bits,\n\t\t\t\t\t  &phys, NULL, &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Tail is a hole, or is marked unwritten. In either case, we\n\t * can count on read and write to return/push zero's.\n\t */\n\tif (phys == 0 || ext_flags & OCFS2_EXT_UNWRITTEN)\n\t\tgoto out;\n\n\tret = ocfs2_grab_eof_pages(inode, range_start, range_end, pages,\n\t\t\t\t   &numpages);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_zero_cluster_pages(inode, range_start, range_end, pages,\n\t\t\t\t numpages, phys, handle);\n\n\t/*\n\t * Initiate writeout of the pages we zero'd here. We don't\n\t * wait on them - the truncate_inode_pages() call later will\n\t * do that for us.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, range_start,\n\t\t\t\t       range_end - 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(pages);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_zero_partial_clusters_range2",
          "args": [
            "(unsigned long long)start",
            "(unsigned long long)end"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_zero_partial_clusters_range1",
          "args": [
            "(unsigned long long)start",
            "(unsigned long long)tmpend"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_zero_partial_clusters",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)start",
            "(unsigned long long)end"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_zero_partial_clusters(struct inode *inode,\n\t\t\t\t       u64 start, u64 len)\n{\n\tint ret = 0;\n\tu64 tmpend, end = start + len;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tunsigned int csize = osb->s_clustersize;\n\thandle_t *handle;\n\n\t/*\n\t * The \"start\" and \"end\" values are NOT necessarily part of\n\t * the range whose allocation is being deleted. Rather, this\n\t * is what the user passed in with the request. We must zero\n\t * partial clusters here. There's no need to worry about\n\t * physical allocation - the zeroing code knows to skip holes.\n\t */\n\ttrace_ocfs2_zero_partial_clusters(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)start, (unsigned long long)end);\n\n\t/*\n\t * If both edges are on a cluster boundary then there's no\n\t * zeroing required as the region is part of the allocation to\n\t * be truncated.\n\t */\n\tif ((start & (csize - 1)) == 0 && (end & (csize - 1)) == 0)\n\t\tgoto out;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We want to get the byte offset of the end of the 1st cluster.\n\t */\n\ttmpend = (u64)osb->s_clustersize + (start & ~(osb->s_clustersize - 1));\n\tif (tmpend > end)\n\t\ttmpend = end;\n\n\ttrace_ocfs2_zero_partial_clusters_range1((unsigned long long)start,\n\t\t\t\t\t\t (unsigned long long)tmpend);\n\n\tret = ocfs2_zero_range_for_truncate(inode, handle, start, tmpend);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (tmpend < end) {\n\t\t/*\n\t\t * This may make start and end equal, but the zeroing\n\t\t * code will skip any work in that case so there's no\n\t\t * need to catch it up here.\n\t\t */\n\t\tstart = end & ~(osb->s_clustersize - 1);\n\n\t\ttrace_ocfs2_zero_partial_clusters_range2(\n\t\t\t(unsigned long long)start, (unsigned long long)end);\n\n\t\tret = ocfs2_zero_range_for_truncate(inode, handle, start, end);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_truncate_cluster_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1504-1519",
    "snippet": "static void ocfs2_truncate_cluster_pages(struct inode *inode, u64 byte_start,\n\t\t\t\t\t u64 byte_len)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tloff_t start, end;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\tstart = (loff_t)ocfs2_align_bytes_to_clusters(inode->i_sb, byte_start);\n\tend = byte_start + byte_len;\n\tend = end & ~(osb->s_clustersize - 1);\n\n\tif (start < end) {\n\t\tunmap_mapping_range(mapping, start, end - start, 0);\n\t\ttruncate_inode_pages_range(mapping, start, end - 1);\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truncate_inode_pages_range",
          "args": [
            "mapping",
            "start",
            "end - 1"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_range",
          "args": [
            "mapping",
            "start",
            "end - start",
            "0"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_align_bytes_to_clusters",
          "args": [
            "inode->i_sb",
            "byte_start"
          ],
          "line": 1511
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_align_bytes_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "775-783",
          "snippet": "static inline u64 ocfs2_align_bytes_to_clusters(struct super_block *sb,\n\t\t\t\t\t\tu64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tclusters = ocfs2_clusters_for_bytes(sb, bytes);\n\treturn (u64)clusters << cl_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_align_bytes_to_clusters(struct super_block *sb,\n\t\t\t\t\t\tu64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tclusters = ocfs2_clusters_for_bytes(sb, bytes);\n\treturn (u64)clusters << cl_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_truncate_cluster_pages(struct inode *inode, u64 byte_start,\n\t\t\t\t\t u64 byte_len)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tloff_t start, end;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\tstart = (loff_t)ocfs2_align_bytes_to_clusters(inode->i_sb, byte_start);\n\tend = byte_start + byte_len;\n\tend = end & ~(osb->s_clustersize - 1);\n\n\tif (start < end) {\n\t\tunmap_mapping_range(mapping, start, end - start, 0);\n\t\ttruncate_inode_pages_range(mapping, start, end - 1);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_allocate_unwritten_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1422-1498",
    "snippet": "static int ocfs2_allocate_unwritten_extents(struct inode *inode,\n\t\t\t\t\t    u64 start, u64 len)\n{\n\tint ret;\n\tu32 cpos, phys_cpos, clusters, alloc_size;\n\tu64 end = start + len;\n\tstruct buffer_head *di_bh = NULL;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_read_inode_block(inode, &di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Nothing to do if the requested reservation range\n\t\t * fits within the inode.\n\t\t */\n\t\tif (ocfs2_size_fits_inline_data(di_bh, end))\n\t\t\tgoto out;\n\n\t\tret = ocfs2_convert_inline_data_to_extents(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We consider both start and len to be inclusive.\n\t */\n\tcpos = start >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(inode->i_sb, start + len);\n\tclusters -= cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos,\n\t\t\t\t\t &alloc_size, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Hole or existing extent len can be arbitrary, so\n\t\t * cap it to our own allocation request.\n\t\t */\n\t\tif (alloc_size > clusters)\n\t\t\talloc_size = clusters;\n\n\t\tif (phys_cpos) {\n\t\t\t/*\n\t\t\t * We already have an allocation at this\n\t\t\t * region so we can safely skip it.\n\t\t\t */\n\t\t\tgoto next;\n\t\t}\n\n\t\tret = __ocfs2_extend_allocation(inode, cpos, alloc_size, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\nnext:\n\t\tcpos += alloc_size;\n\t\tclusters -= alloc_size;\n\t}\n\n\tret = 0;\nout:\n\n\tbrelse(di_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_extend_allocation",
          "args": [
            "inode",
            "cpos",
            "alloc_size",
            "1"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_extend_allocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "560-710",
          "snippet": "static int __ocfs2_extend_allocation(struct inode *inode, u32 logical_start,\n\t\t\t\t     u32 clusters_to_add, int mark_unwritten)\n{\n\tint status = 0;\n\tint restart_func = 0;\n\tint credits;\n\tu32 prev_clusters;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tenum ocfs2_alloc_restarted why = RESTART_NONE;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\t/*\n\t * Unwritten extent only exists for file systems which\n\t * support holes.\n\t */\n\tBUG_ON(mark_unwritten && !ocfs2_sparse_alloc(osb));\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\nrestart_all:\n\tBUG_ON(le32_to_cpu(fe->i_clusters) != OCFS2_I(inode)->ip_clusters);\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), bh);\n\tstatus = ocfs2_lock_allocators(inode, &et, clusters_to_add, 0,\n\t\t\t\t       &data_ac, &meta_ac);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tcredits = ocfs2_calc_extend_credits(osb->sb, &fe->id2.i_list);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\nrestarted_transaction:\n\ttrace_ocfs2_extend_allocation(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)i_size_read(inode),\n\t\tle32_to_cpu(fe->i_clusters), clusters_to_add,\n\t\twhy, restart_func);\n\n\tstatus = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (status)\n\t\tgoto leave;\n\tdid_quota = 1;\n\n\t/* reserve a write to the file entry early on - that we if we\n\t * run out of credits in the allocation path, we can still\n\t * update i_size. */\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tprev_clusters = OCFS2_I(inode)->ip_clusters;\n\n\tstatus = ocfs2_add_inode_data(osb,\n\t\t\t\t      inode,\n\t\t\t\t      &logical_start,\n\t\t\t\t      clusters_to_add,\n\t\t\t\t      mark_unwritten,\n\t\t\t\t      bh,\n\t\t\t\t      handle,\n\t\t\t\t      data_ac,\n\t\t\t\t      meta_ac,\n\t\t\t\t      &why);\n\tif ((status < 0) && (status != -EAGAIN)) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, bh);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tclusters_to_add -= (OCFS2_I(inode)->ip_clusters - prev_clusters);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t/* Release unused quota reservation */\n\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tdid_quota = 0;\n\n\tif (why != RESTART_NONE && clusters_to_add) {\n\t\tif (why == RESTART_META) {\n\t\t\trestart_func = 1;\n\t\t\tstatus = 0;\n\t\t} else {\n\t\t\tBUG_ON(why != RESTART_TRANS);\n\n\t\t\tstatus = ocfs2_allocate_extend_trans(handle, 1);\n\t\t\tif (status < 0) {\n\t\t\t\t/* handle still has to be committed at\n\t\t\t\t * this point. */\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tgoto restarted_transaction;\n\t\t}\n\t}\n\n\ttrace_ocfs2_extend_allocation_end(OCFS2_I(inode)->ip_blkno,\n\t     le32_to_cpu(fe->i_clusters),\n\t     (unsigned long long)le64_to_cpu(fe->i_size),\n\t     OCFS2_I(inode)->ip_clusters,\n\t     (unsigned long long)i_size_read(inode));\n\nleave:\n\tif (status < 0 && did_quota)\n\t\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (handle) {\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\t}\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\tif ((!status) && restart_func) {\n\t\trestart_func = 0;\n\t\tgoto restart_all;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __ocfs2_extend_allocation(struct inode *inode, u32 logical_start,\n\t\t\t\t     u32 clusters_to_add, int mark_unwritten)\n{\n\tint status = 0;\n\tint restart_func = 0;\n\tint credits;\n\tu32 prev_clusters;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tenum ocfs2_alloc_restarted why = RESTART_NONE;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\t/*\n\t * Unwritten extent only exists for file systems which\n\t * support holes.\n\t */\n\tBUG_ON(mark_unwritten && !ocfs2_sparse_alloc(osb));\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\nrestart_all:\n\tBUG_ON(le32_to_cpu(fe->i_clusters) != OCFS2_I(inode)->ip_clusters);\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), bh);\n\tstatus = ocfs2_lock_allocators(inode, &et, clusters_to_add, 0,\n\t\t\t\t       &data_ac, &meta_ac);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tcredits = ocfs2_calc_extend_credits(osb->sb, &fe->id2.i_list);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\nrestarted_transaction:\n\ttrace_ocfs2_extend_allocation(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)i_size_read(inode),\n\t\tle32_to_cpu(fe->i_clusters), clusters_to_add,\n\t\twhy, restart_func);\n\n\tstatus = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (status)\n\t\tgoto leave;\n\tdid_quota = 1;\n\n\t/* reserve a write to the file entry early on - that we if we\n\t * run out of credits in the allocation path, we can still\n\t * update i_size. */\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tprev_clusters = OCFS2_I(inode)->ip_clusters;\n\n\tstatus = ocfs2_add_inode_data(osb,\n\t\t\t\t      inode,\n\t\t\t\t      &logical_start,\n\t\t\t\t      clusters_to_add,\n\t\t\t\t      mark_unwritten,\n\t\t\t\t      bh,\n\t\t\t\t      handle,\n\t\t\t\t      data_ac,\n\t\t\t\t      meta_ac,\n\t\t\t\t      &why);\n\tif ((status < 0) && (status != -EAGAIN)) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, bh);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tclusters_to_add -= (OCFS2_I(inode)->ip_clusters - prev_clusters);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t/* Release unused quota reservation */\n\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tdid_quota = 0;\n\n\tif (why != RESTART_NONE && clusters_to_add) {\n\t\tif (why == RESTART_META) {\n\t\t\trestart_func = 1;\n\t\t\tstatus = 0;\n\t\t} else {\n\t\t\tBUG_ON(why != RESTART_TRANS);\n\n\t\t\tstatus = ocfs2_allocate_extend_trans(handle, 1);\n\t\t\tif (status < 0) {\n\t\t\t\t/* handle still has to be committed at\n\t\t\t\t * this point. */\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tgoto restarted_transaction;\n\t\t}\n\t}\n\n\ttrace_ocfs2_extend_allocation_end(OCFS2_I(inode)->ip_blkno,\n\t     le32_to_cpu(fe->i_clusters),\n\t     (unsigned long long)le64_to_cpu(fe->i_size),\n\t     OCFS2_I(inode)->ip_clusters,\n\t     (unsigned long long)i_size_read(inode));\n\nleave:\n\tif (status < 0 && did_quota)\n\t\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (handle) {\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\t}\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\tif ((!status) && restart_func) {\n\t\trestart_func = 0;\n\t\tgoto restart_all;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&phys_cpos",
            "&alloc_size",
            "NULL"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "608-665",
          "snippet": "int ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "inode->i_sb",
            "start + len"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_convert_inline_data_to_extents",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_convert_inline_data_to_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6836-7003",
          "snippet": "int ocfs2_convert_inline_data_to_extents(struct inode *inode,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret, i, has_data, num_pages = 0;\n\tint need_free = 0;\n\tu32 bit_off, num;\n\thandle_t *handle;\n\tu64 uninitialized_var(block);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct page **pages = NULL;\n\tloff_t end = osb->s_clustersize;\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\thas_data = i_size_read(inode) ? 1 : 0;\n\n\tif (has_data) {\n\t\tpages = kcalloc(ocfs2_pages_per_cluster(osb->sb),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (pages == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\t\t   ocfs2_inline_to_extents_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (has_data) {\n\t\tunsigned int page_end;\n\t\tu64 phys;\n\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t\tdid_quota = 1;\n\n\t\tdata_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &num);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * Save two copies, one for insert, and one that can\n\t\t * be changed by ocfs2_map_and_dirty_page() below.\n\t\t */\n\t\tblock = phys = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\t\t/*\n\t\t * Non sparse file systems zero on extend, so no need\n\t\t * to do that now.\n\t\t */\n\t\tif (!ocfs2_sparse_alloc(osb) &&\n\t\t    PAGE_CACHE_SIZE < osb->s_clustersize)\n\t\t\tend = PAGE_CACHE_SIZE;\n\n\t\tret = ocfs2_grab_eof_pages(inode, 0, end, pages, &num_pages);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * This should populate the 1st page for us and mark\n\t\t * it up to date.\n\t\t */\n\t\tret = ocfs2_read_inline_data(inode, pages[0], di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tpage_end = PAGE_CACHE_SIZE;\n\t\tif (PAGE_CACHE_SIZE > osb->s_clustersize)\n\t\t\tpage_end = osb->s_clustersize;\n\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tocfs2_map_and_dirty_page(inode, handle, 0, page_end,\n\t\t\t\t\t\t pages[i], i > 0, &phys);\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_dinode_new_extent_list(inode, di);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (has_data) {\n\t\t/*\n\t\t * An error at this point should be extremely rare. If\n\t\t * this proves to be false, we could always re-build\n\t\t * the in-inode data from our pages.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\t\tret = ocfs2_insert_extent(handle, &et, 0, block, 1, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t}\n\nout_unlock:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, num_pages);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(osb->sb, 1));\n\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum);\n\t}\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (pages)\n\t\tkfree(pages);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_convert_inline_data_to_extents(struct inode *inode,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret, i, has_data, num_pages = 0;\n\tint need_free = 0;\n\tu32 bit_off, num;\n\thandle_t *handle;\n\tu64 uninitialized_var(block);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct page **pages = NULL;\n\tloff_t end = osb->s_clustersize;\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\thas_data = i_size_read(inode) ? 1 : 0;\n\n\tif (has_data) {\n\t\tpages = kcalloc(ocfs2_pages_per_cluster(osb->sb),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (pages == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\t\t   ocfs2_inline_to_extents_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (has_data) {\n\t\tunsigned int page_end;\n\t\tu64 phys;\n\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t\tdid_quota = 1;\n\n\t\tdata_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &num);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * Save two copies, one for insert, and one that can\n\t\t * be changed by ocfs2_map_and_dirty_page() below.\n\t\t */\n\t\tblock = phys = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\t\t/*\n\t\t * Non sparse file systems zero on extend, so no need\n\t\t * to do that now.\n\t\t */\n\t\tif (!ocfs2_sparse_alloc(osb) &&\n\t\t    PAGE_CACHE_SIZE < osb->s_clustersize)\n\t\t\tend = PAGE_CACHE_SIZE;\n\n\t\tret = ocfs2_grab_eof_pages(inode, 0, end, pages, &num_pages);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * This should populate the 1st page for us and mark\n\t\t * it up to date.\n\t\t */\n\t\tret = ocfs2_read_inline_data(inode, pages[0], di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tpage_end = PAGE_CACHE_SIZE;\n\t\tif (PAGE_CACHE_SIZE > osb->s_clustersize)\n\t\t\tpage_end = osb->s_clustersize;\n\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tocfs2_map_and_dirty_page(inode, handle, 0, page_end,\n\t\t\t\t\t\t pages[i], i > 0, &phys);\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_dinode_new_extent_list(inode, di);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (has_data) {\n\t\t/*\n\t\t * An error at this point should be extremely rare. If\n\t\t * this proves to be false, we could always re-build\n\t\t * the in-inode data from our pages.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\t\tret = ocfs2_insert_extent(handle, &et, 0, block, 1, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t}\n\nout_unlock:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, num_pages);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(osb->sb, 1));\n\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum);\n\t}\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (pages)\n\t\tkfree(pages);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_size_fits_inline_data",
          "args": [
            "di_bh",
            "end"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_size_fits_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1765-1772",
          "snippet": "int ocfs2_size_fits_inline_data(struct buffer_head *di_bh, u64 new_size)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (new_size <= le16_to_cpu(di->id2.i_data.id_count))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_size_fits_inline_data(struct buffer_head *di_bh, u64 new_size)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (new_size <= le16_to_cpu(di->id2.i_data.id_count))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "&di_bh"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_allocate_unwritten_extents(struct inode *inode,\n\t\t\t\t\t    u64 start, u64 len)\n{\n\tint ret;\n\tu32 cpos, phys_cpos, clusters, alloc_size;\n\tu64 end = start + len;\n\tstruct buffer_head *di_bh = NULL;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_read_inode_block(inode, &di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Nothing to do if the requested reservation range\n\t\t * fits within the inode.\n\t\t */\n\t\tif (ocfs2_size_fits_inline_data(di_bh, end))\n\t\t\tgoto out;\n\n\t\tret = ocfs2_convert_inline_data_to_extents(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * We consider both start and len to be inclusive.\n\t */\n\tcpos = start >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(inode->i_sb, start + len);\n\tclusters -= cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos,\n\t\t\t\t\t &alloc_size, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Hole or existing extent len can be arbitrary, so\n\t\t * cap it to our own allocation request.\n\t\t */\n\t\tif (alloc_size > clusters)\n\t\t\talloc_size = clusters;\n\n\t\tif (phys_cpos) {\n\t\t\t/*\n\t\t\t * We already have an allocation at this\n\t\t\t * region so we can safely skip it.\n\t\t\t */\n\t\t\tgoto next;\n\t\t}\n\n\t\tret = __ocfs2_extend_allocation(inode, cpos, alloc_size, 1);\n\t\tif (ret) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\nnext:\n\t\tcpos += alloc_size;\n\t\tclusters -= alloc_size;\n\t}\n\n\tret = 0;\nout:\n\n\tbrelse(di_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_write_remove_suid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1400-1415",
    "snippet": "static int ocfs2_write_remove_suid(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = ocfs2_read_inode_block(inode, &bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret =  __ocfs2_write_remove_suid(inode, bh);\nout:\n\tbrelse(bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_write_remove_suid",
          "args": [
            "inode",
            "bh"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_write_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1320-1360",
          "snippet": "static int __ocfs2_write_remove_suid(struct inode *inode,\n\t\t\t\t     struct buffer_head *bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di;\n\n\ttrace_ocfs2_write_remove_suid(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tinode->i_mode);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_trans;\n\t}\n\n\tinode->i_mode &= ~S_ISUID;\n\tif ((inode->i_mode & S_ISGID) && (inode->i_mode & S_IXGRP))\n\t\tinode->i_mode &= ~S_ISGID;\n\n\tdi = (struct ocfs2_dinode *) bh->b_data;\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, bh);\n\nout_trans:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __ocfs2_write_remove_suid(struct inode *inode,\n\t\t\t\t     struct buffer_head *bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di;\n\n\ttrace_ocfs2_write_remove_suid(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tinode->i_mode);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_trans;\n\t}\n\n\tinode->i_mode &= ~S_ISUID;\n\tif ((inode->i_mode & S_ISGID) && (inode->i_mode & S_IXGRP))\n\t\tinode->i_mode &= ~S_ISGID;\n\n\tdi = (struct ocfs2_dinode *) bh->b_data;\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, bh);\n\nout_trans:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "&bh"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_write_remove_suid(struct inode *inode)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = ocfs2_read_inode_block(inode, &bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret =  __ocfs2_write_remove_suid(inode, bh);\nout:\n\tbrelse(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_check_range_for_holes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1366-1398",
    "snippet": "static int ocfs2_check_range_for_holes(struct inode *inode, loff_t pos,\n\t\t\t\t       size_t count)\n{\n\tint ret = 0;\n\tunsigned int extent_flags;\n\tu32 cpos, clusters, extent_len, phys_cpos;\n\tstruct super_block *sb = inode->i_sb;\n\n\tcpos = pos >> OCFS2_SB(sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(sb, pos + count) - cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &extent_len,\n\t\t\t\t\t &extent_flags);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (phys_cpos == 0 || (extent_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (extent_len > clusters)\n\t\t\textent_len = clusters;\n\n\t\tclusters -= extent_len;\n\t\tcpos += extent_len;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&phys_cpos",
            "&extent_len",
            "&extent_flags"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "608-665",
          "snippet": "int ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "sb",
            "pos + count"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_check_range_for_holes(struct inode *inode, loff_t pos,\n\t\t\t\t       size_t count)\n{\n\tint ret = 0;\n\tunsigned int extent_flags;\n\tu32 cpos, clusters, extent_len, phys_cpos;\n\tstruct super_block *sb = inode->i_sb;\n\n\tcpos = pos >> OCFS2_SB(sb)->s_clustersize_bits;\n\tclusters = ocfs2_clusters_for_bytes(sb, pos + count) - cpos;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &phys_cpos, &extent_len,\n\t\t\t\t\t &extent_flags);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (phys_cpos == 0 || (extent_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (extent_len > clusters)\n\t\t\textent_len = clusters;\n\n\t\tclusters -= extent_len;\n\t\tcpos += extent_len;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_write_remove_suid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1320-1360",
    "snippet": "static int __ocfs2_write_remove_suid(struct inode *inode,\n\t\t\t\t     struct buffer_head *bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di;\n\n\ttrace_ocfs2_write_remove_suid(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tinode->i_mode);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_trans;\n\t}\n\n\tinode->i_mode &= ~S_ISUID;\n\tif ((inode->i_mode & S_ISGID) && (inode->i_mode & S_IXGRP))\n\t\tinode->i_mode &= ~S_ISGID;\n\n\tdi = (struct ocfs2_dinode *) bh->b_data;\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, bh);\n\nout_trans:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "0"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "inode->i_mode"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_write_remove_suid",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "inode->i_mode"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __ocfs2_write_remove_suid(struct inode *inode,\n\t\t\t\t     struct buffer_head *bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di;\n\n\ttrace_ocfs2_write_remove_suid(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\tinode->i_mode);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_trans;\n\t}\n\n\tinode->i_mode &= ~S_ISUID;\n\tif ((inode->i_mode & S_ISGID) && (inode->i_mode & S_IXGRP))\n\t\tinode->i_mode &= ~S_ISGID;\n\n\tdi = (struct ocfs2_dinode *) bh->b_data;\n\tdi->i_mode = cpu_to_le16(inode->i_mode);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, bh);\n\nout_trans:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1299-1318",
    "snippet": "int ocfs2_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret) {\n\t\tif (ret != -ENOENT)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = generic_permission(inode, mask);\n\n\tocfs2_inode_unlock(inode, 0);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "0"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "NULL",
            "0"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\tif (mask & MAY_NOT_BLOCK)\n\t\treturn -ECHILD;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret) {\n\t\tif (ret != -ENOENT)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = generic_permission(inode, mask);\n\n\tocfs2_inode_unlock(inode, 0);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1274-1297",
    "snippet": "int ocfs2_getattr(struct vfsmount *mnt,\n\t\t  struct dentry *dentry,\n\t\t  struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = dentry->d_inode->i_sb;\n\tstruct ocfs2_super *osb = sb->s_fs_info;\n\tint err;\n\n\terr = ocfs2_inode_revalidate(dentry);\n\tif (err) {\n\t\tif (err != -ENOENT)\n\t\t\tmlog_errno(err);\n\t\tgoto bail;\n\t}\n\n\tgeneric_fillattr(inode, stat);\n\n\t/* We set the blksize from the cluster size for performance */\n\tstat->blksize = osb->s_clustersize;\n\nbail:\n\treturn err;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_revalidate",
          "args": [
            "dentry"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_revalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1210-1243",
          "snippet": "int ocfs2_inode_revalidate(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint status = 0;\n\n\ttrace_ocfs2_inode_revalidate(inode,\n\t\tinode ? (unsigned long long)OCFS2_I(inode)->ip_blkno : 0ULL,\n\t\tinode ? (unsigned long long)OCFS2_I(inode)->ip_flags : 0);\n\n\tif (!inode) {\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED) {\n\t\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\t/* Let ocfs2_inode_lock do the work of updating our struct\n\t * inode for us. */\n\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_inode_unlock(inode, 0);\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_inode_revalidate(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint status = 0;\n\n\ttrace_ocfs2_inode_revalidate(inode,\n\t\tinode ? (unsigned long long)OCFS2_I(inode)->ip_blkno : 0ULL,\n\t\tinode ? (unsigned long long)OCFS2_I(inode)->ip_flags : 0);\n\n\tif (!inode) {\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED) {\n\t\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t\tstatus = -ENOENT;\n\t\tgoto bail;\n\t}\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\t/* Let ocfs2_inode_lock do the work of updating our struct\n\t * inode for us. */\n\tstatus = ocfs2_inode_lock(inode, NULL, 0);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tocfs2_inode_unlock(inode, 0);\nbail:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_getattr(struct vfsmount *mnt,\n\t\t  struct dentry *dentry,\n\t\t  struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = dentry->d_inode->i_sb;\n\tstruct ocfs2_super *osb = sb->s_fs_info;\n\tint err;\n\n\terr = ocfs2_inode_revalidate(dentry);\n\tif (err) {\n\t\tif (err != -ENOENT)\n\t\t\tmlog_errno(err);\n\t\tgoto bail;\n\t}\n\n\tgeneric_fillattr(inode, stat);\n\n\t/* We set the blksize from the cluster size for performance */\n\tstat->blksize = osb->s_clustersize;\n\nbail:\n\treturn err;\n}"
  },
  {
    "function_name": "ocfs2_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1126-1272",
    "snippet": "int ocfs2_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint status = 0, size_change;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct dquot *transfer_to[MAXQUOTAS] = { };\n\tint qtype;\n\n\ttrace_ocfs2_setattr(inode, dentry,\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    dentry->d_name.len, dentry->d_name.name,\n\t\t\t    attr->ia_valid, attr->ia_mode,\n\t\t\t    from_kuid(&init_user_ns, attr->ia_uid),\n\t\t\t    from_kgid(&init_user_ns, attr->ia_gid));\n\n\t/* ensuring we don't even attempt to truncate a symlink */\n\tif (S_ISLNK(inode->i_mode))\n\t\tattr->ia_valid &= ~ATTR_SIZE;\n\n#define OCFS2_VALID_ATTRS (ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE \\\n\t\t\t   | ATTR_GID | ATTR_UID | ATTR_MODE)\n\tif (!(attr->ia_valid & OCFS2_VALID_ATTRS))\n\t\treturn 0;\n\n\tstatus = inode_change_ok(inode, attr);\n\tif (status)\n\t\treturn status;\n\n\tif (is_quota_modification(inode, attr))\n\t\tdquot_initialize(inode);\n\tsize_change = S_ISREG(inode->i_mode) && attr->ia_valid & ATTR_SIZE;\n\tif (size_change) {\n\t\tstatus = ocfs2_rw_lock(inode, 1);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail_unlock_rw;\n\t}\n\n\tif (size_change) {\n\t\tstatus = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (status)\n\t\t\tgoto bail_unlock;\n\n\t\tinode_dio_wait(inode);\n\n\t\tif (i_size_read(inode) >= attr->ia_size) {\n\t\t\tif (ocfs2_should_order_data(inode)) {\n\t\t\t\tstatus = ocfs2_begin_ordered_truncate(inode,\n\t\t\t\t\t\t\t\t      attr->ia_size);\n\t\t\t\tif (status)\n\t\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t\tstatus = ocfs2_truncate_file(inode, bh, attr->ia_size);\n\t\t} else\n\t\t\tstatus = ocfs2_extend_file(inode, bh, attr->ia_size);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail_unlock;\n\t\t}\n\t}\n\n\tif ((attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\t/*\n\t\t * Gather pointers to quota structures so that allocation /\n\t\t * freeing of quota structures happens here and not inside\n\t\t * dquot_transfer() where we have problems with lock ordering\n\t\t */\n\t\tif (attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)\n\t\t    && OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t    OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(attr->ia_uid));\n\t\t\tif (!transfer_to[USRQUOTA]) {\n\t\t\t\tstatus = -ESRCH;\n\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t}\n\t\tif (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid)\n\t\t    && OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t    OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(attr->ia_gid));\n\t\t\tif (!transfer_to[GRPQUOTA]) {\n\t\t\t\tstatus = -ESRCH;\n\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t}\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS +\n\t\t\t\t\t   2 * ocfs2_quota_trans_credits(sb));\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock;\n\t\t}\n\t\tstatus = __dquot_transfer(inode, transfer_to);\n\t\tif (status < 0)\n\t\t\tgoto bail_commit;\n\t} else {\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock;\n\t\t}\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\nbail_unlock:\n\tocfs2_inode_unlock(inode, 1);\nbail_unlock_rw:\n\tif (size_change)\n\t\tocfs2_rw_unlock(inode, 1);\nbail:\n\tbrelse(bh);\n\n\t/* Release quota pointers in case we acquired them */\n\tfor (qtype = 0; qtype < OCFS2_MAXQUOTAS; qtype++)\n\t\tdqput(transfer_to[qtype]);\n\n\tif (!status && attr->ia_valid & ATTR_MODE) {\n\t\tstatus = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define OCFS2_VALID_ATTRS (ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE \\\n\t\t\t   | ATTR_GID | ATTR_UID | ATTR_MODE)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_chmod",
          "args": [
            "inode",
            "inode->i_mode"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "518-542",
          "snippet": "int\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_chmod(struct inode *inode, umode_t mode)\n{\n\tstruct posix_acl *acl;\n\tint ret = 0;\n\n\tif (!IS_POSIXACL(inode))\n\t\treturn 0;\n\tif (!inode->i_op->set_acl)\n\t\treturn -EOPNOTSUPP;\n\n\tacl = get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR_OR_NULL(acl)) {\n\t\tif (acl == ERR_PTR(-EOPNOTSUPP))\n\t\t\treturn 0;\n\t\treturn PTR_ERR(acl);\n\t}\n\n\tret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\n\tif (ret)\n\t\treturn ret;\n\tret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\n\tposix_acl_release(acl);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dqput",
          "args": [
            "transfer_to[qtype]"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "dqput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "734-794",
          "snippet": "void dqput(struct dquot *dquot)\n{\n\tint ret;\n\n\tif (!dquot)\n\t\treturn;\n#ifdef CONFIG_QUOTA_DEBUG\n\tif (!atomic_read(&dquot->dq_count)) {\n\t\tquota_error(dquot->dq_sb, \"trying to free free dquot of %s %d\",\n\t\t\t    quotatypes[dquot->dq_id.type],\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tBUG();\n\t}\n#endif\n\tdqstats_inc(DQST_DROPS);\nwe_slept:\n\tspin_lock(&dq_list_lock);\n\tif (atomic_read(&dquot->dq_count) > 1) {\n\t\t/* We have more than one user... nothing to do */\n\t\tatomic_dec(&dquot->dq_count);\n\t\t/* Releasing dquot during quotaoff phase? */\n\t\tif (!sb_has_quota_active(dquot->dq_sb, dquot->dq_id.type) &&\n\t\t    atomic_read(&dquot->dq_count) == 1)\n\t\t\twake_up(&dquot->dq_wait_unused);\n\t\tspin_unlock(&dq_list_lock);\n\t\treturn;\n\t}\n\t/* Need to release dquot? */\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && dquot_dirty(dquot)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\t/* Commit dquot before releasing */\n\t\tret = dquot->dq_sb->dq_op->write_dquot(dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't write quota structure\"\n\t\t\t\t    \" (error %d). Quota may get out of sync!\",\n\t\t\t\t    ret);\n\t\t\t/*\n\t\t\t * We clear dirty bit anyway, so that we avoid\n\t\t\t * infinite loop here\n\t\t\t */\n\t\t\tspin_lock(&dq_list_lock);\n\t\t\tclear_dquot_dirty(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t}\n\t\tgoto we_slept;\n\t}\n\t/* Clear flag in case dquot was inactive (something bad happened) */\n\tclear_dquot_dirty(dquot);\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\tdquot->dq_sb->dq_op->release_dquot(dquot);\n\t\tgoto we_slept;\n\t}\n\tatomic_dec(&dquot->dq_count);\n#ifdef CONFIG_QUOTA_DEBUG\n\t/* sanity check */\n\tBUG_ON(!list_empty(&dquot->dq_free));\n#endif\n\tput_dquot_last(dquot);\n\tspin_unlock(&dq_list_lock);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nvoid dqput(struct dquot *dquot)\n{\n\tint ret;\n\n\tif (!dquot)\n\t\treturn;\n#ifdef CONFIG_QUOTA_DEBUG\n\tif (!atomic_read(&dquot->dq_count)) {\n\t\tquota_error(dquot->dq_sb, \"trying to free free dquot of %s %d\",\n\t\t\t    quotatypes[dquot->dq_id.type],\n\t\t\t    from_kqid(&init_user_ns, dquot->dq_id));\n\t\tBUG();\n\t}\n#endif\n\tdqstats_inc(DQST_DROPS);\nwe_slept:\n\tspin_lock(&dq_list_lock);\n\tif (atomic_read(&dquot->dq_count) > 1) {\n\t\t/* We have more than one user... nothing to do */\n\t\tatomic_dec(&dquot->dq_count);\n\t\t/* Releasing dquot during quotaoff phase? */\n\t\tif (!sb_has_quota_active(dquot->dq_sb, dquot->dq_id.type) &&\n\t\t    atomic_read(&dquot->dq_count) == 1)\n\t\t\twake_up(&dquot->dq_wait_unused);\n\t\tspin_unlock(&dq_list_lock);\n\t\treturn;\n\t}\n\t/* Need to release dquot? */\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags) && dquot_dirty(dquot)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\t/* Commit dquot before releasing */\n\t\tret = dquot->dq_sb->dq_op->write_dquot(dquot);\n\t\tif (ret < 0) {\n\t\t\tquota_error(dquot->dq_sb, \"Can't write quota structure\"\n\t\t\t\t    \" (error %d). Quota may get out of sync!\",\n\t\t\t\t    ret);\n\t\t\t/*\n\t\t\t * We clear dirty bit anyway, so that we avoid\n\t\t\t * infinite loop here\n\t\t\t */\n\t\t\tspin_lock(&dq_list_lock);\n\t\t\tclear_dquot_dirty(dquot);\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t}\n\t\tgoto we_slept;\n\t}\n\t/* Clear flag in case dquot was inactive (something bad happened) */\n\tclear_dquot_dirty(dquot);\n\tif (test_bit(DQ_ACTIVE_B, &dquot->dq_flags)) {\n\t\tspin_unlock(&dq_list_lock);\n\t\tdquot->dq_sb->dq_op->release_dquot(dquot);\n\t\tgoto we_slept;\n\t}\n\tatomic_dec(&dquot->dq_count);\n#ifdef CONFIG_QUOTA_DEBUG\n\t/* sanity check */\n\tBUG_ON(!list_empty(&dquot->dq_free));\n#endif\n\tput_dquot_last(dquot);\n\tspin_unlock(&dq_list_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1692-1704",
          "snippet": "void ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "inode",
            "bh"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1250-1289",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "__setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/file.c",
          "lines": "572-597",
          "snippet": "static void __setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(fi, mode);\n\t}\n}",
          "includes": [
            "#include <trace/events/f2fs.h>",
            "#include \"trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"segment.h\"",
            "#include \"node.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/types.h>",
            "#include <linux/falloc.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/stat.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define __setattr_copy setattr_copy"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/f2fs.h>\n#include \"trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"segment.h\"\n#include \"node.h\"\n#include \"f2fs.h\"\n#include <linux/pagevec.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/types.h>\n#include <linux/falloc.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/stat.h>\n#include <linux/f2fs_fs.h>\n#include <linux/fs.h>\n\n#define __setattr_copy setattr_copy\n\nstatic void __setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tset_acl_inode(fi, mode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dquot_transfer",
          "args": [
            "inode",
            "transfer_to"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "__dquot_transfer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1834-1927",
          "snippet": "int __dquot_transfer(struct inode *inode, struct dquot **transfer_to)\n{\n\tqsize_t space, cur_space;\n\tqsize_t rsv_space = 0;\n\tstruct dquot *transfer_from[MAXQUOTAS] = {};\n\tint cnt, ret = 0;\n\tchar is_valid[MAXQUOTAS] = {};\n\tstruct dquot_warn warn_to[MAXQUOTAS];\n\tstruct dquot_warn warn_from_inodes[MAXQUOTAS];\n\tstruct dquot_warn warn_from_space[MAXQUOTAS];\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn 0;\n\t/* Initialize the arrays */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\twarn_to[cnt].w_type = QUOTA_NL_NOWARN;\n\t\twarn_from_inodes[cnt].w_type = QUOTA_NL_NOWARN;\n\t\twarn_from_space[cnt].w_type = QUOTA_NL_NOWARN;\n\t}\n\n\tspin_lock(&dq_data_lock);\n\tif (IS_NOQUOTA(inode)) {\t/* File without quota accounting? */\n\t\tspin_unlock(&dq_data_lock);\n\t\treturn 0;\n\t}\n\tcur_space = inode_get_bytes(inode);\n\trsv_space = inode_get_rsv_space(inode);\n\tspace = cur_space + rsv_space;\n\t/* Build the transfer_from list and check the limits */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\t/*\n\t\t * Skip changes for same uid or gid or for turned off quota-type.\n\t\t */\n\t\tif (!transfer_to[cnt])\n\t\t\tcontinue;\n\t\t/* Avoid races with quotaoff() */\n\t\tif (!sb_has_quota_active(inode->i_sb, cnt))\n\t\t\tcontinue;\n\t\tis_valid[cnt] = 1;\n\t\ttransfer_from[cnt] = i_dquot(inode)[cnt];\n\t\tret = check_idq(transfer_to[cnt], 1, &warn_to[cnt]);\n\t\tif (ret)\n\t\t\tgoto over_quota;\n\t\tret = check_bdq(transfer_to[cnt], space, 0, &warn_to[cnt]);\n\t\tif (ret)\n\t\t\tgoto over_quota;\n\t}\n\n\t/*\n\t * Finally perform the needed transfer from transfer_from to transfer_to\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!is_valid[cnt])\n\t\t\tcontinue;\n\t\t/* Due to IO error we might not have transfer_from[] structure */\n\t\tif (transfer_from[cnt]) {\n\t\t\tint wtype;\n\t\t\twtype = info_idq_free(transfer_from[cnt], 1);\n\t\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\t\tprepare_warning(&warn_from_inodes[cnt],\n\t\t\t\t\t\ttransfer_from[cnt], wtype);\n\t\t\twtype = info_bdq_free(transfer_from[cnt], space);\n\t\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\t\tprepare_warning(&warn_from_space[cnt],\n\t\t\t\t\t\ttransfer_from[cnt], wtype);\n\t\t\tdquot_decr_inodes(transfer_from[cnt], 1);\n\t\t\tdquot_decr_space(transfer_from[cnt], cur_space);\n\t\t\tdquot_free_reserved_space(transfer_from[cnt],\n\t\t\t\t\t\t  rsv_space);\n\t\t}\n\n\t\tdquot_incr_inodes(transfer_to[cnt], 1);\n\t\tdquot_incr_space(transfer_to[cnt], cur_space);\n\t\tdquot_resv_space(transfer_to[cnt], rsv_space);\n\n\t\ti_dquot(inode)[cnt] = transfer_to[cnt];\n\t}\n\tspin_unlock(&dq_data_lock);\n\n\tmark_all_dquot_dirty(transfer_from);\n\tmark_all_dquot_dirty(transfer_to);\n\tflush_warnings(warn_to);\n\tflush_warnings(warn_from_inodes);\n\tflush_warnings(warn_from_space);\n\t/* Pass back references to put */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (is_valid[cnt])\n\t\t\ttransfer_to[cnt] = transfer_from[cnt];\n\treturn 0;\nover_quota:\n\tspin_unlock(&dq_data_lock);\n\tflush_warnings(warn_to);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);",
            "static qsize_t inode_get_rsv_space(struct inode *inode);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_data_lock);\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nint __dquot_transfer(struct inode *inode, struct dquot **transfer_to)\n{\n\tqsize_t space, cur_space;\n\tqsize_t rsv_space = 0;\n\tstruct dquot *transfer_from[MAXQUOTAS] = {};\n\tint cnt, ret = 0;\n\tchar is_valid[MAXQUOTAS] = {};\n\tstruct dquot_warn warn_to[MAXQUOTAS];\n\tstruct dquot_warn warn_from_inodes[MAXQUOTAS];\n\tstruct dquot_warn warn_from_space[MAXQUOTAS];\n\n\tif (IS_NOQUOTA(inode))\n\t\treturn 0;\n\t/* Initialize the arrays */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\twarn_to[cnt].w_type = QUOTA_NL_NOWARN;\n\t\twarn_from_inodes[cnt].w_type = QUOTA_NL_NOWARN;\n\t\twarn_from_space[cnt].w_type = QUOTA_NL_NOWARN;\n\t}\n\n\tspin_lock(&dq_data_lock);\n\tif (IS_NOQUOTA(inode)) {\t/* File without quota accounting? */\n\t\tspin_unlock(&dq_data_lock);\n\t\treturn 0;\n\t}\n\tcur_space = inode_get_bytes(inode);\n\trsv_space = inode_get_rsv_space(inode);\n\tspace = cur_space + rsv_space;\n\t/* Build the transfer_from list and check the limits */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\t/*\n\t\t * Skip changes for same uid or gid or for turned off quota-type.\n\t\t */\n\t\tif (!transfer_to[cnt])\n\t\t\tcontinue;\n\t\t/* Avoid races with quotaoff() */\n\t\tif (!sb_has_quota_active(inode->i_sb, cnt))\n\t\t\tcontinue;\n\t\tis_valid[cnt] = 1;\n\t\ttransfer_from[cnt] = i_dquot(inode)[cnt];\n\t\tret = check_idq(transfer_to[cnt], 1, &warn_to[cnt]);\n\t\tif (ret)\n\t\t\tgoto over_quota;\n\t\tret = check_bdq(transfer_to[cnt], space, 0, &warn_to[cnt]);\n\t\tif (ret)\n\t\t\tgoto over_quota;\n\t}\n\n\t/*\n\t * Finally perform the needed transfer from transfer_from to transfer_to\n\t */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++) {\n\t\tif (!is_valid[cnt])\n\t\t\tcontinue;\n\t\t/* Due to IO error we might not have transfer_from[] structure */\n\t\tif (transfer_from[cnt]) {\n\t\t\tint wtype;\n\t\t\twtype = info_idq_free(transfer_from[cnt], 1);\n\t\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\t\tprepare_warning(&warn_from_inodes[cnt],\n\t\t\t\t\t\ttransfer_from[cnt], wtype);\n\t\t\twtype = info_bdq_free(transfer_from[cnt], space);\n\t\t\tif (wtype != QUOTA_NL_NOWARN)\n\t\t\t\tprepare_warning(&warn_from_space[cnt],\n\t\t\t\t\t\ttransfer_from[cnt], wtype);\n\t\t\tdquot_decr_inodes(transfer_from[cnt], 1);\n\t\t\tdquot_decr_space(transfer_from[cnt], cur_space);\n\t\t\tdquot_free_reserved_space(transfer_from[cnt],\n\t\t\t\t\t\t  rsv_space);\n\t\t}\n\n\t\tdquot_incr_inodes(transfer_to[cnt], 1);\n\t\tdquot_incr_space(transfer_to[cnt], cur_space);\n\t\tdquot_resv_space(transfer_to[cnt], rsv_space);\n\n\t\ti_dquot(inode)[cnt] = transfer_to[cnt];\n\t}\n\tspin_unlock(&dq_data_lock);\n\n\tmark_all_dquot_dirty(transfer_from);\n\tmark_all_dquot_dirty(transfer_to);\n\tflush_warnings(warn_to);\n\tflush_warnings(warn_from_inodes);\n\tflush_warnings(warn_from_space);\n\t/* Pass back references to put */\n\tfor (cnt = 0; cnt < MAXQUOTAS; cnt++)\n\t\tif (is_valid[cnt])\n\t\t\ttransfer_to[cnt] = transfer_from[cnt];\n\treturn 0;\nover_quota:\n\tspin_unlock(&dq_data_lock);\n\tflush_warnings(warn_to);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_quota_trans_credits",
          "args": [
            "sb"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_quota_trans_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "378-387",
          "snippet": "static inline int ocfs2_quota_trans_credits(struct super_block *sb)\n{\n\tint credits = 0;\n\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\treturn credits;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_QWRITE_CREDITS (OCFS2_QINFO_WRITE_CREDITS + \\\n\t\t\t      OCFS2_QUOTA_BLOCK_UPDATE_CREDITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_QWRITE_CREDITS (OCFS2_QINFO_WRITE_CREDITS + \\\n\t\t\t      OCFS2_QUOTA_BLOCK_UPDATE_CREDITS)\n\nstatic inline int ocfs2_quota_trans_credits(struct super_block *sb)\n{\n\tint credits = 0;\n\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_USRQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\tif (OCFS2_HAS_RO_COMPAT_FEATURE(sb, OCFS2_FEATURE_RO_COMPAT_GRPQUOTA))\n\t\tcredits += OCFS2_QWRITE_CREDITS;\n\treturn credits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dqget",
          "args": [
            "sb",
            "make_kqid_gid(attr->ia_gid)"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "dqget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "832-893",
          "snippet": "struct dquot *dqget(struct super_block *sb, struct kqid qid)\n{\n\tunsigned int hashent = hashfn(sb, qid);\n\tstruct dquot *dquot = NULL, *empty = NULL;\n\n        if (!sb_has_quota_active(sb, qid.type))\n\t\treturn NULL;\nwe_slept:\n\tspin_lock(&dq_list_lock);\n\tspin_lock(&dq_state_lock);\n\tif (!sb_has_quota_active(sb, qid.type)) {\n\t\tspin_unlock(&dq_state_lock);\n\t\tspin_unlock(&dq_list_lock);\n\t\tgoto out;\n\t}\n\tspin_unlock(&dq_state_lock);\n\n\tdquot = find_dquot(hashent, sb, qid);\n\tif (!dquot) {\n\t\tif (!empty) {\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tempty = get_empty_dquot(sb, qid.type);\n\t\t\tif (!empty)\n\t\t\t\tschedule();\t/* Try to wait for a moment... */\n\t\t\tgoto we_slept;\n\t\t}\n\t\tdquot = empty;\n\t\tempty = NULL;\n\t\tdquot->dq_id = qid;\n\t\t/* all dquots go on the inuse_list */\n\t\tput_inuse(dquot);\n\t\t/* hash it first so it can be found */\n\t\tinsert_dquot_hash(dquot);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqstats_inc(DQST_LOOKUPS);\n\t} else {\n\t\tif (!atomic_read(&dquot->dq_count))\n\t\t\tremove_free_dquot(dquot);\n\t\tatomic_inc(&dquot->dq_count);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqstats_inc(DQST_CACHE_HITS);\n\t\tdqstats_inc(DQST_LOOKUPS);\n\t}\n\t/* Wait for dq_lock - after this we know that either dquot_release() is\n\t * already finished or it will be canceled due to dq_count > 1 test */\n\twait_on_dquot(dquot);\n\t/* Read the dquot / allocate space in quota file */\n\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) &&\n\t    sb->dq_op->acquire_dquot(dquot) < 0) {\n\t\tdqput(dquot);\n\t\tdquot = NULL;\n\t\tgoto out;\n\t}\n#ifdef CONFIG_QUOTA_DEBUG\n\tBUG_ON(!dquot->dq_sb);\t/* Has somebody invalidated entry under us? */\n#endif\nout:\n\tif (empty)\n\t\tdo_destroy_dquot(empty);\n\n\treturn dquot;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);",
            "static LIST_HEAD(inuse_list);",
            "static void __dquot_initialize(struct inode *inode, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_list_lock);\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(dq_state_lock);\nstatic LIST_HEAD(inuse_list);\nstatic void __dquot_initialize(struct inode *inode, int type);\n\nstruct dquot *dqget(struct super_block *sb, struct kqid qid)\n{\n\tunsigned int hashent = hashfn(sb, qid);\n\tstruct dquot *dquot = NULL, *empty = NULL;\n\n        if (!sb_has_quota_active(sb, qid.type))\n\t\treturn NULL;\nwe_slept:\n\tspin_lock(&dq_list_lock);\n\tspin_lock(&dq_state_lock);\n\tif (!sb_has_quota_active(sb, qid.type)) {\n\t\tspin_unlock(&dq_state_lock);\n\t\tspin_unlock(&dq_list_lock);\n\t\tgoto out;\n\t}\n\tspin_unlock(&dq_state_lock);\n\n\tdquot = find_dquot(hashent, sb, qid);\n\tif (!dquot) {\n\t\tif (!empty) {\n\t\t\tspin_unlock(&dq_list_lock);\n\t\t\tempty = get_empty_dquot(sb, qid.type);\n\t\t\tif (!empty)\n\t\t\t\tschedule();\t/* Try to wait for a moment... */\n\t\t\tgoto we_slept;\n\t\t}\n\t\tdquot = empty;\n\t\tempty = NULL;\n\t\tdquot->dq_id = qid;\n\t\t/* all dquots go on the inuse_list */\n\t\tput_inuse(dquot);\n\t\t/* hash it first so it can be found */\n\t\tinsert_dquot_hash(dquot);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqstats_inc(DQST_LOOKUPS);\n\t} else {\n\t\tif (!atomic_read(&dquot->dq_count))\n\t\t\tremove_free_dquot(dquot);\n\t\tatomic_inc(&dquot->dq_count);\n\t\tspin_unlock(&dq_list_lock);\n\t\tdqstats_inc(DQST_CACHE_HITS);\n\t\tdqstats_inc(DQST_LOOKUPS);\n\t}\n\t/* Wait for dq_lock - after this we know that either dquot_release() is\n\t * already finished or it will be canceled due to dq_count > 1 test */\n\twait_on_dquot(dquot);\n\t/* Read the dquot / allocate space in quota file */\n\tif (!test_bit(DQ_ACTIVE_B, &dquot->dq_flags) &&\n\t    sb->dq_op->acquire_dquot(dquot) < 0) {\n\t\tdqput(dquot);\n\t\tdquot = NULL;\n\t\tgoto out;\n\t}\n#ifdef CONFIG_QUOTA_DEBUG\n\tBUG_ON(!dquot->dq_sb);\t/* Has somebody invalidated entry under us? */\n#endif\nout:\n\tif (empty)\n\t\tdo_destroy_dquot(empty);\n\n\treturn dquot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kqid_gid",
          "args": [
            "attr->ia_gid"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "OCFS2_FEATURE_RO_COMPAT_GRPQUOTA"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "attr->ia_gid",
            "inode->i_gid"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kqid_uid",
          "args": [
            "attr->ia_uid"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "OCFS2_FEATURE_RO_COMPAT_USRQUOTA"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "attr->ia_uid",
            "inode->i_uid"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "attr->ia_gid",
            "inode->i_gid"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_file",
          "args": [
            "inode",
            "bh",
            "attr->ia_size"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1060-1124",
          "snippet": "static int ocfs2_extend_file(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tBUG_ON(!di_bh);\n\n\t/* setattr sometimes calls us like this. */\n\tif (new_i_size == 0)\n\t\tgoto out;\n\n\tif (i_size_read(inode) == new_i_size)\n\t\tgoto out;\n\tBUG_ON(new_i_size < i_size_read(inode));\n\n\t/*\n\t * The alloc sem blocks people in read/write from reading our\n\t * allocation until we're done changing it. We depend on\n\t * i_mutex to block other extend/truncate calls while we're\n\t * here.  We even have to hold it for sparse files because there\n\t * might be some tail zeroing.\n\t */\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t/*\n\t\t * We can optimize small extends by keeping the inodes\n\t\t * inline data.\n\t\t */\n\t\tif (ocfs2_size_fits_inline_data(di_bh, new_i_size)) {\n\t\t\tup_write(&oi->ip_alloc_sem);\n\t\t\tgoto out_update_size;\n\t\t}\n\n\t\tret = ocfs2_convert_inline_data_to_extents(inode, di_bh);\n\t\tif (ret) {\n\t\t\tup_write(&oi->ip_alloc_sem);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\tret = ocfs2_zero_extend(inode, di_bh, new_i_size);\n\telse\n\t\tret = ocfs2_extend_no_holes(inode, di_bh, new_i_size,\n\t\t\t\t\t    new_i_size);\n\n\tup_write(&oi->ip_alloc_sem);\n\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_size:\n\tret = ocfs2_simple_size_update(inode, di_bh, new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_extend_file(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tBUG_ON(!di_bh);\n\n\t/* setattr sometimes calls us like this. */\n\tif (new_i_size == 0)\n\t\tgoto out;\n\n\tif (i_size_read(inode) == new_i_size)\n\t\tgoto out;\n\tBUG_ON(new_i_size < i_size_read(inode));\n\n\t/*\n\t * The alloc sem blocks people in read/write from reading our\n\t * allocation until we're done changing it. We depend on\n\t * i_mutex to block other extend/truncate calls while we're\n\t * here.  We even have to hold it for sparse files because there\n\t * might be some tail zeroing.\n\t */\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t/*\n\t\t * We can optimize small extends by keeping the inodes\n\t\t * inline data.\n\t\t */\n\t\tif (ocfs2_size_fits_inline_data(di_bh, new_i_size)) {\n\t\t\tup_write(&oi->ip_alloc_sem);\n\t\t\tgoto out_update_size;\n\t\t}\n\n\t\tret = ocfs2_convert_inline_data_to_extents(inode, di_bh);\n\t\tif (ret) {\n\t\t\tup_write(&oi->ip_alloc_sem);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\tret = ocfs2_zero_extend(inode, di_bh, new_i_size);\n\telse\n\t\tret = ocfs2_extend_no_holes(inode, di_bh, new_i_size,\n\t\t\t\t\t    new_i_size);\n\n\tup_write(&oi->ip_alloc_sem);\n\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_size:\n\tret = ocfs2_simple_size_update(inode, di_bh, new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_file",
          "args": [
            "inode",
            "bh",
            "attr->ia_size"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "444-526",
          "snippet": "int ocfs2_truncate_file(struct inode *inode,\n\t\t\t       struct buffer_head *di_bh,\n\t\t\t       u64 new_i_size)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/* We trust di_bh because it comes from ocfs2_inode_lock(), which\n\t * already validated it */\n\tfe = (struct ocfs2_dinode *) di_bh->b_data;\n\n\ttrace_ocfs2_truncate_file((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t  (unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t\t  (unsigned long long)new_i_size);\n\n\tmlog_bug_on_msg(le64_to_cpu(fe->i_size) != i_size_read(inode),\n\t\t\t\"Inode %llu, inode i_size = %lld != di \"\n\t\t\t\"i_size = %llu, i_flags = 0x%x\\n\",\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\ti_size_read(inode),\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\tle32_to_cpu(fe->i_flags));\n\n\tif (new_i_size > le64_to_cpu(fe->i_size)) {\n\t\ttrace_ocfs2_truncate_file_error(\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t(unsigned long long)new_i_size);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_resv_discard(&osb->osb_la_resmap,\n\t\t\t   &OCFS2_I(inode)->ip_la_data_resv);\n\n\t/*\n\t * The inode lock forced other nodes to sync and drop their\n\t * pages, which (correctly) happens even if we have a truncate\n\t * without allocation change - ocfs2 cluster sizes can be much\n\t * greater than page size, so we have to truncate them\n\t * anyway.\n\t */\n\tunmap_mapping_range(inode->i_mapping, new_i_size + PAGE_SIZE - 1, 0, 1);\n\ttruncate_inode_pages(inode->i_mapping, new_i_size);\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstatus = ocfs2_truncate_inline(inode, di_bh, new_i_size,\n\t\t\t\t\t       i_size_read(inode), 1);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* alright, we're going to need to do a full blown alloc size\n\t * change. Orphan the inode so that recovery can complete the\n\t * truncate if necessary. This does the task of marking\n\t * i_size. */\n\tstatus = ocfs2_orphan_for_truncate(osb, inode, di_bh, new_i_size);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\tstatus = ocfs2_commit_truncate(osb, inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* TODO: orphan dir cleanup here. */\nbail_unlock_sem:\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\nbail:\n\tif (!status && OCFS2_I(inode)->ip_clusters == 0)\n\t\tstatus = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_truncate_file(struct inode *inode,\n\t\t\t       struct buffer_head *di_bh,\n\t\t\t       u64 new_i_size)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/* We trust di_bh because it comes from ocfs2_inode_lock(), which\n\t * already validated it */\n\tfe = (struct ocfs2_dinode *) di_bh->b_data;\n\n\ttrace_ocfs2_truncate_file((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t  (unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t\t  (unsigned long long)new_i_size);\n\n\tmlog_bug_on_msg(le64_to_cpu(fe->i_size) != i_size_read(inode),\n\t\t\t\"Inode %llu, inode i_size = %lld != di \"\n\t\t\t\"i_size = %llu, i_flags = 0x%x\\n\",\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\ti_size_read(inode),\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\tle32_to_cpu(fe->i_flags));\n\n\tif (new_i_size > le64_to_cpu(fe->i_size)) {\n\t\ttrace_ocfs2_truncate_file_error(\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t(unsigned long long)new_i_size);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_resv_discard(&osb->osb_la_resmap,\n\t\t\t   &OCFS2_I(inode)->ip_la_data_resv);\n\n\t/*\n\t * The inode lock forced other nodes to sync and drop their\n\t * pages, which (correctly) happens even if we have a truncate\n\t * without allocation change - ocfs2 cluster sizes can be much\n\t * greater than page size, so we have to truncate them\n\t * anyway.\n\t */\n\tunmap_mapping_range(inode->i_mapping, new_i_size + PAGE_SIZE - 1, 0, 1);\n\ttruncate_inode_pages(inode->i_mapping, new_i_size);\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstatus = ocfs2_truncate_inline(inode, di_bh, new_i_size,\n\t\t\t\t\t       i_size_read(inode), 1);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* alright, we're going to need to do a full blown alloc size\n\t * change. Orphan the inode so that recovery can complete the\n\t * truncate if necessary. This does the task of marking\n\t * i_size. */\n\tstatus = ocfs2_orphan_for_truncate(osb, inode, di_bh, new_i_size);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\tstatus = ocfs2_commit_truncate(osb, inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* TODO: orphan dir cleanup here. */\nbail_unlock_sem:\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\nbail:\n\tif (!status && OCFS2_I(inode)->ip_clusters == 0)\n\t\tstatus = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_begin_ordered_truncate",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_begin_ordered_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "625-632",
          "snippet": "static inline int ocfs2_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t       loff_t new_size)\n{\n\treturn jbd2_journal_begin_ordered_truncate(\n\t\t\t\tOCFS2_SB(inode->i_sb)->journal->j_journal,\n\t\t\t\t&OCFS2_I(inode)->ip_jinode,\n\t\t\t\tnew_size);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t       loff_t new_size)\n{\n\treturn jbd2_journal_begin_ordered_truncate(\n\t\t\t\tOCFS2_SB(inode->i_sb)->journal->j_journal,\n\t\t\t\t&OCFS2_I(inode)->ip_jinode,\n\t\t\t\tnew_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_should_order_data",
          "args": [
            "inode"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_should_order_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "474-481",
          "snippet": "static inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "inode"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_newsize_ok",
          "args": [
            "inode",
            "attr->ia_size"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "inode_newsize_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "99-124",
          "snippet": "int inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_newsize_ok(const struct inode *inode, loff_t offset)\n{\n\tif (inode->i_size < offset) {\n\t\tunsigned long limit;\n\n\t\tlimit = rlimit(RLIMIT_FSIZE);\n\t\tif (limit != RLIM_INFINITY && offset > limit)\n\t\t\tgoto out_sig;\n\t\tif (offset > inode->i_sb->s_maxbytes)\n\t\t\tgoto out_big;\n\t} else {\n\t\t/*\n\t\t * truncation of in-use swapfiles is disallowed - it would\n\t\t * cause subsequent swapout to scribble on the now-freed\n\t\t * blocks.\n\t\t */\n\t\tif (IS_SWAPFILE(inode))\n\t\t\treturn -ETXTBSY;\n\t}\n\n\treturn 0;\nout_sig:\n\tsend_sig(SIGXFSZ, current, 0);\nout_big:\n\treturn -EFBIG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&bh",
            "1"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_lock",
          "args": [
            "inode",
            "1"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1665-1690",
          "snippet": "int ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_quota_modification",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_setattr",
          "args": [
            "inode",
            "dentry",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "dentry->d_name.len",
            "dentry->d_name.name",
            "attr->ia_valid",
            "attr->ia_mode",
            "from_kuid(&init_user_ns, attr->ia_uid)",
            "from_kgid(&init_user_ns, attr->ia_gid)"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "attr->ia_gid"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "attr->ia_uid"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\n#define OCFS2_VALID_ATTRS (ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE \\\n\t\t\t   | ATTR_GID | ATTR_UID | ATTR_MODE)\n\nint ocfs2_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint status = 0, size_change;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tstruct buffer_head *bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct dquot *transfer_to[MAXQUOTAS] = { };\n\tint qtype;\n\n\ttrace_ocfs2_setattr(inode, dentry,\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    dentry->d_name.len, dentry->d_name.name,\n\t\t\t    attr->ia_valid, attr->ia_mode,\n\t\t\t    from_kuid(&init_user_ns, attr->ia_uid),\n\t\t\t    from_kgid(&init_user_ns, attr->ia_gid));\n\n\t/* ensuring we don't even attempt to truncate a symlink */\n\tif (S_ISLNK(inode->i_mode))\n\t\tattr->ia_valid &= ~ATTR_SIZE;\n\n#define OCFS2_VALID_ATTRS (ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE \\\n\t\t\t   | ATTR_GID | ATTR_UID | ATTR_MODE)\n\tif (!(attr->ia_valid & OCFS2_VALID_ATTRS))\n\t\treturn 0;\n\n\tstatus = inode_change_ok(inode, attr);\n\tif (status)\n\t\treturn status;\n\n\tif (is_quota_modification(inode, attr))\n\t\tdquot_initialize(inode);\n\tsize_change = S_ISREG(inode->i_mode) && attr->ia_valid & ATTR_SIZE;\n\tif (size_change) {\n\t\tstatus = ocfs2_rw_lock(inode, 1);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_inode_lock(inode, &bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\tgoto bail_unlock_rw;\n\t}\n\n\tif (size_change) {\n\t\tstatus = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (status)\n\t\t\tgoto bail_unlock;\n\n\t\tinode_dio_wait(inode);\n\n\t\tif (i_size_read(inode) >= attr->ia_size) {\n\t\t\tif (ocfs2_should_order_data(inode)) {\n\t\t\t\tstatus = ocfs2_begin_ordered_truncate(inode,\n\t\t\t\t\t\t\t\t      attr->ia_size);\n\t\t\t\tif (status)\n\t\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t\tstatus = ocfs2_truncate_file(inode, bh, attr->ia_size);\n\t\t} else\n\t\t\tstatus = ocfs2_extend_file(inode, bh, attr->ia_size);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENOSPC)\n\t\t\t\tmlog_errno(status);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail_unlock;\n\t\t}\n\t}\n\n\tif ((attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\t/*\n\t\t * Gather pointers to quota structures so that allocation /\n\t\t * freeing of quota structures happens here and not inside\n\t\t * dquot_transfer() where we have problems with lock ordering\n\t\t */\n\t\tif (attr->ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)\n\t\t    && OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t    OCFS2_FEATURE_RO_COMPAT_USRQUOTA)) {\n\t\t\ttransfer_to[USRQUOTA] = dqget(sb, make_kqid_uid(attr->ia_uid));\n\t\t\tif (!transfer_to[USRQUOTA]) {\n\t\t\t\tstatus = -ESRCH;\n\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t}\n\t\tif (attr->ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid)\n\t\t    && OCFS2_HAS_RO_COMPAT_FEATURE(sb,\n\t\t    OCFS2_FEATURE_RO_COMPAT_GRPQUOTA)) {\n\t\t\ttransfer_to[GRPQUOTA] = dqget(sb, make_kqid_gid(attr->ia_gid));\n\t\t\tif (!transfer_to[GRPQUOTA]) {\n\t\t\t\tstatus = -ESRCH;\n\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t}\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS +\n\t\t\t\t\t   2 * ocfs2_quota_trans_credits(sb));\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock;\n\t\t}\n\t\tstatus = __dquot_transfer(inode, transfer_to);\n\t\tif (status < 0)\n\t\t\tgoto bail_commit;\n\t} else {\n\t\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\t\tif (IS_ERR(handle)) {\n\t\t\tstatus = PTR_ERR(handle);\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail_unlock;\n\t\t}\n\t}\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, bh);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail_commit:\n\tocfs2_commit_trans(osb, handle);\nbail_unlock:\n\tocfs2_inode_unlock(inode, 1);\nbail_unlock_rw:\n\tif (size_change)\n\t\tocfs2_rw_unlock(inode, 1);\nbail:\n\tbrelse(bh);\n\n\t/* Release quota pointers in case we acquired them */\n\tfor (qtype = 0; qtype < OCFS2_MAXQUOTAS; qtype++)\n\t\tdqput(transfer_to[qtype]);\n\n\tif (!status && attr->ia_valid & ATTR_MODE) {\n\t\tstatus = posix_acl_chmod(inode, inode->i_mode);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_extend_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1060-1124",
    "snippet": "static int ocfs2_extend_file(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tBUG_ON(!di_bh);\n\n\t/* setattr sometimes calls us like this. */\n\tif (new_i_size == 0)\n\t\tgoto out;\n\n\tif (i_size_read(inode) == new_i_size)\n\t\tgoto out;\n\tBUG_ON(new_i_size < i_size_read(inode));\n\n\t/*\n\t * The alloc sem blocks people in read/write from reading our\n\t * allocation until we're done changing it. We depend on\n\t * i_mutex to block other extend/truncate calls while we're\n\t * here.  We even have to hold it for sparse files because there\n\t * might be some tail zeroing.\n\t */\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t/*\n\t\t * We can optimize small extends by keeping the inodes\n\t\t * inline data.\n\t\t */\n\t\tif (ocfs2_size_fits_inline_data(di_bh, new_i_size)) {\n\t\t\tup_write(&oi->ip_alloc_sem);\n\t\t\tgoto out_update_size;\n\t\t}\n\n\t\tret = ocfs2_convert_inline_data_to_extents(inode, di_bh);\n\t\tif (ret) {\n\t\t\tup_write(&oi->ip_alloc_sem);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\tret = ocfs2_zero_extend(inode, di_bh, new_i_size);\n\telse\n\t\tret = ocfs2_extend_no_holes(inode, di_bh, new_i_size,\n\t\t\t\t\t    new_i_size);\n\n\tup_write(&oi->ip_alloc_sem);\n\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_size:\n\tret = ocfs2_simple_size_update(inode, di_bh, new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_simple_size_update",
          "args": [
            "inode",
            "di_bh",
            "new_i_size"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_simple_size_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "319-343",
          "snippet": "int ocfs2_simple_size_update(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_set_inode_size(handle, inode, di_bh,\n\t\t\t\t   new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_simple_size_update(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_set_inode_size(handle, inode, di_bh,\n\t\t\t\t   new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_no_holes",
          "args": [
            "inode",
            "di_bh",
            "new_i_size",
            "new_i_size"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_no_holes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "1018-1058",
          "snippet": "int ocfs2_extend_no_holes(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  u64 new_i_size, u64 zero_to)\n{\n\tint ret;\n\tu32 clusters_to_add;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t/*\n\t * Only quota files call this without a bh, and they can't be\n\t * refcounted.\n\t */\n\tBUG_ON(!di_bh && (oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\tBUG_ON(!di_bh && !(oi->ip_flags & OCFS2_INODE_SYSTEM_FILE));\n\n\tclusters_to_add = ocfs2_clusters_for_bytes(inode->i_sb, new_i_size);\n\tif (clusters_to_add < oi->ip_clusters)\n\t\tclusters_to_add = 0;\n\telse\n\t\tclusters_to_add -= oi->ip_clusters;\n\n\tif (clusters_to_add) {\n\t\tret = __ocfs2_extend_allocation(inode, oi->ip_clusters,\n\t\t\t\t\t\tclusters_to_add, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Call this even if we don't add any clusters to the tree. We\n\t * still need to zero the area between the old i_size and the\n\t * new i_size.\n\t */\n\tret = ocfs2_zero_extend(inode, di_bh, zero_to);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_extend_no_holes(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  u64 new_i_size, u64 zero_to)\n{\n\tint ret;\n\tu32 clusters_to_add;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t/*\n\t * Only quota files call this without a bh, and they can't be\n\t * refcounted.\n\t */\n\tBUG_ON(!di_bh && (oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\tBUG_ON(!di_bh && !(oi->ip_flags & OCFS2_INODE_SYSTEM_FILE));\n\n\tclusters_to_add = ocfs2_clusters_for_bytes(inode->i_sb, new_i_size);\n\tif (clusters_to_add < oi->ip_clusters)\n\t\tclusters_to_add = 0;\n\telse\n\t\tclusters_to_add -= oi->ip_clusters;\n\n\tif (clusters_to_add) {\n\t\tret = __ocfs2_extend_allocation(inode, oi->ip_clusters,\n\t\t\t\t\t\tclusters_to_add, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Call this even if we don't add any clusters to the tree. We\n\t * still need to zero the area between the old i_size and the\n\t * new i_size.\n\t */\n\tret = ocfs2_zero_extend(inode, di_bh, zero_to);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_extend",
          "args": [
            "inode",
            "di_bh",
            "new_i_size"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "978-1016",
          "snippet": "int ocfs2_zero_extend(struct inode *inode, struct buffer_head *di_bh,\n\t\t      loff_t zero_to_size)\n{\n\tint ret = 0;\n\tu64 zero_start, range_start = 0, range_end = 0;\n\tstruct super_block *sb = inode->i_sb;\n\n\tzero_start = ocfs2_align_bytes_to_blocks(sb, i_size_read(inode));\n\ttrace_ocfs2_zero_extend((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t(unsigned long long)zero_start,\n\t\t\t\t(unsigned long long)i_size_read(inode));\n\twhile (zero_start < zero_to_size) {\n\t\tret = ocfs2_zero_extend_get_range(inode, di_bh, zero_start,\n\t\t\t\t\t\t  zero_to_size,\n\t\t\t\t\t\t  &range_start,\n\t\t\t\t\t\t  &range_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (!range_end)\n\t\t\tbreak;\n\t\t/* Trim the ends */\n\t\tif (range_start < zero_start)\n\t\t\trange_start = zero_start;\n\t\tif (range_end > zero_to_size)\n\t\t\trange_end = zero_to_size;\n\n\t\tret = ocfs2_zero_extend_range(inode, range_start,\n\t\t\t\t\t      range_end, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t\tzero_start = range_end;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_zero_extend(struct inode *inode, struct buffer_head *di_bh,\n\t\t      loff_t zero_to_size)\n{\n\tint ret = 0;\n\tu64 zero_start, range_start = 0, range_end = 0;\n\tstruct super_block *sb = inode->i_sb;\n\n\tzero_start = ocfs2_align_bytes_to_blocks(sb, i_size_read(inode));\n\ttrace_ocfs2_zero_extend((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t(unsigned long long)zero_start,\n\t\t\t\t(unsigned long long)i_size_read(inode));\n\twhile (zero_start < zero_to_size) {\n\t\tret = ocfs2_zero_extend_get_range(inode, di_bh, zero_start,\n\t\t\t\t\t\t  zero_to_size,\n\t\t\t\t\t\t  &range_start,\n\t\t\t\t\t\t  &range_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (!range_end)\n\t\t\tbreak;\n\t\t/* Trim the ends */\n\t\tif (range_start < zero_start)\n\t\t\trange_start = zero_start;\n\t\tif (range_end > zero_to_size)\n\t\t\trange_end = zero_to_size;\n\n\t\tret = ocfs2_zero_extend_range(inode, range_start,\n\t\t\t\t\t      range_end, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t\tzero_start = range_end;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "483-488",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_convert_inline_data_to_extents",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_convert_inline_data_to_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6836-7003",
          "snippet": "int ocfs2_convert_inline_data_to_extents(struct inode *inode,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret, i, has_data, num_pages = 0;\n\tint need_free = 0;\n\tu32 bit_off, num;\n\thandle_t *handle;\n\tu64 uninitialized_var(block);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct page **pages = NULL;\n\tloff_t end = osb->s_clustersize;\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\thas_data = i_size_read(inode) ? 1 : 0;\n\n\tif (has_data) {\n\t\tpages = kcalloc(ocfs2_pages_per_cluster(osb->sb),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (pages == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\t\t   ocfs2_inline_to_extents_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (has_data) {\n\t\tunsigned int page_end;\n\t\tu64 phys;\n\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t\tdid_quota = 1;\n\n\t\tdata_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &num);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * Save two copies, one for insert, and one that can\n\t\t * be changed by ocfs2_map_and_dirty_page() below.\n\t\t */\n\t\tblock = phys = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\t\t/*\n\t\t * Non sparse file systems zero on extend, so no need\n\t\t * to do that now.\n\t\t */\n\t\tif (!ocfs2_sparse_alloc(osb) &&\n\t\t    PAGE_CACHE_SIZE < osb->s_clustersize)\n\t\t\tend = PAGE_CACHE_SIZE;\n\n\t\tret = ocfs2_grab_eof_pages(inode, 0, end, pages, &num_pages);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * This should populate the 1st page for us and mark\n\t\t * it up to date.\n\t\t */\n\t\tret = ocfs2_read_inline_data(inode, pages[0], di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tpage_end = PAGE_CACHE_SIZE;\n\t\tif (PAGE_CACHE_SIZE > osb->s_clustersize)\n\t\t\tpage_end = osb->s_clustersize;\n\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tocfs2_map_and_dirty_page(inode, handle, 0, page_end,\n\t\t\t\t\t\t pages[i], i > 0, &phys);\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_dinode_new_extent_list(inode, di);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (has_data) {\n\t\t/*\n\t\t * An error at this point should be extremely rare. If\n\t\t * this proves to be false, we could always re-build\n\t\t * the in-inode data from our pages.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\t\tret = ocfs2_insert_extent(handle, &et, 0, block, 1, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t}\n\nout_unlock:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, num_pages);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(osb->sb, 1));\n\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum);\n\t}\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (pages)\n\t\tkfree(pages);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_convert_inline_data_to_extents(struct inode *inode,\n\t\t\t\t\t struct buffer_head *di_bh)\n{\n\tint ret, i, has_data, num_pages = 0;\n\tint need_free = 0;\n\tu32 bit_off, num;\n\thandle_t *handle;\n\tu64 uninitialized_var(block);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct page **pages = NULL;\n\tloff_t end = osb->s_clustersize;\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\thas_data = i_size_read(inode) ? 1 : 0;\n\n\tif (has_data) {\n\t\tpages = kcalloc(ocfs2_pages_per_cluster(osb->sb),\n\t\t\t\tsizeof(struct page *), GFP_NOFS);\n\t\tif (pages == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_reserve_clusters(osb, 1, &data_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\thandle = ocfs2_start_trans(osb,\n\t\t\t\t   ocfs2_inline_to_extents_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (has_data) {\n\t\tunsigned int page_end;\n\t\tu64 phys;\n\n\t\tret = dquot_alloc_space_nodirty(inode,\n\t\t\t\t       ocfs2_clusters_to_bytes(osb->sb, 1));\n\t\tif (ret)\n\t\t\tgoto out_commit;\n\t\tdid_quota = 1;\n\n\t\tdata_ac->ac_resv = &OCFS2_I(inode)->ip_la_data_resv;\n\n\t\tret = ocfs2_claim_clusters(handle, data_ac, 1, &bit_off,\n\t\t\t\t\t   &num);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * Save two copies, one for insert, and one that can\n\t\t * be changed by ocfs2_map_and_dirty_page() below.\n\t\t */\n\t\tblock = phys = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);\n\n\t\t/*\n\t\t * Non sparse file systems zero on extend, so no need\n\t\t * to do that now.\n\t\t */\n\t\tif (!ocfs2_sparse_alloc(osb) &&\n\t\t    PAGE_CACHE_SIZE < osb->s_clustersize)\n\t\t\tend = PAGE_CACHE_SIZE;\n\n\t\tret = ocfs2_grab_eof_pages(inode, 0, end, pages, &num_pages);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\t/*\n\t\t * This should populate the 1st page for us and mark\n\t\t * it up to date.\n\t\t */\n\t\tret = ocfs2_read_inline_data(inode, pages[0], di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tpage_end = PAGE_CACHE_SIZE;\n\t\tif (PAGE_CACHE_SIZE > osb->s_clustersize)\n\t\t\tpage_end = osb->s_clustersize;\n\n\t\tfor (i = 0; i < num_pages; i++)\n\t\t\tocfs2_map_and_dirty_page(inode, handle, 0, page_end,\n\t\t\t\t\t\t pages[i], i > 0, &phys);\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_dinode_new_extent_list(inode, di);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tif (has_data) {\n\t\t/*\n\t\t * An error at this point should be extremely rare. If\n\t\t * this proves to be false, we could always re-build\n\t\t * the in-inode data from our pages.\n\t\t */\n\t\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\t\tret = ocfs2_insert_extent(handle, &et, 0, block, 1, 0, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tneed_free = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\t}\n\nout_unlock:\n\tif (pages)\n\t\tocfs2_unlock_and_free_pages(pages, num_pages);\n\nout_commit:\n\tif (ret < 0 && did_quota)\n\t\tdquot_free_space_nodirty(inode,\n\t\t\t\t\t  ocfs2_clusters_to_bytes(osb->sb, 1));\n\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum);\n\t}\n\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (data_ac)\n\t\tocfs2_free_alloc_context(data_ac);\n\tif (pages)\n\t\tkfree(pages);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_size_fits_inline_data",
          "args": [
            "di_bh",
            "new_i_size"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_size_fits_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1765-1772",
          "snippet": "int ocfs2_size_fits_inline_data(struct buffer_head *di_bh, u64 new_size)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (new_size <= le16_to_cpu(di->id2.i_data.id_count))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint ocfs2_size_fits_inline_data(struct buffer_head *di_bh, u64 new_size)\n{\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tif (new_size <= le16_to_cpu(di->id2.i_data.id_count))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_i_size < i_size_read(inode)"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!di_bh"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_extend_file(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tBUG_ON(!di_bh);\n\n\t/* setattr sometimes calls us like this. */\n\tif (new_i_size == 0)\n\t\tgoto out;\n\n\tif (i_size_read(inode) == new_i_size)\n\t\tgoto out;\n\tBUG_ON(new_i_size < i_size_read(inode));\n\n\t/*\n\t * The alloc sem blocks people in read/write from reading our\n\t * allocation until we're done changing it. We depend on\n\t * i_mutex to block other extend/truncate calls while we're\n\t * here.  We even have to hold it for sparse files because there\n\t * might be some tail zeroing.\n\t */\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\t/*\n\t\t * We can optimize small extends by keeping the inodes\n\t\t * inline data.\n\t\t */\n\t\tif (ocfs2_size_fits_inline_data(di_bh, new_i_size)) {\n\t\t\tup_write(&oi->ip_alloc_sem);\n\t\t\tgoto out_update_size;\n\t\t}\n\n\t\tret = ocfs2_convert_inline_data_to_extents(inode, di_bh);\n\t\tif (ret) {\n\t\t\tup_write(&oi->ip_alloc_sem);\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))\n\t\tret = ocfs2_zero_extend(inode, di_bh, new_i_size);\n\telse\n\t\tret = ocfs2_extend_no_holes(inode, di_bh, new_i_size,\n\t\t\t\t\t    new_i_size);\n\n\tup_write(&oi->ip_alloc_sem);\n\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout_update_size:\n\tret = ocfs2_simple_size_update(inode, di_bh, new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_extend_no_holes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "1018-1058",
    "snippet": "int ocfs2_extend_no_holes(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  u64 new_i_size, u64 zero_to)\n{\n\tint ret;\n\tu32 clusters_to_add;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t/*\n\t * Only quota files call this without a bh, and they can't be\n\t * refcounted.\n\t */\n\tBUG_ON(!di_bh && (oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\tBUG_ON(!di_bh && !(oi->ip_flags & OCFS2_INODE_SYSTEM_FILE));\n\n\tclusters_to_add = ocfs2_clusters_for_bytes(inode->i_sb, new_i_size);\n\tif (clusters_to_add < oi->ip_clusters)\n\t\tclusters_to_add = 0;\n\telse\n\t\tclusters_to_add -= oi->ip_clusters;\n\n\tif (clusters_to_add) {\n\t\tret = __ocfs2_extend_allocation(inode, oi->ip_clusters,\n\t\t\t\t\t\tclusters_to_add, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Call this even if we don't add any clusters to the tree. We\n\t * still need to zero the area between the old i_size and the\n\t * new i_size.\n\t */\n\tret = ocfs2_zero_extend(inode, di_bh, zero_to);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_extend",
          "args": [
            "inode",
            "di_bh",
            "zero_to"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "978-1016",
          "snippet": "int ocfs2_zero_extend(struct inode *inode, struct buffer_head *di_bh,\n\t\t      loff_t zero_to_size)\n{\n\tint ret = 0;\n\tu64 zero_start, range_start = 0, range_end = 0;\n\tstruct super_block *sb = inode->i_sb;\n\n\tzero_start = ocfs2_align_bytes_to_blocks(sb, i_size_read(inode));\n\ttrace_ocfs2_zero_extend((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t(unsigned long long)zero_start,\n\t\t\t\t(unsigned long long)i_size_read(inode));\n\twhile (zero_start < zero_to_size) {\n\t\tret = ocfs2_zero_extend_get_range(inode, di_bh, zero_start,\n\t\t\t\t\t\t  zero_to_size,\n\t\t\t\t\t\t  &range_start,\n\t\t\t\t\t\t  &range_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (!range_end)\n\t\t\tbreak;\n\t\t/* Trim the ends */\n\t\tif (range_start < zero_start)\n\t\t\trange_start = zero_start;\n\t\tif (range_end > zero_to_size)\n\t\t\trange_end = zero_to_size;\n\n\t\tret = ocfs2_zero_extend_range(inode, range_start,\n\t\t\t\t\t      range_end, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t\tzero_start = range_end;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_zero_extend(struct inode *inode, struct buffer_head *di_bh,\n\t\t      loff_t zero_to_size)\n{\n\tint ret = 0;\n\tu64 zero_start, range_start = 0, range_end = 0;\n\tstruct super_block *sb = inode->i_sb;\n\n\tzero_start = ocfs2_align_bytes_to_blocks(sb, i_size_read(inode));\n\ttrace_ocfs2_zero_extend((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t(unsigned long long)zero_start,\n\t\t\t\t(unsigned long long)i_size_read(inode));\n\twhile (zero_start < zero_to_size) {\n\t\tret = ocfs2_zero_extend_get_range(inode, di_bh, zero_start,\n\t\t\t\t\t\t  zero_to_size,\n\t\t\t\t\t\t  &range_start,\n\t\t\t\t\t\t  &range_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (!range_end)\n\t\t\tbreak;\n\t\t/* Trim the ends */\n\t\tif (range_start < zero_start)\n\t\t\trange_start = zero_start;\n\t\tif (range_end > zero_to_size)\n\t\t\trange_end = zero_to_size;\n\n\t\tret = ocfs2_zero_extend_range(inode, range_start,\n\t\t\t\t\t      range_end, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t\tzero_start = range_end;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_extend_allocation",
          "args": [
            "inode",
            "oi->ip_clusters",
            "clusters_to_add",
            "0"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_extend_allocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "560-710",
          "snippet": "static int __ocfs2_extend_allocation(struct inode *inode, u32 logical_start,\n\t\t\t\t     u32 clusters_to_add, int mark_unwritten)\n{\n\tint status = 0;\n\tint restart_func = 0;\n\tint credits;\n\tu32 prev_clusters;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tenum ocfs2_alloc_restarted why = RESTART_NONE;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\t/*\n\t * Unwritten extent only exists for file systems which\n\t * support holes.\n\t */\n\tBUG_ON(mark_unwritten && !ocfs2_sparse_alloc(osb));\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\nrestart_all:\n\tBUG_ON(le32_to_cpu(fe->i_clusters) != OCFS2_I(inode)->ip_clusters);\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), bh);\n\tstatus = ocfs2_lock_allocators(inode, &et, clusters_to_add, 0,\n\t\t\t\t       &data_ac, &meta_ac);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tcredits = ocfs2_calc_extend_credits(osb->sb, &fe->id2.i_list);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\nrestarted_transaction:\n\ttrace_ocfs2_extend_allocation(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)i_size_read(inode),\n\t\tle32_to_cpu(fe->i_clusters), clusters_to_add,\n\t\twhy, restart_func);\n\n\tstatus = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (status)\n\t\tgoto leave;\n\tdid_quota = 1;\n\n\t/* reserve a write to the file entry early on - that we if we\n\t * run out of credits in the allocation path, we can still\n\t * update i_size. */\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tprev_clusters = OCFS2_I(inode)->ip_clusters;\n\n\tstatus = ocfs2_add_inode_data(osb,\n\t\t\t\t      inode,\n\t\t\t\t      &logical_start,\n\t\t\t\t      clusters_to_add,\n\t\t\t\t      mark_unwritten,\n\t\t\t\t      bh,\n\t\t\t\t      handle,\n\t\t\t\t      data_ac,\n\t\t\t\t      meta_ac,\n\t\t\t\t      &why);\n\tif ((status < 0) && (status != -EAGAIN)) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, bh);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tclusters_to_add -= (OCFS2_I(inode)->ip_clusters - prev_clusters);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t/* Release unused quota reservation */\n\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tdid_quota = 0;\n\n\tif (why != RESTART_NONE && clusters_to_add) {\n\t\tif (why == RESTART_META) {\n\t\t\trestart_func = 1;\n\t\t\tstatus = 0;\n\t\t} else {\n\t\t\tBUG_ON(why != RESTART_TRANS);\n\n\t\t\tstatus = ocfs2_allocate_extend_trans(handle, 1);\n\t\t\tif (status < 0) {\n\t\t\t\t/* handle still has to be committed at\n\t\t\t\t * this point. */\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tgoto restarted_transaction;\n\t\t}\n\t}\n\n\ttrace_ocfs2_extend_allocation_end(OCFS2_I(inode)->ip_blkno,\n\t     le32_to_cpu(fe->i_clusters),\n\t     (unsigned long long)le64_to_cpu(fe->i_size),\n\t     OCFS2_I(inode)->ip_clusters,\n\t     (unsigned long long)i_size_read(inode));\n\nleave:\n\tif (status < 0 && did_quota)\n\t\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (handle) {\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\t}\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\tif ((!status) && restart_func) {\n\t\trestart_func = 0;\n\t\tgoto restart_all;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __ocfs2_extend_allocation(struct inode *inode, u32 logical_start,\n\t\t\t\t     u32 clusters_to_add, int mark_unwritten)\n{\n\tint status = 0;\n\tint restart_func = 0;\n\tint credits;\n\tu32 prev_clusters;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tenum ocfs2_alloc_restarted why = RESTART_NONE;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\t/*\n\t * Unwritten extent only exists for file systems which\n\t * support holes.\n\t */\n\tBUG_ON(mark_unwritten && !ocfs2_sparse_alloc(osb));\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\nrestart_all:\n\tBUG_ON(le32_to_cpu(fe->i_clusters) != OCFS2_I(inode)->ip_clusters);\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), bh);\n\tstatus = ocfs2_lock_allocators(inode, &et, clusters_to_add, 0,\n\t\t\t\t       &data_ac, &meta_ac);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tcredits = ocfs2_calc_extend_credits(osb->sb, &fe->id2.i_list);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\nrestarted_transaction:\n\ttrace_ocfs2_extend_allocation(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)i_size_read(inode),\n\t\tle32_to_cpu(fe->i_clusters), clusters_to_add,\n\t\twhy, restart_func);\n\n\tstatus = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (status)\n\t\tgoto leave;\n\tdid_quota = 1;\n\n\t/* reserve a write to the file entry early on - that we if we\n\t * run out of credits in the allocation path, we can still\n\t * update i_size. */\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tprev_clusters = OCFS2_I(inode)->ip_clusters;\n\n\tstatus = ocfs2_add_inode_data(osb,\n\t\t\t\t      inode,\n\t\t\t\t      &logical_start,\n\t\t\t\t      clusters_to_add,\n\t\t\t\t      mark_unwritten,\n\t\t\t\t      bh,\n\t\t\t\t      handle,\n\t\t\t\t      data_ac,\n\t\t\t\t      meta_ac,\n\t\t\t\t      &why);\n\tif ((status < 0) && (status != -EAGAIN)) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, bh);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tclusters_to_add -= (OCFS2_I(inode)->ip_clusters - prev_clusters);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t/* Release unused quota reservation */\n\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tdid_quota = 0;\n\n\tif (why != RESTART_NONE && clusters_to_add) {\n\t\tif (why == RESTART_META) {\n\t\t\trestart_func = 1;\n\t\t\tstatus = 0;\n\t\t} else {\n\t\t\tBUG_ON(why != RESTART_TRANS);\n\n\t\t\tstatus = ocfs2_allocate_extend_trans(handle, 1);\n\t\t\tif (status < 0) {\n\t\t\t\t/* handle still has to be committed at\n\t\t\t\t * this point. */\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tgoto restarted_transaction;\n\t\t}\n\t}\n\n\ttrace_ocfs2_extend_allocation_end(OCFS2_I(inode)->ip_blkno,\n\t     le32_to_cpu(fe->i_clusters),\n\t     (unsigned long long)le64_to_cpu(fe->i_size),\n\t     OCFS2_I(inode)->ip_clusters,\n\t     (unsigned long long)i_size_read(inode));\n\nleave:\n\tif (status < 0 && did_quota)\n\t\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (handle) {\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\t}\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\tif ((!status) && restart_func) {\n\t\trestart_func = 0;\n\t\tgoto restart_all;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "inode->i_sb",
            "new_i_size"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!di_bh && !(oi->ip_flags & OCFS2_INODE_SYSTEM_FILE)"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!di_bh && (oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL)"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_extend_no_holes(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  u64 new_i_size, u64 zero_to)\n{\n\tint ret;\n\tu32 clusters_to_add;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\t/*\n\t * Only quota files call this without a bh, and they can't be\n\t * refcounted.\n\t */\n\tBUG_ON(!di_bh && (oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\tBUG_ON(!di_bh && !(oi->ip_flags & OCFS2_INODE_SYSTEM_FILE));\n\n\tclusters_to_add = ocfs2_clusters_for_bytes(inode->i_sb, new_i_size);\n\tif (clusters_to_add < oi->ip_clusters)\n\t\tclusters_to_add = 0;\n\telse\n\t\tclusters_to_add -= oi->ip_clusters;\n\n\tif (clusters_to_add) {\n\t\tret = __ocfs2_extend_allocation(inode, oi->ip_clusters,\n\t\t\t\t\t\tclusters_to_add, 0);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * Call this even if we don't add any clusters to the tree. We\n\t * still need to zero the area between the old i_size and the\n\t * new i_size.\n\t */\n\tret = ocfs2_zero_extend(inode, di_bh, zero_to);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_zero_extend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "978-1016",
    "snippet": "int ocfs2_zero_extend(struct inode *inode, struct buffer_head *di_bh,\n\t\t      loff_t zero_to_size)\n{\n\tint ret = 0;\n\tu64 zero_start, range_start = 0, range_end = 0;\n\tstruct super_block *sb = inode->i_sb;\n\n\tzero_start = ocfs2_align_bytes_to_blocks(sb, i_size_read(inode));\n\ttrace_ocfs2_zero_extend((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t(unsigned long long)zero_start,\n\t\t\t\t(unsigned long long)i_size_read(inode));\n\twhile (zero_start < zero_to_size) {\n\t\tret = ocfs2_zero_extend_get_range(inode, di_bh, zero_start,\n\t\t\t\t\t\t  zero_to_size,\n\t\t\t\t\t\t  &range_start,\n\t\t\t\t\t\t  &range_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (!range_end)\n\t\t\tbreak;\n\t\t/* Trim the ends */\n\t\tif (range_start < zero_start)\n\t\t\trange_start = zero_start;\n\t\tif (range_end > zero_to_size)\n\t\t\trange_end = zero_to_size;\n\n\t\tret = ocfs2_zero_extend_range(inode, range_start,\n\t\t\t\t\t      range_end, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t\tzero_start = range_end;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_extend_range",
          "args": [
            "inode",
            "range_start",
            "range_end",
            "di_bh"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_extend_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "944-976",
          "snippet": "static int ocfs2_zero_extend_range(struct inode *inode, u64 range_start,\n\t\t\t\t   u64 range_end, struct buffer_head *di_bh)\n{\n\tint rc = 0;\n\tu64 next_pos;\n\tu64 zero_pos = range_start;\n\n\ttrace_ocfs2_zero_extend_range(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)range_start,\n\t\t\t(unsigned long long)range_end);\n\tBUG_ON(range_start >= range_end);\n\n\twhile (zero_pos < range_end) {\n\t\tnext_pos = (zero_pos & PAGE_CACHE_MASK) + PAGE_CACHE_SIZE;\n\t\tif (next_pos > range_end)\n\t\t\tnext_pos = range_end;\n\t\trc = ocfs2_write_zero_page(inode, zero_pos, next_pos, di_bh);\n\t\tif (rc < 0) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t\tzero_pos = next_pos;\n\n\t\t/*\n\t\t * Very large extends have the potential to lock up\n\t\t * the cpu for extended periods of time.\n\t\t */\n\t\tcond_resched();\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_zero_extend_range(struct inode *inode, u64 range_start,\n\t\t\t\t   u64 range_end, struct buffer_head *di_bh)\n{\n\tint rc = 0;\n\tu64 next_pos;\n\tu64 zero_pos = range_start;\n\n\ttrace_ocfs2_zero_extend_range(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)range_start,\n\t\t\t(unsigned long long)range_end);\n\tBUG_ON(range_start >= range_end);\n\n\twhile (zero_pos < range_end) {\n\t\tnext_pos = (zero_pos & PAGE_CACHE_MASK) + PAGE_CACHE_SIZE;\n\t\tif (next_pos > range_end)\n\t\t\tnext_pos = range_end;\n\t\trc = ocfs2_write_zero_page(inode, zero_pos, next_pos, di_bh);\n\t\tif (rc < 0) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t\tzero_pos = next_pos;\n\n\t\t/*\n\t\t * Very large extends have the potential to lock up\n\t\t * the cpu for extended periods of time.\n\t\t */\n\t\tcond_resched();\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_extend_get_range",
          "args": [
            "inode",
            "di_bh",
            "zero_start",
            "zero_to_size",
            "&range_start",
            "&range_end"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_extend_get_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "870-938",
          "snippet": "static int ocfs2_zero_extend_get_range(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u64 zero_start, u64 zero_end,\n\t\t\t\t       u64 *range_start, u64 *range_end)\n{\n\tint rc = 0, needs_cow = 0;\n\tu32 p_cpos, zero_clusters = 0;\n\tu32 zero_cpos =\n\t\tzero_start >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 last_cpos = ocfs2_clusters_for_bytes(inode->i_sb, zero_end);\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\n\twhile (zero_cpos < last_cpos) {\n\t\trc = ocfs2_get_clusters(inode, zero_cpos, &p_cpos,\n\t\t\t\t\t&num_clusters, &ext_flags);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (p_cpos && !(ext_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\t\tzero_clusters = num_clusters;\n\t\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\t\tneeds_cow = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tzero_cpos += num_clusters;\n\t}\n\tif (!zero_clusters) {\n\t\t*range_end = 0;\n\t\tgoto out;\n\t}\n\n\twhile ((zero_cpos + zero_clusters) < last_cpos) {\n\t\trc = ocfs2_get_clusters(inode, zero_cpos + zero_clusters,\n\t\t\t\t\t&p_cpos, &num_clusters,\n\t\t\t\t\t&ext_flags);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!p_cpos || (ext_flags & OCFS2_EXT_UNWRITTEN))\n\t\t\tbreak;\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tneeds_cow = 1;\n\t\tzero_clusters += num_clusters;\n\t}\n\tif ((zero_cpos + zero_clusters) > last_cpos)\n\t\tzero_clusters = last_cpos - zero_cpos;\n\n\tif (needs_cow) {\n\t\trc = ocfs2_refcount_cow(inode, di_bh, zero_cpos,\n\t\t\t\t\tzero_clusters, UINT_MAX);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*range_start = ocfs2_clusters_to_bytes(inode->i_sb, zero_cpos);\n\t*range_end = ocfs2_clusters_to_bytes(inode->i_sb,\n\t\t\t\t\t     zero_cpos + zero_clusters);\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_zero_extend_get_range(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u64 zero_start, u64 zero_end,\n\t\t\t\t       u64 *range_start, u64 *range_end)\n{\n\tint rc = 0, needs_cow = 0;\n\tu32 p_cpos, zero_clusters = 0;\n\tu32 zero_cpos =\n\t\tzero_start >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 last_cpos = ocfs2_clusters_for_bytes(inode->i_sb, zero_end);\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\n\twhile (zero_cpos < last_cpos) {\n\t\trc = ocfs2_get_clusters(inode, zero_cpos, &p_cpos,\n\t\t\t\t\t&num_clusters, &ext_flags);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (p_cpos && !(ext_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\t\tzero_clusters = num_clusters;\n\t\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\t\tneeds_cow = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tzero_cpos += num_clusters;\n\t}\n\tif (!zero_clusters) {\n\t\t*range_end = 0;\n\t\tgoto out;\n\t}\n\n\twhile ((zero_cpos + zero_clusters) < last_cpos) {\n\t\trc = ocfs2_get_clusters(inode, zero_cpos + zero_clusters,\n\t\t\t\t\t&p_cpos, &num_clusters,\n\t\t\t\t\t&ext_flags);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!p_cpos || (ext_flags & OCFS2_EXT_UNWRITTEN))\n\t\t\tbreak;\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tneeds_cow = 1;\n\t\tzero_clusters += num_clusters;\n\t}\n\tif ((zero_cpos + zero_clusters) > last_cpos)\n\t\tzero_clusters = last_cpos - zero_cpos;\n\n\tif (needs_cow) {\n\t\trc = ocfs2_refcount_cow(inode, di_bh, zero_cpos,\n\t\t\t\t\tzero_clusters, UINT_MAX);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*range_start = ocfs2_clusters_to_bytes(inode->i_sb, zero_cpos);\n\t*range_end = ocfs2_clusters_to_bytes(inode->i_sb,\n\t\t\t\t\t     zero_cpos + zero_clusters);\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_zero_extend",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)zero_start",
            "(unsigned long long)i_size_read(inode)"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_align_bytes_to_blocks",
          "args": [
            "sb",
            "i_size_read(inode)"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_align_bytes_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "785-792",
          "snippet": "static inline u64 ocfs2_align_bytes_to_blocks(struct super_block *sb,\n\t\t\t\t\t      u64 bytes)\n{\n\tu64 blocks;\n\n        blocks = ocfs2_blocks_for_bytes(sb, bytes);\n\treturn blocks << sb->s_blocksize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_align_bytes_to_blocks(struct super_block *sb,\n\t\t\t\t\t      u64 bytes)\n{\n\tu64 blocks;\n\n        blocks = ocfs2_blocks_for_bytes(sb, bytes);\n\treturn blocks << sb->s_blocksize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_zero_extend(struct inode *inode, struct buffer_head *di_bh,\n\t\t      loff_t zero_to_size)\n{\n\tint ret = 0;\n\tu64 zero_start, range_start = 0, range_end = 0;\n\tstruct super_block *sb = inode->i_sb;\n\n\tzero_start = ocfs2_align_bytes_to_blocks(sb, i_size_read(inode));\n\ttrace_ocfs2_zero_extend((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t(unsigned long long)zero_start,\n\t\t\t\t(unsigned long long)i_size_read(inode));\n\twhile (zero_start < zero_to_size) {\n\t\tret = ocfs2_zero_extend_get_range(inode, di_bh, zero_start,\n\t\t\t\t\t\t  zero_to_size,\n\t\t\t\t\t\t  &range_start,\n\t\t\t\t\t\t  &range_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t\tif (!range_end)\n\t\t\tbreak;\n\t\t/* Trim the ends */\n\t\tif (range_start < zero_start)\n\t\t\trange_start = zero_start;\n\t\tif (range_end > zero_to_size)\n\t\t\trange_end = zero_to_size;\n\n\t\tret = ocfs2_zero_extend_range(inode, range_start,\n\t\t\t\t\t      range_end, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t\tzero_start = range_end;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_zero_extend_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "944-976",
    "snippet": "static int ocfs2_zero_extend_range(struct inode *inode, u64 range_start,\n\t\t\t\t   u64 range_end, struct buffer_head *di_bh)\n{\n\tint rc = 0;\n\tu64 next_pos;\n\tu64 zero_pos = range_start;\n\n\ttrace_ocfs2_zero_extend_range(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)range_start,\n\t\t\t(unsigned long long)range_end);\n\tBUG_ON(range_start >= range_end);\n\n\twhile (zero_pos < range_end) {\n\t\tnext_pos = (zero_pos & PAGE_CACHE_MASK) + PAGE_CACHE_SIZE;\n\t\tif (next_pos > range_end)\n\t\t\tnext_pos = range_end;\n\t\trc = ocfs2_write_zero_page(inode, zero_pos, next_pos, di_bh);\n\t\tif (rc < 0) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t\tzero_pos = next_pos;\n\n\t\t/*\n\t\t * Very large extends have the potential to lock up\n\t\t * the cpu for extended periods of time.\n\t\t */\n\t\tcond_resched();\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_write_zero_page",
          "args": [
            "inode",
            "zero_pos",
            "next_pos",
            "di_bh"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_zero_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "764-856",
          "snippet": "static int ocfs2_write_zero_page(struct inode *inode, u64 abs_from,\n\t\t\t\t u64 abs_to, struct buffer_head *di_bh)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tunsigned long index = abs_from >> PAGE_CACHE_SHIFT;\n\thandle_t *handle;\n\tint ret = 0;\n\tunsigned zero_from, zero_to, block_start, block_end;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tBUG_ON(abs_from >= abs_to);\n\tBUG_ON(abs_to > (((u64)index + 1) << PAGE_CACHE_SHIFT));\n\tBUG_ON(abs_from & (inode->i_blkbits - 1));\n\n\thandle = ocfs2_zero_start_ordered_transaction(inode, di_bh);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit_trans;\n\t}\n\n\t/* Get the offsets within the page that we want to zero */\n\tzero_from = abs_from & (PAGE_CACHE_SIZE - 1);\n\tzero_to = abs_to & (PAGE_CACHE_SIZE - 1);\n\tif (!zero_to)\n\t\tzero_to = PAGE_CACHE_SIZE;\n\n\ttrace_ocfs2_write_zero_page(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)abs_from,\n\t\t\t(unsigned long long)abs_to,\n\t\t\tindex, zero_from, zero_to);\n\n\t/* We know that zero_from is block aligned */\n\tfor (block_start = zero_from; block_start < zero_to;\n\t     block_start = block_end) {\n\t\tblock_end = block_start + (1 << inode->i_blkbits);\n\n\t\t/*\n\t\t * block_start is block-aligned.  Bump it by one to force\n\t\t * __block_write_begin and block_commit_write to zero the\n\t\t * whole block.\n\t\t */\n\t\tret = __block_write_begin(page, block_start + 1, 0,\n\t\t\t\t\t  ocfs2_get_block);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\n\t\t/* must not update i_size! */\n\t\tret = block_commit_write(page, block_start + 1,\n\t\t\t\t\t block_start + 1);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t\telse\n\t\t\tret = 0;\n\t}\n\n\t/*\n\t * fs-writeback will release the dirty pages without page lock\n\t * whose offset are over inode size, the release happens at\n\t * block_write_full_page().\n\t */\n\ti_size_write(inode, abs_to);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tdi->i_size = cpu_to_le64((u64)i_size_read(inode));\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tdi->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tdi->i_mtime_nsec = di->i_ctime_nsec;\n\tif (handle) {\n\t\tocfs2_journal_dirty(handle, di_bh);\n\t\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\t}\n\nout_unlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout_commit_trans:\n\tif (handle)\n\t\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_write_zero_page(struct inode *inode, u64 abs_from,\n\t\t\t\t u64 abs_to, struct buffer_head *di_bh)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tunsigned long index = abs_from >> PAGE_CACHE_SHIFT;\n\thandle_t *handle;\n\tint ret = 0;\n\tunsigned zero_from, zero_to, block_start, block_end;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tBUG_ON(abs_from >= abs_to);\n\tBUG_ON(abs_to > (((u64)index + 1) << PAGE_CACHE_SHIFT));\n\tBUG_ON(abs_from & (inode->i_blkbits - 1));\n\n\thandle = ocfs2_zero_start_ordered_transaction(inode, di_bh);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit_trans;\n\t}\n\n\t/* Get the offsets within the page that we want to zero */\n\tzero_from = abs_from & (PAGE_CACHE_SIZE - 1);\n\tzero_to = abs_to & (PAGE_CACHE_SIZE - 1);\n\tif (!zero_to)\n\t\tzero_to = PAGE_CACHE_SIZE;\n\n\ttrace_ocfs2_write_zero_page(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)abs_from,\n\t\t\t(unsigned long long)abs_to,\n\t\t\tindex, zero_from, zero_to);\n\n\t/* We know that zero_from is block aligned */\n\tfor (block_start = zero_from; block_start < zero_to;\n\t     block_start = block_end) {\n\t\tblock_end = block_start + (1 << inode->i_blkbits);\n\n\t\t/*\n\t\t * block_start is block-aligned.  Bump it by one to force\n\t\t * __block_write_begin and block_commit_write to zero the\n\t\t * whole block.\n\t\t */\n\t\tret = __block_write_begin(page, block_start + 1, 0,\n\t\t\t\t\t  ocfs2_get_block);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\n\t\t/* must not update i_size! */\n\t\tret = block_commit_write(page, block_start + 1,\n\t\t\t\t\t block_start + 1);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t\telse\n\t\t\tret = 0;\n\t}\n\n\t/*\n\t * fs-writeback will release the dirty pages without page lock\n\t * whose offset are over inode size, the release happens at\n\t * block_write_full_page().\n\t */\n\ti_size_write(inode, abs_to);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tdi->i_size = cpu_to_le64((u64)i_size_read(inode));\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tdi->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tdi->i_mtime_nsec = di->i_ctime_nsec;\n\tif (handle) {\n\t\tocfs2_journal_dirty(handle, di_bh);\n\t\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\t}\n\nout_unlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout_commit_trans:\n\tif (handle)\n\t\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "range_start >= range_end"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_zero_extend_range",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)range_start",
            "(unsigned long long)range_end"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_zero_extend_range(struct inode *inode, u64 range_start,\n\t\t\t\t   u64 range_end, struct buffer_head *di_bh)\n{\n\tint rc = 0;\n\tu64 next_pos;\n\tu64 zero_pos = range_start;\n\n\ttrace_ocfs2_zero_extend_range(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)range_start,\n\t\t\t(unsigned long long)range_end);\n\tBUG_ON(range_start >= range_end);\n\n\twhile (zero_pos < range_end) {\n\t\tnext_pos = (zero_pos & PAGE_CACHE_MASK) + PAGE_CACHE_SIZE;\n\t\tif (next_pos > range_end)\n\t\t\tnext_pos = range_end;\n\t\trc = ocfs2_write_zero_page(inode, zero_pos, next_pos, di_bh);\n\t\tif (rc < 0) {\n\t\t\tmlog_errno(rc);\n\t\t\tbreak;\n\t\t}\n\t\tzero_pos = next_pos;\n\n\t\t/*\n\t\t * Very large extends have the potential to lock up\n\t\t * the cpu for extended periods of time.\n\t\t */\n\t\tcond_resched();\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_zero_extend_get_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "870-938",
    "snippet": "static int ocfs2_zero_extend_get_range(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u64 zero_start, u64 zero_end,\n\t\t\t\t       u64 *range_start, u64 *range_end)\n{\n\tint rc = 0, needs_cow = 0;\n\tu32 p_cpos, zero_clusters = 0;\n\tu32 zero_cpos =\n\t\tzero_start >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 last_cpos = ocfs2_clusters_for_bytes(inode->i_sb, zero_end);\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\n\twhile (zero_cpos < last_cpos) {\n\t\trc = ocfs2_get_clusters(inode, zero_cpos, &p_cpos,\n\t\t\t\t\t&num_clusters, &ext_flags);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (p_cpos && !(ext_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\t\tzero_clusters = num_clusters;\n\t\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\t\tneeds_cow = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tzero_cpos += num_clusters;\n\t}\n\tif (!zero_clusters) {\n\t\t*range_end = 0;\n\t\tgoto out;\n\t}\n\n\twhile ((zero_cpos + zero_clusters) < last_cpos) {\n\t\trc = ocfs2_get_clusters(inode, zero_cpos + zero_clusters,\n\t\t\t\t\t&p_cpos, &num_clusters,\n\t\t\t\t\t&ext_flags);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!p_cpos || (ext_flags & OCFS2_EXT_UNWRITTEN))\n\t\t\tbreak;\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tneeds_cow = 1;\n\t\tzero_clusters += num_clusters;\n\t}\n\tif ((zero_cpos + zero_clusters) > last_cpos)\n\t\tzero_clusters = last_cpos - zero_cpos;\n\n\tif (needs_cow) {\n\t\trc = ocfs2_refcount_cow(inode, di_bh, zero_cpos,\n\t\t\t\t\tzero_clusters, UINT_MAX);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*range_start = ocfs2_clusters_to_bytes(inode->i_sb, zero_cpos);\n\t*range_end = ocfs2_clusters_to_bytes(inode->i_sb,\n\t\t\t\t\t     zero_cpos + zero_clusters);\n\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "inode->i_sb",
            "zero_cpos + zero_clusters"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_cow",
          "args": [
            "inode",
            "di_bh",
            "zero_cpos",
            "zero_clusters",
            "UINT_MAX"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_cow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3504-3537",
          "snippet": "int ocfs2_refcount_cow(struct inode *inode,\n\t\t       struct buffer_head *di_bh,\n\t\t       u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\twhile (write_len) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write_len < num_clusters)\n\t\t\tnum_clusters = write_len;\n\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED) {\n\t\t\tret = ocfs2_refcount_cow_hunk(inode, di_bh, cpos,\n\t\t\t\t\t\t      num_clusters, max_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twrite_len -= num_clusters;\n\t\tcpos += num_clusters;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_refcount_cow(struct inode *inode,\n\t\t       struct buffer_head *di_bh,\n\t\t       u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\twhile (write_len) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write_len < num_clusters)\n\t\t\tnum_clusters = write_len;\n\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED) {\n\t\t\tret = ocfs2_refcount_cow_hunk(inode, di_bh, cpos,\n\t\t\t\t\t\t      num_clusters, max_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twrite_len -= num_clusters;\n\t\tcpos += num_clusters;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters",
          "args": [
            "inode",
            "zero_cpos + zero_clusters",
            "&p_cpos",
            "&num_clusters",
            "&ext_flags"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "608-665",
          "snippet": "int ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "rc"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "inode->i_sb",
            "zero_end"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_zero_extend_get_range(struct inode *inode,\n\t\t\t\t       struct buffer_head *di_bh,\n\t\t\t\t       u64 zero_start, u64 zero_end,\n\t\t\t\t       u64 *range_start, u64 *range_end)\n{\n\tint rc = 0, needs_cow = 0;\n\tu32 p_cpos, zero_clusters = 0;\n\tu32 zero_cpos =\n\t\tzero_start >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tu32 last_cpos = ocfs2_clusters_for_bytes(inode->i_sb, zero_end);\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\n\twhile (zero_cpos < last_cpos) {\n\t\trc = ocfs2_get_clusters(inode, zero_cpos, &p_cpos,\n\t\t\t\t\t&num_clusters, &ext_flags);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (p_cpos && !(ext_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\t\tzero_clusters = num_clusters;\n\t\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\t\tneeds_cow = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tzero_cpos += num_clusters;\n\t}\n\tif (!zero_clusters) {\n\t\t*range_end = 0;\n\t\tgoto out;\n\t}\n\n\twhile ((zero_cpos + zero_clusters) < last_cpos) {\n\t\trc = ocfs2_get_clusters(inode, zero_cpos + zero_clusters,\n\t\t\t\t\t&p_cpos, &num_clusters,\n\t\t\t\t\t&ext_flags);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!p_cpos || (ext_flags & OCFS2_EXT_UNWRITTEN))\n\t\t\tbreak;\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED)\n\t\t\tneeds_cow = 1;\n\t\tzero_clusters += num_clusters;\n\t}\n\tif ((zero_cpos + zero_clusters) > last_cpos)\n\t\tzero_clusters = last_cpos - zero_cpos;\n\n\tif (needs_cow) {\n\t\trc = ocfs2_refcount_cow(inode, di_bh, zero_cpos,\n\t\t\t\t\tzero_clusters, UINT_MAX);\n\t\tif (rc) {\n\t\t\tmlog_errno(rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*range_start = ocfs2_clusters_to_bytes(inode->i_sb, zero_cpos);\n\t*range_end = ocfs2_clusters_to_bytes(inode->i_sb,\n\t\t\t\t\t     zero_cpos + zero_clusters);\n\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_write_zero_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "764-856",
    "snippet": "static int ocfs2_write_zero_page(struct inode *inode, u64 abs_from,\n\t\t\t\t u64 abs_to, struct buffer_head *di_bh)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tunsigned long index = abs_from >> PAGE_CACHE_SHIFT;\n\thandle_t *handle;\n\tint ret = 0;\n\tunsigned zero_from, zero_to, block_start, block_end;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tBUG_ON(abs_from >= abs_to);\n\tBUG_ON(abs_to > (((u64)index + 1) << PAGE_CACHE_SHIFT));\n\tBUG_ON(abs_from & (inode->i_blkbits - 1));\n\n\thandle = ocfs2_zero_start_ordered_transaction(inode, di_bh);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit_trans;\n\t}\n\n\t/* Get the offsets within the page that we want to zero */\n\tzero_from = abs_from & (PAGE_CACHE_SIZE - 1);\n\tzero_to = abs_to & (PAGE_CACHE_SIZE - 1);\n\tif (!zero_to)\n\t\tzero_to = PAGE_CACHE_SIZE;\n\n\ttrace_ocfs2_write_zero_page(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)abs_from,\n\t\t\t(unsigned long long)abs_to,\n\t\t\tindex, zero_from, zero_to);\n\n\t/* We know that zero_from is block aligned */\n\tfor (block_start = zero_from; block_start < zero_to;\n\t     block_start = block_end) {\n\t\tblock_end = block_start + (1 << inode->i_blkbits);\n\n\t\t/*\n\t\t * block_start is block-aligned.  Bump it by one to force\n\t\t * __block_write_begin and block_commit_write to zero the\n\t\t * whole block.\n\t\t */\n\t\tret = __block_write_begin(page, block_start + 1, 0,\n\t\t\t\t\t  ocfs2_get_block);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\n\t\t/* must not update i_size! */\n\t\tret = block_commit_write(page, block_start + 1,\n\t\t\t\t\t block_start + 1);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t\telse\n\t\t\tret = 0;\n\t}\n\n\t/*\n\t * fs-writeback will release the dirty pages without page lock\n\t * whose offset are over inode size, the release happens at\n\t * block_write_full_page().\n\t */\n\ti_size_write(inode, abs_to);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tdi->i_size = cpu_to_le64((u64)i_size_read(inode));\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tdi->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tdi->i_mtime_nsec = di->i_ctime_nsec;\n\tif (handle) {\n\t\tocfs2_journal_dirty(handle, di_bh);\n\t\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\t}\n\nout_unlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout_commit_trans:\n\tif (handle)\n\t\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "handle"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_mtime.tv_nsec"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_mtime.tv_sec"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "(u64)i_size_read(inode)"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "inode"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "abs_to"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_commit_write",
          "args": [
            "page",
            "block_start + 1",
            "block_start + 1"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "block_commit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2376-2381",
          "snippet": "int block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_commit_write(struct page *page, unsigned from, unsigned to)\n{\n\tstruct inode *inode = page->mapping->host;\n\t__block_commit_write(inode,page,from,to);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "block_start + 1",
            "0",
            "ocfs2_get_block"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_write_zero_page",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)abs_from",
            "(unsigned long long)abs_to",
            "index",
            "zero_from",
            "zero_to"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "index",
            "GFP_NOFS"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_start_ordered_transaction",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_start_ordered_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "723-759",
          "snippet": "static handle_t *ocfs2_zero_start_ordered_transaction(struct inode *inode,\n\t\t\t\t\t\tstruct buffer_head *di_bh)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\n\tif (!ocfs2_should_order_data(inode))\n\t\tgoto out;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_jbd2_file_inode(handle, inode);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\nout:\n\tif (ret) {\n\t\tif (!IS_ERR(handle))\n\t\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = ERR_PTR(ret);\n\t}\n\treturn handle;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic handle_t *ocfs2_zero_start_ordered_transaction(struct inode *inode,\n\t\t\t\t\t\tstruct buffer_head *di_bh)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\n\tif (!ocfs2_should_order_data(inode))\n\t\tgoto out;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_jbd2_file_inode(handle, inode);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\nout:\n\tif (ret) {\n\t\tif (!IS_ERR(handle))\n\t\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = ERR_PTR(ret);\n\t}\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "abs_from & (inode->i_blkbits - 1)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "abs_to > (((u64)index + 1) << PAGE_CACHE_SHIFT)"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "abs_from >= abs_to"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_write_zero_page(struct inode *inode, u64 abs_from,\n\t\t\t\t u64 abs_to, struct buffer_head *di_bh)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page;\n\tunsigned long index = abs_from >> PAGE_CACHE_SHIFT;\n\thandle_t *handle;\n\tint ret = 0;\n\tunsigned zero_from, zero_to, block_start, block_end;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tBUG_ON(abs_from >= abs_to);\n\tBUG_ON(abs_to > (((u64)index + 1) << PAGE_CACHE_SHIFT));\n\tBUG_ON(abs_from & (inode->i_blkbits - 1));\n\n\thandle = ocfs2_zero_start_ordered_transaction(inode, di_bh);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\n\tpage = find_or_create_page(mapping, index, GFP_NOFS);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit_trans;\n\t}\n\n\t/* Get the offsets within the page that we want to zero */\n\tzero_from = abs_from & (PAGE_CACHE_SIZE - 1);\n\tzero_to = abs_to & (PAGE_CACHE_SIZE - 1);\n\tif (!zero_to)\n\t\tzero_to = PAGE_CACHE_SIZE;\n\n\ttrace_ocfs2_write_zero_page(\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t(unsigned long long)abs_from,\n\t\t\t(unsigned long long)abs_to,\n\t\t\tindex, zero_from, zero_to);\n\n\t/* We know that zero_from is block aligned */\n\tfor (block_start = zero_from; block_start < zero_to;\n\t     block_start = block_end) {\n\t\tblock_end = block_start + (1 << inode->i_blkbits);\n\n\t\t/*\n\t\t * block_start is block-aligned.  Bump it by one to force\n\t\t * __block_write_begin and block_commit_write to zero the\n\t\t * whole block.\n\t\t */\n\t\tret = __block_write_begin(page, block_start + 1, 0,\n\t\t\t\t\t  ocfs2_get_block);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\n\t\t/* must not update i_size! */\n\t\tret = block_commit_write(page, block_start + 1,\n\t\t\t\t\t block_start + 1);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t\telse\n\t\t\tret = 0;\n\t}\n\n\t/*\n\t * fs-writeback will release the dirty pages without page lock\n\t * whose offset are over inode size, the release happens at\n\t * block_write_full_page().\n\t */\n\ti_size_write(inode, abs_to);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tdi->i_size = cpu_to_le64((u64)i_size_read(inode));\n\tinode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tdi->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\tdi->i_mtime_nsec = di->i_ctime_nsec;\n\tif (handle) {\n\t\tocfs2_journal_dirty(handle, di_bh);\n\t\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\t}\n\nout_unlock:\n\tunlock_page(page);\n\tpage_cache_release(page);\nout_commit_trans:\n\tif (handle)\n\t\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_zero_start_ordered_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "723-759",
    "snippet": "static handle_t *ocfs2_zero_start_ordered_transaction(struct inode *inode,\n\t\t\t\t\t\tstruct buffer_head *di_bh)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\n\tif (!ocfs2_should_order_data(inode))\n\t\tgoto out;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_jbd2_file_inode(handle, inode);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\nout:\n\tif (ret) {\n\t\tif (!IS_ERR(handle))\n\t\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = ERR_PTR(ret);\n\t}\n\treturn handle;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_jbd2_file_inode",
          "args": [
            "handle",
            "inode"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_jbd2_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "620-623",
          "snippet": "static inline int ocfs2_jbd2_file_inode(handle_t *handle, struct inode *inode)\n{\n\treturn jbd2_journal_file_inode(handle, &OCFS2_I(inode)->ip_jinode);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ocfs2_jbd2_file_inode(handle_t *handle, struct inode *inode)\n{\n\treturn jbd2_journal_file_inode(handle, &OCFS2_I(inode)->ip_jinode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_should_order_data",
          "args": [
            "inode"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_should_order_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "474-481",
          "snippet": "static inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic handle_t *ocfs2_zero_start_ordered_transaction(struct inode *inode,\n\t\t\t\t\t\tstruct buffer_head *di_bh)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\n\tif (!ocfs2_should_order_data(inode))\n\t\tgoto out;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_jbd2_file_inode(handle, inode);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret)\n\t\tmlog_errno(ret);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\nout:\n\tif (ret) {\n\t\tif (!IS_ERR(handle))\n\t\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = ERR_PTR(ret);\n\t}\n\treturn handle;\n}"
  },
  {
    "function_name": "ocfs2_extend_allocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "712-717",
    "snippet": "int ocfs2_extend_allocation(struct inode *inode, u32 logical_start,\n\t\tu32 clusters_to_add, int mark_unwritten)\n{\n\treturn __ocfs2_extend_allocation(inode, logical_start,\n\t\t\tclusters_to_add, mark_unwritten);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_extend_allocation",
          "args": [
            "inode",
            "logical_start",
            "clusters_to_add",
            "mark_unwritten"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_extend_allocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "560-710",
          "snippet": "static int __ocfs2_extend_allocation(struct inode *inode, u32 logical_start,\n\t\t\t\t     u32 clusters_to_add, int mark_unwritten)\n{\n\tint status = 0;\n\tint restart_func = 0;\n\tint credits;\n\tu32 prev_clusters;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tenum ocfs2_alloc_restarted why = RESTART_NONE;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\t/*\n\t * Unwritten extent only exists for file systems which\n\t * support holes.\n\t */\n\tBUG_ON(mark_unwritten && !ocfs2_sparse_alloc(osb));\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\nrestart_all:\n\tBUG_ON(le32_to_cpu(fe->i_clusters) != OCFS2_I(inode)->ip_clusters);\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), bh);\n\tstatus = ocfs2_lock_allocators(inode, &et, clusters_to_add, 0,\n\t\t\t\t       &data_ac, &meta_ac);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tcredits = ocfs2_calc_extend_credits(osb->sb, &fe->id2.i_list);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\nrestarted_transaction:\n\ttrace_ocfs2_extend_allocation(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)i_size_read(inode),\n\t\tle32_to_cpu(fe->i_clusters), clusters_to_add,\n\t\twhy, restart_func);\n\n\tstatus = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (status)\n\t\tgoto leave;\n\tdid_quota = 1;\n\n\t/* reserve a write to the file entry early on - that we if we\n\t * run out of credits in the allocation path, we can still\n\t * update i_size. */\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tprev_clusters = OCFS2_I(inode)->ip_clusters;\n\n\tstatus = ocfs2_add_inode_data(osb,\n\t\t\t\t      inode,\n\t\t\t\t      &logical_start,\n\t\t\t\t      clusters_to_add,\n\t\t\t\t      mark_unwritten,\n\t\t\t\t      bh,\n\t\t\t\t      handle,\n\t\t\t\t      data_ac,\n\t\t\t\t      meta_ac,\n\t\t\t\t      &why);\n\tif ((status < 0) && (status != -EAGAIN)) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, bh);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tclusters_to_add -= (OCFS2_I(inode)->ip_clusters - prev_clusters);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t/* Release unused quota reservation */\n\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tdid_quota = 0;\n\n\tif (why != RESTART_NONE && clusters_to_add) {\n\t\tif (why == RESTART_META) {\n\t\t\trestart_func = 1;\n\t\t\tstatus = 0;\n\t\t} else {\n\t\t\tBUG_ON(why != RESTART_TRANS);\n\n\t\t\tstatus = ocfs2_allocate_extend_trans(handle, 1);\n\t\t\tif (status < 0) {\n\t\t\t\t/* handle still has to be committed at\n\t\t\t\t * this point. */\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tgoto restarted_transaction;\n\t\t}\n\t}\n\n\ttrace_ocfs2_extend_allocation_end(OCFS2_I(inode)->ip_blkno,\n\t     le32_to_cpu(fe->i_clusters),\n\t     (unsigned long long)le64_to_cpu(fe->i_size),\n\t     OCFS2_I(inode)->ip_clusters,\n\t     (unsigned long long)i_size_read(inode));\n\nleave:\n\tif (status < 0 && did_quota)\n\t\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (handle) {\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\t}\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\tif ((!status) && restart_func) {\n\t\trestart_func = 0;\n\t\tgoto restart_all;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __ocfs2_extend_allocation(struct inode *inode, u32 logical_start,\n\t\t\t\t     u32 clusters_to_add, int mark_unwritten)\n{\n\tint status = 0;\n\tint restart_func = 0;\n\tint credits;\n\tu32 prev_clusters;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tenum ocfs2_alloc_restarted why = RESTART_NONE;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\t/*\n\t * Unwritten extent only exists for file systems which\n\t * support holes.\n\t */\n\tBUG_ON(mark_unwritten && !ocfs2_sparse_alloc(osb));\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\nrestart_all:\n\tBUG_ON(le32_to_cpu(fe->i_clusters) != OCFS2_I(inode)->ip_clusters);\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), bh);\n\tstatus = ocfs2_lock_allocators(inode, &et, clusters_to_add, 0,\n\t\t\t\t       &data_ac, &meta_ac);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tcredits = ocfs2_calc_extend_credits(osb->sb, &fe->id2.i_list);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\nrestarted_transaction:\n\ttrace_ocfs2_extend_allocation(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)i_size_read(inode),\n\t\tle32_to_cpu(fe->i_clusters), clusters_to_add,\n\t\twhy, restart_func);\n\n\tstatus = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (status)\n\t\tgoto leave;\n\tdid_quota = 1;\n\n\t/* reserve a write to the file entry early on - that we if we\n\t * run out of credits in the allocation path, we can still\n\t * update i_size. */\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tprev_clusters = OCFS2_I(inode)->ip_clusters;\n\n\tstatus = ocfs2_add_inode_data(osb,\n\t\t\t\t      inode,\n\t\t\t\t      &logical_start,\n\t\t\t\t      clusters_to_add,\n\t\t\t\t      mark_unwritten,\n\t\t\t\t      bh,\n\t\t\t\t      handle,\n\t\t\t\t      data_ac,\n\t\t\t\t      meta_ac,\n\t\t\t\t      &why);\n\tif ((status < 0) && (status != -EAGAIN)) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, bh);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tclusters_to_add -= (OCFS2_I(inode)->ip_clusters - prev_clusters);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t/* Release unused quota reservation */\n\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tdid_quota = 0;\n\n\tif (why != RESTART_NONE && clusters_to_add) {\n\t\tif (why == RESTART_META) {\n\t\t\trestart_func = 1;\n\t\t\tstatus = 0;\n\t\t} else {\n\t\t\tBUG_ON(why != RESTART_TRANS);\n\n\t\t\tstatus = ocfs2_allocate_extend_trans(handle, 1);\n\t\t\tif (status < 0) {\n\t\t\t\t/* handle still has to be committed at\n\t\t\t\t * this point. */\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tgoto restarted_transaction;\n\t\t}\n\t}\n\n\ttrace_ocfs2_extend_allocation_end(OCFS2_I(inode)->ip_blkno,\n\t     le32_to_cpu(fe->i_clusters),\n\t     (unsigned long long)le64_to_cpu(fe->i_size),\n\t     OCFS2_I(inode)->ip_clusters,\n\t     (unsigned long long)i_size_read(inode));\n\nleave:\n\tif (status < 0 && did_quota)\n\t\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (handle) {\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\t}\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\tif ((!status) && restart_func) {\n\t\trestart_func = 0;\n\t\tgoto restart_all;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_extend_allocation(struct inode *inode, u32 logical_start,\n\t\tu32 clusters_to_add, int mark_unwritten)\n{\n\treturn __ocfs2_extend_allocation(inode, logical_start,\n\t\t\tclusters_to_add, mark_unwritten);\n}"
  },
  {
    "function_name": "__ocfs2_extend_allocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "560-710",
    "snippet": "static int __ocfs2_extend_allocation(struct inode *inode, u32 logical_start,\n\t\t\t\t     u32 clusters_to_add, int mark_unwritten)\n{\n\tint status = 0;\n\tint restart_func = 0;\n\tint credits;\n\tu32 prev_clusters;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tenum ocfs2_alloc_restarted why = RESTART_NONE;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\t/*\n\t * Unwritten extent only exists for file systems which\n\t * support holes.\n\t */\n\tBUG_ON(mark_unwritten && !ocfs2_sparse_alloc(osb));\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\nrestart_all:\n\tBUG_ON(le32_to_cpu(fe->i_clusters) != OCFS2_I(inode)->ip_clusters);\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), bh);\n\tstatus = ocfs2_lock_allocators(inode, &et, clusters_to_add, 0,\n\t\t\t\t       &data_ac, &meta_ac);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tcredits = ocfs2_calc_extend_credits(osb->sb, &fe->id2.i_list);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\nrestarted_transaction:\n\ttrace_ocfs2_extend_allocation(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)i_size_read(inode),\n\t\tle32_to_cpu(fe->i_clusters), clusters_to_add,\n\t\twhy, restart_func);\n\n\tstatus = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (status)\n\t\tgoto leave;\n\tdid_quota = 1;\n\n\t/* reserve a write to the file entry early on - that we if we\n\t * run out of credits in the allocation path, we can still\n\t * update i_size. */\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tprev_clusters = OCFS2_I(inode)->ip_clusters;\n\n\tstatus = ocfs2_add_inode_data(osb,\n\t\t\t\t      inode,\n\t\t\t\t      &logical_start,\n\t\t\t\t      clusters_to_add,\n\t\t\t\t      mark_unwritten,\n\t\t\t\t      bh,\n\t\t\t\t      handle,\n\t\t\t\t      data_ac,\n\t\t\t\t      meta_ac,\n\t\t\t\t      &why);\n\tif ((status < 0) && (status != -EAGAIN)) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, bh);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tclusters_to_add -= (OCFS2_I(inode)->ip_clusters - prev_clusters);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t/* Release unused quota reservation */\n\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tdid_quota = 0;\n\n\tif (why != RESTART_NONE && clusters_to_add) {\n\t\tif (why == RESTART_META) {\n\t\t\trestart_func = 1;\n\t\t\tstatus = 0;\n\t\t} else {\n\t\t\tBUG_ON(why != RESTART_TRANS);\n\n\t\t\tstatus = ocfs2_allocate_extend_trans(handle, 1);\n\t\t\tif (status < 0) {\n\t\t\t\t/* handle still has to be committed at\n\t\t\t\t * this point. */\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tgoto restarted_transaction;\n\t\t}\n\t}\n\n\ttrace_ocfs2_extend_allocation_end(OCFS2_I(inode)->ip_blkno,\n\t     le32_to_cpu(fe->i_clusters),\n\t     (unsigned long long)le64_to_cpu(fe->i_size),\n\t     OCFS2_I(inode)->ip_clusters,\n\t     (unsigned long long)i_size_read(inode));\n\nleave:\n\tif (status < 0 && did_quota)\n\t\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (handle) {\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\t}\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\tif ((!status) && restart_func) {\n\t\trestart_func = 0;\n\t\tgoto restart_all;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "meta_ac"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_space",
          "args": [
            "inode",
            "ocfs2_clusters_to_bytes(osb->sb, clusters_to_add)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_bytes",
          "args": [
            "osb->sb",
            "clusters_to_add"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "759-763",
          "snippet": "static inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_bytes(struct super_block *sb,\n\t\t\t\t\t  u32 clusters)\n{\n\treturn (u64)clusters << OCFS2_SB(sb)->s_clustersize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_extend_allocation_end",
          "args": [
            "OCFS2_I(inode)->ip_blkno",
            "le32_to_cpu(fe->i_clusters)",
            "(unsigned long long)le64_to_cpu(fe->i_size)",
            "OCFS2_I(inode)->ip_clusters",
            "(unsigned long long)i_size_read(inode)"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_size"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->i_clusters"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_allocate_extend_trans",
          "args": [
            "handle",
            "1"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_allocate_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "471-497",
          "snippet": "int ocfs2_allocate_extend_trans(handle_t *handle, int thresh)\n{\n\tint status, old_nblks;\n\n\tBUG_ON(!handle);\n\n\told_nblks = handle->h_buffer_credits;\n\ttrace_ocfs2_allocate_extend_trans(old_nblks, thresh);\n\n\tif (old_nblks < thresh)\n\t\treturn 0;\n\n\tstatus = jbd2_journal_extend(handle, OCFS2_MAX_TRANS_DATA);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (status > 0) {\n\t\tstatus = jbd2_journal_restart(handle, OCFS2_MAX_TRANS_DATA);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_allocate_extend_trans(handle_t *handle, int thresh)\n{\n\tint status, old_nblks;\n\n\tBUG_ON(!handle);\n\n\told_nblks = handle->h_buffer_credits;\n\ttrace_ocfs2_allocate_extend_trans(old_nblks, thresh);\n\n\tif (old_nblks < thresh)\n\t\treturn 0;\n\n\tstatus = jbd2_journal_extend(handle, OCFS2_MAX_TRANS_DATA);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (status > 0) {\n\t\tstatus = jbd2_journal_restart(handle, OCFS2_MAX_TRANS_DATA);\n\t\tif (status < 0)\n\t\t\tmlog_errno(status);\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "why != RESTART_TRANS"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_space",
          "args": [
            "inode",
            "ocfs2_clusters_to_bytes(osb->sb, clusters_to_add)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(inode)->ip_lock"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(inode)->ip_lock"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "1"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_inode_data",
          "args": [
            "osb",
            "inode",
            "&logical_start",
            "clusters_to_add",
            "mark_unwritten",
            "bh",
            "handle",
            "data_ac",
            "meta_ac",
            "&why"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_inode_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "538-558",
          "snippet": "int ocfs2_add_inode_data(struct ocfs2_super *osb,\n\t\t\t struct inode *inode,\n\t\t\t u32 *logical_offset,\n\t\t\t u32 clusters_to_add,\n\t\t\t int mark_unwritten,\n\t\t\t struct buffer_head *fe_bh,\n\t\t\t handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t enum ocfs2_alloc_restarted *reason_ret)\n{\n\tint ret;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), fe_bh);\n\tret = ocfs2_add_clusters_in_btree(handle, &et, logical_offset,\n\t\t\t\t\t  clusters_to_add, mark_unwritten,\n\t\t\t\t\t  data_ac, meta_ac, reason_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_add_inode_data(struct ocfs2_super *osb,\n\t\t\t struct inode *inode,\n\t\t\t u32 *logical_offset,\n\t\t\t u32 clusters_to_add,\n\t\t\t int mark_unwritten,\n\t\t\t struct buffer_head *fe_bh,\n\t\t\t handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t enum ocfs2_alloc_restarted *reason_ret)\n{\n\tint ret;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), fe_bh);\n\tret = ocfs2_add_clusters_in_btree(handle, &et, logical_offset,\n\t\t\t\t\t  clusters_to_add, mark_unwritten,\n\t\t\t\t\t  data_ac, meta_ac, reason_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_alloc_space_nodirty",
          "args": [
            "inode",
            "ocfs2_clusters_to_bytes(osb->sb, clusters_to_add)"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_extend_allocation",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)i_size_read(inode)",
            "le32_to_cpu(fe->i_clusters)",
            "clusters_to_add",
            "why",
            "restart_func"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_extend_credits",
          "args": [
            "osb->sb",
            "&fe->id2.i_list"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_extend_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "531-556",
          "snippet": "static inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_allocators",
          "args": [
            "inode",
            "&et",
            "clusters_to_add",
            "0",
            "&data_ac",
            "&meta_ac"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_allocators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2674-2743",
          "snippet": "int ocfs2_lock_allocators(struct inode *inode,\n\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t  u32 clusters_to_add, u32 extents_to_split,\n\t\t\t  struct ocfs2_alloc_context **data_ac,\n\t\t\t  struct ocfs2_alloc_context **meta_ac)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = clusters_to_add + 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*meta_ac = NULL;\n\tif (data_ac)\n\t\t*data_ac = NULL;\n\n\tBUG_ON(clusters_to_add != 0 && data_ac == NULL);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Sparse allocation file systems need to be more conservative\n\t * with reserving room for expansion - the actual allocation\n\t * happens while we've got a journal handle open so re-taking\n\t * a cluster lock (because we ran out of room for another\n\t * extent) will violate ordering rules.\n\t *\n\t * Most of the time we'll only be seeing this 1 cluster at a time\n\t * anyway.\n\t *\n\t * Always lock for any unwritten extents - we might want to\n\t * add blocks during a split.\n\t */\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed)) {\n\t\tret = ocfs2_reserve_new_metadata(osb, et->et_root_el, meta_ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_to_add == 0)\n\t\tgoto out;\n\n\tret = ocfs2_reserve_clusters(osb, clusters_to_add, data_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\n\t\t/*\n\t\t * We cannot have an error and a non null *data_ac.\n\t\t */\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_lock_allocators(struct inode *inode,\n\t\t\t  struct ocfs2_extent_tree *et,\n\t\t\t  u32 clusters_to_add, u32 extents_to_split,\n\t\t\t  struct ocfs2_alloc_context **data_ac,\n\t\t\t  struct ocfs2_alloc_context **meta_ac)\n{\n\tint ret = 0, num_free_extents;\n\tunsigned int max_recs_needed = clusters_to_add + 2 * extents_to_split;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t*meta_ac = NULL;\n\tif (data_ac)\n\t\t*data_ac = NULL;\n\n\tBUG_ON(clusters_to_add != 0 && data_ac == NULL);\n\n\tnum_free_extents = ocfs2_num_free_extents(osb, et);\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Sparse allocation file systems need to be more conservative\n\t * with reserving room for expansion - the actual allocation\n\t * happens while we've got a journal handle open so re-taking\n\t * a cluster lock (because we ran out of room for another\n\t * extent) will violate ordering rules.\n\t *\n\t * Most of the time we'll only be seeing this 1 cluster at a time\n\t * anyway.\n\t *\n\t * Always lock for any unwritten extents - we might want to\n\t * add blocks during a split.\n\t */\n\tif (!num_free_extents ||\n\t    (ocfs2_sparse_alloc(osb) && num_free_extents < max_recs_needed)) {\n\t\tret = ocfs2_reserve_new_metadata(osb, et->et_root_el, meta_ac);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -ENOSPC)\n\t\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (clusters_to_add == 0)\n\t\tgoto out;\n\n\tret = ocfs2_reserve_clusters(osb, clusters_to_add, data_ac);\n\tif (ret < 0) {\n\t\tif (ret != -ENOSPC)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\n\t\t/*\n\t\t * We cannot have an error and a non null *data_ac.\n\t\t */\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "bh"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "458-464",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le32_to_cpu(fe->i_clusters) != OCFS2_I(inode)->ip_clusters"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "&bh"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mark_unwritten && !ocfs2_sparse_alloc(osb)"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_sparse_alloc",
          "args": [
            "osb"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_sparse_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "483-488",
          "snippet": "static inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_sparse_alloc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_SPARSE_ALLOC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int __ocfs2_extend_allocation(struct inode *inode, u32 logical_start,\n\t\t\t\t     u32 clusters_to_add, int mark_unwritten)\n{\n\tint status = 0;\n\tint restart_func = 0;\n\tint credits;\n\tu32 prev_clusters;\n\tstruct buffer_head *bh = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *data_ac = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tenum ocfs2_alloc_restarted why = RESTART_NONE;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_extent_tree et;\n\tint did_quota = 0;\n\n\t/*\n\t * Unwritten extent only exists for file systems which\n\t * support holes.\n\t */\n\tBUG_ON(mark_unwritten && !ocfs2_sparse_alloc(osb));\n\n\tstatus = ocfs2_read_inode_block(inode, &bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tfe = (struct ocfs2_dinode *) bh->b_data;\n\nrestart_all:\n\tBUG_ON(le32_to_cpu(fe->i_clusters) != OCFS2_I(inode)->ip_clusters);\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), bh);\n\tstatus = ocfs2_lock_allocators(inode, &et, clusters_to_add, 0,\n\t\t\t\t       &data_ac, &meta_ac);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tcredits = ocfs2_calc_extend_credits(osb->sb, &fe->id2.i_list);\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\nrestarted_transaction:\n\ttrace_ocfs2_extend_allocation(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t(unsigned long long)i_size_read(inode),\n\t\tle32_to_cpu(fe->i_clusters), clusters_to_add,\n\t\twhy, restart_func);\n\n\tstatus = dquot_alloc_space_nodirty(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (status)\n\t\tgoto leave;\n\tdid_quota = 1;\n\n\t/* reserve a write to the file entry early on - that we if we\n\t * run out of credits in the allocation path, we can still\n\t * update i_size. */\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tprev_clusters = OCFS2_I(inode)->ip_clusters;\n\n\tstatus = ocfs2_add_inode_data(osb,\n\t\t\t\t      inode,\n\t\t\t\t      &logical_start,\n\t\t\t\t      clusters_to_add,\n\t\t\t\t      mark_unwritten,\n\t\t\t\t      bh,\n\t\t\t\t      handle,\n\t\t\t\t      data_ac,\n\t\t\t\t      meta_ac,\n\t\t\t\t      &why);\n\tif ((status < 0) && (status != -EAGAIN)) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, bh);\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tclusters_to_add -= (OCFS2_I(inode)->ip_clusters - prev_clusters);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\t/* Release unused quota reservation */\n\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tdid_quota = 0;\n\n\tif (why != RESTART_NONE && clusters_to_add) {\n\t\tif (why == RESTART_META) {\n\t\t\trestart_func = 1;\n\t\t\tstatus = 0;\n\t\t} else {\n\t\t\tBUG_ON(why != RESTART_TRANS);\n\n\t\t\tstatus = ocfs2_allocate_extend_trans(handle, 1);\n\t\t\tif (status < 0) {\n\t\t\t\t/* handle still has to be committed at\n\t\t\t\t * this point. */\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t\tgoto restarted_transaction;\n\t\t}\n\t}\n\n\ttrace_ocfs2_extend_allocation_end(OCFS2_I(inode)->ip_blkno,\n\t     le32_to_cpu(fe->i_clusters),\n\t     (unsigned long long)le64_to_cpu(fe->i_size),\n\t     OCFS2_I(inode)->ip_clusters,\n\t     (unsigned long long)i_size_read(inode));\n\nleave:\n\tif (status < 0 && did_quota)\n\t\tdquot_free_space(inode,\n\t\t\tocfs2_clusters_to_bytes(osb->sb, clusters_to_add));\n\tif (handle) {\n\t\tocfs2_commit_trans(osb, handle);\n\t\thandle = NULL;\n\t}\n\tif (data_ac) {\n\t\tocfs2_free_alloc_context(data_ac);\n\t\tdata_ac = NULL;\n\t}\n\tif (meta_ac) {\n\t\tocfs2_free_alloc_context(meta_ac);\n\t\tmeta_ac = NULL;\n\t}\n\tif ((!status) && restart_func) {\n\t\trestart_func = 0;\n\t\tgoto restart_all;\n\t}\n\tbrelse(bh);\n\tbh = NULL;\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_add_inode_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "538-558",
    "snippet": "int ocfs2_add_inode_data(struct ocfs2_super *osb,\n\t\t\t struct inode *inode,\n\t\t\t u32 *logical_offset,\n\t\t\t u32 clusters_to_add,\n\t\t\t int mark_unwritten,\n\t\t\t struct buffer_head *fe_bh,\n\t\t\t handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t enum ocfs2_alloc_restarted *reason_ret)\n{\n\tint ret;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), fe_bh);\n\tret = ocfs2_add_clusters_in_btree(handle, &et, logical_offset,\n\t\t\t\t\t  clusters_to_add, mark_unwritten,\n\t\t\t\t\t  data_ac, meta_ac, reason_ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_add_clusters_in_btree",
          "args": [
            "handle",
            "&et",
            "logical_offset",
            "clusters_to_add",
            "mark_unwritten",
            "data_ac",
            "meta_ac",
            "reason_ret"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_clusters_in_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4735-4845",
          "snippet": "int ocfs2_add_clusters_in_btree(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tu32 *logical_offset,\n\t\t\t\tu32 clusters_to_add,\n\t\t\t\tint mark_unwritten,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tenum ocfs2_alloc_restarted *reason_ret)\n{\n\tint status = 0, err = 0;\n\tint need_free = 0;\n\tint free_extents;\n\tenum ocfs2_alloc_restarted reason = RESTART_NONE;\n\tu32 bit_off, num_bits;\n\tu64 block;\n\tu8 flags = 0;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\tBUG_ON(!clusters_to_add);\n\n\tif (mark_unwritten)\n\t\tflags = OCFS2_EXT_UNWRITTEN;\n\n\tfree_extents = ocfs2_num_free_extents(osb, et);\n\tif (free_extents < 0) {\n\t\tstatus = free_extents;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* there are two cases which could cause us to EAGAIN in the\n\t * we-need-more-metadata case:\n\t * 1) we haven't reserved *any*\n\t * 2) we are so fragmented, we've needed to add metadata too\n\t *    many times. */\n\tif (!free_extents && !meta_ac) {\n\t\terr = -1;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t} else if ((!free_extents)\n\t\t   && (ocfs2_alloc_context_bits_left(meta_ac)\n\t\t       < ocfs2_extend_meta_needed(et->et_root_el))) {\n\t\terr = -2;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t}\n\n\tstatus = __ocfs2_claim_clusters(handle, data_ac, 1,\n\t\t\t\t\tclusters_to_add, &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\t/* reserve our write early -- insert_extent may update the tree root */\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_clusters_in_btree(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t     bit_off, num_bits);\n\tstatus = ocfs2_insert_extent(handle, et, *logical_offset, block,\n\t\t\t\t     num_bits, flags, meta_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tclusters_to_add -= num_bits;\n\t*logical_offset += num_bits;\n\n\tif (clusters_to_add) {\n\t\terr = clusters_to_add;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_TRANS;\n\t}\n\nbail:\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num_bits);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum_bits);\n\t}\n\nleave:\n\tif (reason_ret)\n\t\t*reason_ret = reason;\n\ttrace_ocfs2_add_clusters_in_btree_ret(status, reason, err);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_add_clusters_in_btree(handle_t *handle,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\tu32 *logical_offset,\n\t\t\t\tu32 clusters_to_add,\n\t\t\t\tint mark_unwritten,\n\t\t\t\tstruct ocfs2_alloc_context *data_ac,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tenum ocfs2_alloc_restarted *reason_ret)\n{\n\tint status = 0, err = 0;\n\tint need_free = 0;\n\tint free_extents;\n\tenum ocfs2_alloc_restarted reason = RESTART_NONE;\n\tu32 bit_off, num_bits;\n\tu64 block;\n\tu8 flags = 0;\n\tstruct ocfs2_super *osb =\n\t\tOCFS2_SB(ocfs2_metadata_cache_get_super(et->et_ci));\n\n\tBUG_ON(!clusters_to_add);\n\n\tif (mark_unwritten)\n\t\tflags = OCFS2_EXT_UNWRITTEN;\n\n\tfree_extents = ocfs2_num_free_extents(osb, et);\n\tif (free_extents < 0) {\n\t\tstatus = free_extents;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* there are two cases which could cause us to EAGAIN in the\n\t * we-need-more-metadata case:\n\t * 1) we haven't reserved *any*\n\t * 2) we are so fragmented, we've needed to add metadata too\n\t *    many times. */\n\tif (!free_extents && !meta_ac) {\n\t\terr = -1;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t} else if ((!free_extents)\n\t\t   && (ocfs2_alloc_context_bits_left(meta_ac)\n\t\t       < ocfs2_extend_meta_needed(et->et_root_el))) {\n\t\terr = -2;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_META;\n\t\tgoto leave;\n\t}\n\n\tstatus = __ocfs2_claim_clusters(handle, data_ac, 1,\n\t\t\t\t\tclusters_to_add, &bit_off, &num_bits);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tBUG_ON(num_bits > clusters_to_add);\n\n\t/* reserve our write early -- insert_extent may update the tree root */\n\tstatus = ocfs2_et_root_journal_access(handle, et,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tblock = ocfs2_clusters_to_blocks(osb->sb, bit_off);\n\ttrace_ocfs2_add_clusters_in_btree(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t     bit_off, num_bits);\n\tstatus = ocfs2_insert_extent(handle, et, *logical_offset, block,\n\t\t\t\t     num_bits, flags, meta_ac);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tneed_free = 1;\n\t\tgoto bail;\n\t}\n\n\tocfs2_journal_dirty(handle, et->et_root_bh);\n\n\tclusters_to_add -= num_bits;\n\t*logical_offset += num_bits;\n\n\tif (clusters_to_add) {\n\t\terr = clusters_to_add;\n\t\tstatus = -EAGAIN;\n\t\treason = RESTART_TRANS;\n\t}\n\nbail:\n\tif (need_free) {\n\t\tif (data_ac->ac_which == OCFS2_AC_USE_LOCAL)\n\t\t\tocfs2_free_local_alloc_bits(osb, handle, data_ac,\n\t\t\t\t\tbit_off, num_bits);\n\t\telse\n\t\t\tocfs2_free_clusters(handle,\n\t\t\t\t\tdata_ac->ac_inode,\n\t\t\t\t\tdata_ac->ac_bh,\n\t\t\t\t\tocfs2_clusters_to_blocks(osb->sb, bit_off),\n\t\t\t\t\tnum_bits);\n\t}\n\nleave:\n\tif (reason_ret)\n\t\t*reason_ret = reason;\n\ttrace_ocfs2_add_clusters_in_btree_ret(status, reason, err);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(inode)",
            "fe_bh"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "458-464",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_add_inode_data(struct ocfs2_super *osb,\n\t\t\t struct inode *inode,\n\t\t\t u32 *logical_offset,\n\t\t\t u32 clusters_to_add,\n\t\t\t int mark_unwritten,\n\t\t\t struct buffer_head *fe_bh,\n\t\t\t handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *data_ac,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t enum ocfs2_alloc_restarted *reason_ret)\n{\n\tint ret;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), fe_bh);\n\tret = ocfs2_add_clusters_in_btree(handle, &et, logical_offset,\n\t\t\t\t\t  clusters_to_add, mark_unwritten,\n\t\t\t\t\t  data_ac, meta_ac, reason_ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_truncate_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "444-526",
    "snippet": "int ocfs2_truncate_file(struct inode *inode,\n\t\t\t       struct buffer_head *di_bh,\n\t\t\t       u64 new_i_size)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/* We trust di_bh because it comes from ocfs2_inode_lock(), which\n\t * already validated it */\n\tfe = (struct ocfs2_dinode *) di_bh->b_data;\n\n\ttrace_ocfs2_truncate_file((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t  (unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t\t  (unsigned long long)new_i_size);\n\n\tmlog_bug_on_msg(le64_to_cpu(fe->i_size) != i_size_read(inode),\n\t\t\t\"Inode %llu, inode i_size = %lld != di \"\n\t\t\t\"i_size = %llu, i_flags = 0x%x\\n\",\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\ti_size_read(inode),\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\tle32_to_cpu(fe->i_flags));\n\n\tif (new_i_size > le64_to_cpu(fe->i_size)) {\n\t\ttrace_ocfs2_truncate_file_error(\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t(unsigned long long)new_i_size);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_resv_discard(&osb->osb_la_resmap,\n\t\t\t   &OCFS2_I(inode)->ip_la_data_resv);\n\n\t/*\n\t * The inode lock forced other nodes to sync and drop their\n\t * pages, which (correctly) happens even if we have a truncate\n\t * without allocation change - ocfs2 cluster sizes can be much\n\t * greater than page size, so we have to truncate them\n\t * anyway.\n\t */\n\tunmap_mapping_range(inode->i_mapping, new_i_size + PAGE_SIZE - 1, 0, 1);\n\ttruncate_inode_pages(inode->i_mapping, new_i_size);\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstatus = ocfs2_truncate_inline(inode, di_bh, new_i_size,\n\t\t\t\t\t       i_size_read(inode), 1);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* alright, we're going to need to do a full blown alloc size\n\t * change. Orphan the inode so that recovery can complete the\n\t * truncate if necessary. This does the task of marking\n\t * i_size. */\n\tstatus = ocfs2_orphan_for_truncate(osb, inode, di_bh, new_i_size);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\tstatus = ocfs2_commit_truncate(osb, inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* TODO: orphan dir cleanup here. */\nbail_unlock_sem:\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\nbail:\n\tif (!status && OCFS2_I(inode)->ip_clusters == 0)\n\t\tstatus = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_try_remove_refcount_tree",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_try_remove_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "933-960",
          "snippet": "int ocfs2_try_remove_refcount_tree(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&oi->ip_xattr_sem);\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (oi->ip_clusters)\n\t\tgoto out;\n\n\tif ((oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) && di->i_xattr_loc)\n\t\tgoto out;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL &&\n\t    ocfs2_has_inline_xattr_value_outside(inode, di))\n\t\tgoto out;\n\n\tret = ocfs2_remove_refcount_tree(inode, di_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tup_write(&oi->ip_alloc_sem);\n\tup_write(&oi->ip_xattr_sem);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_try_remove_refcount_tree(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&oi->ip_xattr_sem);\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (oi->ip_clusters)\n\t\tgoto out;\n\n\tif ((oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) && di->i_xattr_loc)\n\t\tgoto out;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL &&\n\t    ocfs2_has_inline_xattr_value_outside(inode, di))\n\t\tgoto out;\n\n\tret = ocfs2_remove_refcount_tree(inode, di_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tup_write(&oi->ip_alloc_sem);\n\tup_write(&oi->ip_xattr_sem);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_truncate",
          "args": [
            "osb",
            "inode",
            "di_bh"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "7011-7172",
          "snippet": "int ocfs2_commit_truncate(struct ocfs2_super *osb,\n\t\t\t  struct inode *inode,\n\t\t\t  struct buffer_head *di_bh)\n{\n\tint status = 0, i, flags = 0;\n\tu32 new_highest_cpos, range, trunc_cpos, trunc_len, phys_cpos, coff;\n\tu64 blkno = 0;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_extent_list *root_el = &(di->id2.i_list);\n\tu64 refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tnew_highest_cpos = ocfs2_clusters_for_bytes(osb->sb,\n\t\t\t\t\t\t     i_size_read(inode));\n\n\tpath = ocfs2_new_path(di_bh, &di->id2.i_list,\n\t\t\t      ocfs2_journal_access_di);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_extent_map_trunc(inode, new_highest_cpos);\n\nstart:\n\t/*\n\t * Check that we still have allocation to delete.\n\t */\n\tif (OCFS2_I(inode)->ip_clusters == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Truncate always works against the rightmost tree branch.\n\t */\n\tstatus = ocfs2_find_path(INODE_CACHE(inode), path, UINT_MAX);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_commit_truncate(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tnew_highest_cpos,\n\t\tOCFS2_I(inode)->ip_clusters,\n\t\tpath->p_tree_depth);\n\n\t/*\n\t * By now, el will point to the extent list on the bottom most\n\t * portion of this tree. Only the tail record is considered in\n\t * each pass.\n\t *\n\t * We handle the following cases, in order:\n\t * - empty extent: delete the remaining branch\n\t * - remove the entire record\n\t * - remove a partial record\n\t * - no record needs to be removed (truncate has completed)\n\t */\n\tel = path_leaf_el(path);\n\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has empty extent block at %llu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)path_leaf_bh(path)->b_blocknr);\n\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\tflags = rec->e_flags;\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (i == 0 && ocfs2_is_empty_extent(rec)) {\n\t\t/*\n\t\t * Lower levels depend on this never happening, but it's best\n\t\t * to check it up here before changing the tree.\n\t\t*/\n\t\tif (root_el->l_tree_depth && rec->e_int_clusters == 0) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has an empty \"\n\t\t\t\t    \"extent record, depth %u\\n\", inode->i_ino,\n\t\t\t\t    le16_to_cpu(root_el->l_tree_depth));\n\t\t\tstatus = -EROFS;\n\t\t\tgoto bail;\n\t\t}\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = 0;\n\t\tblkno = 0;\n\t} else if (le32_to_cpu(rec->e_cpos) >= new_highest_cpos) {\n\t\t/*\n\t\t * Truncate entire record.\n\t\t */\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = ocfs2_rec_clusters(el, rec);\n\t\tblkno = le64_to_cpu(rec->e_blkno);\n\t} else if (range > new_highest_cpos) {\n\t\t/*\n\t\t * Partial truncate. it also should be\n\t\t * the last truncate we're doing.\n\t\t */\n\t\ttrunc_cpos = new_highest_cpos;\n\t\ttrunc_len = range - new_highest_cpos;\n\t\tcoff = new_highest_cpos - le32_to_cpu(rec->e_cpos);\n\t\tblkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t} else {\n\t\t/*\n\t\t * Truncate completed, leave happily.\n\t\t */\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && trunc_len && !ref_tree) {\n\t\tstatus = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t&ref_tree, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t  phys_cpos, trunc_len, flags, &dealloc,\n\t\t\t\t\t  refcount_loc, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_reinit_path(path, 1);\n\n\t/*\n\t * The check above will catch the case where we've truncated\n\t * away all allocation.\n\t */\n\tgoto start;\n\nbail:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tocfs2_free_path(path);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_commit_truncate(struct ocfs2_super *osb,\n\t\t\t  struct inode *inode,\n\t\t\t  struct buffer_head *di_bh)\n{\n\tint status = 0, i, flags = 0;\n\tu32 new_highest_cpos, range, trunc_cpos, trunc_len, phys_cpos, coff;\n\tu64 blkno = 0;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_extent_list *root_el = &(di->id2.i_list);\n\tu64 refcount_loc = le64_to_cpu(di->i_refcount_loc);\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree = NULL;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(inode), di_bh);\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tnew_highest_cpos = ocfs2_clusters_for_bytes(osb->sb,\n\t\t\t\t\t\t     i_size_read(inode));\n\n\tpath = ocfs2_new_path(di_bh, &di->id2.i_list,\n\t\t\t      ocfs2_journal_access_di);\n\tif (!path) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_extent_map_trunc(inode, new_highest_cpos);\n\nstart:\n\t/*\n\t * Check that we still have allocation to delete.\n\t */\n\tif (OCFS2_I(inode)->ip_clusters == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\t/*\n\t * Truncate always works against the rightmost tree branch.\n\t */\n\tstatus = ocfs2_find_path(INODE_CACHE(inode), path, UINT_MAX);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_commit_truncate(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\tnew_highest_cpos,\n\t\tOCFS2_I(inode)->ip_clusters,\n\t\tpath->p_tree_depth);\n\n\t/*\n\t * By now, el will point to the extent list on the bottom most\n\t * portion of this tree. Only the tail record is considered in\n\t * each pass.\n\t *\n\t * We handle the following cases, in order:\n\t * - empty extent: delete the remaining branch\n\t * - remove the entire record\n\t * - remove a partial record\n\t * - no record needs to be removed (truncate has completed)\n\t */\n\tel = path_leaf_el(path);\n\tif (le16_to_cpu(el->l_next_free_rec) == 0) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inode %llu has empty extent block at %llu\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    (unsigned long long)path_leaf_bh(path)->b_blocknr);\n\t\tstatus = -EROFS;\n\t\tgoto bail;\n\t}\n\n\ti = le16_to_cpu(el->l_next_free_rec) - 1;\n\trec = &el->l_recs[i];\n\tflags = rec->e_flags;\n\trange = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\n\tif (i == 0 && ocfs2_is_empty_extent(rec)) {\n\t\t/*\n\t\t * Lower levels depend on this never happening, but it's best\n\t\t * to check it up here before changing the tree.\n\t\t*/\n\t\tif (root_el->l_tree_depth && rec->e_int_clusters == 0) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has an empty \"\n\t\t\t\t    \"extent record, depth %u\\n\", inode->i_ino,\n\t\t\t\t    le16_to_cpu(root_el->l_tree_depth));\n\t\t\tstatus = -EROFS;\n\t\t\tgoto bail;\n\t\t}\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = 0;\n\t\tblkno = 0;\n\t} else if (le32_to_cpu(rec->e_cpos) >= new_highest_cpos) {\n\t\t/*\n\t\t * Truncate entire record.\n\t\t */\n\t\ttrunc_cpos = le32_to_cpu(rec->e_cpos);\n\t\ttrunc_len = ocfs2_rec_clusters(el, rec);\n\t\tblkno = le64_to_cpu(rec->e_blkno);\n\t} else if (range > new_highest_cpos) {\n\t\t/*\n\t\t * Partial truncate. it also should be\n\t\t * the last truncate we're doing.\n\t\t */\n\t\ttrunc_cpos = new_highest_cpos;\n\t\ttrunc_len = range - new_highest_cpos;\n\t\tcoff = new_highest_cpos - le32_to_cpu(rec->e_cpos);\n\t\tblkno = le64_to_cpu(rec->e_blkno) +\n\t\t\t\tocfs2_clusters_to_blocks(inode->i_sb, coff);\n\t} else {\n\t\t/*\n\t\t * Truncate completed, leave happily.\n\t\t */\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tphys_cpos = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\tif ((flags & OCFS2_EXT_REFCOUNTED) && trunc_len && !ref_tree) {\n\t\tstatus = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t&ref_tree, NULL);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = ocfs2_remove_btree_range(inode, &et, trunc_cpos,\n\t\t\t\t\t  phys_cpos, trunc_len, flags, &dealloc,\n\t\t\t\t\t  refcount_loc, true);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_reinit_path(path, 1);\n\n\t/*\n\t * The check above will catch the case where we've truncated\n\t * away all allocation.\n\t */\n\tgoto start;\n\nbail:\n\tif (ref_tree)\n\t\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\n\tocfs2_schedule_truncate_log_flush(osb, 1);\n\n\tocfs2_run_deallocs(osb, &dealloc);\n\n\tocfs2_free_path(path);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_orphan_for_truncate",
          "args": [
            "osb",
            "inode",
            "di_bh",
            "new_i_size"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_orphan_for_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "378-442",
          "snippet": "static int ocfs2_orphan_for_truncate(struct ocfs2_super *osb,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh,\n\t\t\t\t     u64 new_i_size)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di;\n\tu64 cluster_bytes;\n\n\t/*\n\t * We need to CoW the cluster contains the offset if it is reflinked\n\t * since we will call ocfs2_zero_range_for_truncate later which will\n\t * write \"0\" from offset to the end of the cluster.\n\t */\n\tstatus = ocfs2_cow_file_pos(inode, fe_bh, new_i_size);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\t/* TODO: This needs to actually orphan the inode in this\n\t * transaction. */\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Do this before setting i_size.\n\t */\n\tcluster_bytes = ocfs2_align_bytes_to_clusters(inode->i_sb, new_i_size);\n\tstatus = ocfs2_zero_range_for_truncate(inode, handle, new_i_size,\n\t\t\t\t\t       cluster_bytes);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\ti_size_write(inode, new_i_size);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tdi = (struct ocfs2_dinode *) fe_bh->b_data;\n\tdi->i_size = cpu_to_le64(new_i_size);\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_orphan_for_truncate(struct ocfs2_super *osb,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh,\n\t\t\t\t     u64 new_i_size)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di;\n\tu64 cluster_bytes;\n\n\t/*\n\t * We need to CoW the cluster contains the offset if it is reflinked\n\t * since we will call ocfs2_zero_range_for_truncate later which will\n\t * write \"0\" from offset to the end of the cluster.\n\t */\n\tstatus = ocfs2_cow_file_pos(inode, fe_bh, new_i_size);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\t/* TODO: This needs to actually orphan the inode in this\n\t * transaction. */\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Do this before setting i_size.\n\t */\n\tcluster_bytes = ocfs2_align_bytes_to_clusters(inode->i_sb, new_i_size);\n\tstatus = ocfs2_zero_range_for_truncate(inode, handle, new_i_size,\n\t\t\t\t\t       cluster_bytes);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\ti_size_write(inode, new_i_size);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tdi = (struct ocfs2_dinode *) fe_bh->b_data;\n\tdi->i_size = cpu_to_le64(new_i_size);\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_truncate_inline",
          "args": [
            "inode",
            "di_bh",
            "new_i_size",
            "i_size_read(inode)",
            "1"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_truncate_inline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "7177-7248",
          "snippet": "int ocfs2_truncate_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  unsigned int start, unsigned int end, int trunc)\n{\n\tint ret;\n\tunsigned int numbytes;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\tBUG_ON(start > end);\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    !(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL) ||\n\t    !ocfs2_supports_inline_data(osb)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inline data flags for inode %llu don't agree! \"\n\t\t\t    \"Disk: 0x%x, Memory: 0x%x, Superblock: 0x%x\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    le16_to_cpu(di->i_dyn_features),\n\t\t\t    OCFS2_I(inode)->ip_dyn_features,\n\t\t\t    osb->s_feature_incompat);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnumbytes = end - start;\n\tmemset(idata->id_data + start, 0, numbytes);\n\n\t/*\n\t * No need to worry about the data page here - it's been\n\t * truncated already and inline data doesn't need it for\n\t * pushing zero's to disk, so we'll let readpage pick it up\n\t * later.\n\t */\n\tif (trunc) {\n\t\ti_size_write(inode, start);\n\t\tdi->i_size = cpu_to_le64(start);\n\t}\n\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_truncate_inline(struct inode *inode, struct buffer_head *di_bh,\n\t\t\t  unsigned int start, unsigned int end, int trunc)\n{\n\tint ret;\n\tunsigned int numbytes;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inline_data *idata = &di->id2.i_data;\n\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\tBUG_ON(start > end);\n\n\tif (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||\n\t    !(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL) ||\n\t    !ocfs2_supports_inline_data(osb)) {\n\t\tocfs2_error(inode->i_sb,\n\t\t\t    \"Inline data flags for inode %llu don't agree! \"\n\t\t\t    \"Disk: 0x%x, Memory: 0x%x, Superblock: 0x%x\\n\",\n\t\t\t    (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t    le16_to_cpu(di->i_dyn_features),\n\t\t\t    OCFS2_I(inode)->ip_dyn_features,\n\t\t\t    osb->s_feature_incompat);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnumbytes = end - start;\n\tmemset(idata->id_data + start, 0, numbytes);\n\n\t/*\n\t * No need to worry about the data page here - it's been\n\t * truncated already and inline data doesn't need it for\n\t * pushing zero's to disk, so we'll let readpage pick it up\n\t * later.\n\t */\n\tif (trunc) {\n\t\ti_size_write(inode, start);\n\t\tdi->i_size = cpu_to_le64(start);\n\t}\n\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages",
          "args": [
            "inode->i_mapping",
            "new_i_size"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_range",
          "args": [
            "inode->i_mapping",
            "new_i_size + PAGE_SIZE - 1",
            "0",
            "1"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_resv_discard",
          "args": [
            "&osb->osb_la_resmap",
            "&OCFS2_I(inode)->ip_la_data_resv"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_resv_discard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/reservations.c",
          "lines": "270-278",
          "snippet": "void ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tif (resv) {\n\t\tspin_lock(&resv_lock);\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\tspin_unlock(&resv_lock);\n\t}\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/list.h>",
            "#include <linux/bitops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(resv_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic DEFINE_SPINLOCK(resv_lock);\n\nvoid ocfs2_resv_discard(struct ocfs2_reservation_map *resmap,\n\t\t\tstruct ocfs2_alloc_reservation *resv)\n{\n\tif (resv) {\n\t\tspin_lock(&resv_lock);\n\t\t__ocfs2_resv_discard(resmap, resv);\n\t\tspin_unlock(&resv_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_truncate_file_error",
          "args": [
            "(unsigned long long)le64_to_cpu(fe->i_size)",
            "(unsigned long long)new_i_size"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_size"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "le64_to_cpu(fe->i_size) != i_size_read(inode)",
            "\"Inode %llu, inode i_size = %lld != di \"\n\t\t\t\"i_size = %llu, i_flags = 0x%x\\n\"",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "i_size_read(inode)",
            "(unsigned long long)le64_to_cpu(fe->i_size)",
            "le32_to_cpu(fe->i_flags)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->i_flags"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_truncate_file",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "(unsigned long long)le64_to_cpu(fe->i_size)",
            "(unsigned long long)new_i_size"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_truncate_file(struct inode *inode,\n\t\t\t       struct buffer_head *di_bh,\n\t\t\t       u64 new_i_size)\n{\n\tint status = 0;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/* We trust di_bh because it comes from ocfs2_inode_lock(), which\n\t * already validated it */\n\tfe = (struct ocfs2_dinode *) di_bh->b_data;\n\n\ttrace_ocfs2_truncate_file((unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t\t  (unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t\t  (unsigned long long)new_i_size);\n\n\tmlog_bug_on_msg(le64_to_cpu(fe->i_size) != i_size_read(inode),\n\t\t\t\"Inode %llu, inode i_size = %lld != di \"\n\t\t\t\"i_size = %llu, i_flags = 0x%x\\n\",\n\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\ti_size_read(inode),\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\tle32_to_cpu(fe->i_flags));\n\n\tif (new_i_size > le64_to_cpu(fe->i_size)) {\n\t\ttrace_ocfs2_truncate_file_error(\n\t\t\t(unsigned long long)le64_to_cpu(fe->i_size),\n\t\t\t(unsigned long long)new_i_size);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\n\tocfs2_resv_discard(&osb->osb_la_resmap,\n\t\t\t   &OCFS2_I(inode)->ip_la_data_resv);\n\n\t/*\n\t * The inode lock forced other nodes to sync and drop their\n\t * pages, which (correctly) happens even if we have a truncate\n\t * without allocation change - ocfs2 cluster sizes can be much\n\t * greater than page size, so we have to truncate them\n\t * anyway.\n\t */\n\tunmap_mapping_range(inode->i_mapping, new_i_size + PAGE_SIZE - 1, 0, 1);\n\ttruncate_inode_pages(inode->i_mapping, new_i_size);\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tstatus = ocfs2_truncate_inline(inode, di_bh, new_i_size,\n\t\t\t\t\t       i_size_read(inode), 1);\n\t\tif (status)\n\t\t\tmlog_errno(status);\n\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* alright, we're going to need to do a full blown alloc size\n\t * change. Orphan the inode so that recovery can complete the\n\t * truncate if necessary. This does the task of marking\n\t * i_size. */\n\tstatus = ocfs2_orphan_for_truncate(osb, inode, di_bh, new_i_size);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\tstatus = ocfs2_commit_truncate(osb, inode, di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail_unlock_sem;\n\t}\n\n\t/* TODO: orphan dir cleanup here. */\nbail_unlock_sem:\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\nbail:\n\tif (!status && OCFS2_I(inode)->ip_clusters == 0)\n\t\tstatus = ocfs2_try_remove_refcount_tree(inode, di_bh);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_orphan_for_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "378-442",
    "snippet": "static int ocfs2_orphan_for_truncate(struct ocfs2_super *osb,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh,\n\t\t\t\t     u64 new_i_size)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di;\n\tu64 cluster_bytes;\n\n\t/*\n\t * We need to CoW the cluster contains the offset if it is reflinked\n\t * since we will call ocfs2_zero_range_for_truncate later which will\n\t * write \"0\" from offset to the end of the cluster.\n\t */\n\tstatus = ocfs2_cow_file_pos(inode, fe_bh, new_i_size);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\t/* TODO: This needs to actually orphan the inode in this\n\t * transaction. */\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Do this before setting i_size.\n\t */\n\tcluster_bytes = ocfs2_align_bytes_to_clusters(inode->i_sb, new_i_size);\n\tstatus = ocfs2_zero_range_for_truncate(inode, handle, new_i_size,\n\t\t\t\t\t       cluster_bytes);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\ti_size_write(inode, new_i_size);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tdi = (struct ocfs2_dinode *) fe_bh->b_data;\n\tdi->i_size = cpu_to_le64(new_i_size);\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "fe_bh"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "0"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_nsec"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "new_i_size"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "new_i_size"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_zero_range_for_truncate",
          "args": [
            "inode",
            "handle",
            "new_i_size",
            "cluster_bytes"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_zero_range_for_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6723-6789",
          "snippet": "int ocfs2_zero_range_for_truncate(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 range_start, u64 range_end)\n{\n\tint ret = 0, numpages;\n\tstruct page **pages = NULL;\n\tu64 phys;\n\tunsigned int ext_flags;\n\tstruct super_block *sb = inode->i_sb;\n\n\t/*\n\t * File systems which don't support sparse files zero on every\n\t * extend.\n\t */\n\tif (!ocfs2_sparse_alloc(OCFS2_SB(sb)))\n\t\treturn 0;\n\n\tpages = kcalloc(ocfs2_pages_per_cluster(sb),\n\t\t\tsizeof(struct page *), GFP_NOFS);\n\tif (pages == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (range_start == range_end)\n\t\tgoto out;\n\n\tret = ocfs2_extent_map_get_blocks(inode,\n\t\t\t\t\t  range_start >> sb->s_blocksize_bits,\n\t\t\t\t\t  &phys, NULL, &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Tail is a hole, or is marked unwritten. In either case, we\n\t * can count on read and write to return/push zero's.\n\t */\n\tif (phys == 0 || ext_flags & OCFS2_EXT_UNWRITTEN)\n\t\tgoto out;\n\n\tret = ocfs2_grab_eof_pages(inode, range_start, range_end, pages,\n\t\t\t\t   &numpages);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_zero_cluster_pages(inode, range_start, range_end, pages,\n\t\t\t\t numpages, phys, handle);\n\n\t/*\n\t * Initiate writeout of the pages we zero'd here. We don't\n\t * wait on them - the truncate_inode_pages() call later will\n\t * do that for us.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, range_start,\n\t\t\t\t       range_end - 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(pages);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_zero_range_for_truncate(struct inode *inode, handle_t *handle,\n\t\t\t\t  u64 range_start, u64 range_end)\n{\n\tint ret = 0, numpages;\n\tstruct page **pages = NULL;\n\tu64 phys;\n\tunsigned int ext_flags;\n\tstruct super_block *sb = inode->i_sb;\n\n\t/*\n\t * File systems which don't support sparse files zero on every\n\t * extend.\n\t */\n\tif (!ocfs2_sparse_alloc(OCFS2_SB(sb)))\n\t\treturn 0;\n\n\tpages = kcalloc(ocfs2_pages_per_cluster(sb),\n\t\t\tsizeof(struct page *), GFP_NOFS);\n\tif (pages == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (range_start == range_end)\n\t\tgoto out;\n\n\tret = ocfs2_extent_map_get_blocks(inode,\n\t\t\t\t\t  range_start >> sb->s_blocksize_bits,\n\t\t\t\t\t  &phys, NULL, &ext_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Tail is a hole, or is marked unwritten. In either case, we\n\t * can count on read and write to return/push zero's.\n\t */\n\tif (phys == 0 || ext_flags & OCFS2_EXT_UNWRITTEN)\n\t\tgoto out;\n\n\tret = ocfs2_grab_eof_pages(inode, range_start, range_end, pages,\n\t\t\t\t   &numpages);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_zero_cluster_pages(inode, range_start, range_end, pages,\n\t\t\t\t numpages, phys, handle);\n\n\t/*\n\t * Initiate writeout of the pages we zero'd here. We don't\n\t * wait on them - the truncate_inode_pages() call later will\n\t * do that for us.\n\t */\n\tret = filemap_fdatawrite_range(inode->i_mapping, range_start,\n\t\t\t\t       range_end - 1);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(pages);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_align_bytes_to_clusters",
          "args": [
            "inode->i_sb",
            "new_i_size"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_align_bytes_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "775-783",
          "snippet": "static inline u64 ocfs2_align_bytes_to_clusters(struct super_block *sb,\n\t\t\t\t\t\tu64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tclusters = ocfs2_clusters_for_bytes(sb, bytes);\n\treturn (u64)clusters << cl_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_align_bytes_to_clusters(struct super_block *sb,\n\t\t\t\t\t\tu64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tclusters = ocfs2_clusters_for_bytes(sb, bytes);\n\treturn (u64)clusters << cl_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "fe_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cow_file_pos",
          "args": [
            "inode",
            "fe_bh",
            "new_i_size"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_file_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "345-376",
          "snippet": "static int ocfs2_cow_file_pos(struct inode *inode,\n\t\t\t      struct buffer_head *fe_bh,\n\t\t\t      u64 offset)\n{\n\tint status;\n\tu32 phys, cpos = offset >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\n\t/*\n\t * If the new offset is aligned to the range of the cluster, there is\n\t * no space for ocfs2_zero_range_for_truncate to fill, so no need to\n\t * CoW either.\n\t */\n\tif ((offset & (OCFS2_SB(inode->i_sb)->s_clustersize - 1)) == 0)\n\t\treturn 0;\n\n\tstatus = ocfs2_get_clusters(inode, cpos, &phys,\n\t\t\t\t    &num_clusters, &ext_flags);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\treturn ocfs2_refcount_cow(inode, fe_bh, cpos, 1, cpos+1);\n\nout:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_cow_file_pos(struct inode *inode,\n\t\t\t      struct buffer_head *fe_bh,\n\t\t\t      u64 offset)\n{\n\tint status;\n\tu32 phys, cpos = offset >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\n\t/*\n\t * If the new offset is aligned to the range of the cluster, there is\n\t * no space for ocfs2_zero_range_for_truncate to fill, so no need to\n\t * CoW either.\n\t */\n\tif ((offset & (OCFS2_SB(inode->i_sb)->s_clustersize - 1)) == 0)\n\t\treturn 0;\n\n\tstatus = ocfs2_get_clusters(inode, cpos, &phys,\n\t\t\t\t    &num_clusters, &ext_flags);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\treturn ocfs2_refcount_cow(inode, fe_bh, cpos, 1, cpos+1);\n\nout:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_orphan_for_truncate(struct ocfs2_super *osb,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh,\n\t\t\t\t     u64 new_i_size)\n{\n\tint status;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di;\n\tu64 cluster_bytes;\n\n\t/*\n\t * We need to CoW the cluster contains the offset if it is reflinked\n\t * since we will call ocfs2_zero_range_for_truncate later which will\n\t * write \"0\" from offset to the end of the cluster.\n\t */\n\tstatus = ocfs2_cow_file_pos(inode, fe_bh, new_i_size);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\t/* TODO: This needs to actually orphan the inode in this\n\t * transaction. */\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), fe_bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Do this before setting i_size.\n\t */\n\tcluster_bytes = ocfs2_align_bytes_to_clusters(inode->i_sb, new_i_size);\n\tstatus = ocfs2_zero_range_for_truncate(inode, handle, new_i_size,\n\t\t\t\t\t       cluster_bytes);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\ti_size_write(inode, new_i_size);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tdi = (struct ocfs2_dinode *) fe_bh->b_data;\n\tdi->i_size = cpu_to_le64(new_i_size);\n\tdi->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\n\tocfs2_journal_dirty(handle, fe_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_cow_file_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "345-376",
    "snippet": "static int ocfs2_cow_file_pos(struct inode *inode,\n\t\t\t      struct buffer_head *fe_bh,\n\t\t\t      u64 offset)\n{\n\tint status;\n\tu32 phys, cpos = offset >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\n\t/*\n\t * If the new offset is aligned to the range of the cluster, there is\n\t * no space for ocfs2_zero_range_for_truncate to fill, so no need to\n\t * CoW either.\n\t */\n\tif ((offset & (OCFS2_SB(inode->i_sb)->s_clustersize - 1)) == 0)\n\t\treturn 0;\n\n\tstatus = ocfs2_get_clusters(inode, cpos, &phys,\n\t\t\t\t    &num_clusters, &ext_flags);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\treturn ocfs2_refcount_cow(inode, fe_bh, cpos, 1, cpos+1);\n\nout:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_refcount_cow",
          "args": [
            "inode",
            "fe_bh",
            "cpos",
            "1",
            "cpos+1"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_cow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3504-3537",
          "snippet": "int ocfs2_refcount_cow(struct inode *inode,\n\t\t       struct buffer_head *di_bh,\n\t\t       u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\twhile (write_len) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write_len < num_clusters)\n\t\t\tnum_clusters = write_len;\n\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED) {\n\t\t\tret = ocfs2_refcount_cow_hunk(inode, di_bh, cpos,\n\t\t\t\t\t\t      num_clusters, max_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twrite_len -= num_clusters;\n\t\tcpos += num_clusters;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_refcount_cow(struct inode *inode,\n\t\t       struct buffer_head *di_bh,\n\t\t       u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\twhile (write_len) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write_len < num_clusters)\n\t\t\tnum_clusters = write_len;\n\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED) {\n\t\t\tret = ocfs2_refcount_cow_hunk(inode, di_bh, cpos,\n\t\t\t\t\t\t      num_clusters, max_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twrite_len -= num_clusters;\n\t\tcpos += num_clusters;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&phys",
            "&num_clusters",
            "&ext_flags"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "608-665",
          "snippet": "int ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_cow_file_pos(struct inode *inode,\n\t\t\t      struct buffer_head *fe_bh,\n\t\t\t      u64 offset)\n{\n\tint status;\n\tu32 phys, cpos = offset >> OCFS2_SB(inode->i_sb)->s_clustersize_bits;\n\tunsigned int num_clusters = 0;\n\tunsigned int ext_flags = 0;\n\n\t/*\n\t * If the new offset is aligned to the range of the cluster, there is\n\t * no space for ocfs2_zero_range_for_truncate to fill, so no need to\n\t * CoW either.\n\t */\n\tif ((offset & (OCFS2_SB(inode->i_sb)->s_clustersize - 1)) == 0)\n\t\treturn 0;\n\n\tstatus = ocfs2_get_clusters(inode, cpos, &phys,\n\t\t\t\t    &num_clusters, &ext_flags);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out;\n\t}\n\n\tif (!(ext_flags & OCFS2_EXT_REFCOUNTED))\n\t\tgoto out;\n\n\treturn ocfs2_refcount_cow(inode, fe_bh, cpos, 1, cpos+1);\n\nout:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_simple_size_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "319-343",
    "snippet": "int ocfs2_simple_size_update(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_set_inode_size(handle, inode, di_bh,\n\t\t\t\t   new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "0"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_inode_size",
          "args": [
            "handle",
            "inode",
            "di_bh",
            "new_i_size"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_inode_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "298-317",
          "snippet": "int ocfs2_set_inode_size(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct buffer_head *fe_bh,\n\t\t\t\tu64 new_i_size)\n{\n\tint status;\n\n\ti_size_write(inode, new_i_size);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_set_inode_size(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct buffer_head *fe_bh,\n\t\t\t\tu64 new_i_size)\n{\n\tint status;\n\n\ti_size_write(inode, new_i_size);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_simple_size_update(struct inode *inode,\n\t\t\t     struct buffer_head *di_bh,\n\t\t\t     u64 new_i_size)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle = NULL;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_set_inode_size(handle, inode, di_bh,\n\t\t\t\t   new_i_size);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_set_inode_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "298-317",
    "snippet": "int ocfs2_set_inode_size(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct buffer_head *fe_bh,\n\t\t\t\tu64 new_i_size)\n{\n\tint status;\n\n\ti_size_write(inode, new_i_size);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_inode_dirty",
          "args": [
            "handle",
            "inode",
            "fe_bh"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1250-1289",
          "snippet": "int ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mark_inode_dirty(handle_t *handle,\n\t\t\t   struct inode *inode,\n\t\t\t   struct buffer_head *bh)\n{\n\tint status;\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bh->b_data;\n\n\ttrace_ocfs2_mark_inode_dirty((unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&OCFS2_I(inode)->ip_lock);\n\tfe->i_clusters = cpu_to_le32(OCFS2_I(inode)->ip_clusters);\n\tocfs2_get_inode_flags(OCFS2_I(inode));\n\tfe->i_attr = cpu_to_le32(OCFS2_I(inode)->ip_attr);\n\tfe->i_dyn_features = cpu_to_le16(OCFS2_I(inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(inode)->ip_lock);\n\n\tfe->i_size = cpu_to_le64(i_size_read(inode));\n\tocfs2_set_links_count(fe, inode->i_nlink);\n\tfe->i_uid = cpu_to_le32(i_uid_read(inode));\n\tfe->i_gid = cpu_to_le32(i_gid_read(inode));\n\tfe->i_mode = cpu_to_le16(inode->i_mode);\n\tfe->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tfe->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tfe->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tfe->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\tfe->i_mtime = cpu_to_le64(inode->i_mtime.tv_sec);\n\tfe->i_mtime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, bh);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\nleave:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_sector_count",
          "args": [
            "inode"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_sector_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "165-170",
          "snippet": "static inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline blkcnt_t ocfs2_inode_sector_count(struct inode *inode)\n{\n\tint c_to_s_bits = OCFS2_SB(inode->i_sb)->s_clustersize_bits - 9;\n\n\treturn (blkcnt_t)OCFS2_I(inode)->ip_clusters << c_to_s_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "new_i_size"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_set_inode_size(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct buffer_head *fe_bh,\n\t\t\t\tu64 new_i_size)\n{\n\tint status;\n\n\ti_size_write(inode, new_i_size);\n\tinode->i_blocks = ocfs2_inode_sector_count(inode);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\n\tstatus = ocfs2_mark_inode_dirty(handle, inode, fe_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_update_inode_atime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "259-296",
    "snippet": "int ocfs2_update_inode_atime(struct inode *inode,\n\t\t\t     struct buffer_head *bh)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) bh->b_data;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Don't use ocfs2_mark_inode_dirty() here as we don't always\n\t * have i_mutex to guard against concurrent changes to other\n\t * inode fields.\n\t */\n\tinode->i_atime = CURRENT_TIME;\n\tdi->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tdi->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_journal_dirty(handle, bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "handle"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bh"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_inode_fsync_trans",
          "args": [
            "handle",
            "inode",
            "0"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_inode_fsync_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "634-643",
          "snippet": "static inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_update_inode_fsync_trans(handle_t *handle,\n\t\t\t\t\t\t  struct inode *inode,\n\t\t\t\t\t\t  int datasync)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\toi->i_sync_tid = handle->h_transaction->t_tid;\n\tif (datasync)\n\t\toi->i_datasync_tid = handle->h_transaction->t_tid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_atime.tv_nsec"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_atime.tv_sec"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_update_inode_atime(struct inode *inode,\n\t\t\t     struct buffer_head *bh)\n{\n\tint ret;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *) bh->b_data;\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/*\n\t * Don't use ocfs2_mark_inode_dirty() here as we don't always\n\t * have i_mutex to guard against concurrent changes to other\n\t * inode fields.\n\t */\n\tinode->i_atime = CURRENT_TIME;\n\tdi->i_atime = cpu_to_le64(inode->i_atime.tv_sec);\n\tdi->i_atime_nsec = cpu_to_le32(inode->i_atime.tv_nsec);\n\tocfs2_update_inode_fsync_trans(handle, inode, 0);\n\tocfs2_journal_dirty(handle, bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_should_update_atime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "216-257",
    "snippet": "int ocfs2_should_update_atime(struct inode *inode,\n\t\t\t      struct vfsmount *vfsmnt)\n{\n\tstruct timespec now;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn 0;\n\n\tif ((inode->i_flags & S_NOATIME) ||\n\t    ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\treturn 0;\n\n\t/*\n\t * We can be called with no vfsmnt structure - NFSD will\n\t * sometimes do this.\n\t *\n\t * Note that our action here is different than touch_atime() -\n\t * if we can't tell whether this is a noatime mount, then we\n\t * don't know whether to trust the value of s_atime_quantum.\n\t */\n\tif (vfsmnt == NULL)\n\t\treturn 0;\n\n\tif ((vfsmnt->mnt_flags & MNT_NOATIME) ||\n\t    ((vfsmnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\treturn 0;\n\n\tif (vfsmnt->mnt_flags & MNT_RELATIME) {\n\t\tif ((timespec_compare(&inode->i_atime, &inode->i_mtime) <= 0) ||\n\t\t    (timespec_compare(&inode->i_atime, &inode->i_ctime) <= 0))\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\tnow = CURRENT_TIME;\n\tif ((now.tv_sec - inode->i_atime.tv_sec <= osb->s_atime_quantum))\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec_compare",
          "args": [
            "&inode->i_atime",
            "&inode->i_ctime"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_compare",
          "args": [
            "&inode->i_atime",
            "&inode->i_mtime"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_soft_readonly",
          "args": [
            "osb"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_soft_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "626-635",
          "snippet": "static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_SOFT_RO\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_SOFT_RO\t0x0001\n\nstatic inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_should_update_atime(struct inode *inode,\n\t\t\t      struct vfsmount *vfsmnt)\n{\n\tstruct timespec now;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn 0;\n\n\tif ((inode->i_flags & S_NOATIME) ||\n\t    ((inode->i_sb->s_flags & MS_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\treturn 0;\n\n\t/*\n\t * We can be called with no vfsmnt structure - NFSD will\n\t * sometimes do this.\n\t *\n\t * Note that our action here is different than touch_atime() -\n\t * if we can't tell whether this is a noatime mount, then we\n\t * don't know whether to trust the value of s_atime_quantum.\n\t */\n\tif (vfsmnt == NULL)\n\t\treturn 0;\n\n\tif ((vfsmnt->mnt_flags & MNT_NOATIME) ||\n\t    ((vfsmnt->mnt_flags & MNT_NODIRATIME) && S_ISDIR(inode->i_mode)))\n\t\treturn 0;\n\n\tif (vfsmnt->mnt_flags & MNT_RELATIME) {\n\t\tif ((timespec_compare(&inode->i_atime, &inode->i_mtime) <= 0) ||\n\t\t    (timespec_compare(&inode->i_atime, &inode->i_ctime) <= 0))\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\tnow = CURRENT_TIME;\n\tif ((now.tv_sec - inode->i_atime.tv_sec <= osb->s_atime_quantum))\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}"
  },
  {
    "function_name": "ocfs2_sync_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "174-214",
    "snippet": "static int ocfs2_sync_file(struct file *file, loff_t start, loff_t end,\n\t\t\t   int datasync)\n{\n\tint err = 0;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tjournal_t *journal = osb->journal->j_journal;\n\tint ret;\n\ttid_t commit_tid;\n\tbool needs_barrier = false;\n\n\ttrace_ocfs2_sync_file(inode, file, file->f_path.dentry,\n\t\t\t      OCFS2_I(inode)->ip_blkno,\n\t\t\t      file->f_path.dentry->d_name.len,\n\t\t\t      file->f_path.dentry->d_name.name,\n\t\t\t      (unsigned long long)datasync);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\n\tcommit_tid = datasync ? oi->i_datasync_tid : oi->i_sync_tid;\n\tif (journal->j_flags & JBD2_BARRIER &&\n\t    !jbd2_trans_will_send_data_barrier(journal, commit_tid))\n\t\tneeds_barrier = true;\n\terr = jbd2_complete_transaction(journal, commit_tid);\n\tif (needs_barrier) {\n\t\tret = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\n\t\tif (!err)\n\t\t\terr = ret;\n\t}\n\n\tif (err)\n\t\tmlog_errno(err);\n\n\treturn (err < 0) ? -EIO : 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "err"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "inode->i_sb->s_bdev",
            "GFP_KERNEL",
            "NULL"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_complete_transaction",
          "args": [
            "journal",
            "commit_tid"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_complete_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "733-754",
          "snippet": "int jbd2_complete_transaction(journal_t *journal, tid_t tid)\n{\n\tint\tneed_to_wait = 1;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == tid) {\n\t\tif (journal->j_commit_request != tid) {\n\t\t\t/* transaction not yet started, so request it */\n\t\t\tread_unlock(&journal->j_state_lock);\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tgoto wait_commit;\n\t\t}\n\t} else if (!(journal->j_committing_transaction &&\n\t\t     journal->j_committing_transaction->t_tid == tid))\n\t\tneed_to_wait = 0;\n\tread_unlock(&journal->j_state_lock);\n\tif (!need_to_wait)\n\t\treturn 0;\nwait_commit:\n\treturn jbd2_log_wait_commit(journal, tid);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_complete_transaction(journal_t *journal, tid_t tid)\n{\n\tint\tneed_to_wait = 1;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == tid) {\n\t\tif (journal->j_commit_request != tid) {\n\t\t\t/* transaction not yet started, so request it */\n\t\t\tread_unlock(&journal->j_state_lock);\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tgoto wait_commit;\n\t\t}\n\t} else if (!(journal->j_committing_transaction &&\n\t\t     journal->j_committing_transaction->t_tid == tid))\n\t\tneed_to_wait = 0;\n\tread_unlock(&journal->j_state_lock);\n\tif (!need_to_wait)\n\t\treturn 0;\nwait_commit:\n\treturn jbd2_log_wait_commit(journal, tid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_trans_will_send_data_barrier",
          "args": [
            "journal",
            "commit_tid"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_trans_will_send_data_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "659-691",
          "snippet": "int jbd2_trans_will_send_data_barrier(journal_t *journal, tid_t tid)\n{\n\tint ret = 0;\n\ttransaction_t *commit_trans;\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\treturn 0;\n\tread_lock(&journal->j_state_lock);\n\t/* Transaction already committed? */\n\tif (tid_geq(journal->j_commit_sequence, tid))\n\t\tgoto out;\n\tcommit_trans = journal->j_committing_transaction;\n\tif (!commit_trans || commit_trans->t_tid != tid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\t/*\n\t * Transaction is being committed and we already proceeded to\n\t * submitting a flush to fs partition?\n\t */\n\tif (journal->j_fs_dev != journal->j_dev) {\n\t\tif (!commit_trans->t_need_data_flush ||\n\t\t    commit_trans->t_state >= T_COMMIT_DFLUSH)\n\t\t\tgoto out;\n\t} else {\n\t\tif (commit_trans->t_state >= T_COMMIT_JFLUSH)\n\t\t\tgoto out;\n\t}\n\tret = 1;\nout:\n\tread_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_trans_will_send_data_barrier(journal_t *journal, tid_t tid)\n{\n\tint ret = 0;\n\ttransaction_t *commit_trans;\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\treturn 0;\n\tread_lock(&journal->j_state_lock);\n\t/* Transaction already committed? */\n\tif (tid_geq(journal->j_commit_sequence, tid))\n\t\tgoto out;\n\tcommit_trans = journal->j_committing_transaction;\n\tif (!commit_trans || commit_trans->t_tid != tid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\t/*\n\t * Transaction is being committed and we already proceeded to\n\t * submitting a flush to fs partition?\n\t */\n\tif (journal->j_fs_dev != journal->j_dev) {\n\t\tif (!commit_trans->t_need_data_flush ||\n\t\t    commit_trans->t_state >= T_COMMIT_DFLUSH)\n\t\t\tgoto out;\n\t} else {\n\t\tif (commit_trans->t_state >= T_COMMIT_JFLUSH)\n\t\t\tgoto out;\n\t}\n\tret = 1;\nout:\n\tread_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "inode->i_mapping",
            "start",
            "end"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_soft_readonly",
          "args": [
            "osb"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_soft_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "626-635",
          "snippet": "static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_SOFT_RO\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_SOFT_RO\t0x0001\n\nstatic inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_sync_file",
          "args": [
            "inode",
            "file",
            "file->f_path.dentry",
            "OCFS2_I(inode)->ip_blkno",
            "file->f_path.dentry->d_name.len",
            "file->f_path.dentry->d_name.name",
            "(unsigned long long)datasync"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_sync_file(struct file *file, loff_t start, loff_t end,\n\t\t\t   int datasync)\n{\n\tint err = 0;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tjournal_t *journal = osb->journal->j_journal;\n\tint ret;\n\ttid_t commit_tid;\n\tbool needs_barrier = false;\n\n\ttrace_ocfs2_sync_file(inode, file, file->f_path.dentry,\n\t\t\t      OCFS2_I(inode)->ip_blkno,\n\t\t\t      file->f_path.dentry->d_name.len,\n\t\t\t      file->f_path.dentry->d_name.name,\n\t\t\t      (unsigned long long)datasync);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\terr = filemap_write_and_wait_range(inode->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\n\tcommit_tid = datasync ? oi->i_datasync_tid : oi->i_sync_tid;\n\tif (journal->j_flags & JBD2_BARRIER &&\n\t    !jbd2_trans_will_send_data_barrier(journal, commit_tid))\n\t\tneeds_barrier = true;\n\terr = jbd2_complete_transaction(journal, commit_tid);\n\tif (needs_barrier) {\n\t\tret = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\n\t\tif (!err)\n\t\t\terr = ret;\n\t}\n\n\tif (err)\n\t\tmlog_errno(err);\n\n\treturn (err < 0) ? -EIO : 0;\n}"
  },
  {
    "function_name": "ocfs2_dir_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "168-172",
    "snippet": "static int ocfs2_dir_release(struct inode *inode, struct file *file)\n{\n\tocfs2_free_file_private(inode, file);\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_file_private",
          "args": [
            "inode",
            "file"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_file_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "83-94",
          "snippet": "static void ocfs2_free_file_private(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (fp) {\n\t\tocfs2_simple_drop_lockres(osb, &fp->fp_flock);\n\t\tocfs2_lock_res_free(&fp->fp_flock);\n\t\tkfree(fp);\n\t\tfile->private_data = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_free_file_private(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (fp) {\n\t\tocfs2_simple_drop_lockres(osb, &fp->fp_flock);\n\t\tocfs2_lock_res_free(&fp->fp_flock);\n\t\tkfree(fp);\n\t\tfile->private_data = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_dir_release(struct inode *inode, struct file *file)\n{\n\tocfs2_free_file_private(inode, file);\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_dir_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "163-166",
    "snippet": "static int ocfs2_dir_open(struct inode *inode, struct file *file)\n{\n\treturn ocfs2_init_file_private(inode, file);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_init_file_private",
          "args": [
            "inode",
            "file"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_file_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "67-81",
          "snippet": "static int ocfs2_init_file_private(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_file_private *fp;\n\n\tfp = kzalloc(sizeof(struct ocfs2_file_private), GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tfp->fp_file = file;\n\tmutex_init(&fp->fp_mutex);\n\tocfs2_file_lock_res_init(&fp->fp_flock, fp);\n\tfile->private_data = fp;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_init_file_private(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_file_private *fp;\n\n\tfp = kzalloc(sizeof(struct ocfs2_file_private), GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tfp->fp_file = file;\n\tmutex_init(&fp->fp_mutex);\n\tocfs2_file_lock_res_init(&fp->fp_flock, fp);\n\tfile->private_data = fp;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_dir_open(struct inode *inode, struct file *file)\n{\n\treturn ocfs2_init_file_private(inode, file);\n}"
  },
  {
    "function_name": "ocfs2_file_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "143-161",
    "snippet": "static int ocfs2_file_release(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tspin_lock(&oi->ip_lock);\n\tif (!--oi->ip_open_count)\n\t\toi->ip_flags &= ~OCFS2_INODE_OPEN_DIRECT;\n\n\ttrace_ocfs2_file_release(inode, file, file->f_path.dentry,\n\t\t\t\t oi->ip_blkno,\n\t\t\t\t file->f_path.dentry->d_name.len,\n\t\t\t\t file->f_path.dentry->d_name.name,\n\t\t\t\t oi->ip_open_count);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_free_file_private(inode, file);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_file_private",
          "args": [
            "inode",
            "file"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_file_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "83-94",
          "snippet": "static void ocfs2_free_file_private(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (fp) {\n\t\tocfs2_simple_drop_lockres(osb, &fp->fp_flock);\n\t\tocfs2_lock_res_free(&fp->fp_flock);\n\t\tkfree(fp);\n\t\tfile->private_data = NULL;\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_free_file_private(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (fp) {\n\t\tocfs2_simple_drop_lockres(osb, &fp->fp_flock);\n\t\tocfs2_lock_res_free(&fp->fp_flock);\n\t\tkfree(fp);\n\t\tfile->private_data = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_file_release",
          "args": [
            "inode",
            "file",
            "file->f_path.dentry",
            "oi->ip_blkno",
            "file->f_path.dentry->d_name.len",
            "file->f_path.dentry->d_name.name",
            "oi->ip_open_count"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_file_release(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tspin_lock(&oi->ip_lock);\n\tif (!--oi->ip_open_count)\n\t\toi->ip_flags &= ~OCFS2_INODE_OPEN_DIRECT;\n\n\ttrace_ocfs2_file_release(inode, file, file->f_path.dentry,\n\t\t\t\t oi->ip_blkno,\n\t\t\t\t file->f_path.dentry->d_name.len,\n\t\t\t\t file->f_path.dentry->d_name.name,\n\t\t\t\t oi->ip_open_count);\n\tspin_unlock(&oi->ip_lock);\n\n\tocfs2_free_file_private(inode, file);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "96-141",
    "snippet": "static int ocfs2_file_open(struct inode *inode, struct file *file)\n{\n\tint status;\n\tint mode = file->f_flags;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\ttrace_ocfs2_file_open(inode, file, file->f_path.dentry,\n\t\t\t      (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t      file->f_path.dentry->d_name.len,\n\t\t\t      file->f_path.dentry->d_name.name, mode);\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\tdquot_initialize(inode);\n\n\tspin_lock(&oi->ip_lock);\n\n\t/* Check that the inode hasn't been wiped from disk by another\n\t * node. If it hasn't then we're safe as long as we hold the\n\t * spin lock until our increment of open count. */\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED) {\n\t\tspin_unlock(&oi->ip_lock);\n\n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tif (mode & O_DIRECT)\n\t\toi->ip_flags |= OCFS2_INODE_OPEN_DIRECT;\n\n\toi->ip_open_count++;\n\tspin_unlock(&oi->ip_lock);\n\n\tstatus = ocfs2_init_file_private(inode, file);\n\tif (status) {\n\t\t/*\n\t\t * We want to set open count back if we're failing the\n\t\t * open.\n\t\t */\n\t\tspin_lock(&oi->ip_lock);\n\t\toi->ip_open_count--;\n\t\tspin_unlock(&oi->ip_lock);\n\t}\n\nleave:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_file_private",
          "args": [
            "inode",
            "file"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_file_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
          "lines": "67-81",
          "snippet": "static int ocfs2_init_file_private(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_file_private *fp;\n\n\tfp = kzalloc(sizeof(struct ocfs2_file_private), GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tfp->fp_file = file;\n\tmutex_init(&fp->fp_mutex);\n\tocfs2_file_lock_res_init(&fp->fp_flock, fp);\n\tfile->private_data = fp;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"mmap.h\"",
            "#include \"locks.h\"",
            "#include \"journal.h\"",
            "#include \"ioctl.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_init_file_private(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_file_private *fp;\n\n\tfp = kzalloc(sizeof(struct ocfs2_file_private), GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tfp->fp_file = file;\n\tmutex_init(&fp->fp_mutex);\n\tocfs2_file_lock_res_init(&fp->fp_flock, fp);\n\tfile->private_data = fp;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "inode"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_file_open",
          "args": [
            "inode",
            "file",
            "file->f_path.dentry",
            "(unsigned long long)OCFS2_I(inode)->ip_blkno",
            "file->f_path.dentry->d_name.len",
            "file->f_path.dentry->d_name.name",
            "mode"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_file_open(struct inode *inode, struct file *file)\n{\n\tint status;\n\tint mode = file->f_flags;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\ttrace_ocfs2_file_open(inode, file, file->f_path.dentry,\n\t\t\t      (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t\t\t      file->f_path.dentry->d_name.len,\n\t\t\t      file->f_path.dentry->d_name.name, mode);\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\tdquot_initialize(inode);\n\n\tspin_lock(&oi->ip_lock);\n\n\t/* Check that the inode hasn't been wiped from disk by another\n\t * node. If it hasn't then we're safe as long as we hold the\n\t * spin lock until our increment of open count. */\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_DELETED) {\n\t\tspin_unlock(&oi->ip_lock);\n\n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tif (mode & O_DIRECT)\n\t\toi->ip_flags |= OCFS2_INODE_OPEN_DIRECT;\n\n\toi->ip_open_count++;\n\tspin_unlock(&oi->ip_lock);\n\n\tstatus = ocfs2_init_file_private(inode, file);\n\tif (status) {\n\t\t/*\n\t\t * We want to set open count back if we're failing the\n\t\t * open.\n\t\t */\n\t\tspin_lock(&oi->ip_lock);\n\t\toi->ip_open_count--;\n\t\tspin_unlock(&oi->ip_lock);\n\t}\n\nleave:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_free_file_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "83-94",
    "snippet": "static void ocfs2_free_file_private(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (fp) {\n\t\tocfs2_simple_drop_lockres(osb, &fp->fp_flock);\n\t\tocfs2_lock_res_free(&fp->fp_flock);\n\t\tkfree(fp);\n\t\tfile->private_data = NULL;\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fp"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_free",
          "args": [
            "&fp->fp_flock"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "722-749",
          "snippet": "void ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_simple_drop_lockres",
          "args": [
            "osb",
            "&fp->fp_flock"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_simple_drop_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3223-3232",
          "snippet": "void ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic void ocfs2_free_file_private(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_file_private *fp = file->private_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (fp) {\n\t\tocfs2_simple_drop_lockres(osb, &fp->fp_flock);\n\t\tocfs2_lock_res_free(&fp->fp_flock);\n\t\tkfree(fp);\n\t\tfile->private_data = NULL;\n\t}\n}"
  },
  {
    "function_name": "ocfs2_init_file_private",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/file.c",
    "lines": "67-81",
    "snippet": "static int ocfs2_init_file_private(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_file_private *fp;\n\n\tfp = kzalloc(sizeof(struct ocfs2_file_private), GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tfp->fp_file = file;\n\tmutex_init(&fp->fp_mutex);\n\tocfs2_file_lock_res_init(&fp->fp_flock, fp);\n\tfile->private_data = fp;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"refcounttree.h\"",
      "#include \"quota.h\"",
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"super.h\"",
      "#include \"suballoc.h\"",
      "#include \"mmap.h\"",
      "#include \"locks.h\"",
      "#include \"journal.h\"",
      "#include \"ioctl.h\"",
      "#include \"inode.h\"",
      "#include \"sysfile.h\"",
      "#include \"file.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"dir.h\"",
      "#include \"aops.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/falloc.h>",
      "#include <linux/writeback.h>",
      "#include <linux/mount.h>",
      "#include <linux/splice.h>",
      "#include <linux/sched.h>",
      "#include <linux/uio.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_file_lock_res_init",
          "args": [
            "&fp->fp_flock",
            "fp"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_file_lock_res_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "685-698",
          "snippet": "void ocfs2_file_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t      struct ocfs2_file_private *fp)\n{\n\tstruct inode *inode = fp->fp_file->f_mapping->host;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_FLOCK, oi->ip_blkno,\n\t\t\t      inode->i_generation, lockres->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_FLOCK, &ocfs2_flock_lops,\n\t\t\t\t   fp);\n\tlockres->l_flags |= OCFS2_LOCK_NOCACHE;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_lock_res_ops ocfs2_flock_lops = {\n\t.get_osb\t= ocfs2_get_file_osb,\n\t.flags\t\t= 0,\n};",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_flock_lops = {\n\t.get_osb\t= ocfs2_get_file_osb,\n\t.flags\t\t= 0,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_file_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t      struct ocfs2_file_private *fp)\n{\n\tstruct inode *inode = fp->fp_file->f_mapping->host;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_FLOCK, oi->ip_blkno,\n\t\t\t      inode->i_generation, lockres->l_name);\n\tocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t   OCFS2_LOCK_TYPE_FLOCK, &ocfs2_flock_lops,\n\t\t\t\t   fp);\n\tlockres->l_flags |= OCFS2_LOCK_NOCACHE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&fp->fp_mutex"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_file_private)",
            "GFP_KERNEL"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"mmap.h\"\n#include \"locks.h\"\n#include \"journal.h\"\n#include \"ioctl.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nstatic int ocfs2_init_file_private(struct inode *inode, struct file *file)\n{\n\tstruct ocfs2_file_private *fp;\n\n\tfp = kzalloc(sizeof(struct ocfs2_file_private), GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tfp->fp_file = file;\n\tmutex_init(&fp->fp_mutex);\n\tocfs2_file_lock_res_init(&fp->fp_flock, fp);\n\tfile->private_data = fp;\n\n\treturn 0;\n}"
  }
]