[
  {
    "function_name": "__journal_drop_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "753-782",
    "snippet": "void __journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_sync_datalist == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_iobuf_list == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_log_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\n\tJ_ASSERT(transaction->t_updates == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd_drop_transaction(journal, transaction);\n\tjbd_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n\tkfree(transaction);\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "transaction"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Dropping transaction %d, all done\\n\"",
            "transaction->t_tid"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd_drop_transaction",
          "args": [
            "journal",
            "transaction"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_running_transaction != transaction"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_committing_transaction != transaction"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_updates == 0"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_checkpoint_io_list == NULL"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_checkpoint_list == NULL"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_log_list == NULL"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_shadow_list == NULL"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_iobuf_list == NULL"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_forget == NULL"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_sync_datalist == NULL"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_buffers == NULL"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "transaction->t_state == T_FINISHED"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_sync_datalist == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_iobuf_list == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_log_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\n\tJ_ASSERT(transaction->t_updates == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd_drop_transaction(journal, transaction);\n\tjbd_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n\tkfree(transaction);\n}"
  },
  {
    "function_name": "__journal_insert_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "721-741",
    "snippet": "void __journal_insert_checkpoint(struct journal_head *jh,\n\t\t\t       transaction_t *transaction)\n{\n\tJBUFFER_TRACE(jh, \"entry\");\n\tJ_ASSERT_JH(jh, buffer_dirty(jh2bh(jh)) || buffer_jbddirty(jh2bh(jh)));\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\n\t/* Get reference for checkpointing transaction */\n\tjournal_grab_journal_head(jh2bh(jh));\n\tjh->b_cp_transaction = transaction;\n\n\tif (!transaction->t_checkpoint_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_list = jh;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_grab_journal_head",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "journal_grab_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1977-1988",
          "snippet": "struct journal_head *journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_cp_transaction == NULL"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "buffer_dirty(jh2bh(jh)) || buffer_jbddirty(jh2bh(jh))"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbddirty",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"entry\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __journal_insert_checkpoint(struct journal_head *jh,\n\t\t\t       transaction_t *transaction)\n{\n\tJBUFFER_TRACE(jh, \"entry\");\n\tJ_ASSERT_JH(jh, buffer_dirty(jh2bh(jh)) || buffer_jbddirty(jh2bh(jh)));\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\n\t/* Get reference for checkpointing transaction */\n\tjournal_grab_journal_head(jh2bh(jh));\n\tjh->b_cp_transaction = transaction;\n\n\tif (!transaction->t_checkpoint_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_list = jh;\n}"
  },
  {
    "function_name": "__journal_remove_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "665-711",
    "snippet": "int __journal_remove_checkpoint(struct journal_head *jh)\n{\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjournal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\n\t__journal_drop_transaction(journal, transaction);\n\n\t/* Just in case anybody was waiting for more transactions to be\n           checkpointed... */\n\twake_up(&journal->j_wait_logspace);\n\tret = 1;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_logspace"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__journal_drop_transaction",
          "args": [
            "journal",
            "transaction"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_drop_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "753-782",
          "snippet": "void __journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_sync_datalist == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_iobuf_list == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_log_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\n\tJ_ASSERT(transaction->t_updates == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd_drop_transaction(journal, transaction);\n\tjbd_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n\tkfree(transaction);\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __journal_drop_transaction(journal_t *journal, transaction_t *transaction)\n{\n\tassert_spin_locked(&journal->j_list_lock);\n\tif (transaction->t_cpnext) {\n\t\ttransaction->t_cpnext->t_cpprev = transaction->t_cpprev;\n\t\ttransaction->t_cpprev->t_cpnext = transaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions =\n\t\t\t\ttransaction->t_cpnext;\n\t\tif (journal->j_checkpoint_transactions == transaction)\n\t\t\tjournal->j_checkpoint_transactions = NULL;\n\t}\n\n\tJ_ASSERT(transaction->t_state == T_FINISHED);\n\tJ_ASSERT(transaction->t_buffers == NULL);\n\tJ_ASSERT(transaction->t_sync_datalist == NULL);\n\tJ_ASSERT(transaction->t_forget == NULL);\n\tJ_ASSERT(transaction->t_iobuf_list == NULL);\n\tJ_ASSERT(transaction->t_shadow_list == NULL);\n\tJ_ASSERT(transaction->t_log_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(transaction->t_checkpoint_io_list == NULL);\n\tJ_ASSERT(transaction->t_updates == 0);\n\tJ_ASSERT(journal->j_committing_transaction != transaction);\n\tJ_ASSERT(journal->j_running_transaction != transaction);\n\n\ttrace_jbd_drop_transaction(journal, transaction);\n\tjbd_debug(1, \"Dropping transaction %d, all done\\n\", transaction->t_tid);\n\tkfree(transaction);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_put_journal_head",
          "args": [
            "jh"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "journal_put_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "2020-2033",
          "snippet": "void journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__buffer_unlink",
          "args": [
            "jh"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "__buffer_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "51-61",
          "snippet": "static inline void __buffer_unlink(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\tif (transaction->t_checkpoint_io_list == jh) {\n\t\ttransaction->t_checkpoint_io_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_io_list == jh)\n\t\t\ttransaction->t_checkpoint_io_list = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_unlink(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\tif (transaction->t_checkpoint_io_list == jh) {\n\t\ttransaction->t_checkpoint_io_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_io_list == jh)\n\t\t\ttransaction->t_checkpoint_io_list = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"removing from transaction\""
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"not on transaction\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"entry\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint __journal_remove_checkpoint(struct journal_head *jh)\n{\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjournal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\n\t__journal_drop_transaction(journal, transaction);\n\n\t/* Just in case anybody was waiting for more transactions to be\n           checkpointed... */\n\twake_up(&journal->j_wait_logspace);\n\tret = 1;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__journal_clean_checkpoint_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "605-643",
    "snippet": "int __journal_clean_checkpoint_list(journal_t *journal)\n{\n\ttransaction_t *transaction, *last_transaction, *next_transaction;\n\tint ret = 0;\n\tint released;\n\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (!transaction)\n\t\tgoto out;\n\n\tlast_transaction = transaction->t_cpprev;\n\tnext_transaction = transaction;\n\tdo {\n\t\ttransaction = next_transaction;\n\t\tnext_transaction = transaction->t_cpnext;\n\t\tret += journal_clean_one_cp_list(transaction->\n\t\t\t\tt_checkpoint_list, &released);\n\t\t/*\n\t\t * This function only frees up some memory if possible so we\n\t\t * dont have an obligation to finish processing. Bail out if\n\t\t * preemption requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\tgoto out;\n\t\tif (released)\n\t\t\tcontinue;\n\t\t/*\n\t\t * It is essential that we are as careful as in the case of\n\t\t * t_checkpoint_list with removing the buffer from the list as\n\t\t * we can possibly see not yet submitted buffers on io_list\n\t\t */\n\t\tret += journal_clean_one_cp_list(transaction->\n\t\t\t\tt_checkpoint_io_list, &released);\n\t\tif (need_resched())\n\t\t\tgoto out;\n\t} while (transaction != last_transaction);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_clean_one_cp_list",
          "args": [
            "transaction->\n\t\t\t\tt_checkpoint_io_list",
            "&released"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "journal_clean_one_cp_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "557-593",
          "snippet": "static int journal_clean_one_cp_list(struct journal_head *jh, int *released)\n{\n\tstruct journal_head *last_jh;\n\tstruct journal_head *next_jh = jh;\n\tint ret, freed = 0;\n\n\t*released = 0;\n\tif (!jh)\n\t\treturn 0;\n\n\tlast_jh = jh->b_cpprev;\n\tdo {\n\t\tjh = next_jh;\n\t\tnext_jh = jh->b_cpnext;\n\t\t/* Use trylock because of the ranking */\n\t\tif (jbd_trylock_bh_state(jh2bh(jh))) {\n\t\t\tret = __try_to_free_cp_buf(jh);\n\t\t\tif (ret) {\n\t\t\t\tfreed++;\n\t\t\t\tif (ret == 2) {\n\t\t\t\t\t*released = 1;\n\t\t\t\t\treturn freed;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * This function only frees up some memory\n\t\t * if possible so we dont have an obligation\n\t\t * to finish processing. Bail out if preemption\n\t\t * requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\treturn freed;\n\t} while (jh != last_jh);\n\n\treturn freed;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_clean_one_cp_list(struct journal_head *jh, int *released)\n{\n\tstruct journal_head *last_jh;\n\tstruct journal_head *next_jh = jh;\n\tint ret, freed = 0;\n\n\t*released = 0;\n\tif (!jh)\n\t\treturn 0;\n\n\tlast_jh = jh->b_cpprev;\n\tdo {\n\t\tjh = next_jh;\n\t\tnext_jh = jh->b_cpnext;\n\t\t/* Use trylock because of the ranking */\n\t\tif (jbd_trylock_bh_state(jh2bh(jh))) {\n\t\t\tret = __try_to_free_cp_buf(jh);\n\t\t\tif (ret) {\n\t\t\t\tfreed++;\n\t\t\t\tif (ret == 2) {\n\t\t\t\t\t*released = 1;\n\t\t\t\t\treturn freed;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * This function only frees up some memory\n\t\t * if possible so we dont have an obligation\n\t\t * to finish processing. Bail out if preemption\n\t\t * requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\treturn freed;\n\t} while (jh != last_jh);\n\n\treturn freed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint __journal_clean_checkpoint_list(journal_t *journal)\n{\n\ttransaction_t *transaction, *last_transaction, *next_transaction;\n\tint ret = 0;\n\tint released;\n\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (!transaction)\n\t\tgoto out;\n\n\tlast_transaction = transaction->t_cpprev;\n\tnext_transaction = transaction;\n\tdo {\n\t\ttransaction = next_transaction;\n\t\tnext_transaction = transaction->t_cpnext;\n\t\tret += journal_clean_one_cp_list(transaction->\n\t\t\t\tt_checkpoint_list, &released);\n\t\t/*\n\t\t * This function only frees up some memory if possible so we\n\t\t * dont have an obligation to finish processing. Bail out if\n\t\t * preemption requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\tgoto out;\n\t\tif (released)\n\t\t\tcontinue;\n\t\t/*\n\t\t * It is essential that we are as careful as in the case of\n\t\t * t_checkpoint_list with removing the buffer from the list as\n\t\t * we can possibly see not yet submitted buffers on io_list\n\t\t */\n\t\tret += journal_clean_one_cp_list(transaction->\n\t\t\t\tt_checkpoint_io_list, &released);\n\t\tif (need_resched())\n\t\t\tgoto out;\n\t} while (transaction != last_transaction);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "journal_clean_one_cp_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "557-593",
    "snippet": "static int journal_clean_one_cp_list(struct journal_head *jh, int *released)\n{\n\tstruct journal_head *last_jh;\n\tstruct journal_head *next_jh = jh;\n\tint ret, freed = 0;\n\n\t*released = 0;\n\tif (!jh)\n\t\treturn 0;\n\n\tlast_jh = jh->b_cpprev;\n\tdo {\n\t\tjh = next_jh;\n\t\tnext_jh = jh->b_cpnext;\n\t\t/* Use trylock because of the ranking */\n\t\tif (jbd_trylock_bh_state(jh2bh(jh))) {\n\t\t\tret = __try_to_free_cp_buf(jh);\n\t\t\tif (ret) {\n\t\t\t\tfreed++;\n\t\t\t\tif (ret == 2) {\n\t\t\t\t\t*released = 1;\n\t\t\t\t\treturn freed;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * This function only frees up some memory\n\t\t * if possible so we dont have an obligation\n\t\t * to finish processing. Bail out if preemption\n\t\t * requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\treturn freed;\n\t} while (jh != last_jh);\n\n\treturn freed;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__try_to_free_cp_buf",
          "args": [
            "jh"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "__try_to_free_cp_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "93-114",
          "snippet": "static int __try_to_free_cp_buf(struct journal_head *jh)\n{\n\tint ret = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_jlist == BJ_None && !buffer_locked(bh) &&\n\t    !buffer_dirty(bh) && !buffer_write_io_error(bh)) {\n\t\t/*\n\t\t * Get our reference so that bh cannot be freed before\n\t\t * we unlock it\n\t\t */\n\t\tget_bh(bh);\n\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\tret = __journal_remove_checkpoint(jh) + 1;\n\t\tjbd_unlock_bh_state(bh);\n\t\tBUFFER_TRACE(bh, \"release\");\n\t\t__brelse(bh);\n\t} else {\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int __try_to_free_cp_buf(struct journal_head *jh)\n{\n\tint ret = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_jlist == BJ_None && !buffer_locked(bh) &&\n\t    !buffer_dirty(bh) && !buffer_write_io_error(bh)) {\n\t\t/*\n\t\t * Get our reference so that bh cannot be freed before\n\t\t * we unlock it\n\t\t */\n\t\tget_bh(bh);\n\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\tret = __journal_remove_checkpoint(jh) + 1;\n\t\tjbd_unlock_bh_state(bh);\n\t\tBUFFER_TRACE(bh, \"release\");\n\t\t__brelse(bh);\n\t} else {\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_trylock_bh_state",
          "args": [
            "jh2bh(jh)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int journal_clean_one_cp_list(struct journal_head *jh, int *released)\n{\n\tstruct journal_head *last_jh;\n\tstruct journal_head *next_jh = jh;\n\tint ret, freed = 0;\n\n\t*released = 0;\n\tif (!jh)\n\t\treturn 0;\n\n\tlast_jh = jh->b_cpprev;\n\tdo {\n\t\tjh = next_jh;\n\t\tnext_jh = jh->b_cpnext;\n\t\t/* Use trylock because of the ranking */\n\t\tif (jbd_trylock_bh_state(jh2bh(jh))) {\n\t\t\tret = __try_to_free_cp_buf(jh);\n\t\t\tif (ret) {\n\t\t\t\tfreed++;\n\t\t\t\tif (ret == 2) {\n\t\t\t\t\t*released = 1;\n\t\t\t\t\treturn freed;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * This function only frees up some memory\n\t\t * if possible so we dont have an obligation\n\t\t * to finish processing. Bail out if preemption\n\t\t * requested:\n\t\t */\n\t\tif (need_resched())\n\t\t\treturn freed;\n\t} while (jh != last_jh);\n\n\treturn freed;\n}"
  },
  {
    "function_name": "cleanup_journal_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "464-542",
    "snippet": "int cleanup_journal_tail(journal_t *journal)\n{\n\ttransaction_t * transaction;\n\ttid_t\t\tfirst_tid;\n\tunsigned int\tblocknr, freed;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\t/*\n\t * OK, work out the oldest transaction remaining in the log, and\n\t * the log block it starts at.\n\t *\n\t * If the log is now empty, we need to work out which is the\n\t * next transaction ID we will write, and where it will\n\t * start.\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = journal->j_head;\n\t} else {\n\t\tfirst_tid = journal->j_transaction_sequence;\n\t\tblocknr = journal->j_head;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tJ_ASSERT(blocknr != 0);\n\n\t/* If the oldest pinned transaction is at the tail of the log\n           already then there's not much we can do right now. */\n\tif (journal->j_tail_sequence == first_tid) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by log_do_checkpoint() --- are flushed out before we\n\t * drop the transactions from the journal. Similarly we need to be sure\n\t * superblock makes it to disk before next transaction starts reusing\n\t * freed space (otherwise we could replay some blocks of the new\n\t * transaction thinking they belong to the old one). So we use\n\t * WRITE_FLUSH_FUA. It's unlikely this will be necessary, especially\n\t * with an appropriately sized journal, but we need this to guarantee\n\t * correctness.  Fortunately cleanup_journal_tail() doesn't get called\n\t * all that often.\n\t */\n\tjournal_update_sb_log_tail(journal, first_tid, blocknr,\n\t\t\t\t   WRITE_FLUSH_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* OK, update the superblock to recover the freed space.\n\t * Physical blocks come first: have we wrapped beyond the end of\n\t * the log?  */\n\tfreed = blocknr - journal->j_tail;\n\tif (blocknr < journal->j_tail)\n\t\tfreed = freed + journal->j_last - journal->j_first;\n\n\ttrace_jbd_cleanup_journal_tail(journal, first_tid, blocknr, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %u), \"\n\t\t  \"freeing %u\\n\",\n\t\t  journal->j_tail_sequence, first_tid, blocknr, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = first_tid;\n\tjournal->j_tail = blocknr;\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Cleaning journal tail from %d to %d (offset %u), \"\n\t\t  \"freeing %u\\n\"",
            "journal->j_tail_sequence",
            "first_tid",
            "blocknr",
            "freed"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_jbd_cleanup_journal_tail",
          "args": [
            "journal",
            "first_tid",
            "blocknr",
            "freed"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_update_sb_log_tail",
          "args": [
            "journal",
            "first_tid",
            "blocknr",
            "WRITE_FLUSH_FUA"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "journal_update_sb_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1108-1127",
          "snippet": "void journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\tunsigned int tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1,\"JBD: updating superblock (start %u, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjournal_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\tspin_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);\n\nvoid journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\tunsigned int tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1,\"JBD: updating superblock (start %u, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjournal_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\tspin_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JFS_FLUSHED;\n\tspin_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "blocknr != 0"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint cleanup_journal_tail(journal_t *journal)\n{\n\ttransaction_t * transaction;\n\ttid_t\t\tfirst_tid;\n\tunsigned int\tblocknr, freed;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\t/*\n\t * OK, work out the oldest transaction remaining in the log, and\n\t * the log block it starts at.\n\t *\n\t * If the log is now empty, we need to work out which is the\n\t * next transaction ID we will write, and where it will\n\t * start.\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = journal->j_head;\n\t} else {\n\t\tfirst_tid = journal->j_transaction_sequence;\n\t\tblocknr = journal->j_head;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tJ_ASSERT(blocknr != 0);\n\n\t/* If the oldest pinned transaction is at the tail of the log\n           already then there's not much we can do right now. */\n\tif (journal->j_tail_sequence == first_tid) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by log_do_checkpoint() --- are flushed out before we\n\t * drop the transactions from the journal. Similarly we need to be sure\n\t * superblock makes it to disk before next transaction starts reusing\n\t * freed space (otherwise we could replay some blocks of the new\n\t * transaction thinking they belong to the old one). So we use\n\t * WRITE_FLUSH_FUA. It's unlikely this will be necessary, especially\n\t * with an appropriately sized journal, but we need this to guarantee\n\t * correctness.  Fortunately cleanup_journal_tail() doesn't get called\n\t * all that often.\n\t */\n\tjournal_update_sb_log_tail(journal, first_tid, blocknr,\n\t\t\t\t   WRITE_FLUSH_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* OK, update the superblock to recover the freed space.\n\t * Physical blocks come first: have we wrapped beyond the end of\n\t * the log?  */\n\tfreed = blocknr - journal->j_tail;\n\tif (blocknr < journal->j_tail)\n\t\tfreed = freed + journal->j_last - journal->j_first;\n\n\ttrace_jbd_cleanup_journal_tail(journal, first_tid, blocknr, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %u), \"\n\t\t  \"freeing %u\\n\",\n\t\t  journal->j_tail_sequence, first_tid, blocknr, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = first_tid;\n\tjournal->j_tail = blocknr;\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "log_do_checkpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "355-446",
    "snippet": "int log_do_checkpoint(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\ttid_t this_tid;\n\tint result;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = cleanup_journal_tail(journal);\n\ttrace_jbd_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions == transaction &&\n\t\t\ttransaction->t_tid == this_tid) {\n\t\tint batch_count = 0;\n\t\tstruct buffer_head *bhs[NR_BATCH];\n\t\tstruct journal_head *jh;\n\t\tint retry = 0, err;\n\n\t\twhile (!retry && transaction->t_checkpoint_list) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tjh = transaction->t_checkpoint_list;\n\t\t\tbh = jh2bh(jh);\n\t\t\tif (!jbd_trylock_bh_state(bh)) {\n\t\t\t\tjbd_sync_bh(journal, bh);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretry = __process_buffer(journal, jh, bhs,&batch_count);\n\t\t\tif (retry < 0 && !result)\n\t\t\t\tresult = retry;\n\t\t\tif (!retry && (need_resched() ||\n\t\t\t\tspin_needbreak(&journal->j_list_lock))) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (batch_count) {\n\t\t\tif (!retry) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t}\n\t\t\t__flush_batch(journal, bhs, &batch_count);\n\t\t}\n\n\t\tif (retry) {\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\t/*\n\t\t * Now we have cleaned up the first transaction's checkpoint\n\t\t * list. Let's clean up the second one\n\t\t */\n\t\terr = __wait_cp_io(journal, transaction);\n\t\tif (!result)\n\t\t\tresult = err;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjournal_abort(journal, result);\n\telse\n\t\tresult = cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define NR_BATCH\t64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cleanup_journal_tail",
          "args": [
            "journal"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_journal_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "464-542",
          "snippet": "int cleanup_journal_tail(journal_t *journal)\n{\n\ttransaction_t * transaction;\n\ttid_t\t\tfirst_tid;\n\tunsigned int\tblocknr, freed;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\t/*\n\t * OK, work out the oldest transaction remaining in the log, and\n\t * the log block it starts at.\n\t *\n\t * If the log is now empty, we need to work out which is the\n\t * next transaction ID we will write, and where it will\n\t * start.\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = journal->j_head;\n\t} else {\n\t\tfirst_tid = journal->j_transaction_sequence;\n\t\tblocknr = journal->j_head;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tJ_ASSERT(blocknr != 0);\n\n\t/* If the oldest pinned transaction is at the tail of the log\n           already then there's not much we can do right now. */\n\tif (journal->j_tail_sequence == first_tid) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by log_do_checkpoint() --- are flushed out before we\n\t * drop the transactions from the journal. Similarly we need to be sure\n\t * superblock makes it to disk before next transaction starts reusing\n\t * freed space (otherwise we could replay some blocks of the new\n\t * transaction thinking they belong to the old one). So we use\n\t * WRITE_FLUSH_FUA. It's unlikely this will be necessary, especially\n\t * with an appropriately sized journal, but we need this to guarantee\n\t * correctness.  Fortunately cleanup_journal_tail() doesn't get called\n\t * all that often.\n\t */\n\tjournal_update_sb_log_tail(journal, first_tid, blocknr,\n\t\t\t\t   WRITE_FLUSH_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* OK, update the superblock to recover the freed space.\n\t * Physical blocks come first: have we wrapped beyond the end of\n\t * the log?  */\n\tfreed = blocknr - journal->j_tail;\n\tif (blocknr < journal->j_tail)\n\t\tfreed = freed + journal->j_last - journal->j_first;\n\n\ttrace_jbd_cleanup_journal_tail(journal, first_tid, blocknr, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %u), \"\n\t\t  \"freeing %u\\n\",\n\t\t  journal->j_tail_sequence, first_tid, blocknr, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = first_tid;\n\tjournal->j_tail = blocknr;\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint cleanup_journal_tail(journal_t *journal)\n{\n\ttransaction_t * transaction;\n\ttid_t\t\tfirst_tid;\n\tunsigned int\tblocknr, freed;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\t/*\n\t * OK, work out the oldest transaction remaining in the log, and\n\t * the log block it starts at.\n\t *\n\t * If the log is now empty, we need to work out which is the\n\t * next transaction ID we will write, and where it will\n\t * start.\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = journal->j_head;\n\t} else {\n\t\tfirst_tid = journal->j_transaction_sequence;\n\t\tblocknr = journal->j_head;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tJ_ASSERT(blocknr != 0);\n\n\t/* If the oldest pinned transaction is at the tail of the log\n           already then there's not much we can do right now. */\n\tif (journal->j_tail_sequence == first_tid) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by log_do_checkpoint() --- are flushed out before we\n\t * drop the transactions from the journal. Similarly we need to be sure\n\t * superblock makes it to disk before next transaction starts reusing\n\t * freed space (otherwise we could replay some blocks of the new\n\t * transaction thinking they belong to the old one). So we use\n\t * WRITE_FLUSH_FUA. It's unlikely this will be necessary, especially\n\t * with an appropriately sized journal, but we need this to guarantee\n\t * correctness.  Fortunately cleanup_journal_tail() doesn't get called\n\t * all that often.\n\t */\n\tjournal_update_sb_log_tail(journal, first_tid, blocknr,\n\t\t\t\t   WRITE_FLUSH_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* OK, update the superblock to recover the freed space.\n\t * Physical blocks come first: have we wrapped beyond the end of\n\t * the log?  */\n\tfreed = blocknr - journal->j_tail;\n\tif (blocknr < journal->j_tail)\n\t\tfreed = freed + journal->j_last - journal->j_first;\n\n\ttrace_jbd_cleanup_journal_tail(journal, first_tid, blocknr, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %u), \"\n\t\t  \"freeing %u\\n\",\n\t\t  journal->j_tail_sequence, first_tid, blocknr, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = first_tid;\n\tjournal->j_tail = blocknr;\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_abort",
          "args": [
            "journal",
            "result"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "journal_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1759-1762",
          "snippet": "void journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wait_cp_io",
          "args": [
            "journal",
            "transaction"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_cp_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "207-253",
          "snippet": "static int __wait_cp_io(journal_t *journal, transaction_t *transaction)\n{\n\tstruct journal_head *jh;\n\tstruct buffer_head *bh;\n\ttid_t this_tid;\n\tint released = 0;\n\tint ret = 0;\n\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/* Did somebody clean up the transaction in the meanwhile? */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t\t\ttransaction->t_tid != this_tid)\n\t\treturn ret;\n\twhile (!released && transaction->t_checkpoint_io_list) {\n\t\tjh = transaction->t_checkpoint_io_list;\n\t\tbh = jh2bh(jh);\n\t\tif (!jbd_trylock_bh_state(bh)) {\n\t\t\tjbd_sync_bh(journal, bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tget_bh(bh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (unlikely(buffer_write_io_error(bh)))\n\t\t\tret = -EIO;\n\n\t\t/*\n\t\t * Now in whatever state the buffer currently is, we know that\n\t\t * it has been written out and so we can drop it from the list\n\t\t */\n\t\treleased = __journal_remove_checkpoint(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\t__brelse(bh);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int __wait_cp_io(journal_t *journal, transaction_t *transaction)\n{\n\tstruct journal_head *jh;\n\tstruct buffer_head *bh;\n\ttid_t this_tid;\n\tint released = 0;\n\tint ret = 0;\n\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/* Did somebody clean up the transaction in the meanwhile? */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t\t\ttransaction->t_tid != this_tid)\n\t\treturn ret;\n\twhile (!released && transaction->t_checkpoint_io_list) {\n\t\tjh = transaction->t_checkpoint_io_list;\n\t\tbh = jh2bh(jh);\n\t\tif (!jbd_trylock_bh_state(bh)) {\n\t\t\tjbd_sync_bh(journal, bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tget_bh(bh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (unlikely(buffer_write_io_error(bh)))\n\t\t\tret = -EIO;\n\n\t\t/*\n\t\t * Now in whatever state the buffer currently is, we know that\n\t\t * it has been written out and so we can drop it from the list\n\t\t */\n\t\treleased = __journal_remove_checkpoint(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\t__brelse(bh);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__flush_batch",
          "args": [
            "journal",
            "bhs",
            "&batch_count"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "257-275",
          "snippet": "static void\n__flush_batch(journal_t *journal, struct buffer_head **bhs, int *batch_count)\n{\n\tint i;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < *batch_count; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE_SYNC);\n\tblk_finish_plug(&plug);\n\n\tfor (i = 0; i < *batch_count; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\t\tclear_buffer_jwrite(bh);\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t}\n\t*batch_count = 0;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void\n__flush_batch(journal_t *journal, struct buffer_head **bhs, int *batch_count)\n{\n\tint i;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < *batch_count; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE_SYNC);\n\tblk_finish_plug(&plug);\n\n\tfor (i = 0; i < *batch_count; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\t\tclear_buffer_jwrite(bh);\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t}\n\t*batch_count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__process_buffer",
          "args": [
            "journal",
            "jh",
            "bhs",
            "&batch_count"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "__process_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "287-345",
          "snippet": "static int __process_buffer(journal_t *journal, struct journal_head *jh,\n\t\t\tstruct buffer_head **bhs, int *batch_count)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\tint ret = 0;\n\n\tif (buffer_locked(bh)) {\n\t\tget_bh(bh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\twait_on_buffer(bh);\n\t\t/* the journal_head may have gone by now */\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t\tret = 1;\n\t} else if (jh->b_transaction != NULL) {\n\t\ttransaction_t *t = jh->b_transaction;\n\t\ttid_t tid = t->t_tid;\n\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\tlog_start_commit(journal, tid);\n\t\tlog_wait_commit(journal, tid);\n\t\tret = 1;\n\t} else if (!buffer_dirty(bh)) {\n\t\tret = 1;\n\t\tif (unlikely(buffer_write_io_error(bh)))\n\t\t\tret = -EIO;\n\t\tget_bh(bh);\n\t\tJ_ASSERT_JH(jh, !buffer_jbddirty(bh));\n\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t__journal_remove_checkpoint(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\t__brelse(bh);\n\t} else {\n\t\t/*\n\t\t * Important: we are about to write the buffer, and\n\t\t * possibly block, while still holding the journal lock.\n\t\t * We cannot afford to let the transaction logic start\n\t\t * messing around with this buffer before we write it to\n\t\t * disk, as that would break recoverability.\n\t\t */\n\t\tBUFFER_TRACE(bh, \"queue\");\n\t\tget_bh(bh);\n\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\tset_buffer_jwrite(bh);\n\t\tbhs[*batch_count] = bh;\n\t\t__buffer_relink_io(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\t(*batch_count)++;\n\t\tif (*batch_count == NR_BATCH) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t__flush_batch(journal, bhs, batch_count);\n\t\t\tret = 1;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define NR_BATCH\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\n#define NR_BATCH\t64\n\nstatic int __process_buffer(journal_t *journal, struct journal_head *jh,\n\t\t\tstruct buffer_head **bhs, int *batch_count)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\tint ret = 0;\n\n\tif (buffer_locked(bh)) {\n\t\tget_bh(bh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\twait_on_buffer(bh);\n\t\t/* the journal_head may have gone by now */\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t\tret = 1;\n\t} else if (jh->b_transaction != NULL) {\n\t\ttransaction_t *t = jh->b_transaction;\n\t\ttid_t tid = t->t_tid;\n\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\tlog_start_commit(journal, tid);\n\t\tlog_wait_commit(journal, tid);\n\t\tret = 1;\n\t} else if (!buffer_dirty(bh)) {\n\t\tret = 1;\n\t\tif (unlikely(buffer_write_io_error(bh)))\n\t\t\tret = -EIO;\n\t\tget_bh(bh);\n\t\tJ_ASSERT_JH(jh, !buffer_jbddirty(bh));\n\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t__journal_remove_checkpoint(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\t__brelse(bh);\n\t} else {\n\t\t/*\n\t\t * Important: we are about to write the buffer, and\n\t\t * possibly block, while still holding the journal lock.\n\t\t * We cannot afford to let the transaction logic start\n\t\t * messing around with this buffer before we write it to\n\t\t * disk, as that would break recoverability.\n\t\t */\n\t\tBUFFER_TRACE(bh, \"queue\");\n\t\tget_bh(bh);\n\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\tset_buffer_jwrite(bh);\n\t\tbhs[*batch_count] = bh;\n\t\t__buffer_relink_io(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\t(*batch_count)++;\n\t\tif (*batch_count == NR_BATCH) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t__flush_batch(journal, bhs, batch_count);\n\t\t\tret = 1;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_sync_bh",
          "args": [
            "journal",
            "bh"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "jbd_sync_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "186-194",
          "snippet": "static void jbd_sync_bh(journal_t *journal, struct buffer_head *bh)\n\t__releases(journal->j_list_lock)\n{\n\tget_bh(bh);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_lock_bh_state(bh);\n\tjbd_unlock_bh_state(bh);\n\tput_bh(bh);\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void jbd_sync_bh(journal_t *journal, struct buffer_head *bh)\n\t__releases(journal->j_list_lock)\n{\n\tget_bh(bh);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_lock_bh_state(bh);\n\tjbd_unlock_bh_state(bh);\n\tput_bh(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_trylock_bh_state",
          "args": [
            "bh"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"cleanup_journal_tail returned %d\\n\"",
            "result"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_jbd_checkpoint",
          "args": [
            "journal",
            "result"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Start checkpoint\\n\""
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\n#define NR_BATCH\t64\n\nint log_do_checkpoint(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\ttid_t this_tid;\n\tint result;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = cleanup_journal_tail(journal);\n\ttrace_jbd_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions == transaction &&\n\t\t\ttransaction->t_tid == this_tid) {\n\t\tint batch_count = 0;\n\t\tstruct buffer_head *bhs[NR_BATCH];\n\t\tstruct journal_head *jh;\n\t\tint retry = 0, err;\n\n\t\twhile (!retry && transaction->t_checkpoint_list) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tjh = transaction->t_checkpoint_list;\n\t\t\tbh = jh2bh(jh);\n\t\t\tif (!jbd_trylock_bh_state(bh)) {\n\t\t\t\tjbd_sync_bh(journal, bh);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretry = __process_buffer(journal, jh, bhs,&batch_count);\n\t\t\tif (retry < 0 && !result)\n\t\t\t\tresult = retry;\n\t\t\tif (!retry && (need_resched() ||\n\t\t\t\tspin_needbreak(&journal->j_list_lock))) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (batch_count) {\n\t\t\tif (!retry) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t}\n\t\t\t__flush_batch(journal, bhs, &batch_count);\n\t\t}\n\n\t\tif (retry) {\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\t/*\n\t\t * Now we have cleaned up the first transaction's checkpoint\n\t\t * list. Let's clean up the second one\n\t\t */\n\t\terr = __wait_cp_io(journal, transaction);\n\t\tif (!result)\n\t\t\tresult = err;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjournal_abort(journal, result);\n\telse\n\t\tresult = cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}"
  },
  {
    "function_name": "__process_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "287-345",
    "snippet": "static int __process_buffer(journal_t *journal, struct journal_head *jh,\n\t\t\tstruct buffer_head **bhs, int *batch_count)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\tint ret = 0;\n\n\tif (buffer_locked(bh)) {\n\t\tget_bh(bh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\twait_on_buffer(bh);\n\t\t/* the journal_head may have gone by now */\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t\tret = 1;\n\t} else if (jh->b_transaction != NULL) {\n\t\ttransaction_t *t = jh->b_transaction;\n\t\ttid_t tid = t->t_tid;\n\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\tlog_start_commit(journal, tid);\n\t\tlog_wait_commit(journal, tid);\n\t\tret = 1;\n\t} else if (!buffer_dirty(bh)) {\n\t\tret = 1;\n\t\tif (unlikely(buffer_write_io_error(bh)))\n\t\t\tret = -EIO;\n\t\tget_bh(bh);\n\t\tJ_ASSERT_JH(jh, !buffer_jbddirty(bh));\n\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t__journal_remove_checkpoint(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\t__brelse(bh);\n\t} else {\n\t\t/*\n\t\t * Important: we are about to write the buffer, and\n\t\t * possibly block, while still holding the journal lock.\n\t\t * We cannot afford to let the transaction logic start\n\t\t * messing around with this buffer before we write it to\n\t\t * disk, as that would break recoverability.\n\t\t */\n\t\tBUFFER_TRACE(bh, \"queue\");\n\t\tget_bh(bh);\n\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\tset_buffer_jwrite(bh);\n\t\tbhs[*batch_count] = bh;\n\t\t__buffer_relink_io(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\t(*batch_count)++;\n\t\tif (*batch_count == NR_BATCH) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t__flush_batch(journal, bhs, batch_count);\n\t\t\tret = 1;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [
      "#define NR_BATCH\t64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__flush_batch",
          "args": [
            "journal",
            "bhs",
            "batch_count"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "257-275",
          "snippet": "static void\n__flush_batch(journal_t *journal, struct buffer_head **bhs, int *batch_count)\n{\n\tint i;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < *batch_count; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE_SYNC);\n\tblk_finish_plug(&plug);\n\n\tfor (i = 0; i < *batch_count; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\t\tclear_buffer_jwrite(bh);\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t}\n\t*batch_count = 0;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void\n__flush_batch(journal_t *journal, struct buffer_head **bhs, int *batch_count)\n{\n\tint i;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < *batch_count; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE_SYNC);\n\tblk_finish_plug(&plug);\n\n\tfor (i = 0; i < *batch_count; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\t\tclear_buffer_jwrite(bh);\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t}\n\t*batch_count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__buffer_relink_io",
          "args": [
            "jh"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "__buffer_relink_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "68-83",
          "snippet": "static inline void __buffer_relink_io(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\n\tif (!transaction->t_checkpoint_io_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_io_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_io_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_io_list = jh;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_relink_io(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\n\tif (!transaction->t_checkpoint_io_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_io_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_io_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_io_list = jh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_jwrite",
          "args": [
            "bh"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "!buffer_jwrite(bh)"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jwrite",
          "args": [
            "bh"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"queue\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_remove_checkpoint",
          "args": [
            "jh"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_remove_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "665-711",
          "snippet": "int __journal_remove_checkpoint(struct journal_head *jh)\n{\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjournal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\n\t__journal_drop_transaction(journal, transaction);\n\n\t/* Just in case anybody was waiting for more transactions to be\n           checkpointed... */\n\twake_up(&journal->j_wait_logspace);\n\tret = 1;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint __journal_remove_checkpoint(struct journal_head *jh)\n{\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjournal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\n\t__journal_drop_transaction(journal, transaction);\n\n\t/* Just in case anybody was waiting for more transactions to be\n           checkpointed... */\n\twake_up(&journal->j_wait_logspace);\n\tret = 1;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"remove from checkpoint\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "!buffer_jbddirty(bh)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbddirty",
          "args": [
            "bh"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buffer_write_io_error(bh)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_wait_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "569-610",
          "snippet": "int log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_start_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "490-498",
          "snippet": "int log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\tspin_lock(&journal->j_state_lock);\n\tret = __log_start_commit(journal, tid);\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\tspin_lock(&journal->j_state_lock);\n\tret = __log_start_commit(journal, tid);\n\tspin_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"brelse\""
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\n#define NR_BATCH\t64\n\nstatic int __process_buffer(journal_t *journal, struct journal_head *jh,\n\t\t\tstruct buffer_head **bhs, int *batch_count)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\tint ret = 0;\n\n\tif (buffer_locked(bh)) {\n\t\tget_bh(bh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\twait_on_buffer(bh);\n\t\t/* the journal_head may have gone by now */\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t\tret = 1;\n\t} else if (jh->b_transaction != NULL) {\n\t\ttransaction_t *t = jh->b_transaction;\n\t\ttid_t tid = t->t_tid;\n\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\tlog_start_commit(journal, tid);\n\t\tlog_wait_commit(journal, tid);\n\t\tret = 1;\n\t} else if (!buffer_dirty(bh)) {\n\t\tret = 1;\n\t\tif (unlikely(buffer_write_io_error(bh)))\n\t\t\tret = -EIO;\n\t\tget_bh(bh);\n\t\tJ_ASSERT_JH(jh, !buffer_jbddirty(bh));\n\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t__journal_remove_checkpoint(jh);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tjbd_unlock_bh_state(bh);\n\t\t__brelse(bh);\n\t} else {\n\t\t/*\n\t\t * Important: we are about to write the buffer, and\n\t\t * possibly block, while still holding the journal lock.\n\t\t * We cannot afford to let the transaction logic start\n\t\t * messing around with this buffer before we write it to\n\t\t * disk, as that would break recoverability.\n\t\t */\n\t\tBUFFER_TRACE(bh, \"queue\");\n\t\tget_bh(bh);\n\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\tset_buffer_jwrite(bh);\n\t\tbhs[*batch_count] = bh;\n\t\t__buffer_relink_io(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\t(*batch_count)++;\n\t\tif (*batch_count == NR_BATCH) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t__flush_batch(journal, bhs, batch_count);\n\t\t\tret = 1;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__flush_batch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "257-275",
    "snippet": "static void\n__flush_batch(journal_t *journal, struct buffer_head **bhs, int *batch_count)\n{\n\tint i;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < *batch_count; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE_SYNC);\n\tblk_finish_plug(&plug);\n\n\tfor (i = 0; i < *batch_count; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\t\tclear_buffer_jwrite(bh);\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t}\n\t*batch_count = 0;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"brelse\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_jwrite",
          "args": [
            "bh"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blk_finish_plug",
          "args": [
            "&plug"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_dirty_buffer",
          "args": [
            "bhs[i]",
            "WRITE_SYNC"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "write_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3115-3125",
          "snippet": "void write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid write_dirty_buffer(struct buffer_head *bh, int rw)\n{\n\tlock_buffer(bh);\n\tif (!test_clear_buffer_dirty(bh)) {\n\t\tunlock_buffer(bh);\n\t\treturn;\n\t}\n\tbh->b_end_io = end_buffer_write_sync;\n\tget_bh(bh);\n\tsubmit_bh(rw, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blk_start_plug",
          "args": [
            "&plug"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void\n__flush_batch(journal_t *journal, struct buffer_head **bhs, int *batch_count)\n{\n\tint i;\n\tstruct blk_plug plug;\n\n\tblk_start_plug(&plug);\n\tfor (i = 0; i < *batch_count; i++)\n\t\twrite_dirty_buffer(bhs[i], WRITE_SYNC);\n\tblk_finish_plug(&plug);\n\n\tfor (i = 0; i < *batch_count; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\t\tclear_buffer_jwrite(bh);\n\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t__brelse(bh);\n\t}\n\t*batch_count = 0;\n}"
  },
  {
    "function_name": "__wait_cp_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "207-253",
    "snippet": "static int __wait_cp_io(journal_t *journal, transaction_t *transaction)\n{\n\tstruct journal_head *jh;\n\tstruct buffer_head *bh;\n\ttid_t this_tid;\n\tint released = 0;\n\tint ret = 0;\n\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/* Did somebody clean up the transaction in the meanwhile? */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t\t\ttransaction->t_tid != this_tid)\n\t\treturn ret;\n\twhile (!released && transaction->t_checkpoint_io_list) {\n\t\tjh = transaction->t_checkpoint_io_list;\n\t\tbh = jh2bh(jh);\n\t\tif (!jbd_trylock_bh_state(bh)) {\n\t\t\tjbd_sync_bh(journal, bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tget_bh(bh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (unlikely(buffer_write_io_error(bh)))\n\t\t\tret = -EIO;\n\n\t\t/*\n\t\t * Now in whatever state the buffer currently is, we know that\n\t\t * it has been written out and so we can drop it from the list\n\t\t */\n\t\treleased = __journal_remove_checkpoint(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\t__brelse(bh);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_remove_checkpoint",
          "args": [
            "jh"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_remove_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "665-711",
          "snippet": "int __journal_remove_checkpoint(struct journal_head *jh)\n{\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjournal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\n\t__journal_drop_transaction(journal, transaction);\n\n\t/* Just in case anybody was waiting for more transactions to be\n           checkpointed... */\n\twake_up(&journal->j_wait_logspace);\n\tret = 1;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint __journal_remove_checkpoint(struct journal_head *jh)\n{\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjournal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\n\t__journal_drop_transaction(journal, transaction);\n\n\t/* Just in case anybody was waiting for more transactions to be\n           checkpointed... */\n\twake_up(&journal->j_wait_logspace);\n\tret = 1;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "buffer_write_io_error(bh)"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"brelse\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_sync_bh",
          "args": [
            "journal",
            "bh"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "jbd_sync_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "186-194",
          "snippet": "static void jbd_sync_bh(journal_t *journal, struct buffer_head *bh)\n\t__releases(journal->j_list_lock)\n{\n\tget_bh(bh);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_lock_bh_state(bh);\n\tjbd_unlock_bh_state(bh);\n\tput_bh(bh);\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void jbd_sync_bh(journal_t *journal, struct buffer_head *bh)\n\t__releases(journal->j_list_lock)\n{\n\tget_bh(bh);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_lock_bh_state(bh);\n\tjbd_unlock_bh_state(bh);\n\tput_bh(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_trylock_bh_state",
          "args": [
            "bh"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int __wait_cp_io(journal_t *journal, transaction_t *transaction)\n{\n\tstruct journal_head *jh;\n\tstruct buffer_head *bh;\n\ttid_t this_tid;\n\tint released = 0;\n\tint ret = 0;\n\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/* Did somebody clean up the transaction in the meanwhile? */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t\t\ttransaction->t_tid != this_tid)\n\t\treturn ret;\n\twhile (!released && transaction->t_checkpoint_io_list) {\n\t\tjh = transaction->t_checkpoint_io_list;\n\t\tbh = jh2bh(jh);\n\t\tif (!jbd_trylock_bh_state(bh)) {\n\t\t\tjbd_sync_bh(journal, bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tget_bh(bh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (unlikely(buffer_write_io_error(bh)))\n\t\t\tret = -EIO;\n\n\t\t/*\n\t\t * Now in whatever state the buffer currently is, we know that\n\t\t * it has been written out and so we can drop it from the list\n\t\t */\n\t\treleased = __journal_remove_checkpoint(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\t__brelse(bh);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "jbd_sync_bh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "186-194",
    "snippet": "static void jbd_sync_bh(journal_t *journal, struct buffer_head *bh)\n\t__releases(journal->j_list_lock)\n{\n\tget_bh(bh);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_lock_bh_state(bh);\n\tjbd_unlock_bh_state(bh);\n\tput_bh(bh);\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "journal->j_list_lock"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void jbd_sync_bh(journal_t *journal, struct buffer_head *bh)\n\t__releases(journal->j_list_lock)\n{\n\tget_bh(bh);\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_lock_bh_state(bh);\n\tjbd_unlock_bh_state(bh);\n\tput_bh(bh);\n}"
  },
  {
    "function_name": "__log_wait_for_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "122-179",
    "snippet": "void __log_wait_for_space(journal_t *journal)\n{\n\tint nblocks, space_left;\n\tassert_spin_locked(&journal->j_state_lock);\n\n\tnblocks = jbd_space_needed(journal);\n\twhile (__log_space_left(journal) < nblocks) {\n\t\tif (journal->j_flags & JFS_ABORT)\n\t\t\treturn;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\n\t\t/*\n\t\t * Test again, another process may have checkpointed while we\n\t\t * were waiting for the checkpoint lock. If there are no\n\t\t * transactions ready to be checkpointed, try to recover\n\t\t * journal space by calling cleanup_journal_tail(), and if\n\t\t * that doesn't work, by waiting for the currently committing\n\t\t * transaction to complete.  If there is absolutely no way\n\t\t * to make progress, this is either a BUG or corrupted\n\t\t * filesystem, so abort the journal and leave a stack\n\t\t * trace for forensic evidence.\n\t\t */\n\t\tspin_lock(&journal->j_state_lock);\n\t\tspin_lock(&journal->j_list_lock);\n\t\tnblocks = jbd_space_needed(journal);\n\t\tspace_left = __log_space_left(journal);\n\t\tif (space_left < nblocks) {\n\t\t\tint chkpt = journal->j_checkpoint_transactions != NULL;\n\t\t\ttid_t tid = 0;\n\n\t\t\tif (journal->j_committing_transaction)\n\t\t\t\ttid = journal->j_committing_transaction->t_tid;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tif (chkpt) {\n\t\t\t\tlog_do_checkpoint(journal);\n\t\t\t} else if (cleanup_journal_tail(journal) == 0) {\n\t\t\t\t/* We were able to recover space; yay! */\n\t\t\t\t;\n\t\t\t} else if (tid) {\n\t\t\t\tlog_wait_commit(journal, tid);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_ERR \"%s: needed %d blocks and \"\n\t\t\t\t       \"only had %d space available\\n\",\n\t\t\t\t       __func__, nblocks, space_left);\n\t\t\t\tprintk(KERN_ERR \"%s: no way to get more \"\n\t\t\t\t       \"journal space\\n\", __func__);\n\t\t\t\tWARN_ON(1);\n\t\t\t\tjournal_abort(journal, 0);\n\t\t\t}\n\t\t\tspin_lock(&journal->j_state_lock);\n\t\t} else {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t}\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_abort",
          "args": [
            "journal",
            "0"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "journal_abort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "1759-1762",
          "snippet": "void journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: no way to get more \"\n\t\t\t\t       \"journal space\\n\"",
            "__func__"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_wait_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "569-610",
          "snippet": "int log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n#ifdef CONFIG_JBD_DEBUG\n\tspin_lock(&journal->j_state_lock);\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n\tspin_unlock(&journal->j_state_lock);\n#endif\n\tspin_lock(&journal->j_state_lock);\n\t/*\n\t * Not running or committing trans? Must be already committed. This\n\t * saves us from waiting for a *long* time when tid overflows.\n\t */\n\tif (!((journal->j_running_transaction &&\n\t       journal->j_running_transaction->t_tid == tid) ||\n\t      (journal->j_committing_transaction &&\n\t       journal->j_committing_transaction->t_tid == tid)))\n\t\tgoto out_unlock;\n\n\tif (!tid_geq(journal->j_commit_waited, tid))\n\t\tjournal->j_commit_waited = tid;\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\twake_up(&journal->j_wait_commit);\n\t\tspin_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tspin_lock(&journal->j_state_lock);\n\t}\nout_unlock:\n\tspin_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_journal_tail",
          "args": [
            "journal"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_journal_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "464-542",
          "snippet": "int cleanup_journal_tail(journal_t *journal)\n{\n\ttransaction_t * transaction;\n\ttid_t\t\tfirst_tid;\n\tunsigned int\tblocknr, freed;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\t/*\n\t * OK, work out the oldest transaction remaining in the log, and\n\t * the log block it starts at.\n\t *\n\t * If the log is now empty, we need to work out which is the\n\t * next transaction ID we will write, and where it will\n\t * start.\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = journal->j_head;\n\t} else {\n\t\tfirst_tid = journal->j_transaction_sequence;\n\t\tblocknr = journal->j_head;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tJ_ASSERT(blocknr != 0);\n\n\t/* If the oldest pinned transaction is at the tail of the log\n           already then there's not much we can do right now. */\n\tif (journal->j_tail_sequence == first_tid) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by log_do_checkpoint() --- are flushed out before we\n\t * drop the transactions from the journal. Similarly we need to be sure\n\t * superblock makes it to disk before next transaction starts reusing\n\t * freed space (otherwise we could replay some blocks of the new\n\t * transaction thinking they belong to the old one). So we use\n\t * WRITE_FLUSH_FUA. It's unlikely this will be necessary, especially\n\t * with an appropriately sized journal, but we need this to guarantee\n\t * correctness.  Fortunately cleanup_journal_tail() doesn't get called\n\t * all that often.\n\t */\n\tjournal_update_sb_log_tail(journal, first_tid, blocknr,\n\t\t\t\t   WRITE_FLUSH_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* OK, update the superblock to recover the freed space.\n\t * Physical blocks come first: have we wrapped beyond the end of\n\t * the log?  */\n\tfreed = blocknr - journal->j_tail;\n\tif (blocknr < journal->j_tail)\n\t\tfreed = freed + journal->j_last - journal->j_first;\n\n\ttrace_jbd_cleanup_journal_tail(journal, first_tid, blocknr, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %u), \"\n\t\t  \"freeing %u\\n\",\n\t\t  journal->j_tail_sequence, first_tid, blocknr, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = first_tid;\n\tjournal->j_tail = blocknr;\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint cleanup_journal_tail(journal_t *journal)\n{\n\ttransaction_t * transaction;\n\ttid_t\t\tfirst_tid;\n\tunsigned int\tblocknr, freed;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\t/*\n\t * OK, work out the oldest transaction remaining in the log, and\n\t * the log block it starts at.\n\t *\n\t * If the log is now empty, we need to work out which is the\n\t * next transaction ID we will write, and where it will\n\t * start.\n\t */\n\tspin_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\tfirst_tid = transaction->t_tid;\n\t\tblocknr = journal->j_head;\n\t} else {\n\t\tfirst_tid = journal->j_transaction_sequence;\n\t\tblocknr = journal->j_head;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tJ_ASSERT(blocknr != 0);\n\n\t/* If the oldest pinned transaction is at the tail of the log\n           already then there's not much we can do right now. */\n\tif (journal->j_tail_sequence == first_tid) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 1;\n\t}\n\tspin_unlock(&journal->j_state_lock);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by log_do_checkpoint() --- are flushed out before we\n\t * drop the transactions from the journal. Similarly we need to be sure\n\t * superblock makes it to disk before next transaction starts reusing\n\t * freed space (otherwise we could replay some blocks of the new\n\t * transaction thinking they belong to the old one). So we use\n\t * WRITE_FLUSH_FUA. It's unlikely this will be necessary, especially\n\t * with an appropriately sized journal, but we need this to guarantee\n\t * correctness.  Fortunately cleanup_journal_tail() doesn't get called\n\t * all that often.\n\t */\n\tjournal_update_sb_log_tail(journal, first_tid, blocknr,\n\t\t\t\t   WRITE_FLUSH_FUA);\n\n\tspin_lock(&journal->j_state_lock);\n\t/* OK, update the superblock to recover the freed space.\n\t * Physical blocks come first: have we wrapped beyond the end of\n\t * the log?  */\n\tfreed = blocknr - journal->j_tail;\n\tif (blocknr < journal->j_tail)\n\t\tfreed = freed + journal->j_last - journal->j_first;\n\n\ttrace_jbd_cleanup_journal_tail(journal, first_tid, blocknr, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %u), \"\n\t\t  \"freeing %u\\n\",\n\t\t  journal->j_tail_sequence, first_tid, blocknr, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = first_tid;\n\tjournal->j_tail = blocknr;\n\tspin_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_do_checkpoint",
          "args": [
            "journal"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "log_do_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "355-446",
          "snippet": "int log_do_checkpoint(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\ttid_t this_tid;\n\tint result;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = cleanup_journal_tail(journal);\n\ttrace_jbd_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions == transaction &&\n\t\t\ttransaction->t_tid == this_tid) {\n\t\tint batch_count = 0;\n\t\tstruct buffer_head *bhs[NR_BATCH];\n\t\tstruct journal_head *jh;\n\t\tint retry = 0, err;\n\n\t\twhile (!retry && transaction->t_checkpoint_list) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tjh = transaction->t_checkpoint_list;\n\t\t\tbh = jh2bh(jh);\n\t\t\tif (!jbd_trylock_bh_state(bh)) {\n\t\t\t\tjbd_sync_bh(journal, bh);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretry = __process_buffer(journal, jh, bhs,&batch_count);\n\t\t\tif (retry < 0 && !result)\n\t\t\t\tresult = retry;\n\t\t\tif (!retry && (need_resched() ||\n\t\t\t\tspin_needbreak(&journal->j_list_lock))) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (batch_count) {\n\t\t\tif (!retry) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t}\n\t\t\t__flush_batch(journal, bhs, &batch_count);\n\t\t}\n\n\t\tif (retry) {\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\t/*\n\t\t * Now we have cleaned up the first transaction's checkpoint\n\t\t * list. Let's clean up the second one\n\t\t */\n\t\terr = __wait_cp_io(journal, transaction);\n\t\tif (!result)\n\t\t\tresult = err;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjournal_abort(journal, result);\n\telse\n\t\tresult = cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define NR_BATCH\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\n#define NR_BATCH\t64\n\nint log_do_checkpoint(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\ttid_t this_tid;\n\tint result;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = cleanup_journal_tail(journal);\n\ttrace_jbd_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions == transaction &&\n\t\t\ttransaction->t_tid == this_tid) {\n\t\tint batch_count = 0;\n\t\tstruct buffer_head *bhs[NR_BATCH];\n\t\tstruct journal_head *jh;\n\t\tint retry = 0, err;\n\n\t\twhile (!retry && transaction->t_checkpoint_list) {\n\t\t\tstruct buffer_head *bh;\n\n\t\t\tjh = transaction->t_checkpoint_list;\n\t\t\tbh = jh2bh(jh);\n\t\t\tif (!jbd_trylock_bh_state(bh)) {\n\t\t\t\tjbd_sync_bh(journal, bh);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tretry = __process_buffer(journal, jh, bhs,&batch_count);\n\t\t\tif (retry < 0 && !result)\n\t\t\t\tresult = retry;\n\t\t\tif (!retry && (need_resched() ||\n\t\t\t\tspin_needbreak(&journal->j_list_lock))) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (batch_count) {\n\t\t\tif (!retry) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tretry = 1;\n\t\t\t}\n\t\t\t__flush_batch(journal, bhs, &batch_count);\n\t\t}\n\n\t\tif (retry) {\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\t/*\n\t\t * Now we have cleaned up the first transaction's checkpoint\n\t\t * list. Let's clean up the second one\n\t\t */\n\t\terr = __wait_cp_io(journal, transaction);\n\t\tif (!result)\n\t\t\tresult = err;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjournal_abort(journal, result);\n\telse\n\t\tresult = cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__log_space_left",
          "args": [
            "journal"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "__log_space_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "434-453",
          "snippet": "int __log_space_left(journal_t *journal)\n{\n\tint left = journal->j_free;\n\n\tassert_spin_locked(&journal->j_state_lock);\n\n\t/*\n\t * Be pessimistic here about the number of those free blocks which\n\t * might be required for log descriptor control blocks.\n\t */\n\n#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */\n\n\tleft -= MIN_LOG_RESERVED_BLOCKS;\n\n\tif (left <= 0)\n\t\treturn 0;\n\tleft -= (left >> 3);\n\treturn left;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */\n\nint __log_space_left(journal_t *journal)\n{\n\tint left = journal->j_free;\n\n\tassert_spin_locked(&journal->j_state_lock);\n\n\t/*\n\t * Be pessimistic here about the number of those free blocks which\n\t * might be required for log descriptor control blocks.\n\t */\n\n#define MIN_LOG_RESERVED_BLOCKS 32 /* Allow for rounding errors */\n\n\tleft -= MIN_LOG_RESERVED_BLOCKS;\n\n\tif (left <= 0)\n\t\treturn 0;\n\tleft -= (left >> 3);\n\treturn left;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_space_needed",
          "args": [
            "journal"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_space_needed",
          "args": [
            "journal"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid __log_wait_for_space(journal_t *journal)\n{\n\tint nblocks, space_left;\n\tassert_spin_locked(&journal->j_state_lock);\n\n\tnblocks = jbd_space_needed(journal);\n\twhile (__log_space_left(journal) < nblocks) {\n\t\tif (journal->j_flags & JFS_ABORT)\n\t\t\treturn;\n\t\tspin_unlock(&journal->j_state_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\n\t\t/*\n\t\t * Test again, another process may have checkpointed while we\n\t\t * were waiting for the checkpoint lock. If there are no\n\t\t * transactions ready to be checkpointed, try to recover\n\t\t * journal space by calling cleanup_journal_tail(), and if\n\t\t * that doesn't work, by waiting for the currently committing\n\t\t * transaction to complete.  If there is absolutely no way\n\t\t * to make progress, this is either a BUG or corrupted\n\t\t * filesystem, so abort the journal and leave a stack\n\t\t * trace for forensic evidence.\n\t\t */\n\t\tspin_lock(&journal->j_state_lock);\n\t\tspin_lock(&journal->j_list_lock);\n\t\tnblocks = jbd_space_needed(journal);\n\t\tspace_left = __log_space_left(journal);\n\t\tif (space_left < nblocks) {\n\t\t\tint chkpt = journal->j_checkpoint_transactions != NULL;\n\t\t\ttid_t tid = 0;\n\n\t\t\tif (journal->j_committing_transaction)\n\t\t\t\ttid = journal->j_committing_transaction->t_tid;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tspin_unlock(&journal->j_state_lock);\n\t\t\tif (chkpt) {\n\t\t\t\tlog_do_checkpoint(journal);\n\t\t\t} else if (cleanup_journal_tail(journal) == 0) {\n\t\t\t\t/* We were able to recover space; yay! */\n\t\t\t\t;\n\t\t\t} else if (tid) {\n\t\t\t\tlog_wait_commit(journal, tid);\n\t\t\t} else {\n\t\t\t\tprintk(KERN_ERR \"%s: needed %d blocks and \"\n\t\t\t\t       \"only had %d space available\\n\",\n\t\t\t\t       __func__, nblocks, space_left);\n\t\t\t\tprintk(KERN_ERR \"%s: no way to get more \"\n\t\t\t\t       \"journal space\\n\", __func__);\n\t\t\t\tWARN_ON(1);\n\t\t\t\tjournal_abort(journal, 0);\n\t\t\t}\n\t\t\tspin_lock(&journal->j_state_lock);\n\t\t} else {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t}\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n}"
  },
  {
    "function_name": "__try_to_free_cp_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "93-114",
    "snippet": "static int __try_to_free_cp_buf(struct journal_head *jh)\n{\n\tint ret = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_jlist == BJ_None && !buffer_locked(bh) &&\n\t    !buffer_dirty(bh) && !buffer_write_io_error(bh)) {\n\t\t/*\n\t\t * Get our reference so that bh cannot be freed before\n\t\t * we unlock it\n\t\t */\n\t\tget_bh(bh);\n\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\tret = __journal_remove_checkpoint(jh) + 1;\n\t\tjbd_unlock_bh_state(bh);\n\t\tBUFFER_TRACE(bh, \"release\");\n\t\t__brelse(bh);\n\t} else {\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"release\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_remove_checkpoint",
          "args": [
            "jh"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_remove_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "665-711",
          "snippet": "int __journal_remove_checkpoint(struct journal_head *jh)\n{\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjournal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\n\t__journal_drop_transaction(journal, transaction);\n\n\t/* Just in case anybody was waiting for more transactions to be\n           checkpointed... */\n\twake_up(&journal->j_wait_logspace);\n\tret = 1;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint __journal_remove_checkpoint(struct journal_head *jh)\n{\n\ttransaction_t *transaction;\n\tjournal_t *journal;\n\tint ret = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tif ((transaction = jh->b_cp_transaction) == NULL) {\n\t\tJBUFFER_TRACE(jh, \"not on transaction\");\n\t\tgoto out;\n\t}\n\tjournal = transaction->t_journal;\n\n\tJBUFFER_TRACE(jh, \"removing from transaction\");\n\t__buffer_unlink(jh);\n\tjh->b_cp_transaction = NULL;\n\tjournal_put_journal_head(jh);\n\n\tif (transaction->t_checkpoint_list != NULL ||\n\t    transaction->t_checkpoint_io_list != NULL)\n\t\tgoto out;\n\n\t/*\n\t * There is one special case to worry about: if we have just pulled the\n\t * buffer off a running or committing transaction's checkpoing list,\n\t * then even if the checkpoint list is empty, the transaction obviously\n\t * cannot be dropped!\n\t *\n\t * The locking here around t_state is a bit sleazy.\n\t * See the comment at the end of journal_commit_transaction().\n\t */\n\tif (transaction->t_state != T_FINISHED)\n\t\tgoto out;\n\n\t/* OK, that was the last buffer for the transaction: we can now\n\t   safely remove this transaction from the log */\n\n\t__journal_drop_transaction(journal, transaction);\n\n\t/* Just in case anybody was waiting for more transactions to be\n           checkpointed... */\n\twake_up(&journal->j_wait_logspace);\n\tret = 1;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh",
            "\"remove from checkpoint list\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic int __try_to_free_cp_buf(struct journal_head *jh)\n{\n\tint ret = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (jh->b_jlist == BJ_None && !buffer_locked(bh) &&\n\t    !buffer_dirty(bh) && !buffer_write_io_error(bh)) {\n\t\t/*\n\t\t * Get our reference so that bh cannot be freed before\n\t\t * we unlock it\n\t\t */\n\t\tget_bh(bh);\n\t\tJBUFFER_TRACE(jh, \"remove from checkpoint list\");\n\t\tret = __journal_remove_checkpoint(jh) + 1;\n\t\tjbd_unlock_bh_state(bh);\n\t\tBUFFER_TRACE(bh, \"release\");\n\t\t__brelse(bh);\n\t} else {\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__buffer_relink_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "68-83",
    "snippet": "static inline void __buffer_relink_io(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\n\tif (!transaction->t_checkpoint_io_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_io_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_io_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_io_list = jh;\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__buffer_unlink_first",
          "args": [
            "jh"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "__buffer_unlink_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "33-44",
          "snippet": "static inline void __buffer_unlink_first(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_unlink_first(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_relink_io(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\n\tif (!transaction->t_checkpoint_io_list) {\n\t\tjh->b_cpnext = jh->b_cpprev = jh;\n\t} else {\n\t\tjh->b_cpnext = transaction->t_checkpoint_io_list;\n\t\tjh->b_cpprev = transaction->t_checkpoint_io_list->b_cpprev;\n\t\tjh->b_cpprev->b_cpnext = jh;\n\t\tjh->b_cpnext->b_cpprev = jh;\n\t}\n\ttransaction->t_checkpoint_io_list = jh;\n}"
  },
  {
    "function_name": "__buffer_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "51-61",
    "snippet": "static inline void __buffer_unlink(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\tif (transaction->t_checkpoint_io_list == jh) {\n\t\ttransaction->t_checkpoint_io_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_io_list == jh)\n\t\t\ttransaction->t_checkpoint_io_list = NULL;\n\t}\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__buffer_unlink_first",
          "args": [
            "jh"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "__buffer_unlink_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
          "lines": "33-44",
          "snippet": "static inline void __buffer_unlink_first(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/jbd.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_unlink_first(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_unlink(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\t__buffer_unlink_first(jh);\n\tif (transaction->t_checkpoint_io_list == jh) {\n\t\ttransaction->t_checkpoint_io_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_io_list == jh)\n\t\t\ttransaction->t_checkpoint_io_list = NULL;\n\t}\n}"
  },
  {
    "function_name": "__buffer_unlink_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/checkpoint.c",
    "lines": "33-44",
    "snippet": "static inline void __buffer_unlink_first(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}",
    "includes": [
      "#include <trace/events/jbd.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/jbd.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic inline void __buffer_unlink_first(struct journal_head *jh)\n{\n\ttransaction_t *transaction = jh->b_cp_transaction;\n\n\tjh->b_cpnext->b_cpprev = jh->b_cpprev;\n\tjh->b_cpprev->b_cpnext = jh->b_cpnext;\n\tif (transaction->t_checkpoint_list == jh) {\n\t\ttransaction->t_checkpoint_list = jh->b_cpnext;\n\t\tif (transaction->t_checkpoint_list == jh)\n\t\t\ttransaction->t_checkpoint_list = NULL;\n\t}\n}"
  }
]