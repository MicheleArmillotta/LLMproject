[
  {
    "function_name": "exit_msdos_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "676-679",
    "snippet": "static void __exit exit_msdos_fs(void)\n{\n\tunregister_filesystem(&msdos_fs_type);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type msdos_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"msdos\",\n\t.mount\t\t= msdos_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&msdos_fs_type"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct file_system_type msdos_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"msdos\",\n\t.mount\t\t= msdos_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_msdos_fs(void)\n{\n\tunregister_filesystem(&msdos_fs_type);\n}"
  },
  {
    "function_name": "init_msdos_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "671-674",
    "snippet": "static int __init init_msdos_fs(void)\n{\n\treturn register_filesystem(&msdos_fs_type);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type msdos_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"msdos\",\n\t.mount\t\t= msdos_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&msdos_fs_type"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct file_system_type msdos_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"msdos\",\n\t.mount\t\t= msdos_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_msdos_fs(void)\n{\n\treturn register_filesystem(&msdos_fs_type);\n}"
  },
  {
    "function_name": "msdos_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "655-660",
    "snippet": "static struct dentry *msdos_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name,\n\t\t\tvoid *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, msdos_fill_super);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "msdos_fill_super"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct dentry *msdos_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name,\n\t\t\tvoid *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, msdos_fill_super);\n}"
  },
  {
    "function_name": "msdos_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "650-653",
    "snippet": "static int msdos_fill_super(struct super_block *sb, void *data, int silent)\n{\n\treturn fat_fill_super(sb, data, silent, 0, setup);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_fill_super",
          "args": [
            "sb",
            "data",
            "silent",
            "0",
            "setup"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "fat_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1496-1783",
          "snippet": "int fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,\n\t\t   void (*setup)(struct super_block *))\n{\n\tstruct inode *root_inode = NULL, *fat_inode = NULL;\n\tstruct inode *fsinfo_inode = NULL;\n\tstruct buffer_head *bh;\n\tstruct fat_bios_param_block bpb;\n\tstruct msdos_sb_info *sbi;\n\tu16 logical_sector_size;\n\tu32 total_sectors, total_clusters, fat_clusters, rootdir_sectors;\n\tint debug;\n\tlong error;\n\tchar buf[50];\n\n\t/*\n\t * GFP_KERNEL is ok here, because while we do hold the\n\t * supeblock lock, memory pressure can't call back into\n\t * the filesystem, since we're only just about to mount\n\t * it and have no inodes etc active!\n\t */\n\tsbi = kzalloc(sizeof(struct msdos_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\n\tsb->s_flags |= MS_NODIRATIME;\n\tsb->s_magic = MSDOS_SUPER_MAGIC;\n\tsb->s_op = &fat_sops;\n\tsb->s_export_op = &fat_export_ops;\n\tmutex_init(&sbi->nfs_build_inode_lock);\n\tratelimit_state_init(&sbi->ratelimit, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t     DEFAULT_RATELIMIT_BURST);\n\n\terror = parse_options(sb, data, isvfat, silent, &debug, &sbi->options);\n\tif (error)\n\t\tgoto out_fail;\n\n\tsetup(sb); /* flavour-specific stuff that needs options */\n\n\terror = -EIO;\n\tsb_min_blocksize(sb, 512);\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\");\n\t\tgoto out_fail;\n\t}\n\n\terror = fat_read_bpb(sb, (struct fat_boot_sector *)bh->b_data, silent,\n\t\t&bpb);\n\tif (error == -EINVAL && sbi->options.dos1xfloppy)\n\t\terror = fat_read_static_bpb(sb,\n\t\t\t(struct fat_boot_sector *)bh->b_data, silent, &bpb);\n\tbrelse(bh);\n\n\tif (error == -EINVAL)\n\t\tgoto out_invalid;\n\telse if (error)\n\t\tgoto out_fail;\n\n\tlogical_sector_size = bpb.fat_sector_size;\n\tsbi->sec_per_clus = bpb.fat_sec_per_clus;\n\n\terror = -EIO;\n\tif (logical_sector_size < sb->s_blocksize) {\n\t\tfat_msg(sb, KERN_ERR, \"logical sector size too small for device\"\n\t\t       \" (logical sector size = %u)\", logical_sector_size);\n\t\tgoto out_fail;\n\t}\n\n\tif (logical_sector_size > sb->s_blocksize) {\n\t\tstruct buffer_head *bh_resize;\n\n\t\tif (!sb_set_blocksize(sb, logical_sector_size)) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to set blocksize %u\",\n\t\t\t       logical_sector_size);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\t/* Verify that the larger boot sector is fully readable */\n\t\tbh_resize = sb_bread(sb, 0);\n\t\tif (bh_resize == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\"\n\t\t\t       \" (logical sector size = %lu)\",\n\t\t\t       sb->s_blocksize);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tbrelse(bh_resize);\n\t}\n\n\tmutex_init(&sbi->s_lock);\n\tsbi->cluster_size = sb->s_blocksize * sbi->sec_per_clus;\n\tsbi->cluster_bits = ffs(sbi->cluster_size) - 1;\n\tsbi->fats = bpb.fat_fats;\n\tsbi->fat_bits = 0;\t\t/* Don't know yet */\n\tsbi->fat_start = bpb.fat_reserved;\n\tsbi->fat_length = bpb.fat_fat_length;\n\tsbi->root_cluster = 0;\n\tsbi->free_clusters = -1;\t/* Don't know yet */\n\tsbi->free_clus_valid = 0;\n\tsbi->prev_free = FAT_START_ENT;\n\tsb->s_maxbytes = 0xffffffff;\n\n\tif (!sbi->fat_length && bpb.fat32_length) {\n\t\tstruct fat_boot_fsinfo *fsinfo;\n\t\tstruct buffer_head *fsinfo_bh;\n\n\t\t/* Must be FAT32 */\n\t\tsbi->fat_bits = 32;\n\t\tsbi->fat_length = bpb.fat32_length;\n\t\tsbi->root_cluster = bpb.fat32_root_cluster;\n\n\t\t/* MC - if info_sector is 0, don't multiply by 0 */\n\t\tsbi->fsinfo_sector = bpb.fat32_info_sector;\n\t\tif (sbi->fsinfo_sector == 0)\n\t\t\tsbi->fsinfo_sector = 1;\n\n\t\tfsinfo_bh = sb_bread(sb, sbi->fsinfo_sector);\n\t\tif (fsinfo_bh == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"bread failed, FSINFO block\"\n\t\t\t       \" (sector = %lu)\", sbi->fsinfo_sector);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tfsinfo = (struct fat_boot_fsinfo *)fsinfo_bh->b_data;\n\t\tif (!IS_FSINFO(fsinfo)) {\n\t\t\tfat_msg(sb, KERN_WARNING, \"Invalid FSINFO signature: \"\n\t\t\t       \"0x%08x, 0x%08x (sector = %lu)\",\n\t\t\t       le32_to_cpu(fsinfo->signature1),\n\t\t\t       le32_to_cpu(fsinfo->signature2),\n\t\t\t       sbi->fsinfo_sector);\n\t\t} else {\n\t\t\tif (sbi->options.usefree)\n\t\t\t\tsbi->free_clus_valid = 1;\n\t\t\tsbi->free_clusters = le32_to_cpu(fsinfo->free_clusters);\n\t\t\tsbi->prev_free = le32_to_cpu(fsinfo->next_cluster);\n\t\t}\n\n\t\tbrelse(fsinfo_bh);\n\t}\n\n\t/* interpret volume ID as a little endian 32 bit integer */\n\tif (sbi->fat_bits == 32)\n\t\tsbi->vol_id = bpb.fat32_vol_id;\n\telse /* fat 16 or 12 */\n\t\tsbi->vol_id = bpb.fat16_vol_id;\n\n\tsbi->dir_per_block = sb->s_blocksize / sizeof(struct msdos_dir_entry);\n\tsbi->dir_per_block_bits = ffs(sbi->dir_per_block) - 1;\n\n\tsbi->dir_start = sbi->fat_start + sbi->fats * sbi->fat_length;\n\tsbi->dir_entries = bpb.fat_dir_entries;\n\tif (sbi->dir_entries & (sbi->dir_per_block - 1)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus directory-entries per block\"\n\t\t\t       \" (%u)\", sbi->dir_entries);\n\t\tgoto out_invalid;\n\t}\n\n\trootdir_sectors = sbi->dir_entries\n\t\t* sizeof(struct msdos_dir_entry) / sb->s_blocksize;\n\tsbi->data_start = sbi->dir_start + rootdir_sectors;\n\ttotal_sectors = bpb.fat_sectors;\n\tif (total_sectors == 0)\n\t\ttotal_sectors = bpb.fat_total_sect;\n\n\ttotal_clusters = (total_sectors - sbi->data_start) / sbi->sec_per_clus;\n\n\tif (sbi->fat_bits != 32)\n\t\tsbi->fat_bits = (total_clusters > MAX_FAT12) ? 16 : 12;\n\n\t/* some OSes set FAT_STATE_DIRTY and clean it on unmount. */\n\tif (sbi->fat_bits == 32)\n\t\tsbi->dirty = bpb.fat32_state & FAT_STATE_DIRTY;\n\telse /* fat 16 or 12 */\n\t\tsbi->dirty = bpb.fat16_state & FAT_STATE_DIRTY;\n\n\t/* check that FAT table does not overflow */\n\tfat_clusters = calc_fat_clusters(sb);\n\ttotal_clusters = min(total_clusters, fat_clusters - FAT_START_ENT);\n\tif (total_clusters > MAX_FAT(sb)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"count of clusters too big (%u)\",\n\t\t\t       total_clusters);\n\t\tgoto out_invalid;\n\t}\n\n\tsbi->max_cluster = total_clusters + FAT_START_ENT;\n\t/* check the free_clusters, it's not necessarily correct */\n\tif (sbi->free_clusters != -1 && sbi->free_clusters > total_clusters)\n\t\tsbi->free_clusters = -1;\n\t/* check the prev_free, it's not necessarily correct */\n\tsbi->prev_free %= sbi->max_cluster;\n\tif (sbi->prev_free < FAT_START_ENT)\n\t\tsbi->prev_free = FAT_START_ENT;\n\n\t/* set up enough so that it can read an inode */\n\tfat_hash_init(sb);\n\tdir_hash_init(sb);\n\tfat_ent_access_init(sb);\n\n\t/*\n\t * The low byte of FAT's first entry must have same value with\n\t * media-field.  But in real world, too many devices is\n\t * writing wrong value.  So, removed that validity check.\n\t *\n\t * if (FAT_FIRST_ENT(sb, media) != first)\n\t */\n\n\terror = -EINVAL;\n\tsprintf(buf, \"cp%d\", sbi->options.codepage);\n\tsbi->nls_disk = load_nls(buf);\n\tif (!sbi->nls_disk) {\n\t\tfat_msg(sb, KERN_ERR, \"codepage %s not found\", buf);\n\t\tgoto out_fail;\n\t}\n\n\t/* FIXME: utf8 is using iocharset for upper/lower conversion */\n\tif (sbi->options.isvfat) {\n\t\tsbi->nls_io = load_nls(sbi->options.iocharset);\n\t\tif (!sbi->nls_io) {\n\t\t\tfat_msg(sb, KERN_ERR, \"IO charset %s not found\",\n\t\t\t       sbi->options.iocharset);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\terror = -ENOMEM;\n\tfat_inode = new_inode(sb);\n\tif (!fat_inode)\n\t\tgoto out_fail;\n\tMSDOS_I(fat_inode)->i_pos = 0;\n\tsbi->fat_inode = fat_inode;\n\n\tfsinfo_inode = new_inode(sb);\n\tif (!fsinfo_inode)\n\t\tgoto out_fail;\n\tfsinfo_inode->i_ino = MSDOS_FSINFO_INO;\n\tsbi->fsinfo_inode = fsinfo_inode;\n\tinsert_inode_hash(fsinfo_inode);\n\n\troot_inode = new_inode(sb);\n\tif (!root_inode)\n\t\tgoto out_fail;\n\troot_inode->i_ino = MSDOS_ROOT_INO;\n\troot_inode->i_version = 1;\n\terror = fat_read_root(root_inode);\n\tif (error < 0) {\n\t\tiput(root_inode);\n\t\tgoto out_fail;\n\t}\n\terror = -ENOMEM;\n\tinsert_inode_hash(root_inode);\n\tfat_attach(root_inode, 0);\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tfat_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tgoto out_fail;\n\t}\n\n\tif (sbi->options.discard) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\t\t\"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t\t\"the device does not support discard\");\n\t}\n\n\tfat_set_state(sb, 1, 0);\n\treturn 0;\n\nout_invalid:\n\terror = -EINVAL;\n\tif (!silent)\n\t\tfat_msg(sb, KERN_INFO, \"Can't find a valid FAT filesystem\");\n\nout_fail:\n\tif (fsinfo_inode)\n\t\tiput(fsinfo_inode);\n\tif (fat_inode)\n\t\tiput(fat_inode);\n\tunload_nls(sbi->nls_io);\n\tunload_nls(sbi->nls_disk);\n\tif (sbi->options.iocharset != fat_default_iocharset)\n\t\tkfree(sbi->options.iocharset);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n\treturn error;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;",
            "static int fat_show_options(struct seq_file *m, struct dentry *root);",
            "static const struct super_operations fat_sops = {\n\t.alloc_inode\t= fat_alloc_inode,\n\t.destroy_inode\t= fat_destroy_inode,\n\t.write_inode\t= fat_write_inode,\n\t.evict_inode\t= fat_evict_inode,\n\t.put_super\t= fat_put_super,\n\t.statfs\t\t= fat_statfs,\n\t.remount_fs\t= fat_remount,\n\n\t.show_options\t= fat_show_options,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic char fat_default_iocharset[] = CONFIG_FAT_DEFAULT_IOCHARSET;\nstatic int fat_show_options(struct seq_file *m, struct dentry *root);\nstatic const struct super_operations fat_sops = {\n\t.alloc_inode\t= fat_alloc_inode,\n\t.destroy_inode\t= fat_destroy_inode,\n\t.write_inode\t= fat_write_inode,\n\t.evict_inode\t= fat_evict_inode,\n\t.put_super\t= fat_put_super,\n\t.statfs\t\t= fat_statfs,\n\t.remount_fs\t= fat_remount,\n\n\t.show_options\t= fat_show_options,\n};\n\nint fat_fill_super(struct super_block *sb, void *data, int silent, int isvfat,\n\t\t   void (*setup)(struct super_block *))\n{\n\tstruct inode *root_inode = NULL, *fat_inode = NULL;\n\tstruct inode *fsinfo_inode = NULL;\n\tstruct buffer_head *bh;\n\tstruct fat_bios_param_block bpb;\n\tstruct msdos_sb_info *sbi;\n\tu16 logical_sector_size;\n\tu32 total_sectors, total_clusters, fat_clusters, rootdir_sectors;\n\tint debug;\n\tlong error;\n\tchar buf[50];\n\n\t/*\n\t * GFP_KERNEL is ok here, because while we do hold the\n\t * supeblock lock, memory pressure can't call back into\n\t * the filesystem, since we're only just about to mount\n\t * it and have no inodes etc active!\n\t */\n\tsbi = kzalloc(sizeof(struct msdos_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\tsb->s_fs_info = sbi;\n\n\tsb->s_flags |= MS_NODIRATIME;\n\tsb->s_magic = MSDOS_SUPER_MAGIC;\n\tsb->s_op = &fat_sops;\n\tsb->s_export_op = &fat_export_ops;\n\tmutex_init(&sbi->nfs_build_inode_lock);\n\tratelimit_state_init(&sbi->ratelimit, DEFAULT_RATELIMIT_INTERVAL,\n\t\t\t     DEFAULT_RATELIMIT_BURST);\n\n\terror = parse_options(sb, data, isvfat, silent, &debug, &sbi->options);\n\tif (error)\n\t\tgoto out_fail;\n\n\tsetup(sb); /* flavour-specific stuff that needs options */\n\n\terror = -EIO;\n\tsb_min_blocksize(sb, 512);\n\tbh = sb_bread(sb, 0);\n\tif (bh == NULL) {\n\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\");\n\t\tgoto out_fail;\n\t}\n\n\terror = fat_read_bpb(sb, (struct fat_boot_sector *)bh->b_data, silent,\n\t\t&bpb);\n\tif (error == -EINVAL && sbi->options.dos1xfloppy)\n\t\terror = fat_read_static_bpb(sb,\n\t\t\t(struct fat_boot_sector *)bh->b_data, silent, &bpb);\n\tbrelse(bh);\n\n\tif (error == -EINVAL)\n\t\tgoto out_invalid;\n\telse if (error)\n\t\tgoto out_fail;\n\n\tlogical_sector_size = bpb.fat_sector_size;\n\tsbi->sec_per_clus = bpb.fat_sec_per_clus;\n\n\terror = -EIO;\n\tif (logical_sector_size < sb->s_blocksize) {\n\t\tfat_msg(sb, KERN_ERR, \"logical sector size too small for device\"\n\t\t       \" (logical sector size = %u)\", logical_sector_size);\n\t\tgoto out_fail;\n\t}\n\n\tif (logical_sector_size > sb->s_blocksize) {\n\t\tstruct buffer_head *bh_resize;\n\n\t\tif (!sb_set_blocksize(sb, logical_sector_size)) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to set blocksize %u\",\n\t\t\t       logical_sector_size);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\t/* Verify that the larger boot sector is fully readable */\n\t\tbh_resize = sb_bread(sb, 0);\n\t\tif (bh_resize == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"unable to read boot sector\"\n\t\t\t       \" (logical sector size = %lu)\",\n\t\t\t       sb->s_blocksize);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tbrelse(bh_resize);\n\t}\n\n\tmutex_init(&sbi->s_lock);\n\tsbi->cluster_size = sb->s_blocksize * sbi->sec_per_clus;\n\tsbi->cluster_bits = ffs(sbi->cluster_size) - 1;\n\tsbi->fats = bpb.fat_fats;\n\tsbi->fat_bits = 0;\t\t/* Don't know yet */\n\tsbi->fat_start = bpb.fat_reserved;\n\tsbi->fat_length = bpb.fat_fat_length;\n\tsbi->root_cluster = 0;\n\tsbi->free_clusters = -1;\t/* Don't know yet */\n\tsbi->free_clus_valid = 0;\n\tsbi->prev_free = FAT_START_ENT;\n\tsb->s_maxbytes = 0xffffffff;\n\n\tif (!sbi->fat_length && bpb.fat32_length) {\n\t\tstruct fat_boot_fsinfo *fsinfo;\n\t\tstruct buffer_head *fsinfo_bh;\n\n\t\t/* Must be FAT32 */\n\t\tsbi->fat_bits = 32;\n\t\tsbi->fat_length = bpb.fat32_length;\n\t\tsbi->root_cluster = bpb.fat32_root_cluster;\n\n\t\t/* MC - if info_sector is 0, don't multiply by 0 */\n\t\tsbi->fsinfo_sector = bpb.fat32_info_sector;\n\t\tif (sbi->fsinfo_sector == 0)\n\t\t\tsbi->fsinfo_sector = 1;\n\n\t\tfsinfo_bh = sb_bread(sb, sbi->fsinfo_sector);\n\t\tif (fsinfo_bh == NULL) {\n\t\t\tfat_msg(sb, KERN_ERR, \"bread failed, FSINFO block\"\n\t\t\t       \" (sector = %lu)\", sbi->fsinfo_sector);\n\t\t\tgoto out_fail;\n\t\t}\n\n\t\tfsinfo = (struct fat_boot_fsinfo *)fsinfo_bh->b_data;\n\t\tif (!IS_FSINFO(fsinfo)) {\n\t\t\tfat_msg(sb, KERN_WARNING, \"Invalid FSINFO signature: \"\n\t\t\t       \"0x%08x, 0x%08x (sector = %lu)\",\n\t\t\t       le32_to_cpu(fsinfo->signature1),\n\t\t\t       le32_to_cpu(fsinfo->signature2),\n\t\t\t       sbi->fsinfo_sector);\n\t\t} else {\n\t\t\tif (sbi->options.usefree)\n\t\t\t\tsbi->free_clus_valid = 1;\n\t\t\tsbi->free_clusters = le32_to_cpu(fsinfo->free_clusters);\n\t\t\tsbi->prev_free = le32_to_cpu(fsinfo->next_cluster);\n\t\t}\n\n\t\tbrelse(fsinfo_bh);\n\t}\n\n\t/* interpret volume ID as a little endian 32 bit integer */\n\tif (sbi->fat_bits == 32)\n\t\tsbi->vol_id = bpb.fat32_vol_id;\n\telse /* fat 16 or 12 */\n\t\tsbi->vol_id = bpb.fat16_vol_id;\n\n\tsbi->dir_per_block = sb->s_blocksize / sizeof(struct msdos_dir_entry);\n\tsbi->dir_per_block_bits = ffs(sbi->dir_per_block) - 1;\n\n\tsbi->dir_start = sbi->fat_start + sbi->fats * sbi->fat_length;\n\tsbi->dir_entries = bpb.fat_dir_entries;\n\tif (sbi->dir_entries & (sbi->dir_per_block - 1)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"bogus directory-entries per block\"\n\t\t\t       \" (%u)\", sbi->dir_entries);\n\t\tgoto out_invalid;\n\t}\n\n\trootdir_sectors = sbi->dir_entries\n\t\t* sizeof(struct msdos_dir_entry) / sb->s_blocksize;\n\tsbi->data_start = sbi->dir_start + rootdir_sectors;\n\ttotal_sectors = bpb.fat_sectors;\n\tif (total_sectors == 0)\n\t\ttotal_sectors = bpb.fat_total_sect;\n\n\ttotal_clusters = (total_sectors - sbi->data_start) / sbi->sec_per_clus;\n\n\tif (sbi->fat_bits != 32)\n\t\tsbi->fat_bits = (total_clusters > MAX_FAT12) ? 16 : 12;\n\n\t/* some OSes set FAT_STATE_DIRTY and clean it on unmount. */\n\tif (sbi->fat_bits == 32)\n\t\tsbi->dirty = bpb.fat32_state & FAT_STATE_DIRTY;\n\telse /* fat 16 or 12 */\n\t\tsbi->dirty = bpb.fat16_state & FAT_STATE_DIRTY;\n\n\t/* check that FAT table does not overflow */\n\tfat_clusters = calc_fat_clusters(sb);\n\ttotal_clusters = min(total_clusters, fat_clusters - FAT_START_ENT);\n\tif (total_clusters > MAX_FAT(sb)) {\n\t\tif (!silent)\n\t\t\tfat_msg(sb, KERN_ERR, \"count of clusters too big (%u)\",\n\t\t\t       total_clusters);\n\t\tgoto out_invalid;\n\t}\n\n\tsbi->max_cluster = total_clusters + FAT_START_ENT;\n\t/* check the free_clusters, it's not necessarily correct */\n\tif (sbi->free_clusters != -1 && sbi->free_clusters > total_clusters)\n\t\tsbi->free_clusters = -1;\n\t/* check the prev_free, it's not necessarily correct */\n\tsbi->prev_free %= sbi->max_cluster;\n\tif (sbi->prev_free < FAT_START_ENT)\n\t\tsbi->prev_free = FAT_START_ENT;\n\n\t/* set up enough so that it can read an inode */\n\tfat_hash_init(sb);\n\tdir_hash_init(sb);\n\tfat_ent_access_init(sb);\n\n\t/*\n\t * The low byte of FAT's first entry must have same value with\n\t * media-field.  But in real world, too many devices is\n\t * writing wrong value.  So, removed that validity check.\n\t *\n\t * if (FAT_FIRST_ENT(sb, media) != first)\n\t */\n\n\terror = -EINVAL;\n\tsprintf(buf, \"cp%d\", sbi->options.codepage);\n\tsbi->nls_disk = load_nls(buf);\n\tif (!sbi->nls_disk) {\n\t\tfat_msg(sb, KERN_ERR, \"codepage %s not found\", buf);\n\t\tgoto out_fail;\n\t}\n\n\t/* FIXME: utf8 is using iocharset for upper/lower conversion */\n\tif (sbi->options.isvfat) {\n\t\tsbi->nls_io = load_nls(sbi->options.iocharset);\n\t\tif (!sbi->nls_io) {\n\t\t\tfat_msg(sb, KERN_ERR, \"IO charset %s not found\",\n\t\t\t       sbi->options.iocharset);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\terror = -ENOMEM;\n\tfat_inode = new_inode(sb);\n\tif (!fat_inode)\n\t\tgoto out_fail;\n\tMSDOS_I(fat_inode)->i_pos = 0;\n\tsbi->fat_inode = fat_inode;\n\n\tfsinfo_inode = new_inode(sb);\n\tif (!fsinfo_inode)\n\t\tgoto out_fail;\n\tfsinfo_inode->i_ino = MSDOS_FSINFO_INO;\n\tsbi->fsinfo_inode = fsinfo_inode;\n\tinsert_inode_hash(fsinfo_inode);\n\n\troot_inode = new_inode(sb);\n\tif (!root_inode)\n\t\tgoto out_fail;\n\troot_inode->i_ino = MSDOS_ROOT_INO;\n\troot_inode->i_version = 1;\n\terror = fat_read_root(root_inode);\n\tif (error < 0) {\n\t\tiput(root_inode);\n\t\tgoto out_fail;\n\t}\n\terror = -ENOMEM;\n\tinsert_inode_hash(root_inode);\n\tfat_attach(root_inode, 0);\n\tsb->s_root = d_make_root(root_inode);\n\tif (!sb->s_root) {\n\t\tfat_msg(sb, KERN_ERR, \"get root inode failed\");\n\t\tgoto out_fail;\n\t}\n\n\tif (sbi->options.discard) {\n\t\tstruct request_queue *q = bdev_get_queue(sb->s_bdev);\n\t\tif (!blk_queue_discard(q))\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t\t\t\"mounting with \\\"discard\\\" option, but \"\n\t\t\t\t\t\"the device does not support discard\");\n\t}\n\n\tfat_set_state(sb, 1, 0);\n\treturn 0;\n\nout_invalid:\n\terror = -EINVAL;\n\tif (!silent)\n\t\tfat_msg(sb, KERN_INFO, \"Can't find a valid FAT filesystem\");\n\nout_fail:\n\tif (fsinfo_inode)\n\t\tiput(fsinfo_inode);\n\tif (fat_inode)\n\t\tiput(fat_inode);\n\tunload_nls(sbi->nls_io);\n\tunload_nls(sbi->nls_disk);\n\tif (sbi->options.iocharset != fat_default_iocharset)\n\t\tkfree(sbi->options.iocharset);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_fill_super(struct super_block *sb, void *data, int silent)\n{\n\treturn fat_fill_super(sb, data, silent, 0, setup);\n}"
  },
  {
    "function_name": "setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "643-648",
    "snippet": "static void setup(struct super_block *sb)\n{\n\tMSDOS_SB(sb)->dir_ops = &msdos_dir_inode_operations;\n\tsb->s_d_op = &msdos_dentry_operations;\n\tsb->s_flags |= MS_NOATIME;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct dentry_operations msdos_dentry_operations = {\n\t.d_hash\t\t= msdos_hash,\n\t.d_compare\t= msdos_cmp,\n};",
      "static const struct inode_operations msdos_dir_inode_operations = {\n\t.create\t\t= msdos_create,\n\t.lookup\t\t= msdos_lookup,\n\t.unlink\t\t= msdos_unlink,\n\t.mkdir\t\t= msdos_mkdir,\n\t.rmdir\t\t= msdos_rmdir,\n\t.rename\t\t= msdos_rename,\n\t.setattr\t= fat_setattr,\n\t.getattr\t= fat_getattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const struct dentry_operations msdos_dentry_operations = {\n\t.d_hash\t\t= msdos_hash,\n\t.d_compare\t= msdos_cmp,\n};\nstatic const struct inode_operations msdos_dir_inode_operations = {\n\t.create\t\t= msdos_create,\n\t.lookup\t\t= msdos_lookup,\n\t.unlink\t\t= msdos_unlink,\n\t.mkdir\t\t= msdos_mkdir,\n\t.rmdir\t\t= msdos_rmdir,\n\t.rename\t\t= msdos_rename,\n\t.setattr\t= fat_setattr,\n\t.getattr\t= fat_getattr,\n};\n\nstatic void setup(struct super_block *sb)\n{\n\tMSDOS_SB(sb)->dir_ops = &msdos_dir_inode_operations;\n\tsb->s_d_op = &msdos_dentry_operations;\n\tsb->s_flags |= MS_NOATIME;\n}"
  },
  {
    "function_name": "msdos_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "600-630",
    "snippet": "static int msdos_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct super_block *sb = old_dir->i_sb;\n\tunsigned char old_msdos_name[MSDOS_NAME], new_msdos_name[MSDOS_NAME];\n\tint err, is_hid;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = msdos_format_name(old_dentry->d_name.name,\n\t\t\t\told_dentry->d_name.len, old_msdos_name,\n\t\t\t\t&MSDOS_SB(old_dir->i_sb)->options);\n\tif (err)\n\t\tgoto out;\n\terr = msdos_format_name(new_dentry->d_name.name,\n\t\t\t\tnew_dentry->d_name.len, new_msdos_name,\n\t\t\t\t&MSDOS_SB(new_dir->i_sb)->options);\n\tif (err)\n\t\tgoto out;\n\n\tis_hid =\n\t     (new_dentry->d_name.name[0] == '.') && (new_msdos_name[0] != '.');\n\n\terr = do_msdos_rename(old_dir, old_msdos_name, old_dentry,\n\t\t\t      new_dir, new_msdos_name, new_dentry, is_hid);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!err)\n\t\terr = fat_flush_inodes(sb, old_dir, new_dir);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_flush_inodes",
          "args": [
            "sb",
            "old_dir",
            "new_dir"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "fat_flush_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1816-1830",
          "snippet": "int fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_msdos_rename",
          "args": [
            "old_dir",
            "old_msdos_name",
            "old_dentry",
            "new_dir",
            "new_msdos_name",
            "new_dentry",
            "is_hid"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "do_msdos_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "431-597",
          "snippet": "static int do_msdos_rename(struct inode *old_dir, unsigned char *old_name,\n\t\t\t   struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, unsigned char *new_name,\n\t\t\t   struct dentry *new_dentry, int is_hid)\n{\n\tstruct buffer_head *dotdot_bh;\n\tstruct msdos_dir_entry *dotdot_de;\n\tstruct inode *old_inode, *new_inode;\n\tstruct fat_slot_info old_sinfo, sinfo;\n\tstruct timespec ts;\n\tloff_t new_i_pos;\n\tint err, old_attrs, is_dir, update_dotdot, corrupt = 0;\n\n\told_sinfo.bh = sinfo.bh = dotdot_bh = NULL;\n\told_inode = old_dentry->d_inode;\n\tnew_inode = new_dentry->d_inode;\n\n\terr = fat_scan(old_dir, old_name, &old_sinfo);\n\tif (err) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tis_dir = S_ISDIR(old_inode->i_mode);\n\tupdate_dotdot = (is_dir && old_dir != new_dir);\n\tif (update_dotdot) {\n\t\tif (fat_get_dotdot_entry(old_inode, &dotdot_bh, &dotdot_de)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\told_attrs = MSDOS_I(old_inode)->i_attrs;\n\terr = fat_scan(new_dir, new_name, &sinfo);\n\tif (!err) {\n\t\tif (!new_inode) {\n\t\t\t/* \"foo\" -> \".foo\" case. just change the ATTR_HIDDEN */\n\t\t\tif (sinfo.de != old_sinfo.de) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_hid)\n\t\t\t\tMSDOS_I(old_inode)->i_attrs |= ATTR_HIDDEN;\n\t\t\telse\n\t\t\t\tMSDOS_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;\n\t\t\tif (IS_DIRSYNC(old_dir)) {\n\t\t\t\terr = fat_sync_inode(old_inode);\n\t\t\t\tif (err) {\n\t\t\t\t\tMSDOS_I(old_inode)->i_attrs = old_attrs;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tmark_inode_dirty(old_inode);\n\n\t\t\told_dir->i_version++;\n\t\t\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME_SEC;\n\t\t\tif (IS_DIRSYNC(old_dir))\n\t\t\t\t(void)fat_sync_inode(old_dir);\n\t\t\telse\n\t\t\t\tmark_inode_dirty(old_dir);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tts = CURRENT_TIME_SEC;\n\tif (new_inode) {\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (is_dir) {\n\t\t\terr = fat_dir_empty(new_inode);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tnew_i_pos = MSDOS_I(new_inode)->i_pos;\n\t\tfat_detach(new_inode);\n\t} else {\n\t\terr = msdos_add_entry(new_dir, new_name, is_dir, is_hid, 0,\n\t\t\t\t      &ts, &sinfo);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tnew_i_pos = sinfo.i_pos;\n\t}\n\tnew_dir->i_version++;\n\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, new_i_pos);\n\tif (is_hid)\n\t\tMSDOS_I(old_inode)->i_attrs |= ATTR_HIDDEN;\n\telse\n\t\tMSDOS_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;\n\tif (IS_DIRSYNC(new_dir)) {\n\t\terr = fat_sync_inode(old_inode);\n\t\tif (err)\n\t\t\tgoto error_inode;\n\t} else\n\t\tmark_inode_dirty(old_inode);\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(new_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tif (IS_DIRSYNC(new_dir)) {\n\t\t\terr = sync_dirty_buffer(dotdot_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error_dotdot;\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tif (!new_inode)\n\t\t\tinc_nlink(new_dir);\n\t}\n\n\terr = fat_remove_entries(old_dir, &old_sinfo);\t/* and releases bh */\n\told_sinfo.bh = NULL;\n\tif (err)\n\t\tgoto error_dotdot;\n\told_dir->i_version++;\n\told_dir->i_ctime = old_dir->i_mtime = ts;\n\tif (IS_DIRSYNC(old_dir))\n\t\t(void)fat_sync_inode(old_dir);\n\telse\n\t\tmark_inode_dirty(old_dir);\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tif (is_dir)\n\t\t\tdrop_nlink(new_inode);\n\t\tnew_inode->i_ctime = ts;\n\t}\nout:\n\tbrelse(sinfo.bh);\n\tbrelse(dotdot_bh);\n\tbrelse(old_sinfo.bh);\n\treturn err;\n\nerror_dotdot:\n\t/* data cluster is shared, serious corruption */\n\tcorrupt = 1;\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(old_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tcorrupt |= sync_dirty_buffer(dotdot_bh);\n\t}\nerror_inode:\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, old_sinfo.i_pos);\n\tMSDOS_I(old_inode)->i_attrs = old_attrs;\n\tif (new_inode) {\n\t\tfat_attach(new_inode, new_i_pos);\n\t\tif (corrupt)\n\t\t\tcorrupt |= fat_sync_inode(new_inode);\n\t} else {\n\t\t/*\n\t\t * If new entry was not sharing the data cluster, it\n\t\t * shouldn't be serious corruption.\n\t\t */\n\t\tint err2 = fat_remove_entries(new_dir, &sinfo);\n\t\tif (corrupt)\n\t\t\tcorrupt |= err2;\n\t\tsinfo.bh = NULL;\n\t}\n\tif (corrupt < 0) {\n\t\tfat_fs_error(new_dir->i_sb,\n\t\t\t     \"%s: Filesystem corrupted (i_pos %lld)\",\n\t\t\t     __func__, sinfo.i_pos);\n\t}\n\tgoto out;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int do_msdos_rename(struct inode *old_dir, unsigned char *old_name,\n\t\t\t   struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, unsigned char *new_name,\n\t\t\t   struct dentry *new_dentry, int is_hid)\n{\n\tstruct buffer_head *dotdot_bh;\n\tstruct msdos_dir_entry *dotdot_de;\n\tstruct inode *old_inode, *new_inode;\n\tstruct fat_slot_info old_sinfo, sinfo;\n\tstruct timespec ts;\n\tloff_t new_i_pos;\n\tint err, old_attrs, is_dir, update_dotdot, corrupt = 0;\n\n\told_sinfo.bh = sinfo.bh = dotdot_bh = NULL;\n\told_inode = old_dentry->d_inode;\n\tnew_inode = new_dentry->d_inode;\n\n\terr = fat_scan(old_dir, old_name, &old_sinfo);\n\tif (err) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tis_dir = S_ISDIR(old_inode->i_mode);\n\tupdate_dotdot = (is_dir && old_dir != new_dir);\n\tif (update_dotdot) {\n\t\tif (fat_get_dotdot_entry(old_inode, &dotdot_bh, &dotdot_de)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\told_attrs = MSDOS_I(old_inode)->i_attrs;\n\terr = fat_scan(new_dir, new_name, &sinfo);\n\tif (!err) {\n\t\tif (!new_inode) {\n\t\t\t/* \"foo\" -> \".foo\" case. just change the ATTR_HIDDEN */\n\t\t\tif (sinfo.de != old_sinfo.de) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_hid)\n\t\t\t\tMSDOS_I(old_inode)->i_attrs |= ATTR_HIDDEN;\n\t\t\telse\n\t\t\t\tMSDOS_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;\n\t\t\tif (IS_DIRSYNC(old_dir)) {\n\t\t\t\terr = fat_sync_inode(old_inode);\n\t\t\t\tif (err) {\n\t\t\t\t\tMSDOS_I(old_inode)->i_attrs = old_attrs;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tmark_inode_dirty(old_inode);\n\n\t\t\told_dir->i_version++;\n\t\t\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME_SEC;\n\t\t\tif (IS_DIRSYNC(old_dir))\n\t\t\t\t(void)fat_sync_inode(old_dir);\n\t\t\telse\n\t\t\t\tmark_inode_dirty(old_dir);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tts = CURRENT_TIME_SEC;\n\tif (new_inode) {\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (is_dir) {\n\t\t\terr = fat_dir_empty(new_inode);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tnew_i_pos = MSDOS_I(new_inode)->i_pos;\n\t\tfat_detach(new_inode);\n\t} else {\n\t\terr = msdos_add_entry(new_dir, new_name, is_dir, is_hid, 0,\n\t\t\t\t      &ts, &sinfo);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tnew_i_pos = sinfo.i_pos;\n\t}\n\tnew_dir->i_version++;\n\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, new_i_pos);\n\tif (is_hid)\n\t\tMSDOS_I(old_inode)->i_attrs |= ATTR_HIDDEN;\n\telse\n\t\tMSDOS_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;\n\tif (IS_DIRSYNC(new_dir)) {\n\t\terr = fat_sync_inode(old_inode);\n\t\tif (err)\n\t\t\tgoto error_inode;\n\t} else\n\t\tmark_inode_dirty(old_inode);\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(new_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tif (IS_DIRSYNC(new_dir)) {\n\t\t\terr = sync_dirty_buffer(dotdot_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error_dotdot;\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tif (!new_inode)\n\t\t\tinc_nlink(new_dir);\n\t}\n\n\terr = fat_remove_entries(old_dir, &old_sinfo);\t/* and releases bh */\n\told_sinfo.bh = NULL;\n\tif (err)\n\t\tgoto error_dotdot;\n\told_dir->i_version++;\n\told_dir->i_ctime = old_dir->i_mtime = ts;\n\tif (IS_DIRSYNC(old_dir))\n\t\t(void)fat_sync_inode(old_dir);\n\telse\n\t\tmark_inode_dirty(old_dir);\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tif (is_dir)\n\t\t\tdrop_nlink(new_inode);\n\t\tnew_inode->i_ctime = ts;\n\t}\nout:\n\tbrelse(sinfo.bh);\n\tbrelse(dotdot_bh);\n\tbrelse(old_sinfo.bh);\n\treturn err;\n\nerror_dotdot:\n\t/* data cluster is shared, serious corruption */\n\tcorrupt = 1;\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(old_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tcorrupt |= sync_dirty_buffer(dotdot_bh);\n\t}\nerror_inode:\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, old_sinfo.i_pos);\n\tMSDOS_I(old_inode)->i_attrs = old_attrs;\n\tif (new_inode) {\n\t\tfat_attach(new_inode, new_i_pos);\n\t\tif (corrupt)\n\t\t\tcorrupt |= fat_sync_inode(new_inode);\n\t} else {\n\t\t/*\n\t\t * If new entry was not sharing the data cluster, it\n\t\t * shouldn't be serious corruption.\n\t\t */\n\t\tint err2 = fat_remove_entries(new_dir, &sinfo);\n\t\tif (corrupt)\n\t\t\tcorrupt |= err2;\n\t\tsinfo.bh = NULL;\n\t}\n\tif (corrupt < 0) {\n\t\tfat_fs_error(new_dir->i_sb,\n\t\t\t     \"%s: Filesystem corrupted (i_pos %lld)\",\n\t\t\t     __func__, sinfo.i_pos);\n\t}\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msdos_format_name",
          "args": [
            "new_dentry->d_name.name",
            "new_dentry->d_name.len",
            "new_msdos_name",
            "&MSDOS_SB(new_dir->i_sb)->options"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "msdos_format_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "19-116",
          "snippet": "static int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char bad_chars[] = \"*?<>|\\\"\";",
            "static unsigned char bad_if_strict[] = \"+=,; \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic unsigned char bad_chars[] = \"*?<>|\\\"\";\nstatic unsigned char bad_if_strict[] = \"+=,; \";\n\nstatic int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct super_block *sb = old_dir->i_sb;\n\tunsigned char old_msdos_name[MSDOS_NAME], new_msdos_name[MSDOS_NAME];\n\tint err, is_hid;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = msdos_format_name(old_dentry->d_name.name,\n\t\t\t\told_dentry->d_name.len, old_msdos_name,\n\t\t\t\t&MSDOS_SB(old_dir->i_sb)->options);\n\tif (err)\n\t\tgoto out;\n\terr = msdos_format_name(new_dentry->d_name.name,\n\t\t\t\tnew_dentry->d_name.len, new_msdos_name,\n\t\t\t\t&MSDOS_SB(new_dir->i_sb)->options);\n\tif (err)\n\t\tgoto out;\n\n\tis_hid =\n\t     (new_dentry->d_name.name[0] == '.') && (new_msdos_name[0] != '.');\n\n\terr = do_msdos_rename(old_dir, old_msdos_name, old_dentry,\n\t\t\t      new_dir, new_msdos_name, new_dentry, is_hid);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!err)\n\t\terr = fat_flush_inodes(sb, old_dir, new_dir);\n\treturn err;\n}"
  },
  {
    "function_name": "do_msdos_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "431-597",
    "snippet": "static int do_msdos_rename(struct inode *old_dir, unsigned char *old_name,\n\t\t\t   struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, unsigned char *new_name,\n\t\t\t   struct dentry *new_dentry, int is_hid)\n{\n\tstruct buffer_head *dotdot_bh;\n\tstruct msdos_dir_entry *dotdot_de;\n\tstruct inode *old_inode, *new_inode;\n\tstruct fat_slot_info old_sinfo, sinfo;\n\tstruct timespec ts;\n\tloff_t new_i_pos;\n\tint err, old_attrs, is_dir, update_dotdot, corrupt = 0;\n\n\told_sinfo.bh = sinfo.bh = dotdot_bh = NULL;\n\told_inode = old_dentry->d_inode;\n\tnew_inode = new_dentry->d_inode;\n\n\terr = fat_scan(old_dir, old_name, &old_sinfo);\n\tif (err) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tis_dir = S_ISDIR(old_inode->i_mode);\n\tupdate_dotdot = (is_dir && old_dir != new_dir);\n\tif (update_dotdot) {\n\t\tif (fat_get_dotdot_entry(old_inode, &dotdot_bh, &dotdot_de)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\told_attrs = MSDOS_I(old_inode)->i_attrs;\n\terr = fat_scan(new_dir, new_name, &sinfo);\n\tif (!err) {\n\t\tif (!new_inode) {\n\t\t\t/* \"foo\" -> \".foo\" case. just change the ATTR_HIDDEN */\n\t\t\tif (sinfo.de != old_sinfo.de) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_hid)\n\t\t\t\tMSDOS_I(old_inode)->i_attrs |= ATTR_HIDDEN;\n\t\t\telse\n\t\t\t\tMSDOS_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;\n\t\t\tif (IS_DIRSYNC(old_dir)) {\n\t\t\t\terr = fat_sync_inode(old_inode);\n\t\t\t\tif (err) {\n\t\t\t\t\tMSDOS_I(old_inode)->i_attrs = old_attrs;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tmark_inode_dirty(old_inode);\n\n\t\t\told_dir->i_version++;\n\t\t\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME_SEC;\n\t\t\tif (IS_DIRSYNC(old_dir))\n\t\t\t\t(void)fat_sync_inode(old_dir);\n\t\t\telse\n\t\t\t\tmark_inode_dirty(old_dir);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tts = CURRENT_TIME_SEC;\n\tif (new_inode) {\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (is_dir) {\n\t\t\terr = fat_dir_empty(new_inode);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tnew_i_pos = MSDOS_I(new_inode)->i_pos;\n\t\tfat_detach(new_inode);\n\t} else {\n\t\terr = msdos_add_entry(new_dir, new_name, is_dir, is_hid, 0,\n\t\t\t\t      &ts, &sinfo);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tnew_i_pos = sinfo.i_pos;\n\t}\n\tnew_dir->i_version++;\n\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, new_i_pos);\n\tif (is_hid)\n\t\tMSDOS_I(old_inode)->i_attrs |= ATTR_HIDDEN;\n\telse\n\t\tMSDOS_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;\n\tif (IS_DIRSYNC(new_dir)) {\n\t\terr = fat_sync_inode(old_inode);\n\t\tif (err)\n\t\t\tgoto error_inode;\n\t} else\n\t\tmark_inode_dirty(old_inode);\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(new_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tif (IS_DIRSYNC(new_dir)) {\n\t\t\terr = sync_dirty_buffer(dotdot_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error_dotdot;\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tif (!new_inode)\n\t\t\tinc_nlink(new_dir);\n\t}\n\n\terr = fat_remove_entries(old_dir, &old_sinfo);\t/* and releases bh */\n\told_sinfo.bh = NULL;\n\tif (err)\n\t\tgoto error_dotdot;\n\told_dir->i_version++;\n\told_dir->i_ctime = old_dir->i_mtime = ts;\n\tif (IS_DIRSYNC(old_dir))\n\t\t(void)fat_sync_inode(old_dir);\n\telse\n\t\tmark_inode_dirty(old_dir);\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tif (is_dir)\n\t\t\tdrop_nlink(new_inode);\n\t\tnew_inode->i_ctime = ts;\n\t}\nout:\n\tbrelse(sinfo.bh);\n\tbrelse(dotdot_bh);\n\tbrelse(old_sinfo.bh);\n\treturn err;\n\nerror_dotdot:\n\t/* data cluster is shared, serious corruption */\n\tcorrupt = 1;\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(old_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tcorrupt |= sync_dirty_buffer(dotdot_bh);\n\t}\nerror_inode:\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, old_sinfo.i_pos);\n\tMSDOS_I(old_inode)->i_attrs = old_attrs;\n\tif (new_inode) {\n\t\tfat_attach(new_inode, new_i_pos);\n\t\tif (corrupt)\n\t\t\tcorrupt |= fat_sync_inode(new_inode);\n\t} else {\n\t\t/*\n\t\t * If new entry was not sharing the data cluster, it\n\t\t * shouldn't be serious corruption.\n\t\t */\n\t\tint err2 = fat_remove_entries(new_dir, &sinfo);\n\t\tif (corrupt)\n\t\t\tcorrupt |= err2;\n\t\tsinfo.bh = NULL;\n\t}\n\tif (corrupt < 0) {\n\t\tfat_fs_error(new_dir->i_sb,\n\t\t\t     \"%s: Filesystem corrupted (i_pos %lld)\",\n\t\t\t     __func__, sinfo.i_pos);\n\t}\n\tgoto out;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_fs_error",
          "args": [
            "new_dir->i_sb",
            "\"%s: Filesystem corrupted (i_pos %lld)\"",
            "__func__",
            "sinfo.i_pos"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "__fat_fs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "23-43",
          "snippet": "void __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid __fat_fs_error(struct super_block *sb, int report, const char *fmt, ...)\n{\n\tstruct fat_mount_options *opts = &MSDOS_SB(sb)->options;\n\tva_list args;\n\tstruct va_format vaf;\n\n\tif (report) {\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\t\tfat_msg(sb, KERN_ERR, \"error, %pV\", &vaf);\n\t\tva_end(args);\n\t}\n\n\tif (opts->errors == FAT_ERRORS_PANIC)\n\t\tpanic(\"FAT-fs (%s): fs panic from previous error\\n\", sb->s_id);\n\telse if (opts->errors == FAT_ERRORS_RO && !(sb->s_flags & MS_RDONLY)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tfat_msg(sb, KERN_ERR, \"Filesystem has been set read-only\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_remove_entries",
          "args": [
            "new_dir",
            "&sinfo"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "fat_remove_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1030-1079",
          "snippet": "int fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_sync_inode",
          "args": [
            "new_inode"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "824-827",
          "snippet": "int fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_attach",
          "args": [
            "new_inode",
            "new_i_pos"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "fat_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "369-395",
          "snippet": "void fat_attach(struct inode *inode, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\n\tif (inode->i_ino != MSDOS_ROOT_INO) {\n\t\tstruct hlist_head *head =   sbi->inode_hashtable\n\t\t\t\t\t  + fat_hash(i_pos);\n\n\t\tspin_lock(&sbi->inode_hash_lock);\n\t\tMSDOS_I(inode)->i_pos = i_pos;\n\t\thlist_add_head(&MSDOS_I(inode)->i_fat_hash, head);\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t}\n\n\t/* If NFS support is enabled, cache the mapping of start cluster\n\t * to directory inode. This is used during reconnection of\n\t * dentries to the filesystem root.\n\t */\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tstruct hlist_head *d_head = sbi->dir_hashtable;\n\t\td_head += fat_dir_hash(MSDOS_I(inode)->i_logstart);\n\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_add_head(&MSDOS_I(inode)->i_dir_hash, d_head);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fat_show_options(struct seq_file *m, struct dentry *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int fat_show_options(struct seq_file *m, struct dentry *root);\n\nvoid fat_attach(struct inode *inode, loff_t i_pos)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\n\tif (inode->i_ino != MSDOS_ROOT_INO) {\n\t\tstruct hlist_head *head =   sbi->inode_hashtable\n\t\t\t\t\t  + fat_hash(i_pos);\n\n\t\tspin_lock(&sbi->inode_hash_lock);\n\t\tMSDOS_I(inode)->i_pos = i_pos;\n\t\thlist_add_head(&MSDOS_I(inode)->i_fat_hash, head);\n\t\tspin_unlock(&sbi->inode_hash_lock);\n\t}\n\n\t/* If NFS support is enabled, cache the mapping of start cluster\n\t * to directory inode. This is used during reconnection of\n\t * dentries to the filesystem root.\n\t */\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tstruct hlist_head *d_head = sbi->dir_hashtable;\n\t\td_head += fat_dir_hash(MSDOS_I(inode)->i_logstart);\n\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_add_head(&MSDOS_I(inode)->i_dir_hash, d_head);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_I",
          "args": [
            "old_inode"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "147-150",
          "snippet": "static inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_inode_info *MSDOS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct msdos_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_detach",
          "args": [
            "old_inode"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "fat_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "398-411",
          "snippet": "void fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "dotdot_bh"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty_inode",
          "args": [
            "dotdot_bh",
            "old_inode"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "599-617",
          "snippet": "void mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty_inode(struct buffer_head *bh, struct inode *inode)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct address_space *buffer_mapping = bh->b_page->mapping;\n\n\tmark_buffer_dirty(bh);\n\tif (!mapping->private_data) {\n\t\tmapping->private_data = buffer_mapping;\n\t} else {\n\t\tBUG_ON(mapping->private_data != buffer_mapping);\n\t}\n\tif (!bh->b_assoc_map) {\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\tlist_move_tail(&bh->b_assoc_buffers,\n\t\t\t\t&mapping->private_list);\n\t\tbh->b_assoc_map = mapping;\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_set_start",
          "args": [
            "dotdot_de",
            "MSDOS_I(old_dir)->i_logstart"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "fat_set_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "267-271",
          "snippet": "static inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "old_sinfo.bh"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "new_inode"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "old_dir"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "old_dir"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "new_dir"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "new_dir"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "new_dir"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msdos_add_entry",
          "args": [
            "new_dir",
            "new_name",
            "is_dir",
            "is_hid",
            "0",
            "&ts",
            "&sinfo"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "msdos_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "227-261",
          "snippet": "static int msdos_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t   int is_dir, int is_hid, int cluster,\n\t\t\t   struct timespec *ts, struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct msdos_dir_entry de;\n\t__le16 time, date;\n\tint err;\n\n\tmemcpy(de.name, name, MSDOS_NAME);\n\tde.attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tif (is_hid)\n\t\tde.attr |= ATTR_HIDDEN;\n\tde.lcase = 0;\n\tfat_time_unix2fat(sbi, ts, &time, &date, NULL);\n\tde.cdate = de.adate = 0;\n\tde.ctime = 0;\n\tde.ctime_cs = 0;\n\tde.time = time;\n\tde.date = date;\n\tfat_set_start(&de, cluster);\n\tde.size = 0;\n\n\terr = fat_add_entries(dir, &de, 1, sinfo);\n\tif (err)\n\t\treturn err;\n\n\tdir->i_ctime = dir->i_mtime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t   int is_dir, int is_hid, int cluster,\n\t\t\t   struct timespec *ts, struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct msdos_dir_entry de;\n\t__le16 time, date;\n\tint err;\n\n\tmemcpy(de.name, name, MSDOS_NAME);\n\tde.attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tif (is_hid)\n\t\tde.attr |= ATTR_HIDDEN;\n\tde.lcase = 0;\n\tfat_time_unix2fat(sbi, ts, &time, &date, NULL);\n\tde.cdate = de.adate = 0;\n\tde.ctime = 0;\n\tde.ctime_cs = 0;\n\tde.time = time;\n\tde.date = date;\n\tfat_set_start(&de, cluster);\n\tde.size = 0;\n\n\terr = fat_add_entries(dir, &de, 1, sinfo);\n\tif (err)\n\t\treturn err;\n\n\tdir->i_ctime = dir->i_mtime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_dir_empty",
          "args": [
            "new_inode"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "fat_dir_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "906-924",
          "snippet": "int fat_dir_empty(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint result = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (strncmp(de->name, MSDOS_DOT   , MSDOS_NAME) &&\n\t\t    strncmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\t\tresult = -ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn result;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_dir_empty(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint result = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (strncmp(de->name, MSDOS_DOT   , MSDOS_NAME) &&\n\t\t    strncmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\t\tresult = -ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "old_dir"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "old_dir"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_scan",
          "args": [
            "new_dir",
            "new_name",
            "&sinfo"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "fat_scan_logstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "976-993",
          "snippet": "int fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_get_dotdot_entry",
          "args": [
            "old_inode",
            "&dotdot_bh",
            "&dotdot_de"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "fat_get_dotdot_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "891-902",
          "snippet": "int fat_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,\n\t\t\t struct msdos_dir_entry **de)\n{\n\tloff_t offset = 0;\n\n\t*de = NULL;\n\twhile (fat_get_short_entry(dir, &offset, bh, de) >= 0) {\n\t\tif (!strncmp((*de)->name, MSDOS_DOTDOT, MSDOS_NAME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_get_dotdot_entry(struct inode *dir, struct buffer_head **bh,\n\t\t\t struct msdos_dir_entry **de)\n{\n\tloff_t offset = 0;\n\n\t*de = NULL;\n\twhile (fat_get_short_entry(dir, &offset, bh, de) >= 0) {\n\t\tif (!strncmp((*de)->name, MSDOS_DOTDOT, MSDOS_NAME))\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "old_inode->i_mode"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int do_msdos_rename(struct inode *old_dir, unsigned char *old_name,\n\t\t\t   struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, unsigned char *new_name,\n\t\t\t   struct dentry *new_dentry, int is_hid)\n{\n\tstruct buffer_head *dotdot_bh;\n\tstruct msdos_dir_entry *dotdot_de;\n\tstruct inode *old_inode, *new_inode;\n\tstruct fat_slot_info old_sinfo, sinfo;\n\tstruct timespec ts;\n\tloff_t new_i_pos;\n\tint err, old_attrs, is_dir, update_dotdot, corrupt = 0;\n\n\told_sinfo.bh = sinfo.bh = dotdot_bh = NULL;\n\told_inode = old_dentry->d_inode;\n\tnew_inode = new_dentry->d_inode;\n\n\terr = fat_scan(old_dir, old_name, &old_sinfo);\n\tif (err) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tis_dir = S_ISDIR(old_inode->i_mode);\n\tupdate_dotdot = (is_dir && old_dir != new_dir);\n\tif (update_dotdot) {\n\t\tif (fat_get_dotdot_entry(old_inode, &dotdot_bh, &dotdot_de)) {\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\told_attrs = MSDOS_I(old_inode)->i_attrs;\n\terr = fat_scan(new_dir, new_name, &sinfo);\n\tif (!err) {\n\t\tif (!new_inode) {\n\t\t\t/* \"foo\" -> \".foo\" case. just change the ATTR_HIDDEN */\n\t\t\tif (sinfo.de != old_sinfo.de) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (is_hid)\n\t\t\t\tMSDOS_I(old_inode)->i_attrs |= ATTR_HIDDEN;\n\t\t\telse\n\t\t\t\tMSDOS_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;\n\t\t\tif (IS_DIRSYNC(old_dir)) {\n\t\t\t\terr = fat_sync_inode(old_inode);\n\t\t\t\tif (err) {\n\t\t\t\t\tMSDOS_I(old_inode)->i_attrs = old_attrs;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tmark_inode_dirty(old_inode);\n\n\t\t\told_dir->i_version++;\n\t\t\told_dir->i_ctime = old_dir->i_mtime = CURRENT_TIME_SEC;\n\t\t\tif (IS_DIRSYNC(old_dir))\n\t\t\t\t(void)fat_sync_inode(old_dir);\n\t\t\telse\n\t\t\t\tmark_inode_dirty(old_dir);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tts = CURRENT_TIME_SEC;\n\tif (new_inode) {\n\t\tif (err)\n\t\t\tgoto out;\n\t\tif (is_dir) {\n\t\t\terr = fat_dir_empty(new_inode);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tnew_i_pos = MSDOS_I(new_inode)->i_pos;\n\t\tfat_detach(new_inode);\n\t} else {\n\t\terr = msdos_add_entry(new_dir, new_name, is_dir, is_hid, 0,\n\t\t\t\t      &ts, &sinfo);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tnew_i_pos = sinfo.i_pos;\n\t}\n\tnew_dir->i_version++;\n\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, new_i_pos);\n\tif (is_hid)\n\t\tMSDOS_I(old_inode)->i_attrs |= ATTR_HIDDEN;\n\telse\n\t\tMSDOS_I(old_inode)->i_attrs &= ~ATTR_HIDDEN;\n\tif (IS_DIRSYNC(new_dir)) {\n\t\terr = fat_sync_inode(old_inode);\n\t\tif (err)\n\t\t\tgoto error_inode;\n\t} else\n\t\tmark_inode_dirty(old_inode);\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(new_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tif (IS_DIRSYNC(new_dir)) {\n\t\t\terr = sync_dirty_buffer(dotdot_bh);\n\t\t\tif (err)\n\t\t\t\tgoto error_dotdot;\n\t\t}\n\t\tdrop_nlink(old_dir);\n\t\tif (!new_inode)\n\t\t\tinc_nlink(new_dir);\n\t}\n\n\terr = fat_remove_entries(old_dir, &old_sinfo);\t/* and releases bh */\n\told_sinfo.bh = NULL;\n\tif (err)\n\t\tgoto error_dotdot;\n\told_dir->i_version++;\n\told_dir->i_ctime = old_dir->i_mtime = ts;\n\tif (IS_DIRSYNC(old_dir))\n\t\t(void)fat_sync_inode(old_dir);\n\telse\n\t\tmark_inode_dirty(old_dir);\n\n\tif (new_inode) {\n\t\tdrop_nlink(new_inode);\n\t\tif (is_dir)\n\t\t\tdrop_nlink(new_inode);\n\t\tnew_inode->i_ctime = ts;\n\t}\nout:\n\tbrelse(sinfo.bh);\n\tbrelse(dotdot_bh);\n\tbrelse(old_sinfo.bh);\n\treturn err;\n\nerror_dotdot:\n\t/* data cluster is shared, serious corruption */\n\tcorrupt = 1;\n\n\tif (update_dotdot) {\n\t\tfat_set_start(dotdot_de, MSDOS_I(old_dir)->i_logstart);\n\t\tmark_buffer_dirty_inode(dotdot_bh, old_inode);\n\t\tcorrupt |= sync_dirty_buffer(dotdot_bh);\n\t}\nerror_inode:\n\tfat_detach(old_inode);\n\tfat_attach(old_inode, old_sinfo.i_pos);\n\tMSDOS_I(old_inode)->i_attrs = old_attrs;\n\tif (new_inode) {\n\t\tfat_attach(new_inode, new_i_pos);\n\t\tif (corrupt)\n\t\t\tcorrupt |= fat_sync_inode(new_inode);\n\t} else {\n\t\t/*\n\t\t * If new entry was not sharing the data cluster, it\n\t\t * shouldn't be serious corruption.\n\t\t */\n\t\tint err2 = fat_remove_entries(new_dir, &sinfo);\n\t\tif (corrupt)\n\t\t\tcorrupt |= err2;\n\t\tsinfo.bh = NULL;\n\t}\n\tif (corrupt < 0) {\n\t\tfat_fs_error(new_dir->i_sb,\n\t\t\t     \"%s: Filesystem corrupted (i_pos %lld)\",\n\t\t\t     __func__, sinfo.i_pos);\n\t}\n\tgoto out;\n}"
  },
  {
    "function_name": "msdos_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "405-429",
    "snippet": "static int msdos_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\terr = msdos_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t/* and releases bh */\n\tif (err)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tfat_detach(inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!err)\n\t\terr = fat_flush_inodes(sb, dir, inode);\n\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_flush_inodes",
          "args": [
            "sb",
            "dir",
            "inode"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "fat_flush_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1816-1830",
          "snippet": "int fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_detach",
          "args": [
            "inode"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "fat_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "398-411",
          "snippet": "void fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_remove_entries",
          "args": [
            "dir",
            "&sinfo"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "fat_remove_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1030-1079",
          "snippet": "int fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msdos_find",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&sinfo"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "msdos_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "119-143",
          "snippet": "static int msdos_find(struct inode *dir, const unsigned char *name, int len,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint err;\n\n\terr = msdos_format_name(name, len, msdos_name, &sbi->options);\n\tif (err)\n\t\treturn -ENOENT;\n\n\terr = fat_scan(dir, msdos_name, sinfo);\n\tif (!err && sbi->options.dotsOK) {\n\t\tif (name[0] == '.') {\n\t\t\tif (!(sinfo->de->attr & ATTR_HIDDEN))\n\t\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\tif (sinfo->de->attr & ATTR_HIDDEN)\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tif (err)\n\t\t\tbrelse(sinfo->bh);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_find(struct inode *dir, const unsigned char *name, int len,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint err;\n\n\terr = msdos_format_name(name, len, msdos_name, &sbi->options);\n\tif (err)\n\t\treturn -ENOENT;\n\n\terr = fat_scan(dir, msdos_name, sinfo);\n\tif (!err && sbi->options.dotsOK) {\n\t\tif (name[0] == '.') {\n\t\t\tif (!(sinfo->de->attr & ATTR_HIDDEN))\n\t\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\tif (sinfo->de->attr & ATTR_HIDDEN)\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tif (err)\n\t\t\tbrelse(sinfo->bh);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\terr = msdos_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t/* and releases bh */\n\tif (err)\n\t\tgoto out;\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tfat_detach(inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!err)\n\t\terr = fat_flush_inodes(sb, dir, inode);\n\n\treturn err;\n}"
  },
  {
    "function_name": "msdos_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "346-402",
    "snippet": "static int msdos_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tstruct inode *inode;\n\tunsigned char msdos_name[MSDOS_NAME];\n\tstruct timespec ts;\n\tint err, is_hid, cluster;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = msdos_format_name(dentry->d_name.name, dentry->d_name.len,\n\t\t\t\tmsdos_name, &MSDOS_SB(sb)->options);\n\tif (err)\n\t\tgoto out;\n\tis_hid = (dentry->d_name.name[0] == '.') && (msdos_name[0] != '.');\n\t/* foo vs .foo situation */\n\tif (!fat_scan(dir, msdos_name, &sinfo)) {\n\t\tbrelse(sinfo.bh);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tts = CURRENT_TIME_SEC;\n\tcluster = fat_alloc_new_dir(dir, &ts);\n\tif (cluster < 0) {\n\t\terr = cluster;\n\t\tgoto out;\n\t}\n\terr = msdos_add_entry(dir, msdos_name, 1, is_hid, cluster, &ts, &sinfo);\n\tif (err)\n\t\tgoto out_free;\n\tinc_nlink(dir);\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\t/* the directory was completed, just return a error */\n\t\tgoto out;\n\t}\n\tset_nlink(inode, 2);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = ts;\n\t/* timestamp is already written, so mark_inode_dirty() is unneeded. */\n\n\td_instantiate(dentry, inode);\n\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tfat_flush_inodes(sb, dir, inode);\n\treturn 0;\n\nout_free:\n\tfat_free_clusters(dir, cluster);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_free_clusters",
          "args": [
            "dir",
            "cluster"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "fat_free_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fatent.c",
          "lines": "553-633",
          "snippet": "int fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/msdos_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/blkdev.h>\n#include <linux/msdos_fs.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint fat_free_clusters(struct inode *inode, int cluster)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct fatent_operations *ops = sbi->fatent_ops;\n\tstruct fat_entry fatent;\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tint i, err, nr_bhs;\n\tint first_cl = cluster, dirty_fsinfo = 0;\n\n\tnr_bhs = 0;\n\tfatent_init(&fatent);\n\tlock_fat(sbi);\n\tdo {\n\t\tcluster = fat_ent_read(inode, &fatent, cluster);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error;\n\t\t} else if (cluster == FAT_ENT_FREE) {\n\t\t\tfat_fs_error(sb, \"%s: deleting FAT entry beyond EOF\",\n\t\t\t\t     __func__);\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (sbi->options.discard) {\n\t\t\t/*\n\t\t\t * Issue discard for the sectors we no longer\n\t\t\t * care about, batching contiguous clusters\n\t\t\t * into one request\n\t\t\t */\n\t\t\tif (cluster != fatent.entry + 1) {\n\t\t\t\tint nr_clus = fatent.entry - first_cl + 1;\n\n\t\t\t\tsb_issue_discard(sb,\n\t\t\t\t\tfat_clus_to_blknr(sbi, first_cl),\n\t\t\t\t\tnr_clus * sbi->sec_per_clus,\n\t\t\t\t\tGFP_NOFS, 0);\n\n\t\t\t\tfirst_cl = cluster;\n\t\t\t}\n\t\t}\n\n\t\tops->ent_put(&fatent, FAT_ENT_FREE);\n\t\tif (sbi->free_clusters != -1) {\n\t\t\tsbi->free_clusters++;\n\t\t\tdirty_fsinfo = 1;\n\t\t}\n\n\t\tif (nr_bhs + fatent.nr_bhs > MAX_BUF_PER_PAGE) {\n\t\t\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\t\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto error;\n\t\t\t}\n\t\t\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tnr_bhs = 0;\n\t\t}\n\t\tfat_collect_bhs(bhs, &nr_bhs, &fatent);\n\t} while (cluster != FAT_ENT_EOF);\n\n\tif (sb->s_flags & MS_SYNCHRONOUS) {\n\t\terr = fat_sync_bhs(bhs, nr_bhs);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\terr = fat_mirror_bhs(sb, bhs, nr_bhs);\nerror:\n\tfatent_brelse(&fatent);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\tunlock_fat(sbi);\n\tif (dirty_fsinfo)\n\t\tmark_fsinfo_dirty(sb);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_flush_inodes",
          "args": [
            "sb",
            "dir",
            "inode"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "fat_flush_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1816-1830",
          "snippet": "int fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sinfo.bh"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_build_inode",
          "args": [
            "sb",
            "sinfo.de",
            "sinfo.i_pos"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "fat_build_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "533-561",
          "snippet": "struct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msdos_add_entry",
          "args": [
            "dir",
            "msdos_name",
            "1",
            "is_hid",
            "cluster",
            "&ts",
            "&sinfo"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "msdos_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "227-261",
          "snippet": "static int msdos_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t   int is_dir, int is_hid, int cluster,\n\t\t\t   struct timespec *ts, struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct msdos_dir_entry de;\n\t__le16 time, date;\n\tint err;\n\n\tmemcpy(de.name, name, MSDOS_NAME);\n\tde.attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tif (is_hid)\n\t\tde.attr |= ATTR_HIDDEN;\n\tde.lcase = 0;\n\tfat_time_unix2fat(sbi, ts, &time, &date, NULL);\n\tde.cdate = de.adate = 0;\n\tde.ctime = 0;\n\tde.ctime_cs = 0;\n\tde.time = time;\n\tde.date = date;\n\tfat_set_start(&de, cluster);\n\tde.size = 0;\n\n\terr = fat_add_entries(dir, &de, 1, sinfo);\n\tif (err)\n\t\treturn err;\n\n\tdir->i_ctime = dir->i_mtime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t   int is_dir, int is_hid, int cluster,\n\t\t\t   struct timespec *ts, struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct msdos_dir_entry de;\n\t__le16 time, date;\n\tint err;\n\n\tmemcpy(de.name, name, MSDOS_NAME);\n\tde.attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tif (is_hid)\n\t\tde.attr |= ATTR_HIDDEN;\n\tde.lcase = 0;\n\tfat_time_unix2fat(sbi, ts, &time, &date, NULL);\n\tde.cdate = de.adate = 0;\n\tde.ctime = 0;\n\tde.ctime_cs = 0;\n\tde.time = time;\n\tde.date = date;\n\tfat_set_start(&de, cluster);\n\tde.size = 0;\n\n\terr = fat_add_entries(dir, &de, 1, sinfo);\n\tif (err)\n\t\treturn err;\n\n\tdir->i_ctime = dir->i_mtime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_alloc_new_dir",
          "args": [
            "dir",
            "&ts"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "fat_alloc_new_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1131-1190",
          "snippet": "int fat_alloc_new_dir(struct inode *dir, struct timespec *ts)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tstruct msdos_dir_entry *de;\n\tsector_t blknr;\n\t__le16 date, time;\n\tu8 time_cs;\n\tint err, cluster;\n\n\terr = fat_alloc_clusters(dir, &cluster, 1);\n\tif (err)\n\t\tgoto error;\n\n\tblknr = fat_clus_to_blknr(sbi, cluster);\n\tbhs[0] = sb_getblk(sb, blknr);\n\tif (!bhs[0]) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free;\n\t}\n\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\n\tde = (struct msdos_dir_entry *)bhs[0]->b_data;\n\t/* filling the new directory slots (\".\" and \"..\" entries) */\n\tmemcpy(de[0].name, MSDOS_DOT, MSDOS_NAME);\n\tmemcpy(de[1].name, MSDOS_DOTDOT, MSDOS_NAME);\n\tde->attr = de[1].attr = ATTR_DIR;\n\tde[0].lcase = de[1].lcase = 0;\n\tde[0].time = de[1].time = time;\n\tde[0].date = de[1].date = date;\n\tif (sbi->options.isvfat) {\n\t\t/* extra timestamps */\n\t\tde[0].ctime = de[1].ctime = time;\n\t\tde[0].ctime_cs = de[1].ctime_cs = time_cs;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = date;\n\t} else {\n\t\tde[0].ctime = de[1].ctime = 0;\n\t\tde[0].ctime_cs = de[1].ctime_cs = 0;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = 0;\n\t}\n\tfat_set_start(&de[0], cluster);\n\tfat_set_start(&de[1], MSDOS_I(dir)->i_logstart);\n\tde[0].size = de[1].size = 0;\n\tmemset(de + 2, 0, sb->s_blocksize - 2 * sizeof(*de));\n\tset_buffer_uptodate(bhs[0]);\n\tmark_buffer_dirty_inode(bhs[0], dir);\n\n\terr = fat_zeroed_cluster(dir, blknr, 1, bhs, MAX_BUF_PER_PAGE);\n\tif (err)\n\t\tgoto error_free;\n\n\treturn cluster;\n\nerror_free:\n\tfat_free_clusters(dir, cluster);\nerror:\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_alloc_new_dir(struct inode *dir, struct timespec *ts)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bhs[MAX_BUF_PER_PAGE];\n\tstruct msdos_dir_entry *de;\n\tsector_t blknr;\n\t__le16 date, time;\n\tu8 time_cs;\n\tint err, cluster;\n\n\terr = fat_alloc_clusters(dir, &cluster, 1);\n\tif (err)\n\t\tgoto error;\n\n\tblknr = fat_clus_to_blknr(sbi, cluster);\n\tbhs[0] = sb_getblk(sb, blknr);\n\tif (!bhs[0]) {\n\t\terr = -ENOMEM;\n\t\tgoto error_free;\n\t}\n\n\tfat_time_unix2fat(sbi, ts, &time, &date, &time_cs);\n\n\tde = (struct msdos_dir_entry *)bhs[0]->b_data;\n\t/* filling the new directory slots (\".\" and \"..\" entries) */\n\tmemcpy(de[0].name, MSDOS_DOT, MSDOS_NAME);\n\tmemcpy(de[1].name, MSDOS_DOTDOT, MSDOS_NAME);\n\tde->attr = de[1].attr = ATTR_DIR;\n\tde[0].lcase = de[1].lcase = 0;\n\tde[0].time = de[1].time = time;\n\tde[0].date = de[1].date = date;\n\tif (sbi->options.isvfat) {\n\t\t/* extra timestamps */\n\t\tde[0].ctime = de[1].ctime = time;\n\t\tde[0].ctime_cs = de[1].ctime_cs = time_cs;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = date;\n\t} else {\n\t\tde[0].ctime = de[1].ctime = 0;\n\t\tde[0].ctime_cs = de[1].ctime_cs = 0;\n\t\tde[0].adate = de[0].cdate = de[1].adate = de[1].cdate = 0;\n\t}\n\tfat_set_start(&de[0], cluster);\n\tfat_set_start(&de[1], MSDOS_I(dir)->i_logstart);\n\tde[0].size = de[1].size = 0;\n\tmemset(de + 2, 0, sb->s_blocksize - 2 * sizeof(*de));\n\tset_buffer_uptodate(bhs[0]);\n\tmark_buffer_dirty_inode(bhs[0], dir);\n\n\terr = fat_zeroed_cluster(dir, blknr, 1, bhs, MAX_BUF_PER_PAGE);\n\tif (err)\n\t\tgoto error_free;\n\n\treturn cluster;\n\nerror_free:\n\tfat_free_clusters(dir, cluster);\nerror:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_scan",
          "args": [
            "dir",
            "msdos_name",
            "&sinfo"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "fat_scan_logstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "976-993",
          "snippet": "int fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msdos_format_name",
          "args": [
            "dentry->d_name.name",
            "dentry->d_name.len",
            "msdos_name",
            "&MSDOS_SB(sb)->options"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "msdos_format_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "19-116",
          "snippet": "static int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char bad_chars[] = \"*?<>|\\\"\";",
            "static unsigned char bad_if_strict[] = \"+=,; \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic unsigned char bad_chars[] = \"*?<>|\\\"\";\nstatic unsigned char bad_if_strict[] = \"+=,; \";\n\nstatic int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tstruct inode *inode;\n\tunsigned char msdos_name[MSDOS_NAME];\n\tstruct timespec ts;\n\tint err, is_hid, cluster;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = msdos_format_name(dentry->d_name.name, dentry->d_name.len,\n\t\t\t\tmsdos_name, &MSDOS_SB(sb)->options);\n\tif (err)\n\t\tgoto out;\n\tis_hid = (dentry->d_name.name[0] == '.') && (msdos_name[0] != '.');\n\t/* foo vs .foo situation */\n\tif (!fat_scan(dir, msdos_name, &sinfo)) {\n\t\tbrelse(sinfo.bh);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tts = CURRENT_TIME_SEC;\n\tcluster = fat_alloc_new_dir(dir, &ts);\n\tif (cluster < 0) {\n\t\terr = cluster;\n\t\tgoto out;\n\t}\n\terr = msdos_add_entry(dir, msdos_name, 1, is_hid, cluster, &ts, &sinfo);\n\tif (err)\n\t\tgoto out_free;\n\tinc_nlink(dir);\n\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\t/* the directory was completed, just return a error */\n\t\tgoto out;\n\t}\n\tset_nlink(inode, 2);\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = ts;\n\t/* timestamp is already written, so mark_inode_dirty() is unneeded. */\n\n\td_instantiate(dentry, inode);\n\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tfat_flush_inodes(sb, dir, inode);\n\treturn 0;\n\nout_free:\n\tfat_free_clusters(dir, cluster);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "msdos_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "310-343",
    "snippet": "static int msdos_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\t/*\n\t * Check whether the directory is not in use, then check\n\t * whether it is empty.\n\t */\n\terr = fat_dir_empty(inode);\n\tif (err)\n\t\tgoto out;\n\terr = msdos_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t/* and releases bh */\n\tif (err)\n\t\tgoto out;\n\tdrop_nlink(dir);\n\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tfat_detach(inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!err)\n\t\terr = fat_flush_inodes(sb, dir, inode);\n\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_flush_inodes",
          "args": [
            "sb",
            "dir",
            "inode"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "fat_flush_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1816-1830",
          "snippet": "int fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_detach",
          "args": [
            "inode"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "fat_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "398-411",
          "snippet": "void fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid fat_detach(struct inode *inode)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(inode->i_sb);\n\tspin_lock(&sbi->inode_hash_lock);\n\tMSDOS_I(inode)->i_pos = 0;\n\thlist_del_init(&MSDOS_I(inode)->i_fat_hash);\n\tspin_unlock(&sbi->inode_hash_lock);\n\n\tif (S_ISDIR(inode->i_mode) && sbi->options.nfs) {\n\t\tspin_lock(&sbi->dir_hash_lock);\n\t\thlist_del_init(&MSDOS_I(inode)->i_dir_hash);\n\t\tspin_unlock(&sbi->dir_hash_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "dir"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_remove_entries",
          "args": [
            "dir",
            "&sinfo"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "fat_remove_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1030-1079",
          "snippet": "int fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_remove_entries(struct inode *dir, struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_dir_entry *de;\n\tstruct buffer_head *bh;\n\tint err = 0, nr_slots;\n\n\t/*\n\t * First stage: Remove the shortname. By this, the directory\n\t * entry is removed.\n\t */\n\tnr_slots = sinfo->nr_slots;\n\tde = sinfo->de;\n\tsinfo->de = NULL;\n\tbh = sinfo->bh;\n\tsinfo->bh = NULL;\n\twhile (nr_slots && de >= (struct msdos_dir_entry *)bh->b_data) {\n\t\tde->name[0] = DELETED_FLAG;\n\t\tde--;\n\t\tnr_slots--;\n\t}\n\tmark_buffer_dirty_inode(bh, dir);\n\tif (IS_DIRSYNC(dir))\n\t\terr = sync_dirty_buffer(bh);\n\tbrelse(bh);\n\tif (err)\n\t\treturn err;\n\tdir->i_version++;\n\n\tif (nr_slots) {\n\t\t/*\n\t\t * Second stage: remove the remaining longname slots.\n\t\t * (This directory entry is already removed, and so return\n\t\t * the success)\n\t\t */\n\t\terr = __fat_remove_entries(dir, sinfo->slot_off, nr_slots);\n\t\tif (err) {\n\t\t\tfat_msg(sb, KERN_WARNING,\n\t\t\t       \"Couldn't remove the long name slots\");\n\t\t}\n\t}\n\n\tdir->i_mtime = dir->i_atime = CURRENT_TIME_SEC;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msdos_find",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&sinfo"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "msdos_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "119-143",
          "snippet": "static int msdos_find(struct inode *dir, const unsigned char *name, int len,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint err;\n\n\terr = msdos_format_name(name, len, msdos_name, &sbi->options);\n\tif (err)\n\t\treturn -ENOENT;\n\n\terr = fat_scan(dir, msdos_name, sinfo);\n\tif (!err && sbi->options.dotsOK) {\n\t\tif (name[0] == '.') {\n\t\t\tif (!(sinfo->de->attr & ATTR_HIDDEN))\n\t\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\tif (sinfo->de->attr & ATTR_HIDDEN)\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tif (err)\n\t\t\tbrelse(sinfo->bh);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_find(struct inode *dir, const unsigned char *name, int len,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint err;\n\n\terr = msdos_format_name(name, len, msdos_name, &sbi->options);\n\tif (err)\n\t\treturn -ENOENT;\n\n\terr = fat_scan(dir, msdos_name, sinfo);\n\tif (!err && sbi->options.dotsOK) {\n\t\tif (name[0] == '.') {\n\t\t\tif (!(sinfo->de->attr & ATTR_HIDDEN))\n\t\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\tif (sinfo->de->attr & ATTR_HIDDEN)\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tif (err)\n\t\t\tbrelse(sinfo->bh);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_dir_empty",
          "args": [
            "inode"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "fat_dir_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "906-924",
          "snippet": "int fat_dir_empty(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint result = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (strncmp(de->name, MSDOS_DOT   , MSDOS_NAME) &&\n\t\t    strncmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\t\tresult = -ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn result;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_dir_empty(struct inode *dir)\n{\n\tstruct buffer_head *bh;\n\tstruct msdos_dir_entry *de;\n\tloff_t cpos;\n\tint result = 0;\n\n\tbh = NULL;\n\tcpos = 0;\n\twhile (fat_get_short_entry(dir, &cpos, &bh, &de) >= 0) {\n\t\tif (strncmp(de->name, MSDOS_DOT   , MSDOS_NAME) &&\n\t\t    strncmp(de->name, MSDOS_DOTDOT, MSDOS_NAME)) {\n\t\t\tresult = -ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t}\n\tbrelse(bh);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct fat_slot_info sinfo;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\t/*\n\t * Check whether the directory is not in use, then check\n\t * whether it is empty.\n\t */\n\terr = fat_dir_empty(inode);\n\tif (err)\n\t\tgoto out;\n\terr = msdos_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);\n\tif (err)\n\t\tgoto out;\n\n\terr = fat_remove_entries(dir, &sinfo);\t/* and releases bh */\n\tif (err)\n\t\tgoto out;\n\tdrop_nlink(dir);\n\n\tclear_nlink(inode);\n\tinode->i_ctime = CURRENT_TIME_SEC;\n\tfat_detach(inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!err)\n\t\terr = fat_flush_inodes(sb, dir, inode);\n\n\treturn err;\n}"
  },
  {
    "function_name": "msdos_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "264-307",
    "snippet": "static int msdos_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\tbool excl)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = NULL;\n\tstruct fat_slot_info sinfo;\n\tstruct timespec ts;\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint err, is_hid;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = msdos_format_name(dentry->d_name.name, dentry->d_name.len,\n\t\t\t\tmsdos_name, &MSDOS_SB(sb)->options);\n\tif (err)\n\t\tgoto out;\n\tis_hid = (dentry->d_name.name[0] == '.') && (msdos_name[0] != '.');\n\t/* Have to do it due to foo vs. .foo conflicts */\n\tif (!fat_scan(dir, msdos_name, &sinfo)) {\n\t\tbrelse(sinfo.bh);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tts = CURRENT_TIME_SEC;\n\terr = msdos_add_entry(dir, msdos_name, 0, is_hid, 0, &ts, &sinfo);\n\tif (err)\n\t\tgoto out;\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = ts;\n\t/* timestamp is already written, so mark_inode_dirty() is unneeded. */\n\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!err)\n\t\terr = fat_flush_inodes(sb, dir, inode);\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fat_flush_inodes",
          "args": [
            "sb",
            "dir",
            "inode"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "fat_flush_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "1816-1830",
          "snippet": "int fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_flush_inodes(struct super_block *sb, struct inode *i1, struct inode *i2)\n{\n\tint ret = 0;\n\tif (!MSDOS_SB(sb)->options.flush)\n\t\treturn 0;\n\tif (i1)\n\t\tret = writeback_inode(i1);\n\tif (!ret && i2)\n\t\tret = writeback_inode(i2);\n\tif (!ret) {\n\t\tstruct address_space *mapping = sb->s_bdev->bd_inode->i_mapping;\n\t\tret = filemap_flush(mapping);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sinfo.bh"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_build_inode",
          "args": [
            "sb",
            "sinfo.de",
            "sinfo.i_pos"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "fat_build_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "533-561",
          "snippet": "struct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msdos_add_entry",
          "args": [
            "dir",
            "msdos_name",
            "0",
            "is_hid",
            "0",
            "&ts",
            "&sinfo"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "msdos_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "227-261",
          "snippet": "static int msdos_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t   int is_dir, int is_hid, int cluster,\n\t\t\t   struct timespec *ts, struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct msdos_dir_entry de;\n\t__le16 time, date;\n\tint err;\n\n\tmemcpy(de.name, name, MSDOS_NAME);\n\tde.attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tif (is_hid)\n\t\tde.attr |= ATTR_HIDDEN;\n\tde.lcase = 0;\n\tfat_time_unix2fat(sbi, ts, &time, &date, NULL);\n\tde.cdate = de.adate = 0;\n\tde.ctime = 0;\n\tde.ctime_cs = 0;\n\tde.time = time;\n\tde.date = date;\n\tfat_set_start(&de, cluster);\n\tde.size = 0;\n\n\terr = fat_add_entries(dir, &de, 1, sinfo);\n\tif (err)\n\t\treturn err;\n\n\tdir->i_ctime = dir->i_mtime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t   int is_dir, int is_hid, int cluster,\n\t\t\t   struct timespec *ts, struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct msdos_dir_entry de;\n\t__le16 time, date;\n\tint err;\n\n\tmemcpy(de.name, name, MSDOS_NAME);\n\tde.attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tif (is_hid)\n\t\tde.attr |= ATTR_HIDDEN;\n\tde.lcase = 0;\n\tfat_time_unix2fat(sbi, ts, &time, &date, NULL);\n\tde.cdate = de.adate = 0;\n\tde.ctime = 0;\n\tde.ctime_cs = 0;\n\tde.time = time;\n\tde.date = date;\n\tfat_set_start(&de, cluster);\n\tde.size = 0;\n\n\terr = fat_add_entries(dir, &de, 1, sinfo);\n\tif (err)\n\t\treturn err;\n\n\tdir->i_ctime = dir->i_mtime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_scan",
          "args": [
            "dir",
            "msdos_name",
            "&sinfo"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "fat_scan_logstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "976-993",
          "snippet": "int fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msdos_format_name",
          "args": [
            "dentry->d_name.name",
            "dentry->d_name.len",
            "msdos_name",
            "&MSDOS_SB(sb)->options"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "msdos_format_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "19-116",
          "snippet": "static int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char bad_chars[] = \"*?<>|\\\"\";",
            "static unsigned char bad_if_strict[] = \"+=,; \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic unsigned char bad_chars[] = \"*?<>|\\\"\";\nstatic unsigned char bad_if_strict[] = \"+=,; \";\n\nstatic int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\tbool excl)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode = NULL;\n\tstruct fat_slot_info sinfo;\n\tstruct timespec ts;\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint err, is_hid;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\n\terr = msdos_format_name(dentry->d_name.name, dentry->d_name.len,\n\t\t\t\tmsdos_name, &MSDOS_SB(sb)->options);\n\tif (err)\n\t\tgoto out;\n\tis_hid = (dentry->d_name.name[0] == '.') && (msdos_name[0] != '.');\n\t/* Have to do it due to foo vs. .foo conflicts */\n\tif (!fat_scan(dir, msdos_name, &sinfo)) {\n\t\tbrelse(sinfo.bh);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tts = CURRENT_TIME_SEC;\n\terr = msdos_add_entry(dir, msdos_name, 0, is_hid, 0, &ts, &sinfo);\n\tif (err)\n\t\tgoto out;\n\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\tbrelse(sinfo.bh);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = ts;\n\t/* timestamp is already written, so mark_inode_dirty() is unneeded. */\n\n\td_instantiate(dentry, inode);\nout:\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\tif (!err)\n\t\terr = fat_flush_inodes(sb, dir, inode);\n\treturn err;\n}"
  },
  {
    "function_name": "msdos_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "227-261",
    "snippet": "static int msdos_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t   int is_dir, int is_hid, int cluster,\n\t\t\t   struct timespec *ts, struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct msdos_dir_entry de;\n\t__le16 time, date;\n\tint err;\n\n\tmemcpy(de.name, name, MSDOS_NAME);\n\tde.attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tif (is_hid)\n\t\tde.attr |= ATTR_HIDDEN;\n\tde.lcase = 0;\n\tfat_time_unix2fat(sbi, ts, &time, &date, NULL);\n\tde.cdate = de.adate = 0;\n\tde.ctime = 0;\n\tde.ctime_cs = 0;\n\tde.time = time;\n\tde.date = date;\n\tfat_set_start(&de, cluster);\n\tde.size = 0;\n\n\terr = fat_add_entries(dir, &de, 1, sinfo);\n\tif (err)\n\t\treturn err;\n\n\tdir->i_ctime = dir->i_mtime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_sync_inode",
          "args": [
            "dir"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "fat_sync_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "824-827",
          "snippet": "int fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint fat_sync_inode(struct inode *inode)\n{\n\treturn __fat_write_inode(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fat_add_entries",
          "args": [
            "dir",
            "&de",
            "1",
            "sinfo"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "fat_add_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "1273-1405",
          "snippet": "int fat_add_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t    struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh, *prev, *bhs[3]; /* 32*slots (672bytes) */\n\tstruct msdos_dir_entry *uninitialized_var(de);\n\tint err, free_slots, i, nr_bhs;\n\tloff_t pos, i_pos;\n\n\tsinfo->nr_slots = nr_slots;\n\n\t/* First stage: search free directory entries */\n\tfree_slots = nr_bhs = 0;\n\tbh = prev = NULL;\n\tpos = 0;\n\terr = -ENOSPC;\n\twhile (fat_get_entry(dir, &pos, &bh, &de) > -1) {\n\t\t/* check the maximum size of directory */\n\t\tif (pos >= FAT_MAX_DIR_SIZE)\n\t\t\tgoto error;\n\n\t\tif (IS_FREE(de->name)) {\n\t\t\tif (prev != bh) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tbhs[nr_bhs] = prev = bh;\n\t\t\t\tnr_bhs++;\n\t\t\t}\n\t\t\tfree_slots++;\n\t\t\tif (free_slots == nr_slots)\n\t\t\t\tgoto found;\n\t\t} else {\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tprev = NULL;\n\t\t\tfree_slots = nr_bhs = 0;\n\t\t}\n\t}\n\tif (dir->i_ino == MSDOS_ROOT_INO) {\n\t\tif (sbi->fat_bits != 32)\n\t\t\tgoto error;\n\t} else if (MSDOS_I(dir)->i_start == 0) {\n\t\tfat_msg(sb, KERN_ERR, \"Corrupted directory (i_pos %lld)\",\n\t\t       MSDOS_I(dir)->i_pos);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\nfound:\n\terr = 0;\n\tpos -= free_slots * sizeof(*de);\n\tnr_slots -= free_slots;\n\tif (free_slots) {\n\t\t/*\n\t\t * Second stage: filling the free entries with new entries.\n\t\t * NOTE: If this slots has shortname, first, we write\n\t\t * the long name slots, then write the short name.\n\t\t */\n\t\tint size = free_slots * sizeof(*de);\n\t\tint offset = pos & (sb->s_blocksize - 1);\n\t\tint long_bhs = nr_bhs - (nr_slots == 0);\n\n\t\t/* Fill the long name slots. */\n\t\tfor (i = 0; i < long_bhs; i++) {\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\toffset = 0;\n\t\t\tslots += copy;\n\t\t\tsize -= copy;\n\t\t}\n\t\tif (long_bhs && IS_DIRSYNC(dir))\n\t\t\terr = fat_sync_bhs(bhs, long_bhs);\n\t\tif (!err && i < nr_bhs) {\n\t\t\t/* Fill the short name slot. */\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\tif (IS_DIRSYNC(dir))\n\t\t\t\terr = sync_dirty_buffer(bhs[i]);\n\t\t}\n\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\tbrelse(bhs[i]);\n\t\tif (err)\n\t\t\tgoto error_remove;\n\t}\n\n\tif (nr_slots) {\n\t\tint cluster, nr_cluster;\n\n\t\t/*\n\t\t * Third stage: allocate the cluster for new entries.\n\t\t * And initialize the cluster with new entries, then\n\t\t * add the cluster to dir.\n\t\t */\n\t\tcluster = fat_add_new_entries(dir, slots, nr_slots, &nr_cluster,\n\t\t\t\t\t      &de, &bh, &i_pos);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error_remove;\n\t\t}\n\t\terr = fat_chain_add(dir, cluster, nr_cluster);\n\t\tif (err) {\n\t\t\tfat_free_clusters(dir, cluster);\n\t\t\tgoto error_remove;\n\t\t}\n\t\tif (dir->i_size & (sbi->cluster_size - 1)) {\n\t\t\tfat_fs_error(sb, \"Odd directory size\");\n\t\t\tdir->i_size = (dir->i_size + sbi->cluster_size - 1)\n\t\t\t\t& ~((loff_t)sbi->cluster_size - 1);\n\t\t}\n\t\tdir->i_size += nr_cluster << sbi->cluster_bits;\n\t\tMSDOS_I(dir)->mmu_private += nr_cluster << sbi->cluster_bits;\n\t}\n\tsinfo->slot_off = pos;\n\tsinfo->de = de;\n\tsinfo->bh = bh;\n\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\n\treturn 0;\n\nerror:\n\tbrelse(bh);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\treturn err;\n\nerror_remove:\n\tbrelse(bh);\n\tif (free_slots)\n\t\t__fat_remove_entries(dir, pos, free_slots);\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_add_entries(struct inode *dir, void *slots, int nr_slots,\n\t\t    struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct msdos_sb_info *sbi = MSDOS_SB(sb);\n\tstruct buffer_head *bh, *prev, *bhs[3]; /* 32*slots (672bytes) */\n\tstruct msdos_dir_entry *uninitialized_var(de);\n\tint err, free_slots, i, nr_bhs;\n\tloff_t pos, i_pos;\n\n\tsinfo->nr_slots = nr_slots;\n\n\t/* First stage: search free directory entries */\n\tfree_slots = nr_bhs = 0;\n\tbh = prev = NULL;\n\tpos = 0;\n\terr = -ENOSPC;\n\twhile (fat_get_entry(dir, &pos, &bh, &de) > -1) {\n\t\t/* check the maximum size of directory */\n\t\tif (pos >= FAT_MAX_DIR_SIZE)\n\t\t\tgoto error;\n\n\t\tif (IS_FREE(de->name)) {\n\t\t\tif (prev != bh) {\n\t\t\t\tget_bh(bh);\n\t\t\t\tbhs[nr_bhs] = prev = bh;\n\t\t\t\tnr_bhs++;\n\t\t\t}\n\t\t\tfree_slots++;\n\t\t\tif (free_slots == nr_slots)\n\t\t\t\tgoto found;\n\t\t} else {\n\t\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\t\tbrelse(bhs[i]);\n\t\t\tprev = NULL;\n\t\t\tfree_slots = nr_bhs = 0;\n\t\t}\n\t}\n\tif (dir->i_ino == MSDOS_ROOT_INO) {\n\t\tif (sbi->fat_bits != 32)\n\t\t\tgoto error;\n\t} else if (MSDOS_I(dir)->i_start == 0) {\n\t\tfat_msg(sb, KERN_ERR, \"Corrupted directory (i_pos %lld)\",\n\t\t       MSDOS_I(dir)->i_pos);\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\nfound:\n\terr = 0;\n\tpos -= free_slots * sizeof(*de);\n\tnr_slots -= free_slots;\n\tif (free_slots) {\n\t\t/*\n\t\t * Second stage: filling the free entries with new entries.\n\t\t * NOTE: If this slots has shortname, first, we write\n\t\t * the long name slots, then write the short name.\n\t\t */\n\t\tint size = free_slots * sizeof(*de);\n\t\tint offset = pos & (sb->s_blocksize - 1);\n\t\tint long_bhs = nr_bhs - (nr_slots == 0);\n\n\t\t/* Fill the long name slots. */\n\t\tfor (i = 0; i < long_bhs; i++) {\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\toffset = 0;\n\t\t\tslots += copy;\n\t\t\tsize -= copy;\n\t\t}\n\t\tif (long_bhs && IS_DIRSYNC(dir))\n\t\t\terr = fat_sync_bhs(bhs, long_bhs);\n\t\tif (!err && i < nr_bhs) {\n\t\t\t/* Fill the short name slot. */\n\t\t\tint copy = min_t(int, sb->s_blocksize - offset, size);\n\t\t\tmemcpy(bhs[i]->b_data + offset, slots, copy);\n\t\t\tmark_buffer_dirty_inode(bhs[i], dir);\n\t\t\tif (IS_DIRSYNC(dir))\n\t\t\t\terr = sync_dirty_buffer(bhs[i]);\n\t\t}\n\t\tfor (i = 0; i < nr_bhs; i++)\n\t\t\tbrelse(bhs[i]);\n\t\tif (err)\n\t\t\tgoto error_remove;\n\t}\n\n\tif (nr_slots) {\n\t\tint cluster, nr_cluster;\n\n\t\t/*\n\t\t * Third stage: allocate the cluster for new entries.\n\t\t * And initialize the cluster with new entries, then\n\t\t * add the cluster to dir.\n\t\t */\n\t\tcluster = fat_add_new_entries(dir, slots, nr_slots, &nr_cluster,\n\t\t\t\t\t      &de, &bh, &i_pos);\n\t\tif (cluster < 0) {\n\t\t\terr = cluster;\n\t\t\tgoto error_remove;\n\t\t}\n\t\terr = fat_chain_add(dir, cluster, nr_cluster);\n\t\tif (err) {\n\t\t\tfat_free_clusters(dir, cluster);\n\t\t\tgoto error_remove;\n\t\t}\n\t\tif (dir->i_size & (sbi->cluster_size - 1)) {\n\t\t\tfat_fs_error(sb, \"Odd directory size\");\n\t\t\tdir->i_size = (dir->i_size + sbi->cluster_size - 1)\n\t\t\t\t& ~((loff_t)sbi->cluster_size - 1);\n\t\t}\n\t\tdir->i_size += nr_cluster << sbi->cluster_bits;\n\t\tMSDOS_I(dir)->mmu_private += nr_cluster << sbi->cluster_bits;\n\t}\n\tsinfo->slot_off = pos;\n\tsinfo->de = de;\n\tsinfo->bh = bh;\n\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\n\treturn 0;\n\nerror:\n\tbrelse(bh);\n\tfor (i = 0; i < nr_bhs; i++)\n\t\tbrelse(bhs[i]);\n\treturn err;\n\nerror_remove:\n\tbrelse(bh);\n\tif (free_slots)\n\t\t__fat_remove_entries(dir, pos, free_slots);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_set_start",
          "args": [
            "&de",
            "cluster"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "fat_set_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "267-271",
          "snippet": "static inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fat_set_start(struct msdos_dir_entry *de, int cluster)\n{\n\tde->start   = cpu_to_le16(cluster);\n\tde->starthi = cpu_to_le16(cluster >> 16);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_time_unix2fat",
          "args": [
            "sbi",
            "ts",
            "&time",
            "&date",
            "NULL"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "fat_time_unix2fat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/misc.c",
          "lines": "231-266",
          "snippet": "void fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 *time, __le16 *date, u8 *time_cs)\n{\n\tstruct tm tm;\n\ttime_to_tm(ts->tv_sec,\n\t\t   (sbi->options.tz_set ? sbi->options.time_offset :\n\t\t   -sys_tz.tz_minuteswest) * SECS_PER_MIN, &tm);\n\n\t/*  FAT can only support year between 1980 to 2107 */\n\tif (tm.tm_year < 1980 - 1900) {\n\t\t*time = 0;\n\t\t*date = cpu_to_le16((0 << 9) | (1 << 5) | 1);\n\t\tif (time_cs)\n\t\t\t*time_cs = 0;\n\t\treturn;\n\t}\n\tif (tm.tm_year > 2107 - 1900) {\n\t\t*time = cpu_to_le16((23 << 11) | (59 << 5) | 29);\n\t\t*date = cpu_to_le16((127 << 9) | (12 << 5) | 31);\n\t\tif (time_cs)\n\t\t\t*time_cs = 199;\n\t\treturn;\n\t}\n\n\t/* from 1900 -> from 1980 */\n\ttm.tm_year -= 80;\n\t/* 0~11 -> 1~12 */\n\ttm.tm_mon++;\n\t/* 0~59 -> 0~29(2sec counts) */\n\ttm.tm_sec >>= 1;\n\n\t*time = cpu_to_le16(tm.tm_hour << 11 | tm.tm_min << 5 | tm.tm_sec);\n\t*date = cpu_to_le16(tm.tm_year << 9 | tm.tm_mon << 5 | tm.tm_mday);\n\tif (time_cs)\n\t\t*time_cs = (ts->tv_sec & 1) * 100 + ts->tv_nsec / 10000000;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/time.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SECS_PER_MIN\t60"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/time.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\n#define SECS_PER_MIN\t60\n\nvoid fat_time_unix2fat(struct msdos_sb_info *sbi, struct timespec *ts,\n\t\t       __le16 *time, __le16 *date, u8 *time_cs)\n{\n\tstruct tm tm;\n\ttime_to_tm(ts->tv_sec,\n\t\t   (sbi->options.tz_set ? sbi->options.time_offset :\n\t\t   -sys_tz.tz_minuteswest) * SECS_PER_MIN, &tm);\n\n\t/*  FAT can only support year between 1980 to 2107 */\n\tif (tm.tm_year < 1980 - 1900) {\n\t\t*time = 0;\n\t\t*date = cpu_to_le16((0 << 9) | (1 << 5) | 1);\n\t\tif (time_cs)\n\t\t\t*time_cs = 0;\n\t\treturn;\n\t}\n\tif (tm.tm_year > 2107 - 1900) {\n\t\t*time = cpu_to_le16((23 << 11) | (59 << 5) | 29);\n\t\t*date = cpu_to_le16((127 << 9) | (12 << 5) | 31);\n\t\tif (time_cs)\n\t\t\t*time_cs = 199;\n\t\treturn;\n\t}\n\n\t/* from 1900 -> from 1980 */\n\ttm.tm_year -= 80;\n\t/* 0~11 -> 1~12 */\n\ttm.tm_mon++;\n\t/* 0~59 -> 0~29(2sec counts) */\n\ttm.tm_sec >>= 1;\n\n\t*time = cpu_to_le16(tm.tm_hour << 11 | tm.tm_min << 5 | tm.tm_sec);\n\t*date = cpu_to_le16(tm.tm_year << 9 | tm.tm_mon << 5 | tm.tm_mday);\n\tif (time_cs)\n\t\t*time_cs = (ts->tv_sec & 1) * 100 + ts->tv_nsec / 10000000;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de.name",
            "name",
            "MSDOS_NAME"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_add_entry(struct inode *dir, const unsigned char *name,\n\t\t\t   int is_dir, int is_hid, int cluster,\n\t\t\t   struct timespec *ts, struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tstruct msdos_dir_entry de;\n\t__le16 time, date;\n\tint err;\n\n\tmemcpy(de.name, name, MSDOS_NAME);\n\tde.attr = is_dir ? ATTR_DIR : ATTR_ARCH;\n\tif (is_hid)\n\t\tde.attr |= ATTR_HIDDEN;\n\tde.lcase = 0;\n\tfat_time_unix2fat(sbi, ts, &time, &date, NULL);\n\tde.cdate = de.adate = 0;\n\tde.ctime = 0;\n\tde.ctime_cs = 0;\n\tde.time = time;\n\tde.date = date;\n\tfat_set_start(&de, cluster);\n\tde.size = 0;\n\n\terr = fat_add_entries(dir, &de, 1, sinfo);\n\tif (err)\n\t\treturn err;\n\n\tdir->i_ctime = dir->i_mtime = *ts;\n\tif (IS_DIRSYNC(dir))\n\t\t(void)fat_sync_inode(dir);\n\telse\n\t\tmark_inode_dirty(dir);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "msdos_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "201-224",
    "snippet": "static struct dentry *msdos_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tstruct inode *inode;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\terr = msdos_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);\n\tswitch (err) {\n\tcase -ENOENT:\n\t\tinode = NULL;\n\t\tbreak;\n\tcase 0:\n\t\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\t\tbrelse(sinfo.bh);\n\t\tbreak;\n\tdefault:\n\t\tinode = ERR_PTR(err);\n\t}\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn d_splice_alias(inode, dentry);\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_splice_alias",
          "args": [
            "inode",
            "dentry"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "d_splice_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2741-2792",
          "snippet": "struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\n__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock);\n\nstruct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)\n{\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\tBUG_ON(!d_unhashed(dentry));\n\n\tif (!inode) {\n\t\t__d_instantiate(dentry, NULL);\n\t\tgoto out;\n\t}\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tstruct dentry *new = __d_find_any_alias(inode);\n\t\tif (unlikely(new)) {\n\t\t\twrite_seqlock(&rename_lock);\n\t\t\tif (unlikely(d_ancestor(new, dentry))) {\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tdput(new);\n\t\t\t\tnew = ERR_PTR(-ELOOP);\n\t\t\t\tpr_warn_ratelimited(\n\t\t\t\t\t\"VFS: Lookup of '%s' in %s %s\"\n\t\t\t\t\t\" would have caused loop\\n\",\n\t\t\t\t\tdentry->d_name.name,\n\t\t\t\t\tinode->i_sb->s_type->name,\n\t\t\t\t\tinode->i_sb->s_id);\n\t\t\t} else if (!IS_ROOT(new)) {\n\t\t\t\tint err = __d_unalias(inode, dentry, new);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tif (err) {\n\t\t\t\t\tdput(new);\n\t\t\t\t\tnew = ERR_PTR(err);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t__d_move(new, dentry, false);\n\t\t\t\twrite_sequnlock(&rename_lock);\n\t\t\t\tspin_unlock(&inode->i_lock);\n\t\t\t\tsecurity_d_instantiate(new, inode);\n\t\t\t}\n\t\t\tiput(inode);\n\t\t\treturn new;\n\t\t}\n\t}\n\t/* already taking inode->i_lock, so d_add() by hand */\n\t__d_instantiate(dentry, inode);\n\tspin_unlock(&inode->i_lock);\nout:\n\tsecurity_d_instantiate(dentry, inode);\n\td_rehash(dentry);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "sb"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sinfo.bh"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_build_inode",
          "args": [
            "sb",
            "sinfo.de",
            "sinfo.i_pos"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "fat_build_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/inode.c",
          "lines": "533-561",
          "snippet": "struct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/aio.h>",
            "#include <linux/mount.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <asm/unaligned.h>\n#include <linux/blkdev.h>\n#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/aio.h>\n#include <linux/mount.h>\n#include <linux/buffer_head.h>\n#include <linux/mpage.h>\n#include <linux/pagemap.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct inode *fat_build_inode(struct super_block *sb,\n\t\t\tstruct msdos_dir_entry *de, loff_t i_pos)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tfat_lock_build_inode(MSDOS_SB(sb));\n\tinode = fat_iget(sb, i_pos);\n\tif (inode)\n\t\tgoto out;\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tinode = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinode->i_ino = iunique(sb, MSDOS_ROOT_INO);\n\tinode->i_version = 1;\n\terr = fat_fill_inode(inode, de);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\tfat_attach(inode, i_pos);\n\tinsert_inode_hash(inode);\nout:\n\tfat_unlock_build_inode(MSDOS_SB(sb));\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msdos_find",
          "args": [
            "dir",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "&sinfo"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "msdos_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "119-143",
          "snippet": "static int msdos_find(struct inode *dir, const unsigned char *name, int len,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint err;\n\n\terr = msdos_format_name(name, len, msdos_name, &sbi->options);\n\tif (err)\n\t\treturn -ENOENT;\n\n\terr = fat_scan(dir, msdos_name, sinfo);\n\tif (!err && sbi->options.dotsOK) {\n\t\tif (name[0] == '.') {\n\t\t\tif (!(sinfo->de->attr & ATTR_HIDDEN))\n\t\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\tif (sinfo->de->attr & ATTR_HIDDEN)\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tif (err)\n\t\t\tbrelse(sinfo->bh);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_find(struct inode *dir, const unsigned char *name, int len,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint err;\n\n\terr = msdos_format_name(name, len, msdos_name, &sbi->options);\n\tif (err)\n\t\treturn -ENOENT;\n\n\terr = fat_scan(dir, msdos_name, sinfo);\n\tif (!err && sbi->options.dotsOK) {\n\t\tif (name[0] == '.') {\n\t\t\tif (!(sinfo->de->attr & ATTR_HIDDEN))\n\t\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\tif (sinfo->de->attr & ATTR_HIDDEN)\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tif (err)\n\t\t\tbrelse(sinfo->bh);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&MSDOS_SB(sb)->s_lock"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct dentry *msdos_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t   unsigned int flags)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct fat_slot_info sinfo;\n\tstruct inode *inode;\n\tint err;\n\n\tmutex_lock(&MSDOS_SB(sb)->s_lock);\n\terr = msdos_find(dir, dentry->d_name.name, dentry->d_name.len, &sinfo);\n\tswitch (err) {\n\tcase -ENOENT:\n\t\tinode = NULL;\n\t\tbreak;\n\tcase 0:\n\t\tinode = fat_build_inode(sb, sinfo.de, sinfo.i_pos);\n\t\tbrelse(sinfo.bh);\n\t\tbreak;\n\tdefault:\n\t\tinode = ERR_PTR(err);\n\t}\n\tmutex_unlock(&MSDOS_SB(sb)->s_lock);\n\treturn d_splice_alias(inode, dentry);\n}"
  },
  {
    "function_name": "msdos_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "167-189",
    "snippet": "static int msdos_cmp(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct fat_mount_options *options = &MSDOS_SB(parent->d_sb)->options;\n\tunsigned char a_msdos_name[MSDOS_NAME], b_msdos_name[MSDOS_NAME];\n\tint error;\n\n\terror = msdos_format_name(name->name, name->len, a_msdos_name, options);\n\tif (error)\n\t\tgoto old_compare;\n\terror = msdos_format_name(str, len, b_msdos_name, options);\n\tif (error)\n\t\tgoto old_compare;\n\terror = memcmp(a_msdos_name, b_msdos_name, MSDOS_NAME);\nout:\n\treturn error;\n\nold_compare:\n\terror = 1;\n\tif (name->len == len)\n\t\terror = memcmp(name->name, str, len);\n\tgoto out;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name->name",
            "str",
            "len"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a_msdos_name",
            "b_msdos_name",
            "MSDOS_NAME"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msdos_format_name",
          "args": [
            "str",
            "len",
            "b_msdos_name",
            "options"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "msdos_format_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "19-116",
          "snippet": "static int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char bad_chars[] = \"*?<>|\\\"\";",
            "static unsigned char bad_if_strict[] = \"+=,; \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic unsigned char bad_chars[] = \"*?<>|\\\"\";\nstatic unsigned char bad_if_strict[] = \"+=,; \";\n\nstatic int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "parent->d_sb"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_cmp(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct fat_mount_options *options = &MSDOS_SB(parent->d_sb)->options;\n\tunsigned char a_msdos_name[MSDOS_NAME], b_msdos_name[MSDOS_NAME];\n\tint error;\n\n\terror = msdos_format_name(name->name, name->len, a_msdos_name, options);\n\tif (error)\n\t\tgoto old_compare;\n\terror = msdos_format_name(str, len, b_msdos_name, options);\n\tif (error)\n\t\tgoto old_compare;\n\terror = memcmp(a_msdos_name, b_msdos_name, MSDOS_NAME);\nout:\n\treturn error;\n\nold_compare:\n\terror = 1;\n\tif (name->len == len)\n\t\terror = memcmp(name->name, str, len);\n\tgoto out;\n}"
  },
  {
    "function_name": "msdos_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "151-161",
    "snippet": "static int msdos_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tstruct fat_mount_options *options = &MSDOS_SB(dentry->d_sb)->options;\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint error;\n\n\terror = msdos_format_name(qstr->name, qstr->len, msdos_name, options);\n\tif (!error)\n\t\tqstr->hash = full_name_hash(msdos_name, MSDOS_NAME);\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "full_name_hash",
          "args": [
            "msdos_name",
            "MSDOS_NAME"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "full_name_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "1737-1743",
          "snippet": "unsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nunsigned int full_name_hash(const unsigned char *name, unsigned int len)\n{\n\tunsigned long hash = init_name_hash();\n\twhile (len--)\n\t\thash = partial_name_hash(*name++, hash);\n\treturn end_name_hash(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msdos_format_name",
          "args": [
            "qstr->name",
            "qstr->len",
            "msdos_name",
            "options"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "msdos_format_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "19-116",
          "snippet": "static int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char bad_chars[] = \"*?<>|\\\"\";",
            "static unsigned char bad_if_strict[] = \"+=,; \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic unsigned char bad_chars[] = \"*?<>|\\\"\";\nstatic unsigned char bad_if_strict[] = \"+=,; \";\n\nstatic int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "dentry->d_sb"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_hash(const struct dentry *dentry, struct qstr *qstr)\n{\n\tstruct fat_mount_options *options = &MSDOS_SB(dentry->d_sb)->options;\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint error;\n\n\terror = msdos_format_name(qstr->name, qstr->len, msdos_name, options);\n\tif (!error)\n\t\tqstr->hash = full_name_hash(msdos_name, MSDOS_NAME);\n\treturn 0;\n}"
  },
  {
    "function_name": "msdos_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "119-143",
    "snippet": "static int msdos_find(struct inode *dir, const unsigned char *name, int len,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint err;\n\n\terr = msdos_format_name(name, len, msdos_name, &sbi->options);\n\tif (err)\n\t\treturn -ENOENT;\n\n\terr = fat_scan(dir, msdos_name, sinfo);\n\tif (!err && sbi->options.dotsOK) {\n\t\tif (name[0] == '.') {\n\t\t\tif (!(sinfo->de->attr & ATTR_HIDDEN))\n\t\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\tif (sinfo->de->attr & ATTR_HIDDEN)\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tif (err)\n\t\t\tbrelse(sinfo->bh);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sinfo->bh"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "fatent_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "339-348",
          "snippet": "static inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline void fatent_brelse(struct fat_entry *fatent)\n{\n\tint i;\n\tfatent->u.ent32_p = NULL;\n\tfor (i = 0; i < fatent->nr_bhs; i++)\n\t\tbrelse(fatent->bhs[i]);\n\tfatent->nr_bhs = 0;\n\tfatent->bhs[0] = fatent->bhs[1] = NULL;\n\tfatent->fat_inode = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fat_scan",
          "args": [
            "dir",
            "msdos_name",
            "sinfo"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "fat_scan_logstart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/dir.c",
          "lines": "976-993",
          "snippet": "int fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint fat_scan_logstart(struct inode *dir, int i_logstart,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct super_block *sb = dir->i_sb;\n\n\tsinfo->slot_off = 0;\n\tsinfo->bh = NULL;\n\twhile (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,\n\t\t\t\t   &sinfo->de) >= 0) {\n\t\tif (fat_get_start(MSDOS_SB(sb), sinfo->de) == i_logstart) {\n\t\t\tsinfo->slot_off -= sizeof(*sinfo->de);\n\t\t\tsinfo->nr_slots = 1;\n\t\t\tsinfo->i_pos = fat_make_i_pos(sb, sinfo->bh, sinfo->de);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msdos_format_name",
          "args": [
            "name",
            "len",
            "msdos_name",
            "&sbi->options"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "msdos_format_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
          "lines": "19-116",
          "snippet": "static int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fat.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char bad_chars[] = \"*?<>|\\\"\";",
            "static unsigned char bad_if_strict[] = \"+=,; \";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic unsigned char bad_chars[] = \"*?<>|\\\"\";\nstatic unsigned char bad_if_strict[] = \"+=,; \";\n\nstatic int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MSDOS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "MSDOS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/fat.h",
          "lines": "142-145",
          "snippet": "static inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/msdos_fs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/mutex.h>",
            "#include <linux/hash.h>",
            "#include <linux/fs.h>",
            "#include <linux/nls.h>",
            "#include <linux/string.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/msdos_fs.h>\n#include <linux/ratelimit.h>\n#include <linux/mutex.h>\n#include <linux/hash.h>\n#include <linux/fs.h>\n#include <linux/nls.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n\nstatic inline struct msdos_sb_info *MSDOS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int msdos_find(struct inode *dir, const unsigned char *name, int len,\n\t\t      struct fat_slot_info *sinfo)\n{\n\tstruct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);\n\tunsigned char msdos_name[MSDOS_NAME];\n\tint err;\n\n\terr = msdos_format_name(name, len, msdos_name, &sbi->options);\n\tif (err)\n\t\treturn -ENOENT;\n\n\terr = fat_scan(dir, msdos_name, sinfo);\n\tif (!err && sbi->options.dotsOK) {\n\t\tif (name[0] == '.') {\n\t\t\tif (!(sinfo->de->attr & ATTR_HIDDEN))\n\t\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\tif (sinfo->de->attr & ATTR_HIDDEN)\n\t\t\t\terr = -ENOENT;\n\t\t}\n\t\tif (err)\n\t\t\tbrelse(sinfo->bh);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "msdos_format_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fat/namei_msdos.c",
    "lines": "19-116",
    "snippet": "static int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fat.h\"",
      "#include <linux/buffer_head.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned char bad_chars[] = \"*?<>|\\\"\";",
      "static unsigned char bad_if_strict[] = \"+=,; \";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "bad_if_strict",
            "c"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "bad_chars",
            "c"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "bad_if_strict",
            "c"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "bad_chars",
            "c"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fat.h\"\n#include <linux/buffer_head.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic unsigned char bad_chars[] = \"*?<>|\\\"\";\nstatic unsigned char bad_if_strict[] = \"+=,; \";\n\nstatic int msdos_format_name(const unsigned char *name, int len,\n\t\t\t     unsigned char *res, struct fat_mount_options *opts)\n\t/*\n\t * name is the proposed name, len is its length, res is\n\t * the resulting name, opts->name_check is either (r)elaxed,\n\t * (n)ormal or (s)trict, opts->dotsOK allows dots at the\n\t * beginning of name (for hidden files)\n\t */\n{\n\tunsigned char *walk;\n\tunsigned char c;\n\tint space;\n\n\tif (name[0] == '.') {\t/* dotfile because . and .. already done */\n\t\tif (opts->dotsOK) {\n\t\t\t/* Get rid of dot - test for it elsewhere */\n\t\t\tname++;\n\t\t\tlen--;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t}\n\t/*\n\t * disallow names that _really_ start with a dot\n\t */\n\tspace = 1;\n\tc = 0;\n\tfor (walk = res; len && walk - res < 8; walk++) {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && strchr(bad_if_strict, c))\n\t\t\treturn -EINVAL;\n\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\treturn -EINVAL;\n\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\treturn -EINVAL;\n\t/*\n\t * 0xE5 is legal as a first character, but we must substitute\n\t * 0x05 because 0xE5 marks deleted files.  Yes, DOS really\n\t * does this.\n\t * It seems that Microsoft hacked DOS to support non-US\n\t * characters after the 0xE5 character was already in use to\n\t * mark deleted files.\n\t */\n\t\tif ((res == walk) && (c == 0xE5))\n\t\t\tc = 0x05;\n\t\tif (c == '.')\n\t\t\tbreak;\n\t\tspace = (c == ' ');\n\t\t*walk = (!opts->nocase && c >= 'a' && c <= 'z') ? c - 32 : c;\n\t}\n\tif (space)\n\t\treturn -EINVAL;\n\tif (opts->name_check == 's' && len && c != '.') {\n\t\tc = *name++;\n\t\tlen--;\n\t\tif (c != '.')\n\t\t\treturn -EINVAL;\n\t}\n\twhile (c != '.' && len--)\n\t\tc = *name++;\n\tif (c == '.') {\n\t\twhile (walk - res < 8)\n\t\t\t*walk++ = ' ';\n\t\twhile (len > 0 && walk - res < MSDOS_NAME) {\n\t\t\tc = *name++;\n\t\t\tlen--;\n\t\t\tif (opts->name_check != 'r' && strchr(bad_chars, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (opts->name_check == 's' &&\n\t\t\t    strchr(bad_if_strict, c))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c < ' ' || c == ':' || c == '\\\\')\n\t\t\t\treturn -EINVAL;\n\t\t\tif (c == '.') {\n\t\t\t\tif (opts->name_check == 's')\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c >= 'A' && c <= 'Z' && opts->name_check == 's')\n\t\t\t\treturn -EINVAL;\n\t\t\tspace = c == ' ';\n\t\t\tif (!opts->nocase && c >= 'a' && c <= 'z')\n\t\t\t\t*walk++ = c - 32;\n\t\t\telse\n\t\t\t\t*walk++ = c;\n\t\t}\n\t\tif (space)\n\t\t\treturn -EINVAL;\n\t\tif (opts->name_check == 's' && len)\n\t\t\treturn -EINVAL;\n\t}\n\twhile (walk - res < MSDOS_NAME)\n\t\t*walk++ = ' ';\n\n\treturn 0;\n}"
  }
]