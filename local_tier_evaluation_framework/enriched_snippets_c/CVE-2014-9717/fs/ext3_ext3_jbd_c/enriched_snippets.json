[
  {
    "function_name": "__ext3_journal_dirty_metadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3_jbd.c",
    "lines": "52-59",
    "snippet": "int __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh)\n{\n\tint err = journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(where, __func__, bh, handle,err);\n\treturn err;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_abort_handle",
          "args": [
            "where",
            "__func__",
            "bh",
            "handle",
            "err"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_abort_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "106-125",
          "snippet": "void ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_dirty_metadata",
          "args": [
            "handle",
            "bh"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "journal_dirty_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1137-1205",
          "snippet": "int journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\n\tjbd_lock_bh_state(bh);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tjh->b_modified = 1;\n\t\tJ_ASSERT_JH(jh, handle->h_buffer_credits > 0);\n\t\thandle->h_buffer_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_running_transaction);\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == transaction);\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__journal_file_buffer(jh, handle->h_transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tjbd_unlock_bh_state(bh);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn 0;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\n\tjbd_lock_bh_state(bh);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tjh->b_modified = 1;\n\t\tJ_ASSERT_JH(jh, handle->h_buffer_credits > 0);\n\t\thandle->h_buffer_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_running_transaction);\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tJ_ASSERT_JH(jh, jh->b_transaction ==\n\t\t\t\t\tjournal->j_committing_transaction);\n\t\tJ_ASSERT_JH(jh, jh->b_next_transaction == transaction);\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__journal_file_buffer(jh, handle->h_transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tjbd_unlock_bh_state(bh);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nint __ext3_journal_dirty_metadata(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh)\n{\n\tint err = journal_dirty_metadata(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(where, __func__, bh, handle,err);\n\treturn err;\n}"
  },
  {
    "function_name": "__ext3_journal_get_create_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3_jbd.c",
    "lines": "43-50",
    "snippet": "int __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh)\n{\n\tint err = journal_get_create_access(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(where, __func__, bh, handle,err);\n\treturn err;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_abort_handle",
          "args": [
            "where",
            "__func__",
            "bh",
            "handle",
            "err"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_abort_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "106-125",
          "snippet": "void ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_get_create_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "journal_get_create_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "784-853",
          "snippet": "int journal_get_create_access(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh = journal_add_journal_head(bh);\n\tint err;\n\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\terr = -EROFS;\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\terr = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\t/*\n\t * The buffer may already belong to this transaction due to pre-zeroing\n\t * in the filesystem's new_block code.  It may also be on the previous,\n\t * committing transaction's lists, but it HAS to be in Forget state in\n\t * that case: the transaction must have deleted the buffer for it to be\n\t * reused here.\n\t */\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\tJ_ASSERT_JH(jh, (jh->b_transaction == transaction ||\n\t\tjh->b_transaction == NULL ||\n\t\t(jh->b_transaction == journal->j_committing_transaction &&\n\t\t\t  jh->b_jlist == BJ_Forget)));\n\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, buffer_locked(jh2bh(jh)));\n\n\tif (jh->b_transaction == NULL) {\n\t\t/*\n\t\t * Previous journal_forget() could have left the buffer\n\t\t * with jbddirty bit set because it was being committed. When\n\t\t * the commit finished, we've filed the buffer for\n\t\t * checkpointing and marked it dirty. Now we are reallocating\n\t\t * the buffer so the transaction freeing it must have\n\t\t * committed and so it's safe to clear the dirty bit.\n\t\t */\n\t\tclear_buffer_dirty(jh2bh(jh));\n\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\t__journal_file_buffer(jh, transaction, BJ_Reserved);\n\t} else if (jh->b_transaction == journal->j_committing_transaction) {\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"set next transaction\");\n\t\tjh->b_next_transaction = transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\n\t/*\n\t * akpm: I added this.  ext3_alloc_branch can pick up new indirect\n\t * blocks which contain freed but then revoked metadata.  We need\n\t * to cancel the revoke in case we end up freeing it yet again\n\t * and the reallocating as data - this would cause a second revoke,\n\t * which hits an assertion error.\n\t */\n\tJBUFFER_TRACE(jh, \"cancelling revoke\");\n\tjournal_cancel_revoke(handle, jh);\nout:\n\tjournal_put_journal_head(jh);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_get_create_access(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh = journal_add_journal_head(bh);\n\tint err;\n\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\terr = -EROFS;\n\tif (is_handle_aborted(handle))\n\t\tgoto out;\n\terr = 0;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\t/*\n\t * The buffer may already belong to this transaction due to pre-zeroing\n\t * in the filesystem's new_block code.  It may also be on the previous,\n\t * committing transaction's lists, but it HAS to be in Forget state in\n\t * that case: the transaction must have deleted the buffer for it to be\n\t * reused here.\n\t */\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\tJ_ASSERT_JH(jh, (jh->b_transaction == transaction ||\n\t\tjh->b_transaction == NULL ||\n\t\t(jh->b_transaction == journal->j_committing_transaction &&\n\t\t\t  jh->b_jlist == BJ_Forget)));\n\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, buffer_locked(jh2bh(jh)));\n\n\tif (jh->b_transaction == NULL) {\n\t\t/*\n\t\t * Previous journal_forget() could have left the buffer\n\t\t * with jbddirty bit set because it was being committed. When\n\t\t * the commit finished, we've filed the buffer for\n\t\t * checkpointing and marked it dirty. Now we are reallocating\n\t\t * the buffer so the transaction freeing it must have\n\t\t * committed and so it's safe to clear the dirty bit.\n\t\t */\n\t\tclear_buffer_dirty(jh2bh(jh));\n\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Reserved\");\n\t\t__journal_file_buffer(jh, transaction, BJ_Reserved);\n\t} else if (jh->b_transaction == journal->j_committing_transaction) {\n\t\t/* first access by this transaction */\n\t\tjh->b_modified = 0;\n\n\t\tJBUFFER_TRACE(jh, \"set next transaction\");\n\t\tjh->b_next_transaction = transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\n\t/*\n\t * akpm: I added this.  ext3_alloc_branch can pick up new indirect\n\t * blocks which contain freed but then revoked metadata.  We need\n\t * to cancel the revoke in case we end up freeing it yet again\n\t * and the reallocating as data - this would cause a second revoke,\n\t * which hits an assertion error.\n\t */\n\tJBUFFER_TRACE(jh, \"cancelling revoke\");\n\tjournal_cancel_revoke(handle, jh);\nout:\n\tjournal_put_journal_head(jh);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nint __ext3_journal_get_create_access(const char *where,\n\t\t\t\thandle_t *handle, struct buffer_head *bh)\n{\n\tint err = journal_get_create_access(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(where, __func__, bh, handle,err);\n\treturn err;\n}"
  },
  {
    "function_name": "__ext3_journal_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3_jbd.c",
    "lines": "34-41",
    "snippet": "int __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh)\n{\n\tint err = journal_revoke(handle, blocknr, bh);\n\tif (err)\n\t\text3_journal_abort_handle(where, __func__, bh, handle,err);\n\treturn err;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_abort_handle",
          "args": [
            "where",
            "__func__",
            "bh",
            "handle",
            "err"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_abort_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "106-125",
          "snippet": "void ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_revoke",
          "args": [
            "handle",
            "blocknr",
            "bh"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "journal_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "332-406",
          "snippet": "int journal_revoke(handle_t *handle, unsigned int blocknr,\n\t\t   struct buffer_head *bh_in)\n{\n\tstruct buffer_head *bh = NULL;\n\tjournal_t *journal;\n\tstruct block_device *bdev;\n\tint err;\n\n\tmight_sleep();\n\tif (bh_in)\n\t\tBUFFER_TRACE(bh_in, \"enter\");\n\n\tjournal = handle->h_transaction->t_journal;\n\tif (!journal_set_features(journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE)){\n\t\tJ_ASSERT (!\"Cannot set revoke feature!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = journal->j_fs_dev;\n\tbh = bh_in;\n\n\tif (!bh) {\n\t\tbh = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh)\n\t\t\tBUFFER_TRACE(bh, \"found on hash\");\n\t}\n#ifdef JBD_EXPENSIVE_CHECKING\n\telse {\n\t\tstruct buffer_head *bh2;\n\n\t\t/* If there is a different buffer_head lying around in\n\t\t * memory anywhere... */\n\t\tbh2 = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh2) {\n\t\t\t/* ... and it has RevokeValid status... */\n\t\t\tif (bh2 != bh && buffer_revokevalid(bh2))\n\t\t\t\t/* ...then it better be revoked too,\n\t\t\t\t * since it's illegal to create a revoke\n\t\t\t\t * record against a buffer_head which is\n\t\t\t\t * not marked revoked --- that would\n\t\t\t\t * risk missing a subsequent revoke\n\t\t\t\t * cancel. */\n\t\t\t\tJ_ASSERT_BH(bh2, buffer_revoked(bh2));\n\t\t\tput_bh(bh2);\n\t\t}\n\t}\n#endif\n\n\t/* We really ought not ever to revoke twice in a row without\n           first having the revoke cancelled: it's illegal to free a\n           block twice without allocating it in between! */\n\tif (bh) {\n\t\tif (!J_EXPECT_BH(bh, !buffer_revoked(bh),\n\t\t\t\t \"inconsistent data on disk\")) {\n\t\t\tif (!bh_in)\n\t\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tset_buffer_revoked(bh);\n\t\tset_buffer_revokevalid(bh);\n\t\tif (bh_in) {\n\t\t\tBUFFER_TRACE(bh_in, \"call journal_forget\");\n\t\t\tjournal_forget(handle, bh_in);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"call brelse\");\n\t\t\t__brelse(bh);\n\t\t}\n\t}\n\n\tjbd_debug(2, \"insert revoke for block %u, bh_in=%p\\n\", blocknr, bh_in);\n\terr = insert_revoke_hash(journal, blocknr,\n\t\t\t\thandle->h_transaction->t_tid);\n\tBUFFER_TRACE(bh_in, \"exit\");\n\treturn err;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint journal_revoke(handle_t *handle, unsigned int blocknr,\n\t\t   struct buffer_head *bh_in)\n{\n\tstruct buffer_head *bh = NULL;\n\tjournal_t *journal;\n\tstruct block_device *bdev;\n\tint err;\n\n\tmight_sleep();\n\tif (bh_in)\n\t\tBUFFER_TRACE(bh_in, \"enter\");\n\n\tjournal = handle->h_transaction->t_journal;\n\tif (!journal_set_features(journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE)){\n\t\tJ_ASSERT (!\"Cannot set revoke feature!\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdev = journal->j_fs_dev;\n\tbh = bh_in;\n\n\tif (!bh) {\n\t\tbh = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh)\n\t\t\tBUFFER_TRACE(bh, \"found on hash\");\n\t}\n#ifdef JBD_EXPENSIVE_CHECKING\n\telse {\n\t\tstruct buffer_head *bh2;\n\n\t\t/* If there is a different buffer_head lying around in\n\t\t * memory anywhere... */\n\t\tbh2 = __find_get_block(bdev, blocknr, journal->j_blocksize);\n\t\tif (bh2) {\n\t\t\t/* ... and it has RevokeValid status... */\n\t\t\tif (bh2 != bh && buffer_revokevalid(bh2))\n\t\t\t\t/* ...then it better be revoked too,\n\t\t\t\t * since it's illegal to create a revoke\n\t\t\t\t * record against a buffer_head which is\n\t\t\t\t * not marked revoked --- that would\n\t\t\t\t * risk missing a subsequent revoke\n\t\t\t\t * cancel. */\n\t\t\t\tJ_ASSERT_BH(bh2, buffer_revoked(bh2));\n\t\t\tput_bh(bh2);\n\t\t}\n\t}\n#endif\n\n\t/* We really ought not ever to revoke twice in a row without\n           first having the revoke cancelled: it's illegal to free a\n           block twice without allocating it in between! */\n\tif (bh) {\n\t\tif (!J_EXPECT_BH(bh, !buffer_revoked(bh),\n\t\t\t\t \"inconsistent data on disk\")) {\n\t\t\tif (!bh_in)\n\t\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t\tset_buffer_revoked(bh);\n\t\tset_buffer_revokevalid(bh);\n\t\tif (bh_in) {\n\t\t\tBUFFER_TRACE(bh_in, \"call journal_forget\");\n\t\t\tjournal_forget(handle, bh_in);\n\t\t} else {\n\t\t\tBUFFER_TRACE(bh, \"call brelse\");\n\t\t\t__brelse(bh);\n\t\t}\n\t}\n\n\tjbd_debug(2, \"insert revoke for block %u, bh_in=%p\\n\", blocknr, bh_in);\n\terr = insert_revoke_hash(journal, blocknr,\n\t\t\t\thandle->h_transaction->t_tid);\n\tBUFFER_TRACE(bh_in, \"exit\");\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nint __ext3_journal_revoke(const char *where, handle_t *handle,\n\t\t\t\tunsigned long blocknr, struct buffer_head *bh)\n{\n\tint err = journal_revoke(handle, blocknr, bh);\n\tif (err)\n\t\text3_journal_abort_handle(where, __func__, bh, handle,err);\n\treturn err;\n}"
  },
  {
    "function_name": "__ext3_journal_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3_jbd.c",
    "lines": "25-32",
    "snippet": "int __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint err = journal_forget(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(where, __func__, bh, handle,err);\n\treturn err;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_abort_handle",
          "args": [
            "where",
            "__func__",
            "bh",
            "handle",
            "err"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_abort_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "106-125",
          "snippet": "void ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_forget",
          "args": [
            "handle",
            "bh"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "journal_forget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "1235-1344",
          "snippet": "int journal_forget (handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tif (!buffer_jbd(bh))\n\t\tgoto not_jbd;\n\tjh = bh2jh(bh);\n\n\t/* Critical error: attempting to delete a bitmap buffer, maybe?\n\t * Don't do any jbd operations, and return an error. */\n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto not_jbd;\n\t}\n\n\t/* keep track of whether or not this transaction modified us */\n\twas_modified = jh->b_modified;\n\n\t/*\n\t * The buffer's going from the transaction, we must drop\n\t * all references -bzzz\n\t */\n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == handle->h_transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t/* If we are forgetting a buffer which is already part\n\t\t * of this transaction, then we can just drop it from\n\t\t * the transaction immediately. */\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t/*\n\t\t * we only want to drop a reference if this transaction\n\t\t * modified the buffer\n\t\t */\n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t/*\n\t\t * We are no longer going to journal this buffer.\n\t\t * However, the commit of this transaction is still\n\t\t * important to the buffer: the delete that we are now\n\t\t * processing might obsolete an old log entry, so by\n\t\t * committing, we can satisfy the buffer's checkpoint.\n\t\t *\n\t\t * So, if we have a checkpoint on the buffer, we should\n\t\t * now refile the buffer on our BJ_Forget list so that\n\t\t * we know to remove the checkpoint after we commit.\n\t\t */\n\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__journal_temp_unlink_buffer(jh);\n\t\t\t__journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__journal_unfile_buffer(jh);\n\t\t\tif (!buffer_jbd(bh)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\t__bforget(bh);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t/* However, if the buffer is still owned by a prior\n\t\t * (committing) transaction, we can't drop it yet... */\n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t/* ... but we CAN drop it from the new transaction if we\n\t\t * have also modified it since the original commit. */\n\n\t\tif (jh->b_next_transaction) {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\t\t\tjh->b_next_transaction = NULL;\n\n\t\t\t/*\n\t\t\t * only drop a reference if this transaction modified\n\t\t\t * the buffer\n\t\t\t */\n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t}\n\nnot_jbd:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\ndrop:\n\tif (drop_reserve) {\n\t\t/* no need to reserve log space for this block -bzzz */\n\t\thandle->h_buffer_credits++;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_forget (handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal = transaction->t_journal;\n\tstruct journal_head *jh;\n\tint drop_reserve = 0;\n\tint err = 0;\n\tint was_modified = 0;\n\n\tBUFFER_TRACE(bh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\tspin_lock(&journal->j_list_lock);\n\n\tif (!buffer_jbd(bh))\n\t\tgoto not_jbd;\n\tjh = bh2jh(bh);\n\n\t/* Critical error: attempting to delete a bitmap buffer, maybe?\n\t * Don't do any jbd operations, and return an error. */\n\tif (!J_EXPECT_JH(jh, !jh->b_committed_data,\n\t\t\t \"inconsistent data on disk\")) {\n\t\terr = -EIO;\n\t\tgoto not_jbd;\n\t}\n\n\t/* keep track of whether or not this transaction modified us */\n\twas_modified = jh->b_modified;\n\n\t/*\n\t * The buffer's going from the transaction, we must drop\n\t * all references -bzzz\n\t */\n\tjh->b_modified = 0;\n\n\tif (jh->b_transaction == handle->h_transaction) {\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\n\t\t/* If we are forgetting a buffer which is already part\n\t\t * of this transaction, then we can just drop it from\n\t\t * the transaction immediately. */\n\t\tclear_buffer_dirty(bh);\n\t\tclear_buffer_jbddirty(bh);\n\n\t\tJBUFFER_TRACE(jh, \"belongs to current transaction: unfile\");\n\n\t\t/*\n\t\t * we only want to drop a reference if this transaction\n\t\t * modified the buffer\n\t\t */\n\t\tif (was_modified)\n\t\t\tdrop_reserve = 1;\n\n\t\t/*\n\t\t * We are no longer going to journal this buffer.\n\t\t * However, the commit of this transaction is still\n\t\t * important to the buffer: the delete that we are now\n\t\t * processing might obsolete an old log entry, so by\n\t\t * committing, we can satisfy the buffer's checkpoint.\n\t\t *\n\t\t * So, if we have a checkpoint on the buffer, we should\n\t\t * now refile the buffer on our BJ_Forget list so that\n\t\t * we know to remove the checkpoint after we commit.\n\t\t */\n\n\t\tif (jh->b_cp_transaction) {\n\t\t\t__journal_temp_unlink_buffer(jh);\n\t\t\t__journal_file_buffer(jh, transaction, BJ_Forget);\n\t\t} else {\n\t\t\t__journal_unfile_buffer(jh);\n\t\t\tif (!buffer_jbd(bh)) {\n\t\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\t\tjbd_unlock_bh_state(bh);\n\t\t\t\t__bforget(bh);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t} else if (jh->b_transaction) {\n\t\tJ_ASSERT_JH(jh, (jh->b_transaction ==\n\t\t\t\t journal->j_committing_transaction));\n\t\t/* However, if the buffer is still owned by a prior\n\t\t * (committing) transaction, we can't drop it yet... */\n\t\tJBUFFER_TRACE(jh, \"belongs to older transaction\");\n\t\t/* ... but we CAN drop it from the new transaction if we\n\t\t * have also modified it since the original commit. */\n\n\t\tif (jh->b_next_transaction) {\n\t\t\tJ_ASSERT(jh->b_next_transaction == transaction);\n\t\t\tjh->b_next_transaction = NULL;\n\n\t\t\t/*\n\t\t\t * only drop a reference if this transaction modified\n\t\t\t * the buffer\n\t\t\t */\n\t\t\tif (was_modified)\n\t\t\t\tdrop_reserve = 1;\n\t\t}\n\t}\n\nnot_jbd:\n\tspin_unlock(&journal->j_list_lock);\n\tjbd_unlock_bh_state(bh);\n\t__brelse(bh);\ndrop:\n\tif (drop_reserve) {\n\t\t/* no need to reserve log space for this block -bzzz */\n\t\thandle->h_buffer_credits++;\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nint __ext3_journal_forget(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint err = journal_forget(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(where, __func__, bh, handle,err);\n\treturn err;\n}"
  },
  {
    "function_name": "__ext3_journal_get_write_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3_jbd.c",
    "lines": "16-23",
    "snippet": "int __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint err = journal_get_write_access(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(where, __func__, bh, handle,err);\n\treturn err;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_abort_handle",
          "args": [
            "where",
            "__func__",
            "bh",
            "handle",
            "err"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_abort_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "106-125",
          "snippet": "void ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_get_write_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "do_journal_get_write_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/inode.c",
          "lines": "1206-1228",
          "snippet": "static int do_journal_get_write_access(handle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\tint dirty = buffer_dirty(bh);\n\tint ret;\n\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\t/*\n\t * __block_prepare_write() could have dirtied some buffers. Clean\n\t * the dirty bit as jbd2_journal_get_write_access() could complain\n\t * otherwise about fs integrity issues. Setting of the dirty bit\n\t * by __block_prepare_write() isn't a real problem here as we clear\n\t * the bit before releasing a page lock and thus writeback cannot\n\t * ever write the buffer.\n\t */\n\tif (dirty)\n\t\tclear_buffer_dirty(bh);\n\tret = ext3_journal_get_write_access(handle, bh);\n\tif (!ret && dirty)\n\t\tret = ext3_journal_dirty_metadata(handle, bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <linux/aio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highuid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <linux/aio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/quotaops.h>\n#include <linux/highuid.h>\n\nstatic int do_journal_get_write_access(handle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\tint dirty = buffer_dirty(bh);\n\tint ret;\n\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\t/*\n\t * __block_prepare_write() could have dirtied some buffers. Clean\n\t * the dirty bit as jbd2_journal_get_write_access() could complain\n\t * otherwise about fs integrity issues. Setting of the dirty bit\n\t * by __block_prepare_write() isn't a real problem here as we clear\n\t * the bit before releasing a page lock and thus writeback cannot\n\t * ever write the buffer.\n\t */\n\tif (dirty)\n\t\tclear_buffer_dirty(bh);\n\tret = ext3_journal_get_write_access(handle, bh);\n\tif (!ret && dirty)\n\t\tret = ext3_journal_dirty_metadata(handle, bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nint __ext3_journal_get_write_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint err = journal_get_write_access(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(where, __func__, bh, handle,err);\n\treturn err;\n}"
  },
  {
    "function_name": "__ext3_journal_get_undo_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3_jbd.c",
    "lines": "7-14",
    "snippet": "int __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint err = journal_get_undo_access(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(where, __func__, bh, handle,err);\n\treturn err;\n}",
    "includes": [
      "#include \"ext3.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_abort_handle",
          "args": [
            "where",
            "__func__",
            "bh",
            "handle",
            "err"
          ],
          "line": 12
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_abort_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "106-125",
          "snippet": "void ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic const char *ext3_decode_error(struct super_block * sb, int errno,\n\t\t\t\t     char nbuf[16]);\n\nvoid ext3_journal_abort_handle(const char *caller, const char *err_fn,\n\t\tstruct buffer_head *bh, handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext3_decode_error(NULL, err, nbuf);\n\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\n\tprintk(KERN_ERR \"EXT3-fs: %s: aborting transaction: %s in %s\\n\",\n\t\tcaller, errstr, err_fn);\n\n\tjournal_abort_handle(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_get_undo_access",
          "args": [
            "handle",
            "bh"
          ],
          "line": 10
        },
        "resolved": true,
        "details": {
          "function_name": "journal_get_undo_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/transaction.c",
          "lines": "880-928",
          "snippet": "int journal_get_undo_access(handle_t *handle, struct buffer_head *bh)\n{\n\tint err;\n\tstruct journal_head *jh = journal_add_journal_head(bh);\n\tchar *committed_data = NULL;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t/*\n\t * Do this first --- it can drop the journal lock, so we want to\n\t * make sure that obtaining the committed_data is done\n\t * atomically wrt. completion of any outstanding commits.\n\t */\n\terr = do_get_write_access(handle, jh, 1);\n\tif (err)\n\t\tgoto out;\n\nrepeat:\n\tif (!jh->b_committed_data) {\n\t\tcommitted_data = jbd_alloc(jh2bh(jh)->b_size, GFP_NOFS);\n\t\tif (!committed_data) {\n\t\t\tprintk(KERN_ERR \"%s: No memory for committed data\\n\",\n\t\t\t\t__func__);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data) {\n\t\t/* Copy out the current buffer contents into the\n\t\t * preserved, committed copy. */\n\t\tJBUFFER_TRACE(jh, \"generate b_committed data\");\n\t\tif (!committed_data) {\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh->b_committed_data = committed_data;\n\t\tcommitted_data = NULL;\n\t\tmemcpy(jh->b_committed_data, bh->b_data, bh->b_size);\n\t}\n\tjbd_unlock_bh_state(bh);\nout:\n\tjournal_put_journal_head(jh);\n\tif (unlikely(committed_data))\n\t\tjbd_free(committed_data, bh->b_size);\n\treturn err;\n}",
          "includes": [
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_temp_unlink_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __journal_temp_unlink_buffer(struct journal_head *jh);\n\nint journal_get_undo_access(handle_t *handle, struct buffer_head *bh)\n{\n\tint err;\n\tstruct journal_head *jh = journal_add_journal_head(bh);\n\tchar *committed_data = NULL;\n\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\t/*\n\t * Do this first --- it can drop the journal lock, so we want to\n\t * make sure that obtaining the committed_data is done\n\t * atomically wrt. completion of any outstanding commits.\n\t */\n\terr = do_get_write_access(handle, jh, 1);\n\tif (err)\n\t\tgoto out;\n\nrepeat:\n\tif (!jh->b_committed_data) {\n\t\tcommitted_data = jbd_alloc(jh2bh(jh)->b_size, GFP_NOFS);\n\t\tif (!committed_data) {\n\t\t\tprintk(KERN_ERR \"%s: No memory for committed data\\n\",\n\t\t\t\t__func__);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data) {\n\t\t/* Copy out the current buffer contents into the\n\t\t * preserved, committed copy. */\n\t\tJBUFFER_TRACE(jh, \"generate b_committed data\");\n\t\tif (!committed_data) {\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh->b_committed_data = committed_data;\n\t\tcommitted_data = NULL;\n\t\tmemcpy(jh->b_committed_data, bh->b_data, bh->b_size);\n\t}\n\tjbd_unlock_bh_state(bh);\nout:\n\tjournal_put_journal_head(jh);\n\tif (unlikely(committed_data))\n\t\tjbd_free(committed_data, bh->b_size);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n\nint __ext3_journal_get_undo_access(const char *where, handle_t *handle,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint err = journal_get_undo_access(handle, bh);\n\tif (err)\n\t\text3_journal_abort_handle(where, __func__, bh, handle,err);\n\treturn err;\n}"
  }
]