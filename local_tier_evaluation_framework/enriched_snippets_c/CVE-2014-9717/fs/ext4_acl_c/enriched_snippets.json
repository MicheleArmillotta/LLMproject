[
  {
    "function_name": "ext4_init_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/acl.c",
    "lines": "266-288",
    "snippet": "int\next4_init_acl(handle_t *handle, struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = __ext4_set_acl(handle, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t       default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __ext4_set_acl(handle, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t       acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ext4_set_acl",
          "args": [
            "handle",
            "inode",
            "ACL_TYPE_ACCESS",
            "acl"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/acl.c",
          "lines": "191-239",
          "snippet": "static int\n__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic int\n__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_create",
          "args": [
            "dir",
            "&inode->i_mode",
            "&default_acl",
            "&acl"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "545-598",
          "snippet": "int\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nint\next4_init_acl(handle_t *handle, struct inode *inode, struct inode *dir)\n{\n\tstruct posix_acl *default_acl, *acl;\n\tint error;\n\n\terror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = __ext4_set_acl(handle, inode, ACL_TYPE_DEFAULT,\n\t\t\t\t       default_acl);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __ext4_set_acl(handle, inode, ACL_TYPE_ACCESS,\n\t\t\t\t\t       acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/acl.c",
    "lines": "241-258",
    "snippet": "int\next4_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\thandle_t *handle;\n\tint error, retries = 0;\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_XATTR,\n\t\t\t\t    ext4_jbd2_credits_xattr(inode));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terror = __ext4_set_acl(handle, inode, type, acl);\n\text4_journal_stop(handle);\n\tif (error == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext4_should_retry_alloc",
          "args": [
            "inode->i_sb",
            "&retries"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_should_retry_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/balloc.c",
          "lines": "598-608",
          "snippet": "int ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"mballoc.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include \"ext4.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"mballoc.h\"\n#include \"ext4_jbd2.h\"\n#include \"ext4.h\"\n#include <linux/buffer_head.h>\n#include <linux/quotaops.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/time.h>\n\nint ext4_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext4_has_free_clusters(EXT4_SB(sb), 1, 0) ||\n\t    (*retries)++ > 3 ||\n\t    !EXT4_SB(sb)->s_journal)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn jbd2_journal_force_commit_nested(EXT4_SB(sb)->s_journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_journal_stop",
          "args": [
            "handle"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ext4_set_acl",
          "args": [
            "handle",
            "inode",
            "type",
            "acl"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/acl.c",
          "lines": "191-239",
          "snippet": "static int\n__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic int\n__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_journal_start",
          "args": [
            "inode",
            "EXT4_HT_XATTR",
            "ext4_jbd2_credits_xattr(inode)"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "__ext4_journal_start_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.c",
          "lines": "101-123",
          "snippet": "handle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"ext4_jbd2.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"ext4_jbd2.h\"\n\nhandle_t *__ext4_journal_start_reserved(handle_t *handle, unsigned int line,\n\t\t\t\t\tint type)\n{\n\tstruct super_block *sb;\n\tint err;\n\n\tif (!ext4_handle_valid(handle))\n\t\treturn ext4_get_nojournal();\n\n\tsb = handle->h_journal->j_private;\n\ttrace_ext4_journal_start_reserved(sb, handle->h_buffer_credits,\n\t\t\t\t\t  _RET_IP_);\n\terr = ext4_journal_check_start(sb);\n\tif (err < 0) {\n\t\tjbd2_journal_free_reserved(handle);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = jbd2_journal_start_reserved(handle, type, line);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_jbd2_credits_xattr",
          "args": [
            "inode"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_jbd2_credits_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4_jbd2.h",
          "lines": "109-120",
          "snippet": "static inline int ext4_jbd2_credits_xattr(struct inode *inode)\n{\n\tint credits = EXT4_DATA_TRANS_BLOCKS(inode->i_sb);\n\n\t/*\n\t * In case of inline data, we may push out the data to a block,\n\t * so we need to reserve credits for this eventuality\n\t */\n\tif (ext4_has_inline_data(inode))\n\t\tcredits += ext4_writepage_trans_blocks(inode) + 1;\n\treturn credits;\n}",
          "includes": [
            "#include \"ext4.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext4.h\"\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n\nstatic inline int ext4_jbd2_credits_xattr(struct inode *inode)\n{\n\tint credits = EXT4_DATA_TRANS_BLOCKS(inode->i_sb);\n\n\t/*\n\t * In case of inline data, we may push out the data to a block,\n\t * so we need to reserve credits for this eventuality\n\t */\n\tif (ext4_has_inline_data(inode))\n\t\tcredits += ext4_writepage_trans_blocks(inode) + 1;\n\treturn credits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nint\next4_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\thandle_t *handle;\n\tint error, retries = 0;\n\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_XATTR,\n\t\t\t\t    ext4_jbd2_credits_xattr(inode));\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terror = __ext4_set_acl(handle, inode, type, acl);\n\text4_journal_stop(handle);\n\tif (error == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\treturn error;\n}"
  },
  {
    "function_name": "__ext4_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/acl.c",
    "lines": "191-239",
    "snippet": "static int\n__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_xattr_set_handle",
          "args": [
            "handle",
            "inode",
            "name_index",
            "\"\"",
            "value",
            "size",
            "0"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_set_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "1085-1191",
          "snippet": "int\next4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\n\t};\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tunsigned long no_expand;\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tno_expand = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\text4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\n\terror = ext4_reserve_inode_write(handle, inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW)) {\n\t\tstruct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\t\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\t}\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT4_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text4_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = ext4_current_time(inode);\n\t\tif (!value)\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\t\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t/*\n\t\t * The bh is consumed by ext4_mark_iloc_dirty, even with\n\t\t * error != 0.\n\t\t */\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t}\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\tif (no_expand == 0)\n\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nint\next4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,\n\t\t      const char *name, const void *value, size_t value_len,\n\t\t      int flags)\n{\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = name_index,\n\t\t.name = name,\n\t\t.value = value,\n\t\t.value_len = value_len,\n\n\t};\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tstruct ext4_xattr_block_find bs = {\n\t\t.s = { .not_found = -ENODATA, },\n\t};\n\tunsigned long no_expand;\n\tint error;\n\n\tif (!name)\n\t\treturn -EINVAL;\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\tdown_write(&EXT4_I(inode)->xattr_sem);\n\tno_expand = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\text4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\n\terror = ext4_reserve_inode_write(handle, inode, &is.iloc);\n\tif (error)\n\t\tgoto cleanup;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW)) {\n\t\tstruct ext4_inode *raw_inode = ext4_raw_inode(&is.iloc);\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\t\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\t}\n\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found)\n\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\tif (error)\n\t\tgoto cleanup;\n\tif (is.s.not_found && bs.s.not_found) {\n\t\terror = -ENODATA;\n\t\tif (flags & XATTR_REPLACE)\n\t\t\tgoto cleanup;\n\t\terror = 0;\n\t\tif (!value)\n\t\t\tgoto cleanup;\n\t} else {\n\t\terror = -EEXIST;\n\t\tif (flags & XATTR_CREATE)\n\t\t\tgoto cleanup;\n\t}\n\tif (!value) {\n\t\tif (!is.s.not_found)\n\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\telse if (!bs.s.not_found)\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t} else {\n\t\terror = ext4_xattr_ibody_set(handle, inode, &i, &is);\n\t\tif (!error && !bs.s.not_found) {\n\t\t\ti.value = NULL;\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t} else if (error == -ENOSPC) {\n\t\t\tif (EXT4_I(inode)->i_file_acl && !bs.s.base) {\n\t\t\t\terror = ext4_xattr_block_find(inode, &i, &bs);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\terror = ext4_xattr_block_set(handle, inode, &i, &bs);\n\t\t\tif (error)\n\t\t\t\tgoto cleanup;\n\t\t\tif (!is.s.not_found) {\n\t\t\t\ti.value = NULL;\n\t\t\t\terror = ext4_xattr_ibody_set(handle, inode, &i,\n\t\t\t\t\t\t\t     &is);\n\t\t\t}\n\t\t}\n\t}\n\tif (!error) {\n\t\text4_xattr_update_super_block(handle, inode->i_sb);\n\t\tinode->i_ctime = ext4_current_time(inode);\n\t\tif (!value)\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\t\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\t\t/*\n\t\t * The bh is consumed by ext4_mark_iloc_dirty, even with\n\t\t * error != 0.\n\t\t */\n\t\tis.iloc.bh = NULL;\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t}\n\ncleanup:\n\tbrelse(is.iloc.bh);\n\tbrelse(bs.bh);\n\tif (no_expand == 0)\n\t\text4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);\n\tup_write(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "value"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "value"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_acl_to_disk",
          "args": [
            "acl",
            "&size"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_acl_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/acl.c",
          "lines": "93-140",
          "snippet": "static void *\next4_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\text4_acl_header *ext_acl;\n\tchar *e;\n\tsize_t n;\n\n\t*size = ext4_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(ext4_acl_header) + acl->a_count *\n\t\t\tsizeof(ext4_acl_entry), GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(EXT4_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(ext4_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text4_acl_entry *entry = (ext4_acl_entry *)e;\n\t\tentry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic void *\next4_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\text4_acl_header *ext_acl;\n\tchar *e;\n\tsize_t n;\n\n\t*size = ext4_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(ext4_acl_header) + acl->a_count *\n\t\t\tsizeof(ext4_acl_entry), GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(EXT4_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(ext4_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text4_acl_entry *entry = (ext4_acl_entry *)e;\n\t\tentry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_mark_inode_dirty",
          "args": [
            "handle",
            "inode"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/inode.c",
          "lines": "4887-4930",
          "snippet": "int ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/ext4.h>",
            "#include \"truncate.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/aio.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/kernel.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bio.h>",
            "#include <linux/uio.h>",
            "#include <linux/namei.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highuid.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext4.h>\n#include \"truncate.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/bitops.h>\n#include <linux/aio.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/bio.h>\n#include <linux/uio.h>\n#include <linux/namei.h>\n#include <linux/mpage.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highuid.h>\n#include <linux/jbd2.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!err)\n\t\terr = ext4_mark_iloc_dirty(handle, inode, &iloc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_current_time",
          "args": [
            "inode"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_current_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/ext4.h",
          "lines": "1365-1369",
          "snippet": "static inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}",
          "includes": [
            "#include \"extents_status.h\"",
            "#include <linux/compat.h>",
            "#include <linux/falloc.h>",
            "#include <crypto/hash.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/wait.h>",
            "#include <linux/timer.h>",
            "#include <linux/mutex.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/quota.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extents_status.h\"\n#include <linux/compat.h>\n#include <linux/falloc.h>\n#include <crypto/hash.h>\n#include <linux/ratelimit.h>\n#include <linux/percpu_counter.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/wait.h>\n#include <linux/timer.h>\n#include <linux/mutex.h>\n#include <linux/seqlock.h>\n#include <linux/rbtree.h>\n#include <linux/rwsem.h>\n#include <linux/quota.h>\n#include <linux/jbd2.h>\n#include <linux/magic.h>\n#include <linux/blkdev.h>\n#include <linux/types.h>\n\nstatic inline struct timespec ext4_current_time(struct inode *inode)\n{\n\treturn (inode->i_sb->s_time_gran < NSEC_PER_SEC) ?\n\t\tcurrent_fs_time(inode->i_sb) : CURRENT_TIME_SEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "acl",
            "&inode->i_mode"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "242-282",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic int\n__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ext4_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/acl.c",
    "lines": "147-184",
    "snippet": "struct posix_acl *\next4_get_acl(struct inode *inode, int type)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = ext4_xattr_get(inode, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ext4_xattr_get(inode, name_index, \"\", value, retval);\n\t}\n\tif (retval > 0)\n\t\tacl = ext4_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA || retval == -ENOSYS)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn acl;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_acl_from_disk",
          "args": [
            "value",
            "retval"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_acl_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/acl.c",
          "lines": "20-88",
          "snippet": "static struct posix_acl *\next4_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(ext4_acl_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (((ext4_acl_header *)value)->a_version !=\n\t    cpu_to_le32(EXT4_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(ext4_acl_header);\n\tcount = ext4_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\text4_acl_entry *entry =\n\t\t\t(ext4_acl_entry *)value;\n\t\tif ((char *)value + sizeof(ext4_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t\tsizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic struct posix_acl *\next4_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(ext4_acl_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (((ext4_acl_header *)value)->a_version !=\n\t    cpu_to_le32(EXT4_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(ext4_acl_header);\n\tcount = ext4_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\text4_acl_entry *entry =\n\t\t\t(ext4_acl_entry *)value;\n\t\tif ((char *)value + sizeof(ext4_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t\tsizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_xattr_get",
          "args": [
            "inode",
            "name_index",
            "\"\"",
            "value",
            "retval"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/xattr.c",
          "lines": "379-396",
          "snippet": "int\next4_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tint error;\n\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\terror = ext4_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t     buffer_size);\n\tif (error == -ENODATA)\n\t\terror = ext4_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t     buffer_size);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext4.h\"",
            "#include \"ext4_jbd2.h\"",
            "#include <linux/rwsem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/rwsem.h>\n#include <linux/quotaops.h>\n#include <linux/mbcache.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n\nstatic int ext4_xattr_list(struct dentry *dentry, char *buffer,\n\t\t\t   size_t buffer_size);\n\nint\next4_xattr_get(struct inode *inode, int name_index, const char *name,\n\t       void *buffer, size_t buffer_size)\n{\n\tint error;\n\n\tif (strlen(name) > 255)\n\t\treturn -ERANGE;\n\n\tdown_read(&EXT4_I(inode)->xattr_sem);\n\terror = ext4_xattr_ibody_get(inode, name_index, name, buffer,\n\t\t\t\t     buffer_size);\n\tif (error == -ENODATA)\n\t\terror = ext4_xattr_block_get(inode, name_index, name, buffer,\n\t\t\t\t\t     buffer_size);\n\tup_read(&EXT4_I(inode)->xattr_sem);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "retval",
            "GFP_NOFS"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstruct posix_acl *\next4_get_acl(struct inode *inode, int type)\n{\n\tint name_index;\n\tchar *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tretval = ext4_xattr_get(inode, name_index, \"\", NULL, 0);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_NOFS);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = ext4_xattr_get(inode, name_index, \"\", value, retval);\n\t}\n\tif (retval > 0)\n\t\tacl = ext4_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA || retval == -ENOSYS)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn acl;\n}"
  },
  {
    "function_name": "ext4_acl_to_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/acl.c",
    "lines": "93-140",
    "snippet": "static void *\next4_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\text4_acl_header *ext_acl;\n\tchar *e;\n\tsize_t n;\n\n\t*size = ext4_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(ext4_acl_header) + acl->a_count *\n\t\t\tsizeof(ext4_acl_entry), GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(EXT4_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(ext4_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text4_acl_entry *entry = (ext4_acl_entry *)e;\n\t\tentry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ext_acl"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kgid(&init_user_ns, acl_e->e_gid)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "acl_e->e_gid"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kuid(&init_user_ns, acl_e->e_uid)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "acl_e->e_uid"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "acl_e->e_perm"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "acl_e->e_tag"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_ACL_VERSION"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(ext4_acl_header) + acl->a_count *\n\t\t\tsizeof(ext4_acl_entry)",
            "GFP_NOFS"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext4_acl_size",
          "args": [
            "acl->a_count"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_acl_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/acl.h",
          "lines": "26-36",
          "snippet": "static inline size_t ext4_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(ext4_acl_header) +\n\t\t       count * sizeof(ext4_acl_entry_short);\n\t} else {\n\t\treturn sizeof(ext4_acl_header) +\n\t\t       4 * sizeof(ext4_acl_entry_short) +\n\t\t       (count - 4) * sizeof(ext4_acl_entry);\n\t}\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/posix_acl_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/posix_acl_xattr.h>\n\nstatic inline size_t ext4_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(ext4_acl_header) +\n\t\t       count * sizeof(ext4_acl_entry_short);\n\t} else {\n\t\treturn sizeof(ext4_acl_header) +\n\t\t       4 * sizeof(ext4_acl_entry_short) +\n\t\t       (count - 4) * sizeof(ext4_acl_entry);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic void *\next4_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\text4_acl_header *ext_acl;\n\tchar *e;\n\tsize_t n;\n\n\t*size = ext4_acl_size(acl->a_count);\n\text_acl = kmalloc(sizeof(ext4_acl_header) + acl->a_count *\n\t\t\tsizeof(ext4_acl_entry), GFP_NOFS);\n\tif (!ext_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\text_acl->a_version = cpu_to_le32(EXT4_ACL_VERSION);\n\te = (char *)ext_acl + sizeof(ext4_acl_header);\n\tfor (n = 0; n < acl->a_count; n++) {\n\t\tconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\n\t\text4_acl_entry *entry = (ext4_acl_entry *)e;\n\t\tentry->e_tag  = cpu_to_le16(acl_e->e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl_e->e_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kuid(&init_user_ns, acl_e->e_uid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\tfrom_kgid(&init_user_ns, acl_e->e_gid));\n\t\t\te += sizeof(ext4_acl_entry);\n\t\t\tbreak;\n\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\te += sizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (char *)ext_acl;\n\nfail:\n\tkfree(ext_acl);\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "ext4_acl_from_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/acl.c",
    "lines": "20-88",
    "snippet": "static struct posix_acl *\next4_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(ext4_acl_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (((ext4_acl_header *)value)->a_version !=\n\t    cpu_to_le32(EXT4_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(ext4_acl_header);\n\tcount = ext4_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\text4_acl_entry *entry =\n\t\t\t(ext4_acl_entry *)value;\n\t\tif ((char *)value + sizeof(ext4_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t\tsizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"ext4.h\"",
      "#include \"ext4_jbd2.h\"",
      "#include <linux/fs.h>",
      "#include <linux/capability.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(entry->e_id)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_id"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(entry->e_id)"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_perm"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_alloc",
          "args": [
            "count",
            "GFP_NOFS"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "140-149",
          "snippet": "struct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext4_acl_count",
          "args": [
            "size"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "ext4_acl_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext4/acl.h",
          "lines": "38-52",
          "snippet": "static inline int ext4_acl_count(size_t size)\n{\n\tssize_t s;\n\tsize -= sizeof(ext4_acl_header);\n\ts = size - 4 * sizeof(ext4_acl_entry_short);\n\tif (s < 0) {\n\t\tif (size % sizeof(ext4_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(ext4_acl_entry_short);\n\t} else {\n\t\tif (s % sizeof(ext4_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(ext4_acl_entry) + 4;\n\t}\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/posix_acl_xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/posix_acl_xattr.h>\n\nstatic inline int ext4_acl_count(size_t size)\n{\n\tssize_t s;\n\tsize -= sizeof(ext4_acl_header);\n\ts = size - 4 * sizeof(ext4_acl_entry_short);\n\tif (s < 0) {\n\t\tif (size % sizeof(ext4_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(ext4_acl_entry_short);\n\t} else {\n\t\tif (s % sizeof(ext4_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(ext4_acl_entry) + 4;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "EXT4_ACL_VERSION"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext4.h\"\n#include \"ext4_jbd2.h\"\n#include <linux/fs.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic struct posix_acl *\next4_acl_from_disk(const void *value, size_t size)\n{\n\tconst char *end = (char *)value + size;\n\tint n, count;\n\tstruct posix_acl *acl;\n\n\tif (!value)\n\t\treturn NULL;\n\tif (size < sizeof(ext4_acl_header))\n\t\t return ERR_PTR(-EINVAL);\n\tif (((ext4_acl_header *)value)->a_version !=\n\t    cpu_to_le32(EXT4_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\tvalue = (char *)value + sizeof(ext4_acl_header);\n\tcount = ext4_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (n = 0; n < count; n++) {\n\t\text4_acl_entry *entry =\n\t\t\t(ext4_acl_entry *)value;\n\t\tif ((char *)value + sizeof(ext4_acl_entry_short) > end)\n\t\t\tgoto fail;\n\t\tacl->a_entries[n].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[n].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[n].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tvalue = (char *)value +\n\t\t\t\tsizeof(ext4_acl_entry_short);\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tvalue = (char *)value + sizeof(ext4_acl_entry);\n\t\t\tif ((char *)value > end)\n\t\t\t\tgoto fail;\n\t\t\tacl->a_entries[n].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t  le32_to_cpu(entry->e_id));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (value != end)\n\t\tgoto fail;\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
  }
]