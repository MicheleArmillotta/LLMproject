[
  {
    "function_name": "fs2_mark_erased_block(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/erase.c",
    "lines": "427-515",
    "snippet": "atic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tsize_t retlen;\n\tint ret;\n\tuint32_t uninitialized_var(bad_offset);\n\n\tswitch (jffs2_block_check_erase(c, jeb, &bad_offset)) {\n\tcase -EAGAIN:\tgoto refile;\n\tcase -EIO:\tgoto filebad;\n\t}\n\n\t/* Write the erase complete marker */\n\tjffs2_dbg(1, \"Writing erased marker to block at 0x%08x\\n\", jeb->offset);\n\tbad_offset = jeb->offset;\n\n\t/* Cleanmarker in oob area or no cleanmarker at all ? */\n\tif (jffs2_cleanmarker_oob(c) || c->cleanmarker_size == 0) {\n\n\t\tif (jffs2_cleanmarker_oob(c)) {\n\t\t\tif (jffs2_write_nand_cleanmarker(c, jeb))\n\t\t\t\tgoto filebad;\n\t\t}\n\t} else {\n\n\t\tstruct kvec vecs[1];\n\t\tstruct jffs2_unknown_node marker = {\n\t\t\t.magic =\tcpu_to_je16(JFFS2_MAGIC_BITMASK),\n\t\t\t.nodetype =\tcpu_to_je16(JFFS2_NODETYPE_CLEANMARKER),\n\t\t\t.totlen =\tcpu_to_je32(c->cleanmarker_size)\n\t\t};\n\n\t\tjffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\t\tmarker.hdr_crc = cpu_to_je32(crc32(0, &marker, sizeof(struct jffs2_unknown_node)-4));\n\n\t\tvecs[0].iov_base = (unsigned char *) &marker;\n\t\tvecs[0].iov_len = sizeof(marker);\n\t\tret = jffs2_flash_direct_writev(c, vecs, 1, jeb->offset, &retlen);\n\n\t\tif (ret || retlen != sizeof(marker)) {\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Write clean marker to block at 0x%08x failed: %d\\n\",\n\t\t\t\t       jeb->offset, ret);\n\t\t\telse\n\t\t\t\tpr_warn(\"Short write to newly-erased block at 0x%08x: Wanted %zd, got %zd\\n\",\n\t\t\t\t       jeb->offset, sizeof(marker), retlen);\n\n\t\t\tgoto filebad;\n\t\t}\n\t}\n\t/* Everything else got zeroed before the erase */\n\tjeb->free_size = c->sector_size;\n\n\tmutex_lock(&c->erase_free_sem);\n\tspin_lock(&c->erase_completion_lock);\n\n\tc->erasing_size -= c->sector_size;\n\tc->free_size += c->sector_size;\n\n\t/* Account for cleanmarker now, if it's in-band */\n\tif (c->cleanmarker_size && !jffs2_cleanmarker_oob(c))\n\t\tjffs2_link_node_ref(c, jeb, jeb->offset | REF_NORMAL, c->cleanmarker_size, NULL);\n\n\tlist_move_tail(&jeb->list, &c->free_list);\n\tc->nr_erasing_blocks--;\n\tc->nr_free_blocks++;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n\twake_up(&c->erase_wait);\n\treturn;\n\nfilebad:\n\tjffs2_erase_failed(c, jeb, bad_offset);\n\treturn;\n\nrefile:\n\t/* Stick it back on the list from whence it came and come back later */\n\tmutex_lock(&c->erase_free_sem);\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tlist_move(&jeb->list, &c->erase_complete_list);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n\treturn;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset);\ns",
      "atic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\ns",
      "atic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_move(&",
          "args": [
            "eb->list,",
            "->erase_complete_list);"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_trigger(c",
          "args": [
            ";"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_erase_failed(c",
          "args": [
            "b,",
            "d_offset);"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ke_up(&",
          "args": [
            "->erase_wait);"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_acct_paranoia_check_nolock(c",
          "args": [
            "b);"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_acct_sanity_check_nolock(c",
          "args": [
            "b);"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_move_tail(&",
          "args": [
            "eb->list,",
            "->free_list);"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_link_node_ref(c",
          "args": [
            "b,",
            "b->offset | REF_NORMAL,",
            ">cleanmarker_size,",
            "LL);"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_cleanmarker_oob(c",
          "args": [
            ")"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "hort write to newly-erased block at 0x%08x: Wanted %zd, got %zd\\n\",",
            "b->offset,",
            "zeof(marker),",
            "tlen);"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "rite clean marker to block at 0x%08x failed: %d\\n\",",
            "b->offset,",
            "t);"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_flash_direct_writev(c",
          "args": [
            "cs,",
            "b->offset,",
            "etlen);"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, &marker, sizeof(struct jffs2_unknown_node)-4));"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "arker,",
            "zeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_prealloc_raw_node_refs(c",
          "args": [
            "b,",
            ";"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            ">cleanmarker_size)"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_NODETYPE_CLEANMARKER),"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_MAGIC_BITMASK),"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_write_nand_cleanmarker(c",
          "args": [
            "b))"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_cleanmarker_oob(c",
          "args": [
            ")"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_cleanmarker_oob(c",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "riting erased marker to block at 0x%08x\\n\",",
            "b->offset);"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_block_check_erase(c",
          "args": [
            "b,",
            "ad_offset))"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/pagemap.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset);\ns;\natic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\ns;\natic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\n\natic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tsize_t retlen;\n\tint ret;\n\tuint32_t uninitialized_var(bad_offset);\n\n\tswitch (jffs2_block_check_erase(c, jeb, &bad_offset)) {\n\tcase -EAGAIN:\tgoto refile;\n\tcase -EIO:\tgoto filebad;\n\t}\n\n\t/* Write the erase complete marker */\n\tjffs2_dbg(1, \"Writing erased marker to block at 0x%08x\\n\", jeb->offset);\n\tbad_offset = jeb->offset;\n\n\t/* Cleanmarker in oob area or no cleanmarker at all ? */\n\tif (jffs2_cleanmarker_oob(c) || c->cleanmarker_size == 0) {\n\n\t\tif (jffs2_cleanmarker_oob(c)) {\n\t\t\tif (jffs2_write_nand_cleanmarker(c, jeb))\n\t\t\t\tgoto filebad;\n\t\t}\n\t} else {\n\n\t\tstruct kvec vecs[1];\n\t\tstruct jffs2_unknown_node marker = {\n\t\t\t.magic =\tcpu_to_je16(JFFS2_MAGIC_BITMASK),\n\t\t\t.nodetype =\tcpu_to_je16(JFFS2_NODETYPE_CLEANMARKER),\n\t\t\t.totlen =\tcpu_to_je32(c->cleanmarker_size)\n\t\t};\n\n\t\tjffs2_prealloc_raw_node_refs(c, jeb, 1);\n\n\t\tmarker.hdr_crc = cpu_to_je32(crc32(0, &marker, sizeof(struct jffs2_unknown_node)-4));\n\n\t\tvecs[0].iov_base = (unsigned char *) &marker;\n\t\tvecs[0].iov_len = sizeof(marker);\n\t\tret = jffs2_flash_direct_writev(c, vecs, 1, jeb->offset, &retlen);\n\n\t\tif (ret || retlen != sizeof(marker)) {\n\t\t\tif (ret)\n\t\t\t\tpr_warn(\"Write clean marker to block at 0x%08x failed: %d\\n\",\n\t\t\t\t       jeb->offset, ret);\n\t\t\telse\n\t\t\t\tpr_warn(\"Short write to newly-erased block at 0x%08x: Wanted %zd, got %zd\\n\",\n\t\t\t\t       jeb->offset, sizeof(marker), retlen);\n\n\t\t\tgoto filebad;\n\t\t}\n\t}\n\t/* Everything else got zeroed before the erase */\n\tjeb->free_size = c->sector_size;\n\n\tmutex_lock(&c->erase_free_sem);\n\tspin_lock(&c->erase_completion_lock);\n\n\tc->erasing_size -= c->sector_size;\n\tc->free_size += c->sector_size;\n\n\t/* Account for cleanmarker now, if it's in-band */\n\tif (c->cleanmarker_size && !jffs2_cleanmarker_oob(c))\n\t\tjffs2_link_node_ref(c, jeb, jeb->offset | REF_NORMAL, c->cleanmarker_size, NULL);\n\n\tlist_move_tail(&jeb->list, &c->free_list);\n\tc->nr_erasing_blocks--;\n\tc->nr_free_blocks++;\n\n\tjffs2_dbg_acct_sanity_check_nolock(c, jeb);\n\tjffs2_dbg_acct_paranoia_check_nolock(c, jeb);\n\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n\twake_up(&c->erase_wait);\n\treturn;\n\nfilebad:\n\tjffs2_erase_failed(c, jeb, bad_offset);\n\treturn;\n\nrefile:\n\t/* Stick it back on the list from whence it came and come back later */\n\tmutex_lock(&c->erase_free_sem);\n\tspin_lock(&c->erase_completion_lock);\n\tjffs2_garbage_collect_trigger(c);\n\tlist_move(&jeb->list, &c->erase_complete_list);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n\treturn;\n}"
  },
  {
    "function_name": "fs2_block_check_erase(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/erase.c",
    "lines": "340-425",
    "snippet": "atic int jffs2_block_check_erase(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t *bad_offset)\n{\n\tvoid *ebuf;\n\tuint32_t ofs;\n\tsize_t retlen;\n\tint ret;\n\tunsigned long *wordebuf;\n\n\tret = mtd_point(c->mtd, jeb->offset, c->sector_size, &retlen,\n\t\t\t&ebuf, NULL);\n\tif (ret != -EOPNOTSUPP) {\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"MTD point failed %d\\n\", ret);\n\t\t\tgoto do_flash_read;\n\t\t}\n\t\tif (retlen < c->sector_size) {\n\t\t\t/* Don't muck about if it won't let us point to the whole erase sector */\n\t\t\tjffs2_dbg(1, \"MTD point returned len too short: 0x%zx\\n\",\n\t\t\t\t  retlen);\n\t\t\tmtd_unpoint(c->mtd, jeb->offset, retlen);\n\t\t\tgoto do_flash_read;\n\t\t}\n\t\twordebuf = ebuf-sizeof(*wordebuf);\n\t\tretlen /= sizeof(*wordebuf);\n\t\tdo {\n\t\t   if (*++wordebuf != ~0)\n\t\t\t   break;\n\t\t} while(--retlen);\n\t\tmtd_unpoint(c->mtd, jeb->offset, c->sector_size);\n\t\tif (retlen) {\n\t\t\tpr_warn(\"Newly-erased block contained word 0x%lx at offset 0x%08tx\\n\",\n\t\t\t\t*wordebuf,\n\t\t\t\tjeb->offset +\n\t\t\t\tc->sector_size-retlen * sizeof(*wordebuf));\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn 0;\n\t}\n do_flash_read:\n\tebuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!ebuf) {\n\t\tpr_warn(\"Failed to allocate page buffer for verifying erase at 0x%08x. Refiling\\n\",\n\t\t\tjeb->offset);\n\t\treturn -EAGAIN;\n\t}\n\n\tjffs2_dbg(1, \"Verifying erase at 0x%08x\\n\", jeb->offset);\n\n\tfor (ofs = jeb->offset; ofs < jeb->offset + c->sector_size; ) {\n\t\tuint32_t readlen = min((uint32_t)PAGE_SIZE, jeb->offset + c->sector_size - ofs);\n\t\tint i;\n\n\t\t*bad_offset = ofs;\n\n\t\tret = mtd_read(c->mtd, ofs, readlen, &retlen, ebuf);\n\t\tif (ret) {\n\t\t\tpr_warn(\"Read of newly-erased block at 0x%08x failed: %d. Putting on bad_list\\n\",\n\t\t\t\tofs, ret);\n\t\t\tret = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (retlen != readlen) {\n\t\t\tpr_warn(\"Short read from newly-erased block at 0x%08x. Wanted %d, got %zd\\n\",\n\t\t\t\tofs, readlen, retlen);\n\t\t\tret = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tfor (i=0; i<readlen; i += sizeof(unsigned long)) {\n\t\t\t/* It's OK. We know it's properly aligned */\n\t\t\tunsigned long *datum = ebuf + i;\n\t\t\tif (*datum + 1) {\n\t\t\t\t*bad_offset += i;\n\t\t\t\tpr_warn(\"Newly-erased block contained word 0x%lx at offset 0x%08x\\n\",\n\t\t\t\t\t*datum, *bad_offset);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tofs += readlen;\n\t\tcond_resched();\n\t}\n\tret = 0;\nfail:\n\tkfree(ebuf);\n\treturn ret;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset);\ns",
      "atic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\ns",
      "atic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(e",
          "args": [
            "uf);"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_resched()",
          "args": [],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ewly-erased block contained word 0x%lx at offset 0x%08x\\n\",",
            "atum,",
            "ad_offset);"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "hort read from newly-erased block at 0x%08x. Wanted %d, got %zd\\n\",",
            "s,",
            "adlen,",
            "tlen);"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ead of newly-erased block at 0x%08x failed: %d. Putting on bad_list\\n\",",
            "s,",
            "t);"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_read(c",
          "args": [
            ">mtd,",
            "s,",
            "adlen,",
            "etlen,",
            "uf);"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n((",
          "args": [
            "int32_t)PAGE_SIZE,",
            "b->offset + c->sector_size - ofs);"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "erifying erase at 0x%08x\\n\",",
            "b->offset);"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ailed to allocate page buffer for verifying erase at 0x%08x. Refiling\\n\",",
            "b->offset);"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(P",
          "args": [
            "GE_SIZE,",
            "P_KERNEL);"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ewly-erased block contained word 0x%lx at offset 0x%08tx\\n\",",
            "ordebuf,",
            "b->offset +\n\t\t\t\tc->sector_size-retlen * sizeof(*wordebuf));"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unpoint(c",
          "args": [
            ">mtd,",
            "b->offset,",
            ">sector_size);"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unpoint(c",
          "args": [
            ">mtd,",
            "b->offset,",
            "tlen);"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "TD point returned len too short: 0x%zx\\n\",",
            "tlen);"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "TD point failed %d\\n\",",
            "t);"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_point(c",
          "args": [
            ">mtd,",
            "b->offset,",
            ">sector_size,",
            "etlen,",
            "buf,",
            "LL);"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/pagemap.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset);\ns;\natic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\ns;\natic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\n\natic int jffs2_block_check_erase(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t *bad_offset)\n{\n\tvoid *ebuf;\n\tuint32_t ofs;\n\tsize_t retlen;\n\tint ret;\n\tunsigned long *wordebuf;\n\n\tret = mtd_point(c->mtd, jeb->offset, c->sector_size, &retlen,\n\t\t\t&ebuf, NULL);\n\tif (ret != -EOPNOTSUPP) {\n\t\tif (ret) {\n\t\t\tjffs2_dbg(1, \"MTD point failed %d\\n\", ret);\n\t\t\tgoto do_flash_read;\n\t\t}\n\t\tif (retlen < c->sector_size) {\n\t\t\t/* Don't muck about if it won't let us point to the whole erase sector */\n\t\t\tjffs2_dbg(1, \"MTD point returned len too short: 0x%zx\\n\",\n\t\t\t\t  retlen);\n\t\t\tmtd_unpoint(c->mtd, jeb->offset, retlen);\n\t\t\tgoto do_flash_read;\n\t\t}\n\t\twordebuf = ebuf-sizeof(*wordebuf);\n\t\tretlen /= sizeof(*wordebuf);\n\t\tdo {\n\t\t   if (*++wordebuf != ~0)\n\t\t\t   break;\n\t\t} while(--retlen);\n\t\tmtd_unpoint(c->mtd, jeb->offset, c->sector_size);\n\t\tif (retlen) {\n\t\t\tpr_warn(\"Newly-erased block contained word 0x%lx at offset 0x%08tx\\n\",\n\t\t\t\t*wordebuf,\n\t\t\t\tjeb->offset +\n\t\t\t\tc->sector_size-retlen * sizeof(*wordebuf));\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn 0;\n\t}\n do_flash_read:\n\tebuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!ebuf) {\n\t\tpr_warn(\"Failed to allocate page buffer for verifying erase at 0x%08x. Refiling\\n\",\n\t\t\tjeb->offset);\n\t\treturn -EAGAIN;\n\t}\n\n\tjffs2_dbg(1, \"Verifying erase at 0x%08x\\n\", jeb->offset);\n\n\tfor (ofs = jeb->offset; ofs < jeb->offset + c->sector_size; ) {\n\t\tuint32_t readlen = min((uint32_t)PAGE_SIZE, jeb->offset + c->sector_size - ofs);\n\t\tint i;\n\n\t\t*bad_offset = ofs;\n\n\t\tret = mtd_read(c->mtd, ofs, readlen, &retlen, ebuf);\n\t\tif (ret) {\n\t\t\tpr_warn(\"Read of newly-erased block at 0x%08x failed: %d. Putting on bad_list\\n\",\n\t\t\t\tofs, ret);\n\t\t\tret = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (retlen != readlen) {\n\t\t\tpr_warn(\"Short read from newly-erased block at 0x%08x. Wanted %d, got %zd\\n\",\n\t\t\t\tofs, readlen, retlen);\n\t\t\tret = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tfor (i=0; i<readlen; i += sizeof(unsigned long)) {\n\t\t\t/* It's OK. We know it's properly aligned */\n\t\t\tunsigned long *datum = ebuf + i;\n\t\t\tif (*datum + 1) {\n\t\t\t\t*bad_offset += i;\n\t\t\t\tpr_warn(\"Newly-erased block contained word 0x%lx at offset 0x%08x\\n\",\n\t\t\t\t\t*datum, *bad_offset);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t\tofs += readlen;\n\t\tcond_resched();\n\t}\n\tret = 0;\nfail:\n\tkfree(ebuf);\n\treturn ret;\n}"
  },
  {
    "function_name": "fs2_free_jeb_node_refs(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/erase.c",
    "lines": "316-338",
    "snippet": "id jffs2_free_jeb_node_refs(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tstruct jffs2_raw_node_ref *block, *ref;\n\tjffs2_dbg(1, \"Freeing all node refs for eraseblock offset 0x%08x\\n\",\n\t\t  jeb->offset);\n\n\tblock = ref = jeb->first_node;\n\n\twhile (ref) {\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tref = ref->next_in_ino;\n\t\t\tjffs2_free_refblock(block);\n\t\t\tblock = ref;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ref->flash_offset != REF_EMPTY_NODE && ref->next_in_ino)\n\t\t\tjffs2_remove_node_refs_from_ino_list(c, ref, jeb);\n\t\t/* else it was a non-inode node or already removed, so don't bother */\n\n\t\tref++;\n\t}\n\tjeb->first_node = jeb->last_node = NULL;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_remove_node_refs_from_ino_list(c",
          "args": [
            "f,",
            "b);"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_refblock(b",
          "args": [
            "ock);"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "reeing all node refs for eraseblock offset 0x%08x\\n\",",
            "b->offset);"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/pagemap.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\n\nid jffs2_free_jeb_node_refs(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tstruct jffs2_raw_node_ref *block, *ref;\n\tjffs2_dbg(1, \"Freeing all node refs for eraseblock offset 0x%08x\\n\",\n\t\t  jeb->offset);\n\n\tblock = ref = jeb->first_node;\n\n\twhile (ref) {\n\t\tif (ref->flash_offset == REF_LINK_NODE) {\n\t\t\tref = ref->next_in_ino;\n\t\t\tjffs2_free_refblock(block);\n\t\t\tblock = ref;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ref->flash_offset != REF_EMPTY_NODE && ref->next_in_ino)\n\t\t\tjffs2_remove_node_refs_from_ino_list(c, ref, jeb);\n\t\t/* else it was a non-inode node or already removed, so don't bother */\n\n\t\tref++;\n\t}\n\tjeb->first_node = jeb->last_node = NULL;\n}"
  },
  {
    "function_name": "fs2_remove_node_refs_from_ino_list(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/erase.c",
    "lines": "235-314",
    "snippet": "atic inline void jffs2_remove_node_refs_from_ino_list(struct jffs2_sb_info *c,\n\t\t\tstruct jffs2_raw_node_ref *ref, struct jffs2_eraseblock *jeb)\n{\n\tstruct jffs2_inode_cache *ic = NULL;\n\tstruct jffs2_raw_node_ref **prev;\n\n\tprev = &ref->next_in_ino;\n\n\t/* Walk the inode's list once, removing any nodes from this eraseblock */\n\twhile (1) {\n\t\tif (!(*prev)->next_in_ino) {\n\t\t\t/* We're looking at the jffs2_inode_cache, which is\n\t\t\t   at the end of the linked list. Stash it and continue\n\t\t\t   from the beginning of the list */\n\t\t\tic = (struct jffs2_inode_cache *)(*prev);\n\t\t\tprev = &ic->nodes;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (SECTOR_ADDR((*prev)->flash_offset) == jeb->offset) {\n\t\t\t/* It's in the block we're erasing */\n\t\t\tstruct jffs2_raw_node_ref *this;\n\n\t\t\tthis = *prev;\n\t\t\t*prev = this->next_in_ino;\n\t\t\tthis->next_in_ino = NULL;\n\n\t\t\tif (this == ref)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\t\t/* Not to be deleted. Skip */\n\t\tprev = &((*prev)->next_in_ino);\n\t}\n\n\t/* PARANOIA */\n\tif (!ic) {\n\t\tJFFS2_WARNING(\"inode_cache/xattr_datum/xattr_ref\"\n\t\t\t      \" not found in remove_node_refs()!!\\n\");\n\t\treturn;\n\t}\n\n\tjffs2_dbg(1, \"Removed nodes in range 0x%08x-0x%08x from ino #%u\\n\",\n\t\t  jeb->offset, jeb->offset + c->sector_size, ic->ino);\n\n\tD2({\n\t\tint i=0;\n\t\tstruct jffs2_raw_node_ref *this;\n\t\tprintk(KERN_DEBUG \"After remove_node_refs_from_ino_list: \\n\");\n\n\t\tthis = ic->nodes;\n\n\t\tprintk(KERN_DEBUG);\n\t\twhile(this) {\n\t\t\tpr_cont(\"0x%08x(%d)->\",\n\t\t\t       ref_offset(this), ref_flags(this));\n\t\t\tif (++i == 5) {\n\t\t\t\tprintk(KERN_DEBUG);\n\t\t\t\ti=0;\n\t\t\t}\n\t\t\tthis = this->next_in_ino;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t});\n\n\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\tbreak;\n\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t}\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset);\ns",
      "atic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\ns",
      "atic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_del_ino_cache(c",
          "args": [
            ");"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_release_xattr_ref(c",
          "args": [
            "truct jffs2_xattr_ref *)ic);"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_release_xattr_datum(c",
          "args": [
            "truct jffs2_xattr_datum *)ic);"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "({",
          "args": [
            "int i=0;\n\t\tstruct jffs2_raw_node_ref *this;\n\t\tprintk(KERN_DEBUG \"After remove_node_refs_from_ino_list: \\n\");\n\n\t\tthis = ic->nodes;\n\n\t\tprintk(KERN_DEBUG);\n\t\twhile(this) {\n\t\t\tpr_cont(\"0x%08x(%d)->\",\n\t\t\t       ref_offset(this), ref_flags(this));\n\t\t\tif (++i == 5) {\n\t\t\t\tprintk(KERN_DEBUG);\n\t\t\t\ti=0;\n\t\t\t}\n\t\t\tthis = this->next_in_ino;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t});"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cont(\"",
          "args": [
            "n\");"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intk(K",
          "args": [
            "RN_DEBUG);"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cont(\"",
          "args": [
            "x%08x(%d)->\",",
            "f_offset(this),",
            "f_flags(this));"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_flags(t",
          "args": [
            "is))"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(t",
          "args": [
            "is),"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intk(K",
          "args": [
            "RN_DEBUG);"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intk(K",
          "args": [
            "RN_DEBUG \"After remove_node_refs_from_ino_list: \\n\");"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "emoved nodes in range 0x%08x-0x%08x from ino #%u\\n\",",
            "b->offset,",
            "b->offset + c->sector_size,",
            "->ino);"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_WARNING(\"",
          "args": [
            "node_cache/xattr_datum/xattr_ref\"\n\t\t\t      \" not found in remove_node_refs()!!\\n\");"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTOR_ADDR((",
          "args": [
            "prev)->flash_offset)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/pagemap.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset);\ns;\natic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\ns;\natic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\n\natic inline void jffs2_remove_node_refs_from_ino_list(struct jffs2_sb_info *c,\n\t\t\tstruct jffs2_raw_node_ref *ref, struct jffs2_eraseblock *jeb)\n{\n\tstruct jffs2_inode_cache *ic = NULL;\n\tstruct jffs2_raw_node_ref **prev;\n\n\tprev = &ref->next_in_ino;\n\n\t/* Walk the inode's list once, removing any nodes from this eraseblock */\n\twhile (1) {\n\t\tif (!(*prev)->next_in_ino) {\n\t\t\t/* We're looking at the jffs2_inode_cache, which is\n\t\t\t   at the end of the linked list. Stash it and continue\n\t\t\t   from the beginning of the list */\n\t\t\tic = (struct jffs2_inode_cache *)(*prev);\n\t\t\tprev = &ic->nodes;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (SECTOR_ADDR((*prev)->flash_offset) == jeb->offset) {\n\t\t\t/* It's in the block we're erasing */\n\t\t\tstruct jffs2_raw_node_ref *this;\n\n\t\t\tthis = *prev;\n\t\t\t*prev = this->next_in_ino;\n\t\t\tthis->next_in_ino = NULL;\n\n\t\t\tif (this == ref)\n\t\t\t\tbreak;\n\n\t\t\tcontinue;\n\t\t}\n\t\t/* Not to be deleted. Skip */\n\t\tprev = &((*prev)->next_in_ino);\n\t}\n\n\t/* PARANOIA */\n\tif (!ic) {\n\t\tJFFS2_WARNING(\"inode_cache/xattr_datum/xattr_ref\"\n\t\t\t      \" not found in remove_node_refs()!!\\n\");\n\t\treturn;\n\t}\n\n\tjffs2_dbg(1, \"Removed nodes in range 0x%08x-0x%08x from ino #%u\\n\",\n\t\t  jeb->offset, jeb->offset + c->sector_size, ic->ino);\n\n\tD2({\n\t\tint i=0;\n\t\tstruct jffs2_raw_node_ref *this;\n\t\tprintk(KERN_DEBUG \"After remove_node_refs_from_ino_list: \\n\");\n\n\t\tthis = ic->nodes;\n\n\t\tprintk(KERN_DEBUG);\n\t\twhile(this) {\n\t\t\tpr_cont(\"0x%08x(%d)->\",\n\t\t\t       ref_offset(this), ref_flags(this));\n\t\t\tif (++i == 5) {\n\t\t\t\tprintk(KERN_DEBUG);\n\t\t\t\ti=0;\n\t\t\t}\n\t\t\tthis = this->next_in_ino;\n\t\t}\n\t\tpr_cont(\"\\n\");\n\t});\n\n\tswitch (ic->class) {\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t\tcase RAWNODE_CLASS_XATTR_DATUM:\n\t\t\tjffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\n\t\t\tbreak;\n\t\tcase RAWNODE_CLASS_XATTR_REF:\n\t\t\tjffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\n\t\t\t\tjffs2_del_ino_cache(c, ic);\n\t}\n}"
  },
  {
    "function_name": "fs2_erase_callback(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/erase.c",
    "lines": "218-230",
    "snippet": "atic void jffs2_erase_callback(struct erase_info *instr)\n{\n\tstruct erase_priv_struct *priv = (void *)instr->priv;\n\n\tif(instr->state != MTD_ERASE_DONE) {\n\t\tpr_warn(\"Erase at 0x%08llx finished, but state != MTD_ERASE_DONE. State is 0x%x instead.\\n\",\n\t\t\t(unsigned long long)instr->addr, instr->state);\n\t\tjffs2_erase_failed(priv->c, priv->jeb, instr->fail_addr);\n\t} else {\n\t\tjffs2_erase_succeeded(priv->c, priv->jeb);\n\t}\n\tkfree(instr);\n}\n#",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(i",
          "args": [
            "str);"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_erase_succeeded(p",
          "args": [
            "iv->c,",
            "iv->jeb);"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_erase_failed(p",
          "args": [
            "iv->c,",
            "iv->jeb,",
            "str->fail_addr);"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "rase at 0x%08llx finished, but state != MTD_ERASE_DONE. State is 0x%x instead.\\n\",",
            "nsigned long long)instr->addr,",
            "str->state);"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/pagemap.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\n\natic void jffs2_erase_callback(struct erase_info *instr)\n{\n\tstruct erase_priv_struct *priv = (void *)instr->priv;\n\n\tif(instr->state != MTD_ERASE_DONE) {\n\t\tpr_warn(\"Erase at 0x%08llx finished, but state != MTD_ERASE_DONE. State is 0x%x instead.\\n\",\n\t\t\t(unsigned long long)instr->addr, instr->state);\n\t\tjffs2_erase_failed(priv->c, priv->jeb, instr->fail_addr);\n\t} else {\n\t\tjffs2_erase_succeeded(priv->c, priv->jeb);\n\t}\n\tkfree(instr);\n}\n#"
  },
  {
    "function_name": "fs2_erase_failed(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/erase.c",
    "lines": "185-215",
    "snippet": "atic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset)\n{\n\t/* For NAND, if the failure did not occur at the device level for a\n\t   specific physical page, don't bother updating the bad block table. */\n\tif (jffs2_cleanmarker_oob(c) && (bad_offset != (uint32_t)MTD_FAIL_ADDR_UNKNOWN)) {\n\t\t/* We had a device-level failure to erase.  Let's see if we've\n\t\t   failed too many times. */\n\t\tif (!jffs2_write_nand_badblock(c, jeb, bad_offset)) {\n\t\t\t/* We'd like to give this block another try. */\n\t\t\tmutex_lock(&c->erase_free_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\tlist_move(&jeb->list, &c->erase_pending_list);\n\t\t\tc->erasing_size -= c->sector_size;\n\t\t\tc->dirty_size += c->sector_size;\n\t\t\tjeb->dirty_size = c->sector_size;\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->erase_free_sem);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmutex_lock(&c->erase_free_sem);\n\tspin_lock(&c->erase_completion_lock);\n\tc->erasing_size -= c->sector_size;\n\tc->bad_size += c->sector_size;\n\tlist_move(&jeb->list, &c->bad_list);\n\tc->nr_erasing_blocks--;\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n\twake_up(&c->erase_wait);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset);\ns",
      "atic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\ns",
      "atic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ke_up(&",
          "args": [
            "->erase_wait);"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_move(&",
          "args": [
            "eb->list,",
            "->bad_list);"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_move(&",
          "args": [
            "eb->list,",
            "->erase_pending_list);"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_write_nand_badblock(c",
          "args": [
            "b,",
            "d_offset))"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_cleanmarker_oob(c",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/pagemap.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset);\ns;\natic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\ns;\natic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\n\natic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset)\n{\n\t/* For NAND, if the failure did not occur at the device level for a\n\t   specific physical page, don't bother updating the bad block table. */\n\tif (jffs2_cleanmarker_oob(c) && (bad_offset != (uint32_t)MTD_FAIL_ADDR_UNKNOWN)) {\n\t\t/* We had a device-level failure to erase.  Let's see if we've\n\t\t   failed too many times. */\n\t\tif (!jffs2_write_nand_badblock(c, jeb, bad_offset)) {\n\t\t\t/* We'd like to give this block another try. */\n\t\t\tmutex_lock(&c->erase_free_sem);\n\t\t\tspin_lock(&c->erase_completion_lock);\n\t\t\tlist_move(&jeb->list, &c->erase_pending_list);\n\t\t\tc->erasing_size -= c->sector_size;\n\t\t\tc->dirty_size += c->sector_size;\n\t\t\tjeb->dirty_size = c->sector_size;\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->erase_free_sem);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmutex_lock(&c->erase_free_sem);\n\tspin_lock(&c->erase_completion_lock);\n\tc->erasing_size -= c->sector_size;\n\tc->bad_size += c->sector_size;\n\tlist_move(&jeb->list, &c->bad_list);\n\tc->nr_erasing_blocks--;\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n\twake_up(&c->erase_wait);\n}"
  },
  {
    "function_name": "fs2_erase_succeeded(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/erase.c",
    "lines": "172-183",
    "snippet": "atic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tjffs2_dbg(1, \"Erase completed successfully at 0x%08x\\n\", jeb->offset);\n\tmutex_lock(&c->erase_free_sem);\n\tspin_lock(&c->erase_completion_lock);\n\tlist_move_tail(&jeb->list, &c->erase_complete_list);\n\t/* Wake the GC thread to mark them clean */\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n\twake_up(&c->erase_wait);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ke_up(&",
          "args": [
            "->erase_wait);"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_trigger(c",
          "args": [
            ";"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_move_tail(&",
          "args": [
            "eb->list,",
            "->erase_complete_list);"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "rase completed successfully at 0x%08x\\n\",",
            "b->offset);"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/pagemap.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\n\natic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\n{\n\tjffs2_dbg(1, \"Erase completed successfully at 0x%08x\\n\", jeb->offset);\n\tmutex_lock(&c->erase_free_sem);\n\tspin_lock(&c->erase_completion_lock);\n\tlist_move_tail(&jeb->list, &c->erase_complete_list);\n\t/* Wake the GC thread to mark them clean */\n\tjffs2_garbage_collect_trigger(c);\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n\twake_up(&c->erase_wait);\n}"
  },
  {
    "function_name": "fs2_erase_pending_blocks(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/erase.c",
    "lines": "112-170",
    "snippet": "t jffs2_erase_pending_blocks(struct jffs2_sb_info *c, int count)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint work_done = 0;\n\n\tmutex_lock(&c->erase_free_sem);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\twhile (!list_empty(&c->erase_complete_list) ||\n\t       !list_empty(&c->erase_pending_list)) {\n\n\t\tif (!list_empty(&c->erase_complete_list)) {\n\t\t\tjeb = list_entry(c->erase_complete_list.next, struct jffs2_eraseblock, list);\n\t\t\tlist_move(&jeb->list, &c->erase_checking_list);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->erase_free_sem);\n\t\t\tjffs2_mark_erased_block(c, jeb);\n\n\t\t\twork_done++;\n\t\t\tif (!--count) {\n\t\t\t\tjffs2_dbg(1, \"Count reached. jffs2_erase_pending_blocks leaving\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t} else if (!list_empty(&c->erase_pending_list)) {\n\t\t\tjeb = list_entry(c->erase_pending_list.next, struct jffs2_eraseblock, list);\n\t\t\tjffs2_dbg(1, \"Starting erase of pending block 0x%08x\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t\tc->erasing_size += c->sector_size;\n\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\tc->free_size -= jeb->free_size;\n\t\t\tc->used_size -= jeb->used_size;\n\t\t\tc->dirty_size -= jeb->dirty_size;\n\t\t\tjeb->wasted_size = jeb->used_size = jeb->dirty_size = jeb->free_size = 0;\n\t\t\tjffs2_free_jeb_node_refs(c, jeb);\n\t\t\tlist_add(&jeb->list, &c->erasing_list);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->erase_free_sem);\n\n\t\t\tjffs2_erase_block(c, jeb);\n\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\n\t\t/* Be nice */\n\t\tcond_resched();\n\t\tmutex_lock(&c->erase_free_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n done:\n\tjffs2_dbg(1, \"jffs2_erase_pending_blocks completed\\n\");\n\treturn work_done;\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ffs2_erase_pending_blocks completed\\n\");"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_resched()",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_erase_block(c",
          "args": [
            "b);"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_add(&",
          "args": [
            "eb->list,",
            "->erasing_list);"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_jeb_node_refs(c",
          "args": [
            "b);"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_del(&",
          "args": [
            "eb->list);"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "tarting erase of pending block 0x%08x\\n\",",
            "b->offset);"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_entry(c",
          "args": [
            ">erase_pending_list.next,",
            "ruct jfs2_eraseblock,",
            "st);"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->erase_pending_list))"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ount reached. jffs2_erase_pending_blocks leaving\\n\");"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_mark_erased_block(c",
          "args": [
            "b);"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_move(&",
          "args": [
            "eb->list,",
            "->erase_checking_list);"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_entry(c",
          "args": [
            ">erase_complete_list.next,",
            "ruct jfs2_eraseblock,",
            "st);"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->erase_complete_list))"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->erase_pending_list))"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->erase_complete_list)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/pagemap.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\n\nt jffs2_erase_pending_blocks(struct jffs2_sb_info *c, int count)\n{\n\tstruct jffs2_eraseblock *jeb;\n\tint work_done = 0;\n\n\tmutex_lock(&c->erase_free_sem);\n\n\tspin_lock(&c->erase_completion_lock);\n\n\twhile (!list_empty(&c->erase_complete_list) ||\n\t       !list_empty(&c->erase_pending_list)) {\n\n\t\tif (!list_empty(&c->erase_complete_list)) {\n\t\t\tjeb = list_entry(c->erase_complete_list.next, struct jffs2_eraseblock, list);\n\t\t\tlist_move(&jeb->list, &c->erase_checking_list);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->erase_free_sem);\n\t\t\tjffs2_mark_erased_block(c, jeb);\n\n\t\t\twork_done++;\n\t\t\tif (!--count) {\n\t\t\t\tjffs2_dbg(1, \"Count reached. jffs2_erase_pending_blocks leaving\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t} else if (!list_empty(&c->erase_pending_list)) {\n\t\t\tjeb = list_entry(c->erase_pending_list.next, struct jffs2_eraseblock, list);\n\t\t\tjffs2_dbg(1, \"Starting erase of pending block 0x%08x\\n\",\n\t\t\t\t  jeb->offset);\n\t\t\tlist_del(&jeb->list);\n\t\t\tc->erasing_size += c->sector_size;\n\t\t\tc->wasted_size -= jeb->wasted_size;\n\t\t\tc->free_size -= jeb->free_size;\n\t\t\tc->used_size -= jeb->used_size;\n\t\t\tc->dirty_size -= jeb->dirty_size;\n\t\t\tjeb->wasted_size = jeb->used_size = jeb->dirty_size = jeb->free_size = 0;\n\t\t\tjffs2_free_jeb_node_refs(c, jeb);\n\t\t\tlist_add(&jeb->list, &c->erasing_list);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->erase_free_sem);\n\n\t\t\tjffs2_erase_block(c, jeb);\n\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\n\t\t/* Be nice */\n\t\tcond_resched();\n\t\tmutex_lock(&c->erase_free_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\tspin_unlock(&c->erase_completion_lock);\n\tmutex_unlock(&c->erase_free_sem);\n done:\n\tjffs2_dbg(1, \"jffs2_erase_pending_blocks completed\\n\");\n\treturn work_done;\n}"
  },
  {
    "function_name": "fs2_erase_block(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/erase.c",
    "lines": "36-110",
    "snippet": "atic void jffs2_erase_block(struct jffs2_sb_info *c,\n\t\t\t      struct jffs2_eraseblock *jeb)\n{\n\tint ret;\n\tuint32_t bad_offset;\n#ifdef __ECOS\n       ret = jffs2_flash_erase(c, jeb);\n       if (!ret) {\n\t       jffs2_erase_succeeded(c, jeb);\n\t       return;\n       }\n       bad_offset = jeb->offset;\n#else /* Linux */\n\tstruct erase_info *instr;\n\n\tjffs2_dbg(1, \"%s(): erase block %#08x (range %#08x-%#08x)\\n\",\n\t\t  __func__,\n\t\t  jeb->offset, jeb->offset, jeb->offset + c->sector_size);\n\tinstr = kmalloc(sizeof(struct erase_info) + sizeof(struct erase_priv_struct), GFP_KERNEL);\n\tif (!instr) {\n\t\tpr_warn(\"kmalloc for struct erase_info in jffs2_erase_block failed. Refiling block for later\\n\");\n\t\tmutex_lock(&c->erase_free_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tlist_move(&jeb->list, &c->erase_pending_list);\n\t\tc->erasing_size -= c->sector_size;\n\t\tc->dirty_size += c->sector_size;\n\t\tjeb->dirty_size = c->sector_size;\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->erase_free_sem);\n\t\treturn;\n\t}\n\n\tmemset(instr, 0, sizeof(*instr));\n\n\tinstr->mtd = c->mtd;\n\tinstr->addr = jeb->offset;\n\tinstr->len = c->sector_size;\n\tinstr->callback = jffs2_erase_callback;\n\tinstr->priv = (unsigned long)(&instr[1]);\n\n\t((struct erase_priv_struct *)instr->priv)->jeb = jeb;\n\t((struct erase_priv_struct *)instr->priv)->c = c;\n\n\tret = mtd_erase(c->mtd, instr);\n\tif (!ret)\n\t\treturn;\n\n\tbad_offset = instr->fail_addr;\n\tkfree(instr);\n#endif /* __ECOS */\n\n\tif (ret == -ENOMEM || ret == -EAGAIN) {\n\t\t/* Erase failed immediately. Refile it on the list */\n\t\tjffs2_dbg(1, \"Erase at 0x%08x failed: %d. Refiling on erase_pending_list\\n\",\n\t\t\t  jeb->offset, ret);\n\t\tmutex_lock(&c->erase_free_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tlist_move(&jeb->list, &c->erase_pending_list);\n\t\tc->erasing_size -= c->sector_size;\n\t\tc->dirty_size += c->sector_size;\n\t\tjeb->dirty_size = c->sector_size;\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->erase_free_sem);\n\t\treturn;\n\t}\n\n\tif (ret == -EROFS)\n\t\tpr_warn(\"Erase at 0x%08x failed immediately: -EROFS. Is the sector locked?\\n\",\n\t\t\tjeb->offset);\n\telse\n\t\tpr_warn(\"Erase at 0x%08x failed immediately: errno %d\\n\",\n\t\t\tjeb->offset, ret);\n\n\tjffs2_erase_failed(c, jeb, bad_offset);\n}",
    "includes": [
      "nclude \"nodelist.h\"\n\ns",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/sched.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset);\ns",
      "atic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\ns",
      "atic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_erase_failed(c",
          "args": [
            "b,",
            "d_offset);"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "rase at 0x%08x failed immediately: errno %d\\n\",",
            "b->offset,",
            "t);"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "rase at 0x%08x failed immediately: -EROFS. Is the sector locked?\\n\",",
            "b->offset);"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_move(&",
          "args": [
            "eb->list,",
            "->erase_pending_list);"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "rase at 0x%08x failed: %d. Refiling on erase_pending_list\\n\",",
            "b->offset,",
            "t);"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(i",
          "args": [
            "str);"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_erase(c",
          "args": [
            ">mtd,",
            "str);"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mset(i",
          "args": [
            "str,",
            "zeof(*instr));"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_move(&",
          "args": [
            "eb->list,",
            "->erase_pending_list);"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "malloc for struct erase_info in jffs2_erase_block failed. Refiling block for later\\n\");"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(s",
          "args": [
            "zeof(struct erase_info) + sizeof(struct erase_priv_struct),",
            "P_KERNEL);"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): erase block %#08x (range %#08x-%#08x)\\n\",",
            "func__,",
            "b->offset,",
            "b->offset,",
            "b->offset + c->sector_size);"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_erase_succeeded(c",
          "args": [
            "b);"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_flash_erase(c",
          "args": [
            "b);"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/pagemap.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset);\ns;\natic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\ns;\natic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb);\n\natic void jffs2_erase_block(struct jffs2_sb_info *c,\n\t\t\t      struct jffs2_eraseblock *jeb)\n{\n\tint ret;\n\tuint32_t bad_offset;\n#ifdef __ECOS\n       ret = jffs2_flash_erase(c, jeb);\n       if (!ret) {\n\t       jffs2_erase_succeeded(c, jeb);\n\t       return;\n       }\n       bad_offset = jeb->offset;\n#else /* Linux */\n\tstruct erase_info *instr;\n\n\tjffs2_dbg(1, \"%s(): erase block %#08x (range %#08x-%#08x)\\n\",\n\t\t  __func__,\n\t\t  jeb->offset, jeb->offset, jeb->offset + c->sector_size);\n\tinstr = kmalloc(sizeof(struct erase_info) + sizeof(struct erase_priv_struct), GFP_KERNEL);\n\tif (!instr) {\n\t\tpr_warn(\"kmalloc for struct erase_info in jffs2_erase_block failed. Refiling block for later\\n\");\n\t\tmutex_lock(&c->erase_free_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tlist_move(&jeb->list, &c->erase_pending_list);\n\t\tc->erasing_size -= c->sector_size;\n\t\tc->dirty_size += c->sector_size;\n\t\tjeb->dirty_size = c->sector_size;\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->erase_free_sem);\n\t\treturn;\n\t}\n\n\tmemset(instr, 0, sizeof(*instr));\n\n\tinstr->mtd = c->mtd;\n\tinstr->addr = jeb->offset;\n\tinstr->len = c->sector_size;\n\tinstr->callback = jffs2_erase_callback;\n\tinstr->priv = (unsigned long)(&instr[1]);\n\n\t((struct erase_priv_struct *)instr->priv)->jeb = jeb;\n\t((struct erase_priv_struct *)instr->priv)->c = c;\n\n\tret = mtd_erase(c->mtd, instr);\n\tif (!ret)\n\t\treturn;\n\n\tbad_offset = instr->fail_addr;\n\tkfree(instr);\n#endif /* __ECOS */\n\n\tif (ret == -ENOMEM || ret == -EAGAIN) {\n\t\t/* Erase failed immediately. Refile it on the list */\n\t\tjffs2_dbg(1, \"Erase at 0x%08x failed: %d. Refiling on erase_pending_list\\n\",\n\t\t\t  jeb->offset, ret);\n\t\tmutex_lock(&c->erase_free_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tlist_move(&jeb->list, &c->erase_pending_list);\n\t\tc->erasing_size -= c->sector_size;\n\t\tc->dirty_size += c->sector_size;\n\t\tjeb->dirty_size = c->sector_size;\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->erase_free_sem);\n\t\treturn;\n\t}\n\n\tif (ret == -EROFS)\n\t\tpr_warn(\"Erase at 0x%08x failed immediately: -EROFS. Is the sector locked?\\n\",\n\t\t\tjeb->offset);\n\telse\n\t\tpr_warn(\"Erase at 0x%08x failed immediately: errno %d\\n\",\n\t\t\tjeb->offset, ret);\n\n\tjffs2_erase_failed(c, jeb, bad_offset);\n}"
  }
]