[
  {
    "function_name": "btrfs_add_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.h",
    "lines": "86-92",
    "snippet": "static inline int\nbtrfs_add_free_space(struct btrfs_block_group_cache *block_group,\n\t\t     u64 bytenr, u64 size)\n{\n\treturn __btrfs_add_free_space(block_group->free_space_ctl,\n\t\t\t\t      bytenr, size);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_add_free_space",
          "args": [
            "block_group->free_space_ctl",
            "bytenr",
            "size"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_add_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/free-space-cache.c",
          "lines": "2155-2207",
          "snippet": "int __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"extent_io.h\"",
            "#include \"disk-io.h\"",
            "#include \"transaction.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/math64.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);",
            "static void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"extent_io.h\"\n#include \"disk-io.h\"\n#include \"transaction.h\"\n#include \"free-space-cache.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/math64.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n\nstatic int link_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   struct btrfs_free_space *info);\nstatic void unlink_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t      struct btrfs_free_space *info);\n\nint __btrfs_add_free_space(struct btrfs_free_space_ctl *ctl,\n\t\t\t   u64 offset, u64 bytes)\n{\n\tstruct btrfs_free_space *info;\n\tint ret = 0;\n\n\tinfo = kmem_cache_zalloc(btrfs_free_space_cachep, GFP_NOFS);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->offset = offset;\n\tinfo->bytes = bytes;\n\tRB_CLEAR_NODE(&info->offset_index);\n\n\tspin_lock(&ctl->tree_lock);\n\n\tif (try_merge_free_space(ctl, info, true))\n\t\tgoto link;\n\n\t/*\n\t * There was no extent directly to the left or right of this new\n\t * extent then we know we're going to have to allocate a new extent, so\n\t * before we do that see if we need to drop this into a bitmap\n\t */\n\tret = insert_into_bitmap(ctl, info);\n\tif (ret < 0) {\n\t\tgoto out;\n\t} else if (ret) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\nlink:\n\t/*\n\t * Only steal free space from adjacent bitmaps if we're sure we're not\n\t * going to add the new free space to existing bitmap entries - because\n\t * that would mean unnecessary work that would be reverted. Therefore\n\t * attempt to steal space from bitmaps if we're adding an extent entry.\n\t */\n\tsteal_from_bitmap(ctl, info, true);\n\n\tret = link_free_space(ctl, info);\n\tif (ret)\n\t\tkmem_cache_free(btrfs_free_space_cachep, info);\nout:\n\tspin_unlock(&ctl->tree_lock);\n\n\tif (ret) {\n\t\tprintk(KERN_CRIT \"BTRFS: unable to add free space :%d\\n\", ret);\n\t\tASSERT(ret != -EEXIST);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline int\nbtrfs_add_free_space(struct btrfs_block_group_cache *block_group,\n\t\t     u64 bytenr, u64 size)\n{\n\treturn __btrfs_add_free_space(block_group->free_space_ctl,\n\t\t\t\t      bytenr, size);\n}"
  }
]