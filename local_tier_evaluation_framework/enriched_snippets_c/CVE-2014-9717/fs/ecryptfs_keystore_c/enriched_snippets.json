[
  {
    "function_name": "ecryptfs_add_global_auth_tok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "2504-2528",
    "snippet": "int\necryptfs_add_global_auth_tok(struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *sig, u32 global_auth_tok_flags)\n{\n\tstruct ecryptfs_global_auth_tok *new_auth_tok;\n\tint rc = 0;\n\n\tnew_auth_tok = kmem_cache_zalloc(ecryptfs_global_auth_tok_cache,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!new_auth_tok) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"Error allocating from \"\n\t\t       \"ecryptfs_global_auth_tok_cache\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(new_auth_tok->sig, sig, ECRYPTFS_SIG_SIZE_HEX);\n\tnew_auth_tok->flags = global_auth_tok_flags;\n\tnew_auth_tok->sig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_add(&new_auth_tok->mount_crypt_stat_list,\n\t\t &mount_crypt_stat->global_auth_tok_list);\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_global_auth_tok_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mount_crypt_stat->global_auth_tok_list_mutex"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_auth_tok->mount_crypt_stat_list",
            "&mount_crypt_stat->global_auth_tok_list"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mount_crypt_stat->global_auth_tok_list_mutex"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_auth_tok->sig",
            "sig",
            "ECRYPTFS_SIG_SIZE_HEX"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error allocating from \"\n\t\t       \"ecryptfs_global_auth_tok_cache\\n\""
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "ecryptfs_global_auth_tok_cache",
            "GFP_KERNEL"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_global_auth_tok_cache;\n\nint\necryptfs_add_global_auth_tok(struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *sig, u32 global_auth_tok_flags)\n{\n\tstruct ecryptfs_global_auth_tok *new_auth_tok;\n\tint rc = 0;\n\n\tnew_auth_tok = kmem_cache_zalloc(ecryptfs_global_auth_tok_cache,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!new_auth_tok) {\n\t\trc = -ENOMEM;\n\t\tprintk(KERN_ERR \"Error allocating from \"\n\t\t       \"ecryptfs_global_auth_tok_cache\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(new_auth_tok->sig, sig, ECRYPTFS_SIG_SIZE_HEX);\n\tnew_auth_tok->flags = global_auth_tok_flags;\n\tnew_auth_tok->sig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_add(&new_auth_tok->mount_crypt_stat_list,\n\t\t &mount_crypt_stat->global_auth_tok_list);\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_add_keysig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "2484-2500",
    "snippet": "int ecryptfs_add_keysig(struct ecryptfs_crypt_stat *crypt_stat, char *sig)\n{\n\tstruct ecryptfs_key_sig *new_key_sig;\n\n\tnew_key_sig = kmem_cache_alloc(ecryptfs_key_sig_cache, GFP_KERNEL);\n\tif (!new_key_sig) {\n\t\tprintk(KERN_ERR\n\t\t       \"Error allocating from ecryptfs_key_sig_cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(new_key_sig->keysig, sig, ECRYPTFS_SIG_SIZE_HEX);\n\tnew_key_sig->keysig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t/* Caller must hold keysig_list_mutex */\n\tlist_add(&new_key_sig->crypt_stat_list, &crypt_stat->keysig_list);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_key_sig_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_key_sig->crypt_stat_list",
            "&crypt_stat->keysig_list"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_key_sig->keysig",
            "sig",
            "ECRYPTFS_SIG_SIZE_HEX"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"Error allocating from ecryptfs_key_sig_cache\\n\""
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ecryptfs_key_sig_cache",
            "GFP_KERNEL"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_key_sig_cache;\n\nint ecryptfs_add_keysig(struct ecryptfs_crypt_stat *crypt_stat, char *sig)\n{\n\tstruct ecryptfs_key_sig *new_key_sig;\n\n\tnew_key_sig = kmem_cache_alloc(ecryptfs_key_sig_cache, GFP_KERNEL);\n\tif (!new_key_sig) {\n\t\tprintk(KERN_ERR\n\t\t       \"Error allocating from ecryptfs_key_sig_cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(new_key_sig->keysig, sig, ECRYPTFS_SIG_SIZE_HEX);\n\tnew_key_sig->keysig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t/* Caller must hold keysig_list_mutex */\n\tlist_add(&new_key_sig->crypt_stat_list, &crypt_stat->keysig_list);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ecryptfs_generate_key_packet_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "2389-2480",
    "snippet": "int\necryptfs_generate_key_packet_set(char *dest_base,\n\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t struct dentry *ecryptfs_dentry, size_t *len,\n\t\t\t\t size_t max)\n{\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tstruct key *auth_tok_key = NULL;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(\n\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\tsize_t written;\n\tstruct ecryptfs_key_record *key_rec;\n\tstruct ecryptfs_key_sig *key_sig;\n\tint rc = 0;\n\n\t(*len) = 0;\n\tmutex_lock(&crypt_stat->keysig_list_mutex);\n\tkey_rec = kmem_cache_alloc(ecryptfs_key_record_cache, GFP_KERNEL);\n\tif (!key_rec) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tlist_for_each_entry(key_sig, &crypt_stat->keysig_list,\n\t\t\t    crypt_stat_list) {\n\t\tmemset(key_rec, 0, sizeof(*key_rec));\n\t\trc = ecryptfs_find_global_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t\t\t   &auth_tok,\n\t\t\t\t\t\t\t   mount_crypt_stat,\n\t\t\t\t\t\t\t   key_sig->keysig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"Unable to retrieve auth tok with \"\n\t\t\t       \"sig = [%s]\\n\", key_sig->keysig);\n\t\t\trc = process_find_global_auth_tok_for_sig_err(rc);\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (auth_tok->token_type == ECRYPTFS_PASSWORD) {\n\t\t\trc = write_tag_3_packet((dest_base + (*len)),\n\t\t\t\t\t\t&max, auth_tok,\n\t\t\t\t\t\tcrypt_stat, key_rec,\n\t\t\t\t\t\t&written);\n\t\t\tup_write(&(auth_tok_key->sem));\n\t\t\tkey_put(auth_tok_key);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_WARNING, \"Error \"\n\t\t\t\t\t\t\"writing tag 3 packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t\t/* Write auth tok signature packet */\n\t\t\trc = write_tag_11_packet((dest_base + (*len)), &max,\n\t\t\t\t\t\t key_rec->sig,\n\t\t\t\t\t\t ECRYPTFS_SIG_SIZE, &written);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error writing \"\n\t\t\t\t\t\t\"auth tok signature packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t} else if (auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {\n\t\t\trc = write_tag_1_packet(dest_base + (*len), &max,\n\t\t\t\t\t\tauth_tok_key, auth_tok,\n\t\t\t\t\t\tcrypt_stat, key_rec, &written);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_WARNING, \"Error \"\n\t\t\t\t\t\t\"writing tag 1 packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t} else {\n\t\t\tup_write(&(auth_tok_key->sem));\n\t\t\tkey_put(auth_tok_key);\n\t\t\tecryptfs_printk(KERN_WARNING, \"Unsupported \"\n\t\t\t\t\t\"authentication token type\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\tif (likely(max > 0)) {\n\t\tdest_base[(*len)] = 0x00;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error writing boundary byte\\n\");\n\t\trc = -EIO;\n\t}\nout_free:\n\tkmem_cache_free(ecryptfs_key_record_cache, key_rec);\nout:\n\tif (rc)\n\t\t(*len) = 0;\n\tmutex_unlock(&crypt_stat->keysig_list_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_key_record_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&crypt_stat->keysig_list_mutex"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_key_record_cache",
            "key_rec"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Error writing boundary byte\\n\""
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "max > 0"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "auth_tok_key"
          ],
          "line": 2460
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&(auth_tok_key->sem)"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_tag_1_packet",
          "args": [
            "dest_base + (*len)",
            "&max",
            "auth_tok_key",
            "auth_tok",
            "crypt_stat",
            "key_rec",
            "&written"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "write_tag_1_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "2022-2102",
          "snippet": "static int\nwrite_tag_1_packet(char *dest, size_t *remaining_bytes,\n\t\t   struct key *auth_tok_key, struct ecryptfs_auth_tok *auth_tok,\n\t\t   struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   struct ecryptfs_key_record *key_rec, size_t *packet_size)\n{\n\tsize_t i;\n\tsize_t encrypted_session_key_valid = 0;\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\tecryptfs_from_hex(key_rec->sig, auth_tok->token.private_key.signature,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\tencrypted_session_key_valid = 0;\n\tfor (i = 0; i < crypt_stat->key_size; i++)\n\t\tencrypted_session_key_valid |=\n\t\t\tauth_tok->session_key.encrypted_key[i];\n\tif (encrypted_session_key_valid) {\n\t\tmemcpy(key_rec->enc_key,\n\t\t       auth_tok->session_key.encrypted_key,\n\t\t       auth_tok->session_key.encrypted_key_size);\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\tgoto encrypted_session_key_set;\n\t}\n\tif (auth_tok->session_key.encrypted_key_size == 0)\n\t\tauth_tok->session_key.encrypted_key_size =\n\t\t\tauth_tok->token.private_key.key_size;\n\trc = pki_encrypt_session_key(auth_tok_key, auth_tok, crypt_stat,\n\t\t\t\t     key_rec);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to encrypt session key via a key \"\n\t\t       \"module; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Encrypted key:\\n\");\n\t\tecryptfs_dump_hex(key_rec->enc_key, key_rec->enc_key_size);\n\t}\nencrypted_session_key_set:\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 1 */\n\tmax_packet_size = (1                         /* Tag 1 identifier */\n\t\t\t   + 3                       /* Max Tag 1 packet size */\n\t\t\t   + 1                       /* Version */\n\t\t\t   + ECRYPTFS_SIG_SIZE       /* Key identifier */\n\t\t\t   + 1                       /* Cipher identifier */\n\t\t\t   + key_rec->enc_key_size); /* Encrypted key size */\n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet length larger than maximum allowable; \"\n\t\t       \"need up to [%td] bytes, but there are only [%td] \"\n\t\t       \"available\\n\", max_packet_size, (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = ECRYPTFS_TAG_1_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[(*packet_size)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 1 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\t(*packet_size) += packet_size_length;\n\tdest[(*packet_size)++] = 0x03; /* version 3 */\n\tmemcpy(&dest[(*packet_size)], key_rec->sig, ECRYPTFS_SIG_SIZE);\n\t(*packet_size) += ECRYPTFS_SIG_SIZE;\n\tdest[(*packet_size)++] = RFC2440_CIPHER_RSA;\n\tmemcpy(&dest[(*packet_size)], key_rec->enc_key,\n\t       key_rec->enc_key_size);\n\t(*packet_size) += key_rec->enc_key_size;\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_size);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nwrite_tag_1_packet(char *dest, size_t *remaining_bytes,\n\t\t   struct key *auth_tok_key, struct ecryptfs_auth_tok *auth_tok,\n\t\t   struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   struct ecryptfs_key_record *key_rec, size_t *packet_size)\n{\n\tsize_t i;\n\tsize_t encrypted_session_key_valid = 0;\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\tecryptfs_from_hex(key_rec->sig, auth_tok->token.private_key.signature,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\tencrypted_session_key_valid = 0;\n\tfor (i = 0; i < crypt_stat->key_size; i++)\n\t\tencrypted_session_key_valid |=\n\t\t\tauth_tok->session_key.encrypted_key[i];\n\tif (encrypted_session_key_valid) {\n\t\tmemcpy(key_rec->enc_key,\n\t\t       auth_tok->session_key.encrypted_key,\n\t\t       auth_tok->session_key.encrypted_key_size);\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\tgoto encrypted_session_key_set;\n\t}\n\tif (auth_tok->session_key.encrypted_key_size == 0)\n\t\tauth_tok->session_key.encrypted_key_size =\n\t\t\tauth_tok->token.private_key.key_size;\n\trc = pki_encrypt_session_key(auth_tok_key, auth_tok, crypt_stat,\n\t\t\t\t     key_rec);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to encrypt session key via a key \"\n\t\t       \"module; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Encrypted key:\\n\");\n\t\tecryptfs_dump_hex(key_rec->enc_key, key_rec->enc_key_size);\n\t}\nencrypted_session_key_set:\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 1 */\n\tmax_packet_size = (1                         /* Tag 1 identifier */\n\t\t\t   + 3                       /* Max Tag 1 packet size */\n\t\t\t   + 1                       /* Version */\n\t\t\t   + ECRYPTFS_SIG_SIZE       /* Key identifier */\n\t\t\t   + 1                       /* Cipher identifier */\n\t\t\t   + key_rec->enc_key_size); /* Encrypted key size */\n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet length larger than maximum allowable; \"\n\t\t       \"need up to [%td] bytes, but there are only [%td] \"\n\t\t       \"available\\n\", max_packet_size, (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = ECRYPTFS_TAG_1_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[(*packet_size)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 1 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\t(*packet_size) += packet_size_length;\n\tdest[(*packet_size)++] = 0x03; /* version 3 */\n\tmemcpy(&dest[(*packet_size)], key_rec->sig, ECRYPTFS_SIG_SIZE);\n\t(*packet_size) += ECRYPTFS_SIG_SIZE;\n\tdest[(*packet_size)++] = RFC2440_CIPHER_RSA;\n\tmemcpy(&dest[(*packet_size)], key_rec->enc_key,\n\t       key_rec->enc_key_size);\n\t(*packet_size) += key_rec->enc_key_size;\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_size);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_tag_11_packet",
          "args": [
            "(dest_base + (*len))",
            "&max",
            "key_rec->sig",
            "ECRYPTFS_SIG_SIZE",
            "&written"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "write_tag_11_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "2114-2163",
          "snippet": "static int\nwrite_tag_11_packet(char *dest, size_t *remaining_bytes, char *contents,\n\t\t    size_t contents_length, size_t *packet_length)\n{\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tint rc = 0;\n\n\t(*packet_length) = 0;\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 11 */\n\tmax_packet_size = (1                   /* Tag 11 identifier */\n\t\t\t   + 3                 /* Max Tag 11 packet size */\n\t\t\t   + 1                 /* Binary format specifier */\n\t\t\t   + 1                 /* Filename length */\n\t\t\t   + 8                 /* Filename (\"_CONSOLE\") */\n\t\t\t   + 4                 /* Modification date */\n\t\t\t   + contents_length); /* Literal data */\n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet length larger than maximum allowable; \"\n\t\t       \"need up to [%td] bytes, but there are only [%td] \"\n\t\t       \"available\\n\", max_packet_size, (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_length)++] = ECRYPTFS_TAG_11_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[(*packet_length)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error generating tag 11 packet header; cannot \"\n\t\t       \"generate packet length. rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\t(*packet_length) += packet_size_length;\n\tdest[(*packet_length)++] = 0x62; /* binary data format specifier */\n\tdest[(*packet_length)++] = 8;\n\tmemcpy(&dest[(*packet_length)], \"_CONSOLE\", 8);\n\t(*packet_length) += 8;\n\tmemset(&dest[(*packet_length)], 0x00, 4);\n\t(*packet_length) += 4;\n\tmemcpy(&dest[(*packet_length)], contents, contents_length);\n\t(*packet_length) += contents_length;\n out:\n\tif (rc)\n\t\t(*packet_length) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_length);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nwrite_tag_11_packet(char *dest, size_t *remaining_bytes, char *contents,\n\t\t    size_t contents_length, size_t *packet_length)\n{\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tint rc = 0;\n\n\t(*packet_length) = 0;\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 11 */\n\tmax_packet_size = (1                   /* Tag 11 identifier */\n\t\t\t   + 3                 /* Max Tag 11 packet size */\n\t\t\t   + 1                 /* Binary format specifier */\n\t\t\t   + 1                 /* Filename length */\n\t\t\t   + 8                 /* Filename (\"_CONSOLE\") */\n\t\t\t   + 4                 /* Modification date */\n\t\t\t   + contents_length); /* Literal data */\n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet length larger than maximum allowable; \"\n\t\t       \"need up to [%td] bytes, but there are only [%td] \"\n\t\t       \"available\\n\", max_packet_size, (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_length)++] = ECRYPTFS_TAG_11_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[(*packet_length)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error generating tag 11 packet header; cannot \"\n\t\t       \"generate packet length. rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\t(*packet_length) += packet_size_length;\n\tdest[(*packet_length)++] = 0x62; /* binary data format specifier */\n\tdest[(*packet_length)++] = 8;\n\tmemcpy(&dest[(*packet_length)], \"_CONSOLE\", 8);\n\t(*packet_length) += 8;\n\tmemset(&dest[(*packet_length)], 0x00, 4);\n\t(*packet_length) += 4;\n\tmemcpy(&dest[(*packet_length)], contents, contents_length);\n\t(*packet_length) += contents_length;\n out:\n\tif (rc)\n\t\t(*packet_length) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_length);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&(auth_tok_key->sem)"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_tag_3_packet",
          "args": [
            "(dest_base + (*len))",
            "&max",
            "auth_tok",
            "crypt_stat",
            "key_rec",
            "&written"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "write_tag_3_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "2177-2370",
          "snippet": "static int\nwrite_tag_3_packet(char *dest, size_t *remaining_bytes,\n\t\t   struct ecryptfs_auth_tok *auth_tok,\n\t\t   struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   struct ecryptfs_key_record *key_rec, size_t *packet_size)\n{\n\tsize_t i;\n\tsize_t encrypted_session_key_valid = 0;\n\tchar session_key_encryption_key[ECRYPTFS_MAX_KEY_BYTES];\n\tstruct scatterlist dst_sg[2];\n\tstruct scatterlist src_sg[2];\n\tstruct mutex *tfm_mutex = NULL;\n\tu8 cipher_code;\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\tcrypt_stat->mount_crypt_stat;\n\tstruct blkcipher_desc desc = {\n\t\t.tfm = NULL,\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\tecryptfs_from_hex(key_rec->sig, auth_tok->token.password.signature,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\n\t\t\t\t\t\t\tcrypt_stat->cipher);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       crypt_stat->cipher, rc);\n\t\tgoto out;\n\t}\n\tif (mount_crypt_stat->global_default_cipher_key_size == 0) {\n\t\tstruct blkcipher_alg *alg = crypto_blkcipher_alg(desc.tfm);\n\n\t\tprintk(KERN_WARNING \"No key size specified at mount; \"\n\t\t       \"defaulting to [%d]\\n\", alg->max_keysize);\n\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\talg->max_keysize;\n\t}\n\tif (crypt_stat->key_size == 0)\n\t\tcrypt_stat->key_size =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tif (auth_tok->session_key.encrypted_key_size == 0)\n\t\tauth_tok->session_key.encrypted_key_size =\n\t\t\tcrypt_stat->key_size;\n\tif (crypt_stat->key_size == 24\n\t    && strcmp(\"aes\", crypt_stat->cipher) == 0) {\n\t\tmemset((crypt_stat->key + 24), 0, 8);\n\t\tauth_tok->session_key.encrypted_key_size = 32;\n\t} else\n\t\tauth_tok->session_key.encrypted_key_size = crypt_stat->key_size;\n\tkey_rec->enc_key_size =\n\t\tauth_tok->session_key.encrypted_key_size;\n\tencrypted_session_key_valid = 0;\n\tfor (i = 0; i < auth_tok->session_key.encrypted_key_size; i++)\n\t\tencrypted_session_key_valid |=\n\t\t\tauth_tok->session_key.encrypted_key[i];\n\tif (encrypted_session_key_valid) {\n\t\tecryptfs_printk(KERN_DEBUG, \"encrypted_session_key_valid != 0; \"\n\t\t\t\t\"using auth_tok->session_key.encrypted_key, \"\n\t\t\t\t\"where key_rec->enc_key_size = [%zd]\\n\",\n\t\t\t\tkey_rec->enc_key_size);\n\t\tmemcpy(key_rec->enc_key,\n\t\t       auth_tok->session_key.encrypted_key,\n\t\t       key_rec->enc_key_size);\n\t\tgoto encrypted_session_key_set;\n\t}\n\tif (auth_tok->token.password.flags &\n\t    ECRYPTFS_SESSION_KEY_ENCRYPTION_KEY_SET) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Using previously generated \"\n\t\t\t\t\"session key encryption key of size [%d]\\n\",\n\t\t\t\tauth_tok->token.password.\n\t\t\t\tsession_key_encryption_key_bytes);\n\t\tmemcpy(session_key_encryption_key,\n\t\t       auth_tok->token.password.session_key_encryption_key,\n\t\t       crypt_stat->key_size);\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\"Cached session key encryption key:\\n\");\n\t\tif (ecryptfs_verbosity > 0)\n\t\t\tecryptfs_dump_hex(session_key_encryption_key, 16);\n\t}\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Session key encryption key:\\n\");\n\t\tecryptfs_dump_hex(session_key_encryption_key, 16);\n\t}\n\trc = virt_to_scatterlist(crypt_stat->key, key_rec->enc_key_size,\n\t\t\t\t src_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating scatterlist \"\n\t\t\t\t\"for crypt_stat session key; expected rc = 1; \"\n\t\t\t\t\"got rc = [%d]. key_rec->enc_key_size = [%zd]\\n\",\n\t\t\t\trc, key_rec->enc_key_size);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = virt_to_scatterlist(key_rec->enc_key, key_rec->enc_key_size,\n\t\t\t\t dst_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating scatterlist \"\n\t\t\t\t\"for crypt_stat encrypted session key; \"\n\t\t\t\t\"expected rc = 1; got rc = [%d]. \"\n\t\t\t\t\"key_rec->enc_key_size = [%zd]\\n\", rc,\n\t\t\t\tkey_rec->enc_key_size);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(tfm_mutex);\n\trc = crypto_blkcipher_setkey(desc.tfm, session_key_encryption_key,\n\t\t\t\t     crypt_stat->key_size);\n\tif (rc < 0) {\n\t\tmutex_unlock(tfm_mutex);\n\t\tecryptfs_printk(KERN_ERR, \"Error setting key for crypto \"\n\t\t\t\t\"context; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = 0;\n\tecryptfs_printk(KERN_DEBUG, \"Encrypting [%zd] bytes of the key\\n\",\n\t\t\tcrypt_stat->key_size);\n\trc = crypto_blkcipher_encrypt(&desc, dst_sg, src_sg,\n\t\t\t\t      (*key_rec).enc_key_size);\n\tmutex_unlock(tfm_mutex);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error encrypting; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tecryptfs_printk(KERN_DEBUG, \"This should be the encrypted key:\\n\");\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"EFEK of size [%zd]:\\n\",\n\t\t\t\tkey_rec->enc_key_size);\n\t\tecryptfs_dump_hex(key_rec->enc_key,\n\t\t\t\t  key_rec->enc_key_size);\n\t}\nencrypted_session_key_set:\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 3 */\n\tmax_packet_size = (1                         /* Tag 3 identifier */\n\t\t\t   + 3                       /* Max Tag 3 packet size */\n\t\t\t   + 1                       /* Version */\n\t\t\t   + 1                       /* Cipher code */\n\t\t\t   + 1                       /* S2K specifier */\n\t\t\t   + 1                       /* Hash identifier */\n\t\t\t   + ECRYPTFS_SALT_SIZE      /* Salt */\n\t\t\t   + 1                       /* Hash iterations */\n\t\t\t   + key_rec->enc_key_size); /* Encrypted key size */\n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet too large; need up to [%td] bytes, but \"\n\t\t       \"there are only [%td] available\\n\", max_packet_size,\n\t\t       (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = ECRYPTFS_TAG_3_PACKET_TYPE;\n\t/* Chop off the Tag 3 identifier(1) and Tag 3 packet size(3)\n\t * to get the number of octets in the actual Tag 3 packet */\n\trc = ecryptfs_write_packet_length(&dest[(*packet_size)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error generating tag 3 packet header; cannot \"\n\t\t       \"generate packet length. rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\t(*packet_size) += packet_size_length;\n\tdest[(*packet_size)++] = 0x04; /* version 4 */\n\t/* TODO: Break from RFC2440 so that arbitrary ciphers can be\n\t * specified with strings */\n\tcipher_code = ecryptfs_code_for_cipher_string(crypt_stat->cipher,\n\t\t\t\t\t\t      crypt_stat->key_size);\n\tif (cipher_code == 0) {\n\t\tecryptfs_printk(KERN_WARNING, \"Unable to generate code for \"\n\t\t\t\t\"cipher [%s]\\n\", crypt_stat->cipher);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = cipher_code;\n\tdest[(*packet_size)++] = 0x03;\t/* S2K */\n\tdest[(*packet_size)++] = 0x01;\t/* MD5 (TODO: parameterize) */\n\tmemcpy(&dest[(*packet_size)], auth_tok->token.password.salt,\n\t       ECRYPTFS_SALT_SIZE);\n\t(*packet_size) += ECRYPTFS_SALT_SIZE;\t/* salt */\n\tdest[(*packet_size)++] = 0x60;\t/* hash iterations (65536) */\n\tmemcpy(&dest[(*packet_size)], key_rec->enc_key,\n\t       key_rec->enc_key_size);\n\t(*packet_size) += key_rec->enc_key_size;\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_size);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nwrite_tag_3_packet(char *dest, size_t *remaining_bytes,\n\t\t   struct ecryptfs_auth_tok *auth_tok,\n\t\t   struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   struct ecryptfs_key_record *key_rec, size_t *packet_size)\n{\n\tsize_t i;\n\tsize_t encrypted_session_key_valid = 0;\n\tchar session_key_encryption_key[ECRYPTFS_MAX_KEY_BYTES];\n\tstruct scatterlist dst_sg[2];\n\tstruct scatterlist src_sg[2];\n\tstruct mutex *tfm_mutex = NULL;\n\tu8 cipher_code;\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\tcrypt_stat->mount_crypt_stat;\n\tstruct blkcipher_desc desc = {\n\t\t.tfm = NULL,\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\tecryptfs_from_hex(key_rec->sig, auth_tok->token.password.signature,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\n\t\t\t\t\t\t\tcrypt_stat->cipher);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       crypt_stat->cipher, rc);\n\t\tgoto out;\n\t}\n\tif (mount_crypt_stat->global_default_cipher_key_size == 0) {\n\t\tstruct blkcipher_alg *alg = crypto_blkcipher_alg(desc.tfm);\n\n\t\tprintk(KERN_WARNING \"No key size specified at mount; \"\n\t\t       \"defaulting to [%d]\\n\", alg->max_keysize);\n\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\talg->max_keysize;\n\t}\n\tif (crypt_stat->key_size == 0)\n\t\tcrypt_stat->key_size =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tif (auth_tok->session_key.encrypted_key_size == 0)\n\t\tauth_tok->session_key.encrypted_key_size =\n\t\t\tcrypt_stat->key_size;\n\tif (crypt_stat->key_size == 24\n\t    && strcmp(\"aes\", crypt_stat->cipher) == 0) {\n\t\tmemset((crypt_stat->key + 24), 0, 8);\n\t\tauth_tok->session_key.encrypted_key_size = 32;\n\t} else\n\t\tauth_tok->session_key.encrypted_key_size = crypt_stat->key_size;\n\tkey_rec->enc_key_size =\n\t\tauth_tok->session_key.encrypted_key_size;\n\tencrypted_session_key_valid = 0;\n\tfor (i = 0; i < auth_tok->session_key.encrypted_key_size; i++)\n\t\tencrypted_session_key_valid |=\n\t\t\tauth_tok->session_key.encrypted_key[i];\n\tif (encrypted_session_key_valid) {\n\t\tecryptfs_printk(KERN_DEBUG, \"encrypted_session_key_valid != 0; \"\n\t\t\t\t\"using auth_tok->session_key.encrypted_key, \"\n\t\t\t\t\"where key_rec->enc_key_size = [%zd]\\n\",\n\t\t\t\tkey_rec->enc_key_size);\n\t\tmemcpy(key_rec->enc_key,\n\t\t       auth_tok->session_key.encrypted_key,\n\t\t       key_rec->enc_key_size);\n\t\tgoto encrypted_session_key_set;\n\t}\n\tif (auth_tok->token.password.flags &\n\t    ECRYPTFS_SESSION_KEY_ENCRYPTION_KEY_SET) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Using previously generated \"\n\t\t\t\t\"session key encryption key of size [%d]\\n\",\n\t\t\t\tauth_tok->token.password.\n\t\t\t\tsession_key_encryption_key_bytes);\n\t\tmemcpy(session_key_encryption_key,\n\t\t       auth_tok->token.password.session_key_encryption_key,\n\t\t       crypt_stat->key_size);\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\"Cached session key encryption key:\\n\");\n\t\tif (ecryptfs_verbosity > 0)\n\t\t\tecryptfs_dump_hex(session_key_encryption_key, 16);\n\t}\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Session key encryption key:\\n\");\n\t\tecryptfs_dump_hex(session_key_encryption_key, 16);\n\t}\n\trc = virt_to_scatterlist(crypt_stat->key, key_rec->enc_key_size,\n\t\t\t\t src_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating scatterlist \"\n\t\t\t\t\"for crypt_stat session key; expected rc = 1; \"\n\t\t\t\t\"got rc = [%d]. key_rec->enc_key_size = [%zd]\\n\",\n\t\t\t\trc, key_rec->enc_key_size);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = virt_to_scatterlist(key_rec->enc_key, key_rec->enc_key_size,\n\t\t\t\t dst_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating scatterlist \"\n\t\t\t\t\"for crypt_stat encrypted session key; \"\n\t\t\t\t\"expected rc = 1; got rc = [%d]. \"\n\t\t\t\t\"key_rec->enc_key_size = [%zd]\\n\", rc,\n\t\t\t\tkey_rec->enc_key_size);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(tfm_mutex);\n\trc = crypto_blkcipher_setkey(desc.tfm, session_key_encryption_key,\n\t\t\t\t     crypt_stat->key_size);\n\tif (rc < 0) {\n\t\tmutex_unlock(tfm_mutex);\n\t\tecryptfs_printk(KERN_ERR, \"Error setting key for crypto \"\n\t\t\t\t\"context; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = 0;\n\tecryptfs_printk(KERN_DEBUG, \"Encrypting [%zd] bytes of the key\\n\",\n\t\t\tcrypt_stat->key_size);\n\trc = crypto_blkcipher_encrypt(&desc, dst_sg, src_sg,\n\t\t\t\t      (*key_rec).enc_key_size);\n\tmutex_unlock(tfm_mutex);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error encrypting; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tecryptfs_printk(KERN_DEBUG, \"This should be the encrypted key:\\n\");\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"EFEK of size [%zd]:\\n\",\n\t\t\t\tkey_rec->enc_key_size);\n\t\tecryptfs_dump_hex(key_rec->enc_key,\n\t\t\t\t  key_rec->enc_key_size);\n\t}\nencrypted_session_key_set:\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 3 */\n\tmax_packet_size = (1                         /* Tag 3 identifier */\n\t\t\t   + 3                       /* Max Tag 3 packet size */\n\t\t\t   + 1                       /* Version */\n\t\t\t   + 1                       /* Cipher code */\n\t\t\t   + 1                       /* S2K specifier */\n\t\t\t   + 1                       /* Hash identifier */\n\t\t\t   + ECRYPTFS_SALT_SIZE      /* Salt */\n\t\t\t   + 1                       /* Hash iterations */\n\t\t\t   + key_rec->enc_key_size); /* Encrypted key size */\n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet too large; need up to [%td] bytes, but \"\n\t\t       \"there are only [%td] available\\n\", max_packet_size,\n\t\t       (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = ECRYPTFS_TAG_3_PACKET_TYPE;\n\t/* Chop off the Tag 3 identifier(1) and Tag 3 packet size(3)\n\t * to get the number of octets in the actual Tag 3 packet */\n\trc = ecryptfs_write_packet_length(&dest[(*packet_size)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error generating tag 3 packet header; cannot \"\n\t\t       \"generate packet length. rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\t(*packet_size) += packet_size_length;\n\tdest[(*packet_size)++] = 0x04; /* version 4 */\n\t/* TODO: Break from RFC2440 so that arbitrary ciphers can be\n\t * specified with strings */\n\tcipher_code = ecryptfs_code_for_cipher_string(crypt_stat->cipher,\n\t\t\t\t\t\t      crypt_stat->key_size);\n\tif (cipher_code == 0) {\n\t\tecryptfs_printk(KERN_WARNING, \"Unable to generate code for \"\n\t\t\t\t\"cipher [%s]\\n\", crypt_stat->cipher);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = cipher_code;\n\tdest[(*packet_size)++] = 0x03;\t/* S2K */\n\tdest[(*packet_size)++] = 0x01;\t/* MD5 (TODO: parameterize) */\n\tmemcpy(&dest[(*packet_size)], auth_tok->token.password.salt,\n\t       ECRYPTFS_SALT_SIZE);\n\t(*packet_size) += ECRYPTFS_SALT_SIZE;\t/* salt */\n\tdest[(*packet_size)++] = 0x60;\t/* hash iterations (65536) */\n\tmemcpy(&dest[(*packet_size)], key_rec->enc_key,\n\t       key_rec->enc_key_size);\n\t(*packet_size) += key_rec->enc_key_size;\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_size);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_find_global_auth_tok_for_sig_err",
          "args": [
            "rc"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "process_find_global_auth_tok_for_sig_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "67-83",
          "snippet": "static int process_find_global_auth_tok_for_sig_err(int err_code)\n{\n\tint rc = err_code;\n\n\tswitch (err_code) {\n\tcase -ENOENT:\n\t\tecryptfs_printk(KERN_WARNING, \"Missing auth tok\\n\");\n\t\tbreak;\n\tcase -EINVAL:\n\t\tecryptfs_printk(KERN_WARNING, \"Invalid auth tok\\n\");\n\t\tbreak;\n\tdefault:\n\t\trc = process_request_key_err(err_code);\n\t\tbreak;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int process_find_global_auth_tok_for_sig_err(int err_code)\n{\n\tint rc = err_code;\n\n\tswitch (err_code) {\n\tcase -ENOENT:\n\t\tecryptfs_printk(KERN_WARNING, \"Missing auth tok\\n\");\n\t\tbreak;\n\tcase -EINVAL:\n\t\tecryptfs_printk(KERN_WARNING, \"Invalid auth tok\\n\");\n\t\tbreak;\n\tdefault:\n\t\trc = process_request_key_err(err_code);\n\t\tbreak;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_find_global_auth_tok_for_sig",
          "args": [
            "&auth_tok_key",
            "&auth_tok",
            "mount_crypt_stat",
            "key_sig->keysig"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_find_global_auth_tok_for_sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "489-541",
          "snippet": "static int\necryptfs_find_global_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat, char *sig)\n{\n\tstruct ecryptfs_global_auth_tok *walker;\n\tint rc = 0;\n\n\t(*auth_tok_key) = NULL;\n\t(*auth_tok) = NULL;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry(walker,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\tif (memcmp(walker->sig, sig, ECRYPTFS_SIG_SIZE_HEX))\n\t\t\tcontinue;\n\n\t\tif (walker->flags & ECRYPTFS_AUTH_TOK_INVALID) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = key_validate(walker->global_auth_tok_key);\n\t\tif (rc) {\n\t\t\tif (rc == -EKEYEXPIRED)\n\t\t\t\tgoto out;\n\t\t\tgoto out_invalid_auth_tok;\n\t\t}\n\n\t\tdown_write(&(walker->global_auth_tok_key->sem));\n\t\trc = ecryptfs_verify_auth_tok_from_key(\n\t\t\t\twalker->global_auth_tok_key, auth_tok);\n\t\tif (rc)\n\t\t\tgoto out_invalid_auth_tok_unlock;\n\n\t\t(*auth_tok_key) = walker->global_auth_tok_key;\n\t\tkey_get(*auth_tok_key);\n\t\tgoto out;\n\t}\n\trc = -ENOENT;\n\tgoto out;\nout_invalid_auth_tok_unlock:\n\tup_write(&(walker->global_auth_tok_key->sem));\nout_invalid_auth_tok:\n\tprintk(KERN_WARNING \"Invalidating auth tok with sig = [%s]\\n\", sig);\n\twalker->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\tkey_put(walker->global_auth_tok_key);\n\twalker->global_auth_tok_key = NULL;\nout:\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_find_global_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat, char *sig)\n{\n\tstruct ecryptfs_global_auth_tok *walker;\n\tint rc = 0;\n\n\t(*auth_tok_key) = NULL;\n\t(*auth_tok) = NULL;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry(walker,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\tif (memcmp(walker->sig, sig, ECRYPTFS_SIG_SIZE_HEX))\n\t\t\tcontinue;\n\n\t\tif (walker->flags & ECRYPTFS_AUTH_TOK_INVALID) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = key_validate(walker->global_auth_tok_key);\n\t\tif (rc) {\n\t\t\tif (rc == -EKEYEXPIRED)\n\t\t\t\tgoto out;\n\t\t\tgoto out_invalid_auth_tok;\n\t\t}\n\n\t\tdown_write(&(walker->global_auth_tok_key->sem));\n\t\trc = ecryptfs_verify_auth_tok_from_key(\n\t\t\t\twalker->global_auth_tok_key, auth_tok);\n\t\tif (rc)\n\t\t\tgoto out_invalid_auth_tok_unlock;\n\n\t\t(*auth_tok_key) = walker->global_auth_tok_key;\n\t\tkey_get(*auth_tok_key);\n\t\tgoto out;\n\t}\n\trc = -ENOENT;\n\tgoto out;\nout_invalid_auth_tok_unlock:\n\tup_write(&(walker->global_auth_tok_key->sem));\nout_invalid_auth_tok:\n\tprintk(KERN_WARNING \"Invalidating auth tok with sig = [%s]\\n\", sig);\n\twalker->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\tkey_put(walker->global_auth_tok_key);\n\twalker->global_auth_tok_key = NULL;\nout:\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "key_rec",
            "0",
            "sizeof(*key_rec)"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "key_sig",
            "&crypt_stat->keysig_list",
            "crypt_stat_list"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "ecryptfs_key_record_cache",
            "GFP_KERNEL"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&crypt_stat->keysig_list_mutex"
          ],
          "line": 2406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_superblock_to_private",
          "args": [
            "ecryptfs_dentry->d_sb"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_superblock_to_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "473-477",
          "snippet": "static inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_sb_info *\necryptfs_superblock_to_private(struct super_block *sb)\n{\n\treturn (struct ecryptfs_sb_info *)sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_key_record_cache;\n\nint\necryptfs_generate_key_packet_set(char *dest_base,\n\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t struct dentry *ecryptfs_dentry, size_t *len,\n\t\t\t\t size_t max)\n{\n\tstruct ecryptfs_auth_tok *auth_tok;\n\tstruct key *auth_tok_key = NULL;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\t&ecryptfs_superblock_to_private(\n\t\t\tecryptfs_dentry->d_sb)->mount_crypt_stat;\n\tsize_t written;\n\tstruct ecryptfs_key_record *key_rec;\n\tstruct ecryptfs_key_sig *key_sig;\n\tint rc = 0;\n\n\t(*len) = 0;\n\tmutex_lock(&crypt_stat->keysig_list_mutex);\n\tkey_rec = kmem_cache_alloc(ecryptfs_key_record_cache, GFP_KERNEL);\n\tif (!key_rec) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tlist_for_each_entry(key_sig, &crypt_stat->keysig_list,\n\t\t\t    crypt_stat_list) {\n\t\tmemset(key_rec, 0, sizeof(*key_rec));\n\t\trc = ecryptfs_find_global_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t\t\t   &auth_tok,\n\t\t\t\t\t\t\t   mount_crypt_stat,\n\t\t\t\t\t\t\t   key_sig->keysig);\n\t\tif (rc) {\n\t\t\tprintk(KERN_WARNING \"Unable to retrieve auth tok with \"\n\t\t\t       \"sig = [%s]\\n\", key_sig->keysig);\n\t\t\trc = process_find_global_auth_tok_for_sig_err(rc);\n\t\t\tgoto out_free;\n\t\t}\n\t\tif (auth_tok->token_type == ECRYPTFS_PASSWORD) {\n\t\t\trc = write_tag_3_packet((dest_base + (*len)),\n\t\t\t\t\t\t&max, auth_tok,\n\t\t\t\t\t\tcrypt_stat, key_rec,\n\t\t\t\t\t\t&written);\n\t\t\tup_write(&(auth_tok_key->sem));\n\t\t\tkey_put(auth_tok_key);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_WARNING, \"Error \"\n\t\t\t\t\t\t\"writing tag 3 packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t\t/* Write auth tok signature packet */\n\t\t\trc = write_tag_11_packet((dest_base + (*len)), &max,\n\t\t\t\t\t\t key_rec->sig,\n\t\t\t\t\t\t ECRYPTFS_SIG_SIZE, &written);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error writing \"\n\t\t\t\t\t\t\"auth tok signature packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t} else if (auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {\n\t\t\trc = write_tag_1_packet(dest_base + (*len), &max,\n\t\t\t\t\t\tauth_tok_key, auth_tok,\n\t\t\t\t\t\tcrypt_stat, key_rec, &written);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_WARNING, \"Error \"\n\t\t\t\t\t\t\"writing tag 1 packet\\n\");\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t\t(*len) += written;\n\t\t} else {\n\t\t\tup_write(&(auth_tok_key->sem));\n\t\t\tkey_put(auth_tok_key);\n\t\t\tecryptfs_printk(KERN_WARNING, \"Unsupported \"\n\t\t\t\t\t\"authentication token type\\n\");\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\tif (likely(max > 0)) {\n\t\tdest_base[(*len)] = 0x00;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error writing boundary byte\\n\");\n\t\trc = -EIO;\n\t}\nout_free:\n\tkmem_cache_free(ecryptfs_key_record_cache, key_rec);\nout:\n\tif (rc)\n\t\t(*len) = 0;\n\tmutex_unlock(&crypt_stat->keysig_list_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "write_tag_3_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "2177-2370",
    "snippet": "static int\nwrite_tag_3_packet(char *dest, size_t *remaining_bytes,\n\t\t   struct ecryptfs_auth_tok *auth_tok,\n\t\t   struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   struct ecryptfs_key_record *key_rec, size_t *packet_size)\n{\n\tsize_t i;\n\tsize_t encrypted_session_key_valid = 0;\n\tchar session_key_encryption_key[ECRYPTFS_MAX_KEY_BYTES];\n\tstruct scatterlist dst_sg[2];\n\tstruct scatterlist src_sg[2];\n\tstruct mutex *tfm_mutex = NULL;\n\tu8 cipher_code;\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\tcrypt_stat->mount_crypt_stat;\n\tstruct blkcipher_desc desc = {\n\t\t.tfm = NULL,\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\tecryptfs_from_hex(key_rec->sig, auth_tok->token.password.signature,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\n\t\t\t\t\t\t\tcrypt_stat->cipher);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       crypt_stat->cipher, rc);\n\t\tgoto out;\n\t}\n\tif (mount_crypt_stat->global_default_cipher_key_size == 0) {\n\t\tstruct blkcipher_alg *alg = crypto_blkcipher_alg(desc.tfm);\n\n\t\tprintk(KERN_WARNING \"No key size specified at mount; \"\n\t\t       \"defaulting to [%d]\\n\", alg->max_keysize);\n\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\talg->max_keysize;\n\t}\n\tif (crypt_stat->key_size == 0)\n\t\tcrypt_stat->key_size =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tif (auth_tok->session_key.encrypted_key_size == 0)\n\t\tauth_tok->session_key.encrypted_key_size =\n\t\t\tcrypt_stat->key_size;\n\tif (crypt_stat->key_size == 24\n\t    && strcmp(\"aes\", crypt_stat->cipher) == 0) {\n\t\tmemset((crypt_stat->key + 24), 0, 8);\n\t\tauth_tok->session_key.encrypted_key_size = 32;\n\t} else\n\t\tauth_tok->session_key.encrypted_key_size = crypt_stat->key_size;\n\tkey_rec->enc_key_size =\n\t\tauth_tok->session_key.encrypted_key_size;\n\tencrypted_session_key_valid = 0;\n\tfor (i = 0; i < auth_tok->session_key.encrypted_key_size; i++)\n\t\tencrypted_session_key_valid |=\n\t\t\tauth_tok->session_key.encrypted_key[i];\n\tif (encrypted_session_key_valid) {\n\t\tecryptfs_printk(KERN_DEBUG, \"encrypted_session_key_valid != 0; \"\n\t\t\t\t\"using auth_tok->session_key.encrypted_key, \"\n\t\t\t\t\"where key_rec->enc_key_size = [%zd]\\n\",\n\t\t\t\tkey_rec->enc_key_size);\n\t\tmemcpy(key_rec->enc_key,\n\t\t       auth_tok->session_key.encrypted_key,\n\t\t       key_rec->enc_key_size);\n\t\tgoto encrypted_session_key_set;\n\t}\n\tif (auth_tok->token.password.flags &\n\t    ECRYPTFS_SESSION_KEY_ENCRYPTION_KEY_SET) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Using previously generated \"\n\t\t\t\t\"session key encryption key of size [%d]\\n\",\n\t\t\t\tauth_tok->token.password.\n\t\t\t\tsession_key_encryption_key_bytes);\n\t\tmemcpy(session_key_encryption_key,\n\t\t       auth_tok->token.password.session_key_encryption_key,\n\t\t       crypt_stat->key_size);\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\"Cached session key encryption key:\\n\");\n\t\tif (ecryptfs_verbosity > 0)\n\t\t\tecryptfs_dump_hex(session_key_encryption_key, 16);\n\t}\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Session key encryption key:\\n\");\n\t\tecryptfs_dump_hex(session_key_encryption_key, 16);\n\t}\n\trc = virt_to_scatterlist(crypt_stat->key, key_rec->enc_key_size,\n\t\t\t\t src_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating scatterlist \"\n\t\t\t\t\"for crypt_stat session key; expected rc = 1; \"\n\t\t\t\t\"got rc = [%d]. key_rec->enc_key_size = [%zd]\\n\",\n\t\t\t\trc, key_rec->enc_key_size);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = virt_to_scatterlist(key_rec->enc_key, key_rec->enc_key_size,\n\t\t\t\t dst_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating scatterlist \"\n\t\t\t\t\"for crypt_stat encrypted session key; \"\n\t\t\t\t\"expected rc = 1; got rc = [%d]. \"\n\t\t\t\t\"key_rec->enc_key_size = [%zd]\\n\", rc,\n\t\t\t\tkey_rec->enc_key_size);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(tfm_mutex);\n\trc = crypto_blkcipher_setkey(desc.tfm, session_key_encryption_key,\n\t\t\t\t     crypt_stat->key_size);\n\tif (rc < 0) {\n\t\tmutex_unlock(tfm_mutex);\n\t\tecryptfs_printk(KERN_ERR, \"Error setting key for crypto \"\n\t\t\t\t\"context; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = 0;\n\tecryptfs_printk(KERN_DEBUG, \"Encrypting [%zd] bytes of the key\\n\",\n\t\t\tcrypt_stat->key_size);\n\trc = crypto_blkcipher_encrypt(&desc, dst_sg, src_sg,\n\t\t\t\t      (*key_rec).enc_key_size);\n\tmutex_unlock(tfm_mutex);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error encrypting; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tecryptfs_printk(KERN_DEBUG, \"This should be the encrypted key:\\n\");\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"EFEK of size [%zd]:\\n\",\n\t\t\t\tkey_rec->enc_key_size);\n\t\tecryptfs_dump_hex(key_rec->enc_key,\n\t\t\t\t  key_rec->enc_key_size);\n\t}\nencrypted_session_key_set:\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 3 */\n\tmax_packet_size = (1                         /* Tag 3 identifier */\n\t\t\t   + 3                       /* Max Tag 3 packet size */\n\t\t\t   + 1                       /* Version */\n\t\t\t   + 1                       /* Cipher code */\n\t\t\t   + 1                       /* S2K specifier */\n\t\t\t   + 1                       /* Hash identifier */\n\t\t\t   + ECRYPTFS_SALT_SIZE      /* Salt */\n\t\t\t   + 1                       /* Hash iterations */\n\t\t\t   + key_rec->enc_key_size); /* Encrypted key size */\n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet too large; need up to [%td] bytes, but \"\n\t\t       \"there are only [%td] available\\n\", max_packet_size,\n\t\t       (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = ECRYPTFS_TAG_3_PACKET_TYPE;\n\t/* Chop off the Tag 3 identifier(1) and Tag 3 packet size(3)\n\t * to get the number of octets in the actual Tag 3 packet */\n\trc = ecryptfs_write_packet_length(&dest[(*packet_size)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error generating tag 3 packet header; cannot \"\n\t\t       \"generate packet length. rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\t(*packet_size) += packet_size_length;\n\tdest[(*packet_size)++] = 0x04; /* version 4 */\n\t/* TODO: Break from RFC2440 so that arbitrary ciphers can be\n\t * specified with strings */\n\tcipher_code = ecryptfs_code_for_cipher_string(crypt_stat->cipher,\n\t\t\t\t\t\t      crypt_stat->key_size);\n\tif (cipher_code == 0) {\n\t\tecryptfs_printk(KERN_WARNING, \"Unable to generate code for \"\n\t\t\t\t\"cipher [%s]\\n\", crypt_stat->cipher);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = cipher_code;\n\tdest[(*packet_size)++] = 0x03;\t/* S2K */\n\tdest[(*packet_size)++] = 0x01;\t/* MD5 (TODO: parameterize) */\n\tmemcpy(&dest[(*packet_size)], auth_tok->token.password.salt,\n\t       ECRYPTFS_SALT_SIZE);\n\t(*packet_size) += ECRYPTFS_SALT_SIZE;\t/* salt */\n\tdest[(*packet_size)++] = 0x60;\t/* hash iterations (65536) */\n\tmemcpy(&dest[(*packet_size)], key_rec->enc_key,\n\t       key_rec->enc_key_size);\n\t(*packet_size) += key_rec->enc_key_size;\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_size);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dest[(*packet_size)]",
            "key_rec->enc_key",
            "key_rec->enc_key_size"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dest[(*packet_size)]",
            "auth_tok->token.password.salt",
            "ECRYPTFS_SALT_SIZE"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_WARNING",
            "\"Unable to generate code for \"\n\t\t\t\t\"cipher [%s]\\n\"",
            "crypt_stat->cipher"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_code_for_cipher_string",
          "args": [
            "crypt_stat->cipher",
            "crypt_stat->key_size"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_code_for_cipher_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "985-1011",
          "snippet": "u8 ecryptfs_code_for_cipher_string(char *cipher_name, size_t key_bytes)\n{\n\tint i;\n\tu8 code = 0;\n\tstruct ecryptfs_cipher_code_str_map_elem *map =\n\t\tecryptfs_cipher_code_str_map;\n\n\tif (strcmp(cipher_name, \"aes\") == 0) {\n\t\tswitch (key_bytes) {\n\t\tcase 16:\n\t\t\tcode = RFC2440_CIPHER_AES_128;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tcode = RFC2440_CIPHER_AES_192;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcode = RFC2440_CIPHER_AES_256;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\t\tif (strcmp(cipher_name, map[i].cipher_str) == 0) {\n\t\t\t\tcode = map[i].cipher_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn code;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};\n\nu8 ecryptfs_code_for_cipher_string(char *cipher_name, size_t key_bytes)\n{\n\tint i;\n\tu8 code = 0;\n\tstruct ecryptfs_cipher_code_str_map_elem *map =\n\t\tecryptfs_cipher_code_str_map;\n\n\tif (strcmp(cipher_name, \"aes\") == 0) {\n\t\tswitch (key_bytes) {\n\t\tcase 16:\n\t\t\tcode = RFC2440_CIPHER_AES_128;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tcode = RFC2440_CIPHER_AES_192;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcode = RFC2440_CIPHER_AES_256;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\t\tif (strcmp(cipher_name, map[i].cipher_str) == 0) {\n\t\t\t\tcode = map[i].cipher_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_packet_length",
          "args": [
            "&dest[(*packet_size)]",
            "(max_packet_size - 4)",
            "&packet_size_length"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "135-154",
          "snippet": "int ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dump_hex",
          "args": [
            "key_rec->enc_key",
            "key_rec->enc_key_size"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dump_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/debug.c",
          "lines": "98-120",
          "snippet": "void ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n\nvoid ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "tfm_mutex"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_encrypt",
          "args": [
            "&desc",
            "dst_sg",
            "src_sg",
            "(*key_rec).enc_key_size"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "tfm_mutex"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_setkey",
          "args": [
            "desc.tfm",
            "session_key_encryption_key",
            "crypt_stat->key_size"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "tfm_mutex"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_scatterlist",
          "args": [
            "key_rec->enc_key",
            "key_rec->enc_key_size",
            "dst_sg",
            "2"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "virt_to_scatterlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "283-312",
          "snippet": "int virt_to_scatterlist(const void *addr, int size, struct scatterlist *sg,\n\t\t\tint sg_size)\n{\n\tint i = 0;\n\tstruct page *pg;\n\tint offset;\n\tint remainder_of_page;\n\n\tsg_init_table(sg, sg_size);\n\n\twhile (size > 0 && i < sg_size) {\n\t\tpg = virt_to_page(addr);\n\t\toffset = offset_in_page(addr);\n\t\tsg_set_page(&sg[i], pg, 0, offset);\n\t\tremainder_of_page = PAGE_CACHE_SIZE - offset;\n\t\tif (size >= remainder_of_page) {\n\t\t\tsg[i].length = remainder_of_page;\n\t\t\taddr += remainder_of_page;\n\t\t\tsize -= remainder_of_page;\n\t\t} else {\n\t\t\tsg[i].length = size;\n\t\t\taddr += size;\n\t\t\tsize = 0;\n\t\t}\n\t\ti++;\n\t}\n\tif (size > 0)\n\t\treturn -ENOMEM;\n\treturn i;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint virt_to_scatterlist(const void *addr, int size, struct scatterlist *sg,\n\t\t\tint sg_size)\n{\n\tint i = 0;\n\tstruct page *pg;\n\tint offset;\n\tint remainder_of_page;\n\n\tsg_init_table(sg, sg_size);\n\n\twhile (size > 0 && i < sg_size) {\n\t\tpg = virt_to_page(addr);\n\t\toffset = offset_in_page(addr);\n\t\tsg_set_page(&sg[i], pg, 0, offset);\n\t\tremainder_of_page = PAGE_CACHE_SIZE - offset;\n\t\tif (size >= remainder_of_page) {\n\t\t\tsg[i].length = remainder_of_page;\n\t\t\taddr += remainder_of_page;\n\t\t\tsize -= remainder_of_page;\n\t\t} else {\n\t\t\tsg[i].length = size;\n\t\t\taddr += size;\n\t\t\tsize = 0;\n\t\t}\n\t\ti++;\n\t}\n\tif (size > 0)\n\t\treturn -ENOMEM;\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ecryptfs_verbosity > 0"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "session_key_encryption_key",
            "auth_tok->token.password.session_key_encryption_key",
            "crypt_stat->key_size"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key_rec->enc_key",
            "auth_tok->session_key.encrypted_key",
            "key_rec->enc_key_size"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(crypt_stat->key + 24)",
            "0",
            "8"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "\"aes\"",
            "crypt_stat->cipher"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_alg",
          "args": [
            "desc.tfm"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_tfm_and_mutex_for_cipher_name",
          "args": [
            "&desc.tfm",
            "&tfm_mutex",
            "crypt_stat->cipher"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_tfm_and_mutex_for_cipher_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1751-1775",
          "snippet": "int ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mutex key_tfm_list_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct mutex key_tfm_list_mutex;\n\nint ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_from_hex",
          "args": [
            "key_rec->sig",
            "auth_tok->token.password.signature",
            "ECRYPTFS_SIG_SIZE"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_from_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "65-75",
          "snippet": "void ecryptfs_from_hex(char *dst, char *src, int dst_size)\n{\n\tint x;\n\tchar tmp[3] = { 0, };\n\n\tfor (x = 0; x < dst_size; x++) {\n\t\ttmp[0] = src[x * 2];\n\t\ttmp[1] = src[x * 2 + 1];\n\t\tdst[x] = (unsigned char)simple_strtol(tmp, NULL, 16);\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_from_hex(char *dst, char *src, int dst_size)\n{\n\tint x;\n\tchar tmp[3] = { 0, };\n\n\tfor (x = 0; x < dst_size; x++) {\n\t\ttmp[0] = src[x * 2];\n\t\ttmp[1] = src[x * 2 + 1];\n\t\tdst[x] = (unsigned char)simple_strtol(tmp, NULL, 16);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nwrite_tag_3_packet(char *dest, size_t *remaining_bytes,\n\t\t   struct ecryptfs_auth_tok *auth_tok,\n\t\t   struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   struct ecryptfs_key_record *key_rec, size_t *packet_size)\n{\n\tsize_t i;\n\tsize_t encrypted_session_key_valid = 0;\n\tchar session_key_encryption_key[ECRYPTFS_MAX_KEY_BYTES];\n\tstruct scatterlist dst_sg[2];\n\tstruct scatterlist src_sg[2];\n\tstruct mutex *tfm_mutex = NULL;\n\tu8 cipher_code;\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat =\n\t\tcrypt_stat->mount_crypt_stat;\n\tstruct blkcipher_desc desc = {\n\t\t.tfm = NULL,\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\tecryptfs_from_hex(key_rec->sig, auth_tok->token.password.signature,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\n\t\t\t\t\t\t\tcrypt_stat->cipher);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       crypt_stat->cipher, rc);\n\t\tgoto out;\n\t}\n\tif (mount_crypt_stat->global_default_cipher_key_size == 0) {\n\t\tstruct blkcipher_alg *alg = crypto_blkcipher_alg(desc.tfm);\n\n\t\tprintk(KERN_WARNING \"No key size specified at mount; \"\n\t\t       \"defaulting to [%d]\\n\", alg->max_keysize);\n\t\tmount_crypt_stat->global_default_cipher_key_size =\n\t\t\talg->max_keysize;\n\t}\n\tif (crypt_stat->key_size == 0)\n\t\tcrypt_stat->key_size =\n\t\t\tmount_crypt_stat->global_default_cipher_key_size;\n\tif (auth_tok->session_key.encrypted_key_size == 0)\n\t\tauth_tok->session_key.encrypted_key_size =\n\t\t\tcrypt_stat->key_size;\n\tif (crypt_stat->key_size == 24\n\t    && strcmp(\"aes\", crypt_stat->cipher) == 0) {\n\t\tmemset((crypt_stat->key + 24), 0, 8);\n\t\tauth_tok->session_key.encrypted_key_size = 32;\n\t} else\n\t\tauth_tok->session_key.encrypted_key_size = crypt_stat->key_size;\n\tkey_rec->enc_key_size =\n\t\tauth_tok->session_key.encrypted_key_size;\n\tencrypted_session_key_valid = 0;\n\tfor (i = 0; i < auth_tok->session_key.encrypted_key_size; i++)\n\t\tencrypted_session_key_valid |=\n\t\t\tauth_tok->session_key.encrypted_key[i];\n\tif (encrypted_session_key_valid) {\n\t\tecryptfs_printk(KERN_DEBUG, \"encrypted_session_key_valid != 0; \"\n\t\t\t\t\"using auth_tok->session_key.encrypted_key, \"\n\t\t\t\t\"where key_rec->enc_key_size = [%zd]\\n\",\n\t\t\t\tkey_rec->enc_key_size);\n\t\tmemcpy(key_rec->enc_key,\n\t\t       auth_tok->session_key.encrypted_key,\n\t\t       key_rec->enc_key_size);\n\t\tgoto encrypted_session_key_set;\n\t}\n\tif (auth_tok->token.password.flags &\n\t    ECRYPTFS_SESSION_KEY_ENCRYPTION_KEY_SET) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Using previously generated \"\n\t\t\t\t\"session key encryption key of size [%d]\\n\",\n\t\t\t\tauth_tok->token.password.\n\t\t\t\tsession_key_encryption_key_bytes);\n\t\tmemcpy(session_key_encryption_key,\n\t\t       auth_tok->token.password.session_key_encryption_key,\n\t\t       crypt_stat->key_size);\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\"Cached session key encryption key:\\n\");\n\t\tif (ecryptfs_verbosity > 0)\n\t\t\tecryptfs_dump_hex(session_key_encryption_key, 16);\n\t}\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Session key encryption key:\\n\");\n\t\tecryptfs_dump_hex(session_key_encryption_key, 16);\n\t}\n\trc = virt_to_scatterlist(crypt_stat->key, key_rec->enc_key_size,\n\t\t\t\t src_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating scatterlist \"\n\t\t\t\t\"for crypt_stat session key; expected rc = 1; \"\n\t\t\t\t\"got rc = [%d]. key_rec->enc_key_size = [%zd]\\n\",\n\t\t\t\trc, key_rec->enc_key_size);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\trc = virt_to_scatterlist(key_rec->enc_key, key_rec->enc_key_size,\n\t\t\t\t dst_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating scatterlist \"\n\t\t\t\t\"for crypt_stat encrypted session key; \"\n\t\t\t\t\"expected rc = 1; got rc = [%d]. \"\n\t\t\t\t\"key_rec->enc_key_size = [%zd]\\n\", rc,\n\t\t\t\tkey_rec->enc_key_size);\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(tfm_mutex);\n\trc = crypto_blkcipher_setkey(desc.tfm, session_key_encryption_key,\n\t\t\t\t     crypt_stat->key_size);\n\tif (rc < 0) {\n\t\tmutex_unlock(tfm_mutex);\n\t\tecryptfs_printk(KERN_ERR, \"Error setting key for crypto \"\n\t\t\t\t\"context; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = 0;\n\tecryptfs_printk(KERN_DEBUG, \"Encrypting [%zd] bytes of the key\\n\",\n\t\t\tcrypt_stat->key_size);\n\trc = crypto_blkcipher_encrypt(&desc, dst_sg, src_sg,\n\t\t\t\t      (*key_rec).enc_key_size);\n\tmutex_unlock(tfm_mutex);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error encrypting; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tecryptfs_printk(KERN_DEBUG, \"This should be the encrypted key:\\n\");\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"EFEK of size [%zd]:\\n\",\n\t\t\t\tkey_rec->enc_key_size);\n\t\tecryptfs_dump_hex(key_rec->enc_key,\n\t\t\t\t  key_rec->enc_key_size);\n\t}\nencrypted_session_key_set:\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 3 */\n\tmax_packet_size = (1                         /* Tag 3 identifier */\n\t\t\t   + 3                       /* Max Tag 3 packet size */\n\t\t\t   + 1                       /* Version */\n\t\t\t   + 1                       /* Cipher code */\n\t\t\t   + 1                       /* S2K specifier */\n\t\t\t   + 1                       /* Hash identifier */\n\t\t\t   + ECRYPTFS_SALT_SIZE      /* Salt */\n\t\t\t   + 1                       /* Hash iterations */\n\t\t\t   + key_rec->enc_key_size); /* Encrypted key size */\n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet too large; need up to [%td] bytes, but \"\n\t\t       \"there are only [%td] available\\n\", max_packet_size,\n\t\t       (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = ECRYPTFS_TAG_3_PACKET_TYPE;\n\t/* Chop off the Tag 3 identifier(1) and Tag 3 packet size(3)\n\t * to get the number of octets in the actual Tag 3 packet */\n\trc = ecryptfs_write_packet_length(&dest[(*packet_size)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error generating tag 3 packet header; cannot \"\n\t\t       \"generate packet length. rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\t(*packet_size) += packet_size_length;\n\tdest[(*packet_size)++] = 0x04; /* version 4 */\n\t/* TODO: Break from RFC2440 so that arbitrary ciphers can be\n\t * specified with strings */\n\tcipher_code = ecryptfs_code_for_cipher_string(crypt_stat->cipher,\n\t\t\t\t\t\t      crypt_stat->key_size);\n\tif (cipher_code == 0) {\n\t\tecryptfs_printk(KERN_WARNING, \"Unable to generate code for \"\n\t\t\t\t\"cipher [%s]\\n\", crypt_stat->cipher);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = cipher_code;\n\tdest[(*packet_size)++] = 0x03;\t/* S2K */\n\tdest[(*packet_size)++] = 0x01;\t/* MD5 (TODO: parameterize) */\n\tmemcpy(&dest[(*packet_size)], auth_tok->token.password.salt,\n\t       ECRYPTFS_SALT_SIZE);\n\t(*packet_size) += ECRYPTFS_SALT_SIZE;\t/* salt */\n\tdest[(*packet_size)++] = 0x60;\t/* hash iterations (65536) */\n\tmemcpy(&dest[(*packet_size)], key_rec->enc_key,\n\t       key_rec->enc_key_size);\n\t(*packet_size) += key_rec->enc_key_size;\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_size);\n\treturn rc;\n}"
  },
  {
    "function_name": "write_tag_11_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "2114-2163",
    "snippet": "static int\nwrite_tag_11_packet(char *dest, size_t *remaining_bytes, char *contents,\n\t\t    size_t contents_length, size_t *packet_length)\n{\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tint rc = 0;\n\n\t(*packet_length) = 0;\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 11 */\n\tmax_packet_size = (1                   /* Tag 11 identifier */\n\t\t\t   + 3                 /* Max Tag 11 packet size */\n\t\t\t   + 1                 /* Binary format specifier */\n\t\t\t   + 1                 /* Filename length */\n\t\t\t   + 8                 /* Filename (\"_CONSOLE\") */\n\t\t\t   + 4                 /* Modification date */\n\t\t\t   + contents_length); /* Literal data */\n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet length larger than maximum allowable; \"\n\t\t       \"need up to [%td] bytes, but there are only [%td] \"\n\t\t       \"available\\n\", max_packet_size, (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_length)++] = ECRYPTFS_TAG_11_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[(*packet_length)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error generating tag 11 packet header; cannot \"\n\t\t       \"generate packet length. rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\t(*packet_length) += packet_size_length;\n\tdest[(*packet_length)++] = 0x62; /* binary data format specifier */\n\tdest[(*packet_length)++] = 8;\n\tmemcpy(&dest[(*packet_length)], \"_CONSOLE\", 8);\n\t(*packet_length) += 8;\n\tmemset(&dest[(*packet_length)], 0x00, 4);\n\t(*packet_length) += 4;\n\tmemcpy(&dest[(*packet_length)], contents, contents_length);\n\t(*packet_length) += contents_length;\n out:\n\tif (rc)\n\t\t(*packet_length) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_length);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dest[(*packet_length)]",
            "contents",
            "contents_length"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dest[(*packet_length)]",
            "0x00",
            "4"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dest[(*packet_length)]",
            "\"_CONSOLE\"",
            "8"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Error generating tag 11 packet header; cannot \"\n\t\t       \"generate packet length. rc = [%d]\\n\"",
            "rc"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_packet_length",
          "args": [
            "&dest[(*packet_length)]",
            "(max_packet_size - 4)",
            "&packet_size_length"
          ],
          "line": 2140
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "135-154",
          "snippet": "int ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nwrite_tag_11_packet(char *dest, size_t *remaining_bytes, char *contents,\n\t\t    size_t contents_length, size_t *packet_length)\n{\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tint rc = 0;\n\n\t(*packet_length) = 0;\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 11 */\n\tmax_packet_size = (1                   /* Tag 11 identifier */\n\t\t\t   + 3                 /* Max Tag 11 packet size */\n\t\t\t   + 1                 /* Binary format specifier */\n\t\t\t   + 1                 /* Filename length */\n\t\t\t   + 8                 /* Filename (\"_CONSOLE\") */\n\t\t\t   + 4                 /* Modification date */\n\t\t\t   + contents_length); /* Literal data */\n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet length larger than maximum allowable; \"\n\t\t       \"need up to [%td] bytes, but there are only [%td] \"\n\t\t       \"available\\n\", max_packet_size, (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_length)++] = ECRYPTFS_TAG_11_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[(*packet_length)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Error generating tag 11 packet header; cannot \"\n\t\t       \"generate packet length. rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\t(*packet_length) += packet_size_length;\n\tdest[(*packet_length)++] = 0x62; /* binary data format specifier */\n\tdest[(*packet_length)++] = 8;\n\tmemcpy(&dest[(*packet_length)], \"_CONSOLE\", 8);\n\t(*packet_length) += 8;\n\tmemset(&dest[(*packet_length)], 0x00, 4);\n\t(*packet_length) += 4;\n\tmemcpy(&dest[(*packet_length)], contents, contents_length);\n\t(*packet_length) += contents_length;\n out:\n\tif (rc)\n\t\t(*packet_length) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_length);\n\treturn rc;\n}"
  },
  {
    "function_name": "write_tag_1_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "2022-2102",
    "snippet": "static int\nwrite_tag_1_packet(char *dest, size_t *remaining_bytes,\n\t\t   struct key *auth_tok_key, struct ecryptfs_auth_tok *auth_tok,\n\t\t   struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   struct ecryptfs_key_record *key_rec, size_t *packet_size)\n{\n\tsize_t i;\n\tsize_t encrypted_session_key_valid = 0;\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\tecryptfs_from_hex(key_rec->sig, auth_tok->token.private_key.signature,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\tencrypted_session_key_valid = 0;\n\tfor (i = 0; i < crypt_stat->key_size; i++)\n\t\tencrypted_session_key_valid |=\n\t\t\tauth_tok->session_key.encrypted_key[i];\n\tif (encrypted_session_key_valid) {\n\t\tmemcpy(key_rec->enc_key,\n\t\t       auth_tok->session_key.encrypted_key,\n\t\t       auth_tok->session_key.encrypted_key_size);\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\tgoto encrypted_session_key_set;\n\t}\n\tif (auth_tok->session_key.encrypted_key_size == 0)\n\t\tauth_tok->session_key.encrypted_key_size =\n\t\t\tauth_tok->token.private_key.key_size;\n\trc = pki_encrypt_session_key(auth_tok_key, auth_tok, crypt_stat,\n\t\t\t\t     key_rec);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to encrypt session key via a key \"\n\t\t       \"module; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Encrypted key:\\n\");\n\t\tecryptfs_dump_hex(key_rec->enc_key, key_rec->enc_key_size);\n\t}\nencrypted_session_key_set:\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 1 */\n\tmax_packet_size = (1                         /* Tag 1 identifier */\n\t\t\t   + 3                       /* Max Tag 1 packet size */\n\t\t\t   + 1                       /* Version */\n\t\t\t   + ECRYPTFS_SIG_SIZE       /* Key identifier */\n\t\t\t   + 1                       /* Cipher identifier */\n\t\t\t   + key_rec->enc_key_size); /* Encrypted key size */\n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet length larger than maximum allowable; \"\n\t\t       \"need up to [%td] bytes, but there are only [%td] \"\n\t\t       \"available\\n\", max_packet_size, (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = ECRYPTFS_TAG_1_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[(*packet_size)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 1 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\t(*packet_size) += packet_size_length;\n\tdest[(*packet_size)++] = 0x03; /* version 3 */\n\tmemcpy(&dest[(*packet_size)], key_rec->sig, ECRYPTFS_SIG_SIZE);\n\t(*packet_size) += ECRYPTFS_SIG_SIZE;\n\tdest[(*packet_size)++] = RFC2440_CIPHER_RSA;\n\tmemcpy(&dest[(*packet_size)], key_rec->enc_key,\n\t       key_rec->enc_key_size);\n\t(*packet_size) += key_rec->enc_key_size;\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_size);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dest[(*packet_size)]",
            "key_rec->enc_key",
            "key_rec->enc_key_size"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&dest[(*packet_size)]",
            "key_rec->sig",
            "ECRYPTFS_SIG_SIZE"
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Error generating tag 1 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\""
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_packet_length",
          "args": [
            "&dest[(*packet_size)]",
            "(max_packet_size - 4)",
            "&packet_size_length"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "135-154",
          "snippet": "int ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dump_hex",
          "args": [
            "key_rec->enc_key",
            "key_rec->enc_key_size"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dump_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/debug.c",
          "lines": "98-120",
          "snippet": "void ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n\nvoid ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pki_encrypt_session_key",
          "args": [
            "auth_tok_key",
            "auth_tok",
            "crypt_stat",
            "key_rec"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "pki_encrypt_session_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "1964-2007",
          "snippet": "static int\npki_encrypt_session_key(struct key *auth_tok_key,\n\t\t\tstruct ecryptfs_auth_tok *auth_tok,\n\t\t\tstruct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct ecryptfs_key_record *key_rec)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx = NULL;\n\tchar *payload = NULL;\n\tsize_t payload_len = 0;\n\tstruct ecryptfs_message *msg;\n\tint rc;\n\n\trc = write_tag_66_packet(auth_tok->token.private_key.signature,\n\t\t\t\t ecryptfs_code_for_cipher_string(\n\t\t\t\t\t crypt_stat->cipher,\n\t\t\t\t\t crypt_stat->key_size),\n\t\t\t\t crypt_stat, &payload, &payload_len);\n\tup_write(&(auth_tok_key->sem));\n\tkey_put(auth_tok_key);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_send_message(payload, payload_len, &msg_ctx);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error sending message to \"\n\t\t\t\t\"ecryptfsd: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_wait_for_response(msg_ctx, &msg);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to receive tag 67 packet \"\n\t\t\t\t\"from the user space daemon\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = parse_tag_67_packet(key_rec, msg);\n\tif (rc)\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing tag 67 packet\\n\");\n\tkfree(msg);\nout:\n\tkfree(payload);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\npki_encrypt_session_key(struct key *auth_tok_key,\n\t\t\tstruct ecryptfs_auth_tok *auth_tok,\n\t\t\tstruct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct ecryptfs_key_record *key_rec)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx = NULL;\n\tchar *payload = NULL;\n\tsize_t payload_len = 0;\n\tstruct ecryptfs_message *msg;\n\tint rc;\n\n\trc = write_tag_66_packet(auth_tok->token.private_key.signature,\n\t\t\t\t ecryptfs_code_for_cipher_string(\n\t\t\t\t\t crypt_stat->cipher,\n\t\t\t\t\t crypt_stat->key_size),\n\t\t\t\t crypt_stat, &payload, &payload_len);\n\tup_write(&(auth_tok_key->sem));\n\tkey_put(auth_tok_key);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_send_message(payload, payload_len, &msg_ctx);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error sending message to \"\n\t\t\t\t\"ecryptfsd: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_wait_for_response(msg_ctx, &msg);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to receive tag 67 packet \"\n\t\t\t\t\"from the user space daemon\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = parse_tag_67_packet(key_rec, msg);\n\tif (rc)\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing tag 67 packet\\n\");\n\tkfree(msg);\nout:\n\tkfree(payload);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "auth_tok_key"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&(auth_tok_key->sem)"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key_rec->enc_key",
            "auth_tok->session_key.encrypted_key",
            "auth_tok->session_key.encrypted_key_size"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_from_hex",
          "args": [
            "key_rec->sig",
            "auth_tok->token.private_key.signature",
            "ECRYPTFS_SIG_SIZE"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_from_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "65-75",
          "snippet": "void ecryptfs_from_hex(char *dst, char *src, int dst_size)\n{\n\tint x;\n\tchar tmp[3] = { 0, };\n\n\tfor (x = 0; x < dst_size; x++) {\n\t\ttmp[0] = src[x * 2];\n\t\ttmp[1] = src[x * 2 + 1];\n\t\tdst[x] = (unsigned char)simple_strtol(tmp, NULL, 16);\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_from_hex(char *dst, char *src, int dst_size)\n{\n\tint x;\n\tchar tmp[3] = { 0, };\n\n\tfor (x = 0; x < dst_size; x++) {\n\t\ttmp[0] = src[x * 2];\n\t\ttmp[1] = src[x * 2 + 1];\n\t\tdst[x] = (unsigned char)simple_strtol(tmp, NULL, 16);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nwrite_tag_1_packet(char *dest, size_t *remaining_bytes,\n\t\t   struct key *auth_tok_key, struct ecryptfs_auth_tok *auth_tok,\n\t\t   struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   struct ecryptfs_key_record *key_rec, size_t *packet_size)\n{\n\tsize_t i;\n\tsize_t encrypted_session_key_valid = 0;\n\tsize_t packet_size_length;\n\tsize_t max_packet_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\tecryptfs_from_hex(key_rec->sig, auth_tok->token.private_key.signature,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\tencrypted_session_key_valid = 0;\n\tfor (i = 0; i < crypt_stat->key_size; i++)\n\t\tencrypted_session_key_valid |=\n\t\t\tauth_tok->session_key.encrypted_key[i];\n\tif (encrypted_session_key_valid) {\n\t\tmemcpy(key_rec->enc_key,\n\t\t       auth_tok->session_key.encrypted_key,\n\t\t       auth_tok->session_key.encrypted_key_size);\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\tgoto encrypted_session_key_set;\n\t}\n\tif (auth_tok->session_key.encrypted_key_size == 0)\n\t\tauth_tok->session_key.encrypted_key_size =\n\t\t\tauth_tok->token.private_key.key_size;\n\trc = pki_encrypt_session_key(auth_tok_key, auth_tok, crypt_stat,\n\t\t\t\t     key_rec);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to encrypt session key via a key \"\n\t\t       \"module; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Encrypted key:\\n\");\n\t\tecryptfs_dump_hex(key_rec->enc_key, key_rec->enc_key_size);\n\t}\nencrypted_session_key_set:\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 1 */\n\tmax_packet_size = (1                         /* Tag 1 identifier */\n\t\t\t   + 3                       /* Max Tag 1 packet size */\n\t\t\t   + 1                       /* Version */\n\t\t\t   + ECRYPTFS_SIG_SIZE       /* Key identifier */\n\t\t\t   + 1                       /* Cipher identifier */\n\t\t\t   + key_rec->enc_key_size); /* Encrypted key size */\n\tif (max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_ERR \"Packet length larger than maximum allowable; \"\n\t\t       \"need up to [%td] bytes, but there are only [%td] \"\n\t\t       \"available\\n\", max_packet_size, (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tdest[(*packet_size)++] = ECRYPTFS_TAG_1_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[(*packet_size)],\n\t\t\t\t\t  (max_packet_size - 4),\n\t\t\t\t\t  &packet_size_length);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 1 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\t(*packet_size) += packet_size_length;\n\tdest[(*packet_size)++] = 0x03; /* version 3 */\n\tmemcpy(&dest[(*packet_size)], key_rec->sig, ECRYPTFS_SIG_SIZE);\n\t(*packet_size) += ECRYPTFS_SIG_SIZE;\n\tdest[(*packet_size)++] = RFC2440_CIPHER_RSA;\n\tmemcpy(&dest[(*packet_size)], key_rec->enc_key,\n\t       key_rec->enc_key_size);\n\t(*packet_size) += key_rec->enc_key_size;\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\telse\n\t\t(*remaining_bytes) -= (*packet_size);\n\treturn rc;\n}"
  },
  {
    "function_name": "pki_encrypt_session_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "1964-2007",
    "snippet": "static int\npki_encrypt_session_key(struct key *auth_tok_key,\n\t\t\tstruct ecryptfs_auth_tok *auth_tok,\n\t\t\tstruct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct ecryptfs_key_record *key_rec)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx = NULL;\n\tchar *payload = NULL;\n\tsize_t payload_len = 0;\n\tstruct ecryptfs_message *msg;\n\tint rc;\n\n\trc = write_tag_66_packet(auth_tok->token.private_key.signature,\n\t\t\t\t ecryptfs_code_for_cipher_string(\n\t\t\t\t\t crypt_stat->cipher,\n\t\t\t\t\t crypt_stat->key_size),\n\t\t\t\t crypt_stat, &payload, &payload_len);\n\tup_write(&(auth_tok_key->sem));\n\tkey_put(auth_tok_key);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_send_message(payload, payload_len, &msg_ctx);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error sending message to \"\n\t\t\t\t\"ecryptfsd: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_wait_for_response(msg_ctx, &msg);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to receive tag 67 packet \"\n\t\t\t\t\"from the user space daemon\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = parse_tag_67_packet(key_rec, msg);\n\tif (rc)\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing tag 67 packet\\n\");\n\tkfree(msg);\nout:\n\tkfree(payload);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "payload"
          ],
          "line": 2005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "msg"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Error parsing tag 67 packet\\n\""
          ],
          "line": 2002
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_tag_67_packet",
          "args": [
            "key_rec",
            "msg"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "parse_tag_67_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "358-422",
          "snippet": "static int\nparse_tag_67_packet(struct ecryptfs_key_record *key_rec,\n\t\t    struct ecryptfs_message *msg)\n{\n\tsize_t i = 0;\n\tchar *data;\n\tsize_t data_len;\n\tsize_t message_len;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 65 Packet Format *****\n\t *    | Content Type                       | 1 byte       |\n\t *    | Status Indicator                   | 1 byte       |\n\t *    | Encrypted File Encryption Key Size | 1 or 2 bytes |\n\t *    | Encrypted File Encryption Key      | arbitrary    |\n\t */\n\tmessage_len = msg->data_len;\n\tdata = msg->data;\n\t/* verify that everything through the encrypted FEK size is present */\n\tif (message_len < 4) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: message_len is [%zd]; minimum acceptable \"\n\t\t       \"message length is [%d]\\n\", __func__, message_len, 4);\n\t\tgoto out;\n\t}\n\tif (data[i++] != ECRYPTFS_TAG_67_PACKET_TYPE) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Type should be ECRYPTFS_TAG_67\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\tif (data[i++]) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Status indicator has non zero \"\n\t\t       \"value [%d]\\n\", __func__, data[i-1]);\n\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[i], &key_rec->enc_key_size,\n\t\t\t\t\t  &data_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error parsing packet length; \"\n\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\ti += data_len;\n\tif (message_len < (i + key_rec->enc_key_size)) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: message_len [%zd]; max len is [%zd]\\n\",\n\t\t       __func__, message_len, (i + key_rec->enc_key_size));\n\t\tgoto out;\n\t}\n\tif (key_rec->enc_key_size > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Encrypted key_size [%zd] larger than \"\n\t\t       \"the maximum key size [%d]\\n\", __func__,\n\t\t       key_rec->enc_key_size,\n\t\t       ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES);\n\t\tgoto out;\n\t}\n\tmemcpy(key_rec->enc_key, &data[i], key_rec->enc_key_size);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nparse_tag_67_packet(struct ecryptfs_key_record *key_rec,\n\t\t    struct ecryptfs_message *msg)\n{\n\tsize_t i = 0;\n\tchar *data;\n\tsize_t data_len;\n\tsize_t message_len;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 65 Packet Format *****\n\t *    | Content Type                       | 1 byte       |\n\t *    | Status Indicator                   | 1 byte       |\n\t *    | Encrypted File Encryption Key Size | 1 or 2 bytes |\n\t *    | Encrypted File Encryption Key      | arbitrary    |\n\t */\n\tmessage_len = msg->data_len;\n\tdata = msg->data;\n\t/* verify that everything through the encrypted FEK size is present */\n\tif (message_len < 4) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: message_len is [%zd]; minimum acceptable \"\n\t\t       \"message length is [%d]\\n\", __func__, message_len, 4);\n\t\tgoto out;\n\t}\n\tif (data[i++] != ECRYPTFS_TAG_67_PACKET_TYPE) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Type should be ECRYPTFS_TAG_67\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\tif (data[i++]) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Status indicator has non zero \"\n\t\t       \"value [%d]\\n\", __func__, data[i-1]);\n\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[i], &key_rec->enc_key_size,\n\t\t\t\t\t  &data_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error parsing packet length; \"\n\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\ti += data_len;\n\tif (message_len < (i + key_rec->enc_key_size)) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: message_len [%zd]; max len is [%zd]\\n\",\n\t\t       __func__, message_len, (i + key_rec->enc_key_size));\n\t\tgoto out;\n\t}\n\tif (key_rec->enc_key_size > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Encrypted key_size [%zd] larger than \"\n\t\t       \"the maximum key size [%d]\\n\", __func__,\n\t\t       key_rec->enc_key_size,\n\t\t       ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES);\n\t\tgoto out;\n\t}\n\tmemcpy(key_rec->enc_key, &data[i], key_rec->enc_key_size);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_wait_for_response",
          "args": [
            "msg_ctx",
            "&msg"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_wait_for_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "639-643",
          "snippet": "static inline int ecryptfs_wait_for_response(struct ecryptfs_msg_ctx *msg_ctx,\n\t\t\t\t\t     struct ecryptfs_message **emsg)\n{\n\treturn -ENOMSG;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline int ecryptfs_wait_for_response(struct ecryptfs_msg_ctx *msg_ctx,\n\t\t\t\t\t     struct ecryptfs_message **emsg)\n{\n\treturn -ENOMSG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_send_message",
          "args": [
            "payload",
            "payload_len",
            "&msg_ctx"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "634-638",
          "snippet": "static inline int ecryptfs_send_message(char *data, int data_len,\n\t\t\t\t\tstruct ecryptfs_msg_ctx **msg_ctx)\n{\n\treturn -ENOTCONN;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline int ecryptfs_send_message(char *data, int data_len,\n\t\t\t\t\tstruct ecryptfs_msg_ctx **msg_ctx)\n{\n\treturn -ENOTCONN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "auth_tok_key"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&(auth_tok_key->sem)"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_tag_66_packet",
          "args": [
            "auth_tok->token.private_key.signature",
            "ecryptfs_code_for_cipher_string(\n\t\t\t\t\t crypt_stat->cipher,\n\t\t\t\t\t crypt_stat->key_size)",
            "crypt_stat",
            "&payload",
            "&payload_len"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "write_tag_66_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "297-356",
          "snippet": "static int\nwrite_tag_66_packet(char *signature, u8 cipher_code,\n\t\t    struct ecryptfs_crypt_stat *crypt_stat, char **packet,\n\t\t    size_t *packet_len)\n{\n\tsize_t i = 0;\n\tsize_t j;\n\tsize_t data_len;\n\tsize_t checksum = 0;\n\tsize_t packet_size_len;\n\tchar *message;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 66 Packet Format *****\n\t *         | Content Type             | 1 byte       |\n\t *         | Key Identifier Size      | 1 or 2 bytes |\n\t *         | Key Identifier           | arbitrary    |\n\t *         | File Encryption Key Size | 1 or 2 bytes |\n\t *         | File Encryption Key      | arbitrary    |\n\t */\n\tdata_len = (5 + ECRYPTFS_SIG_SIZE_HEX + crypt_stat->key_size);\n\t*packet = kmalloc(data_len, GFP_KERNEL);\n\tmessage = *packet;\n\tif (!message) {\n\t\tecryptfs_printk(KERN_ERR, \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmessage[i++] = ECRYPTFS_TAG_66_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&message[i], ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], signature, ECRYPTFS_SIG_SIZE_HEX);\n\ti += ECRYPTFS_SIG_SIZE_HEX;\n\t/* The encrypted key includes 1 byte cipher code and 2 byte checksum */\n\trc = ecryptfs_write_packet_length(&message[i], crypt_stat->key_size + 3,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmessage[i++] = cipher_code;\n\tmemcpy(&message[i], crypt_stat->key, crypt_stat->key_size);\n\ti += crypt_stat->key_size;\n\tfor (j = 0; j < crypt_stat->key_size; j++)\n\t\tchecksum += crypt_stat->key[j];\n\tmessage[i++] = (checksum / 256) % 256;\n\tmessage[i++] = (checksum % 256);\n\t*packet_len = i;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nwrite_tag_66_packet(char *signature, u8 cipher_code,\n\t\t    struct ecryptfs_crypt_stat *crypt_stat, char **packet,\n\t\t    size_t *packet_len)\n{\n\tsize_t i = 0;\n\tsize_t j;\n\tsize_t data_len;\n\tsize_t checksum = 0;\n\tsize_t packet_size_len;\n\tchar *message;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 66 Packet Format *****\n\t *         | Content Type             | 1 byte       |\n\t *         | Key Identifier Size      | 1 or 2 bytes |\n\t *         | Key Identifier           | arbitrary    |\n\t *         | File Encryption Key Size | 1 or 2 bytes |\n\t *         | File Encryption Key      | arbitrary    |\n\t */\n\tdata_len = (5 + ECRYPTFS_SIG_SIZE_HEX + crypt_stat->key_size);\n\t*packet = kmalloc(data_len, GFP_KERNEL);\n\tmessage = *packet;\n\tif (!message) {\n\t\tecryptfs_printk(KERN_ERR, \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmessage[i++] = ECRYPTFS_TAG_66_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&message[i], ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], signature, ECRYPTFS_SIG_SIZE_HEX);\n\ti += ECRYPTFS_SIG_SIZE_HEX;\n\t/* The encrypted key includes 1 byte cipher code and 2 byte checksum */\n\trc = ecryptfs_write_packet_length(&message[i], crypt_stat->key_size + 3,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmessage[i++] = cipher_code;\n\tmemcpy(&message[i], crypt_stat->key, crypt_stat->key_size);\n\ti += crypt_stat->key_size;\n\tfor (j = 0; j < crypt_stat->key_size; j++)\n\t\tchecksum += crypt_stat->key[j];\n\tmessage[i++] = (checksum / 256) % 256;\n\tmessage[i++] = (checksum % 256);\n\t*packet_len = i;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_code_for_cipher_string",
          "args": [
            "crypt_stat->cipher",
            "crypt_stat->key_size"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_code_for_cipher_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "985-1011",
          "snippet": "u8 ecryptfs_code_for_cipher_string(char *cipher_name, size_t key_bytes)\n{\n\tint i;\n\tu8 code = 0;\n\tstruct ecryptfs_cipher_code_str_map_elem *map =\n\t\tecryptfs_cipher_code_str_map;\n\n\tif (strcmp(cipher_name, \"aes\") == 0) {\n\t\tswitch (key_bytes) {\n\t\tcase 16:\n\t\t\tcode = RFC2440_CIPHER_AES_128;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tcode = RFC2440_CIPHER_AES_192;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcode = RFC2440_CIPHER_AES_256;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\t\tif (strcmp(cipher_name, map[i].cipher_str) == 0) {\n\t\t\t\tcode = map[i].cipher_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn code;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};\n\nu8 ecryptfs_code_for_cipher_string(char *cipher_name, size_t key_bytes)\n{\n\tint i;\n\tu8 code = 0;\n\tstruct ecryptfs_cipher_code_str_map_elem *map =\n\t\tecryptfs_cipher_code_str_map;\n\n\tif (strcmp(cipher_name, \"aes\") == 0) {\n\t\tswitch (key_bytes) {\n\t\tcase 16:\n\t\t\tcode = RFC2440_CIPHER_AES_128;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tcode = RFC2440_CIPHER_AES_192;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcode = RFC2440_CIPHER_AES_256;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\t\tif (strcmp(cipher_name, map[i].cipher_str) == 0) {\n\t\t\t\tcode = map[i].cipher_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\npki_encrypt_session_key(struct key *auth_tok_key,\n\t\t\tstruct ecryptfs_auth_tok *auth_tok,\n\t\t\tstruct ecryptfs_crypt_stat *crypt_stat,\n\t\t\tstruct ecryptfs_key_record *key_rec)\n{\n\tstruct ecryptfs_msg_ctx *msg_ctx = NULL;\n\tchar *payload = NULL;\n\tsize_t payload_len = 0;\n\tstruct ecryptfs_message *msg;\n\tint rc;\n\n\trc = write_tag_66_packet(auth_tok->token.private_key.signature,\n\t\t\t\t ecryptfs_code_for_cipher_string(\n\t\t\t\t\t crypt_stat->cipher,\n\t\t\t\t\t crypt_stat->key_size),\n\t\t\t\t crypt_stat, &payload, &payload_len);\n\tup_write(&(auth_tok_key->sem));\n\tkey_put(auth_tok_key);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_send_message(payload, payload_len, &msg_ctx);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error sending message to \"\n\t\t\t\t\"ecryptfsd: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_wait_for_response(msg_ctx, &msg);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to receive tag 67 packet \"\n\t\t\t\t\"from the user space daemon\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = parse_tag_67_packet(key_rec, msg);\n\tif (rc)\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing tag 67 packet\\n\");\n\tkfree(msg);\nout:\n\tkfree(payload);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_parse_packet_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "1757-1962",
    "snippet": "int ecryptfs_parse_packet_set(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t      unsigned char *src,\n\t\t\t      struct dentry *ecryptfs_dentry)\n{\n\tsize_t i = 0;\n\tsize_t found_auth_tok;\n\tsize_t next_packet_is_auth_tok_packet;\n\tstruct list_head auth_tok_list;\n\tstruct ecryptfs_auth_tok *matching_auth_tok;\n\tstruct ecryptfs_auth_tok *candidate_auth_tok;\n\tchar *candidate_auth_tok_sig;\n\tsize_t packet_size;\n\tstruct ecryptfs_auth_tok *new_auth_tok;\n\tunsigned char sig_tmp_space[ECRYPTFS_SIG_SIZE];\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t tag_11_contents_size;\n\tsize_t tag_11_packet_size;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\tINIT_LIST_HEAD(&auth_tok_list);\n\t/* Parse the header to find as many packets as we can; these will be\n\t * added the our &auth_tok_list */\n\tnext_packet_is_auth_tok_packet = 1;\n\twhile (next_packet_is_auth_tok_packet) {\n\t\tsize_t max_packet_size = ((PAGE_CACHE_SIZE - 8) - i);\n\n\t\tswitch (src[i]) {\n\t\tcase ECRYPTFS_TAG_3_PACKET_TYPE:\n\t\t\trc = parse_tag_3_packet(crypt_stat,\n\t\t\t\t\t\t(unsigned char *)&src[i],\n\t\t\t\t\t\t&auth_tok_list, &new_auth_tok,\n\t\t\t\t\t\t&packet_size, max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error parsing \"\n\t\t\t\t\t\t\"tag 3 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += packet_size;\n\t\t\trc = parse_tag_11_packet((unsigned char *)&src[i],\n\t\t\t\t\t\t sig_tmp_space,\n\t\t\t\t\t\t ECRYPTFS_SIG_SIZE,\n\t\t\t\t\t\t &tag_11_contents_size,\n\t\t\t\t\t\t &tag_11_packet_size,\n\t\t\t\t\t\t max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"No valid \"\n\t\t\t\t\t\t\"(ecryptfs-specific) literal \"\n\t\t\t\t\t\t\"packet containing \"\n\t\t\t\t\t\t\"authentication token \"\n\t\t\t\t\t\t\"signature found after \"\n\t\t\t\t\t\t\"tag 3 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += tag_11_packet_size;\n\t\t\tif (ECRYPTFS_SIG_SIZE != tag_11_contents_size) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Expected \"\n\t\t\t\t\t\t\"signature of size [%d]; \"\n\t\t\t\t\t\t\"read size [%zd]\\n\",\n\t\t\t\t\t\tECRYPTFS_SIG_SIZE,\n\t\t\t\t\t\ttag_11_contents_size);\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\tecryptfs_to_hex(new_auth_tok->token.password.signature,\n\t\t\t\t\tsig_tmp_space, tag_11_contents_size);\n\t\t\tnew_auth_tok->token.password.signature[\n\t\t\t\tECRYPTFS_PASSWORD_SIG_SIZE] = '\\0';\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPTED;\n\t\t\tbreak;\n\t\tcase ECRYPTFS_TAG_1_PACKET_TYPE:\n\t\t\trc = parse_tag_1_packet(crypt_stat,\n\t\t\t\t\t\t(unsigned char *)&src[i],\n\t\t\t\t\t\t&auth_tok_list, &new_auth_tok,\n\t\t\t\t\t\t&packet_size, max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error parsing \"\n\t\t\t\t\t\t\"tag 1 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += packet_size;\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPTED;\n\t\t\tbreak;\n\t\tcase ECRYPTFS_TAG_11_PACKET_TYPE:\n\t\t\tecryptfs_printk(KERN_WARNING, \"Invalid packet set \"\n\t\t\t\t\t\"(Tag 11 not allowed by itself)\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto out_wipe_list;\n\t\tdefault:\n\t\t\tecryptfs_printk(KERN_DEBUG, \"No packet at offset [%zd] \"\n\t\t\t\t\t\"of the file header; hex value of \"\n\t\t\t\t\t\"character is [0x%.2x]\\n\", i, src[i]);\n\t\t\tnext_packet_is_auth_tok_packet = 0;\n\t\t}\n\t}\n\tif (list_empty(&auth_tok_list)) {\n\t\tprintk(KERN_ERR \"The lower file appears to be a non-encrypted \"\n\t\t       \"eCryptfs file; this is not supported in this version \"\n\t\t       \"of the eCryptfs kernel module\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* auth_tok_list contains the set of authentication tokens\n\t * parsed from the metadata. We need to find a matching\n\t * authentication token that has the secret component(s)\n\t * necessary to decrypt the EFEK in the auth_tok parsed from\n\t * the metadata. There may be several potential matches, but\n\t * just one will be sufficient to decrypt to get the FEK. */\nfind_next_matching_auth_tok:\n\tfound_auth_tok = 0;\n\tlist_for_each_entry(auth_tok_list_item, &auth_tok_list, list) {\n\t\tcandidate_auth_tok = &auth_tok_list_item->auth_tok;\n\t\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\t\"Considering cadidate auth tok:\\n\");\n\t\t\tecryptfs_dump_auth_tok(candidate_auth_tok);\n\t\t}\n\t\trc = ecryptfs_get_auth_tok_sig(&candidate_auth_tok_sig,\n\t\t\t\t\t       candidate_auth_tok);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Unrecognized candidate auth tok type: [%d]\\n\",\n\t\t\t       candidate_auth_tok->token_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_wipe_list;\n\t\t}\n\t\trc = ecryptfs_find_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t       &matching_auth_tok,\n\t\t\t\t\t       crypt_stat->mount_crypt_stat,\n\t\t\t\t\t       candidate_auth_tok_sig);\n\t\tif (!rc) {\n\t\t\tfound_auth_tok = 1;\n\t\t\tgoto found_matching_auth_tok;\n\t\t}\n\t}\n\tif (!found_auth_tok) {\n\t\tecryptfs_printk(KERN_ERR, \"Could not find a usable \"\n\t\t\t\t\"authentication token\\n\");\n\t\trc = -EIO;\n\t\tgoto out_wipe_list;\n\t}\nfound_matching_auth_tok:\n\tif (candidate_auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {\n\t\tmemcpy(&(candidate_auth_tok->token.private_key),\n\t\t       &(matching_auth_tok->token.private_key),\n\t\t       sizeof(struct ecryptfs_private_key));\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = decrypt_pki_encrypted_session_key(candidate_auth_tok,\n\t\t\t\t\t\t       crypt_stat);\n\t} else if (candidate_auth_tok->token_type == ECRYPTFS_PASSWORD) {\n\t\tmemcpy(&(candidate_auth_tok->token.password),\n\t\t       &(matching_auth_tok->token.password),\n\t\t       sizeof(struct ecryptfs_password));\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = decrypt_passphrase_encrypted_session_key(\n\t\t\tcandidate_auth_tok, crypt_stat);\n\t} else {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = -EINVAL;\n\t}\n\tif (rc) {\n\t\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;\n\n\t\tecryptfs_printk(KERN_WARNING, \"Error decrypting the \"\n\t\t\t\t\"session key for authentication token with sig \"\n\t\t\t\t\"[%.*s]; rc = [%d]. Removing auth tok \"\n\t\t\t\t\"candidate from the list and searching for \"\n\t\t\t\t\"the next match.\\n\", ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\tcandidate_auth_tok_sig,\trc);\n\t\tlist_for_each_entry_safe(auth_tok_list_item,\n\t\t\t\t\t auth_tok_list_item_tmp,\n\t\t\t\t\t &auth_tok_list, list) {\n\t\t\tif (candidate_auth_tok\n\t\t\t    == &auth_tok_list_item->auth_tok) {\n\t\t\t\tlist_del(&auth_tok_list_item->list);\n\t\t\t\tkmem_cache_free(\n\t\t\t\t\tecryptfs_auth_tok_list_item_cache,\n\t\t\t\t\tauth_tok_list_item);\n\t\t\t\tgoto find_next_matching_auth_tok;\n\t\t\t}\n\t\t}\n\t\tBUG();\n\t}\n\trc = ecryptfs_compute_root_iv(crypt_stat);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error computing \"\n\t\t\t\t\"the root IV\\n\");\n\t\tgoto out_wipe_list;\n\t}\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error initializing crypto \"\n\t\t\t\t\"context for cipher [%s]; rc = [%d]\\n\",\n\t\t\t\tcrypt_stat->cipher, rc);\n\t}\nout_wipe_list:\n\twipe_auth_tok_list(&auth_tok_list);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_auth_tok_list_item_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wipe_auth_tok_list",
          "args": [
            "&auth_tok_list"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "wipe_auth_tok_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "1209-1220",
          "snippet": "static void wipe_auth_tok_list(struct list_head *auth_tok_list_head)\n{\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;\n\n\tlist_for_each_entry_safe(auth_tok_list_item, auth_tok_list_item_tmp,\n\t\t\t\t auth_tok_list_head, list) {\n\t\tlist_del(&auth_tok_list_item->list);\n\t\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\t\tauth_tok_list_item);\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_auth_tok_list_item_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_auth_tok_list_item_cache;\n\nstatic void wipe_auth_tok_list(struct list_head *auth_tok_list_head)\n{\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;\n\n\tlist_for_each_entry_safe(auth_tok_list_item, auth_tok_list_item_tmp,\n\t\t\t\t auth_tok_list_head, list) {\n\t\tlist_del(&auth_tok_list_item->list);\n\t\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\t\tauth_tok_list_item);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Error initializing crypto \"\n\t\t\t\t\"context for cipher [%s]; rc = [%d]\\n\"",
            "crypt_stat->cipher",
            "rc"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_init_crypt_ctx",
          "args": [
            "crypt_stat"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_init_crypt_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "607-642",
          "snippet": "int ecryptfs_init_crypt_ctx(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tchar *full_alg_name;\n\tint rc = -EINVAL;\n\n\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\"Initializing cipher [%s]; strlen = [%d]; \"\n\t\t\t\"key_size_bits = [%zd]\\n\",\n\t\t\tcrypt_stat->cipher, (int)strlen(crypt_stat->cipher),\n\t\t\tcrypt_stat->key_size << 3);\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\tif (crypt_stat->tfm) {\n\t\trc = 0;\n\t\tgoto out_unlock;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name,\n\t\t\t\t\t\t    crypt_stat->cipher, \"cbc\");\n\tif (rc)\n\t\tgoto out_unlock;\n\tcrypt_stat->tfm = crypto_alloc_ablkcipher(full_alg_name, 0, 0);\n\tif (IS_ERR(crypt_stat->tfm)) {\n\t\trc = PTR_ERR(crypt_stat->tfm);\n\t\tcrypt_stat->tfm = NULL;\n\t\tecryptfs_printk(KERN_ERR, \"cryptfs: init_crypt_ctx(): \"\n\t\t\t\t\"Error initializing cipher [%s]\\n\",\n\t\t\t\tfull_alg_name);\n\t\tgoto out_free;\n\t}\n\tcrypto_ablkcipher_set_flags(crypt_stat->tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\trc = 0;\nout_free:\n\tkfree(full_alg_name);\nout_unlock:\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_init_crypt_ctx(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tchar *full_alg_name;\n\tint rc = -EINVAL;\n\n\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\"Initializing cipher [%s]; strlen = [%d]; \"\n\t\t\t\"key_size_bits = [%zd]\\n\",\n\t\t\tcrypt_stat->cipher, (int)strlen(crypt_stat->cipher),\n\t\t\tcrypt_stat->key_size << 3);\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\tif (crypt_stat->tfm) {\n\t\trc = 0;\n\t\tgoto out_unlock;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name,\n\t\t\t\t\t\t    crypt_stat->cipher, \"cbc\");\n\tif (rc)\n\t\tgoto out_unlock;\n\tcrypt_stat->tfm = crypto_alloc_ablkcipher(full_alg_name, 0, 0);\n\tif (IS_ERR(crypt_stat->tfm)) {\n\t\trc = PTR_ERR(crypt_stat->tfm);\n\t\tcrypt_stat->tfm = NULL;\n\t\tecryptfs_printk(KERN_ERR, \"cryptfs: init_crypt_ctx(): \"\n\t\t\t\t\"Error initializing cipher [%s]\\n\",\n\t\t\t\tfull_alg_name);\n\t\tgoto out_free;\n\t}\n\tcrypto_ablkcipher_set_flags(crypt_stat->tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\trc = 0;\nout_free:\n\tkfree(full_alg_name);\nout_unlock:\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_compute_root_iv",
          "args": [
            "crypt_stat"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_compute_root_iv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "684-711",
          "snippet": "int ecryptfs_compute_root_iv(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\n\tBUG_ON(crypt_stat->iv_bytes > MD5_DIGEST_SIZE);\n\tBUG_ON(crypt_stat->iv_bytes <= 0);\n\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING, \"Session key not valid; \"\n\t\t\t\t\"cannot generate root IV\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, crypt_stat->key,\n\t\t\t\t    crypt_stat->key_size);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating root IV\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(crypt_stat->root_iv, dst, crypt_stat->iv_bytes);\nout:\n\tif (rc) {\n\t\tmemset(crypt_stat->root_iv, 0, crypt_stat->iv_bytes);\n\t\tcrypt_stat->flags |= ECRYPTFS_SECURITY_WARNING;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_compute_root_iv(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tint rc = 0;\n\tchar dst[MD5_DIGEST_SIZE];\n\n\tBUG_ON(crypt_stat->iv_bytes > MD5_DIGEST_SIZE);\n\tBUG_ON(crypt_stat->iv_bytes <= 0);\n\tif (!(crypt_stat->flags & ECRYPTFS_KEY_VALID)) {\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING, \"Session key not valid; \"\n\t\t\t\t\"cannot generate root IV\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_calculate_md5(dst, crypt_stat, crypt_stat->key,\n\t\t\t\t    crypt_stat->key_size);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error attempting to compute \"\n\t\t\t\t\"MD5 while generating root IV\\n\");\n\t\tgoto out;\n\t}\n\tmemcpy(crypt_stat->root_iv, dst, crypt_stat->iv_bytes);\nout:\n\tif (rc) {\n\t\tmemset(crypt_stat->root_iv, 0, crypt_stat->iv_bytes);\n\t\tcrypt_stat->flags |= ECRYPTFS_SECURITY_WARNING;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_auth_tok_list_item_cache",
            "auth_tok_list_item"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&auth_tok_list_item->list"
          ],
          "line": 1937
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "auth_tok_list_item",
            "auth_tok_list_item_tmp",
            "&auth_tok_list",
            "list"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "auth_tok_key"
          ],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&(auth_tok_key->sem)"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decrypt_passphrase_encrypted_session_key",
          "args": [
            "candidate_auth_tok",
            "crypt_stat"
          ],
          "line": 1916
        },
        "resolved": true,
        "details": {
          "function_name": "decrypt_passphrase_encrypted_session_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "1663-1742",
          "snippet": "static int\ndecrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,\n\t\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tstruct scatterlist dst_sg[2];\n\tstruct scatterlist src_sg[2];\n\tstruct mutex *tfm_mutex;\n\tstruct blkcipher_desc desc = {\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(\n\t\t\tKERN_DEBUG, \"Session key encryption key (size [%d]):\\n\",\n\t\t\tauth_tok->token.password.session_key_encryption_key_bytes);\n\t\tecryptfs_dump_hex(\n\t\t\tauth_tok->token.password.session_key_encryption_key,\n\t\t\tauth_tok->token.password.session_key_encryption_key_bytes);\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\n\t\t\t\t\t\t\tcrypt_stat->cipher);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       crypt_stat->cipher, rc);\n\t\tgoto out;\n\t}\n\trc = virt_to_scatterlist(auth_tok->session_key.encrypted_key,\n\t\t\t\t auth_tok->session_key.encrypted_key_size,\n\t\t\t\t src_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to convert \"\n\t\t\t\"auth_tok->session_key.encrypted_key to scatterlist; \"\n\t\t\t\"expected rc = 1; got rc = [%d]. \"\n\t\t       \"auth_tok->session_key.encrypted_key_size = [%d]\\n\", rc,\n\t\t\tauth_tok->session_key.encrypted_key_size);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.decrypted_key_size =\n\t\tauth_tok->session_key.encrypted_key_size;\n\trc = virt_to_scatterlist(auth_tok->session_key.decrypted_key,\n\t\t\t\t auth_tok->session_key.decrypted_key_size,\n\t\t\t\t dst_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to convert \"\n\t\t\t\"auth_tok->session_key.decrypted_key to scatterlist; \"\n\t\t\t\"expected rc = 1; got rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(tfm_mutex);\n\trc = crypto_blkcipher_setkey(\n\t\tdesc.tfm, auth_tok->token.password.session_key_encryption_key,\n\t\tcrypt_stat->key_size);\n\tif (unlikely(rc < 0)) {\n\t\tmutex_unlock(tfm_mutex);\n\t\tprintk(KERN_ERR \"Error setting key for crypto context\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = crypto_blkcipher_decrypt(&desc, dst_sg, src_sg,\n\t\t\t\t      auth_tok->session_key.encrypted_key_size);\n\tmutex_unlock(tfm_mutex);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Error decrypting; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\tmemcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,\n\t       auth_tok->session_key.decrypted_key_size);\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"FEK of size [%zd]:\\n\",\n\t\t\t\tcrypt_stat->key_size);\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\ndecrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,\n\t\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tstruct scatterlist dst_sg[2];\n\tstruct scatterlist src_sg[2];\n\tstruct mutex *tfm_mutex;\n\tstruct blkcipher_desc desc = {\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(\n\t\t\tKERN_DEBUG, \"Session key encryption key (size [%d]):\\n\",\n\t\t\tauth_tok->token.password.session_key_encryption_key_bytes);\n\t\tecryptfs_dump_hex(\n\t\t\tauth_tok->token.password.session_key_encryption_key,\n\t\t\tauth_tok->token.password.session_key_encryption_key_bytes);\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\n\t\t\t\t\t\t\tcrypt_stat->cipher);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       crypt_stat->cipher, rc);\n\t\tgoto out;\n\t}\n\trc = virt_to_scatterlist(auth_tok->session_key.encrypted_key,\n\t\t\t\t auth_tok->session_key.encrypted_key_size,\n\t\t\t\t src_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to convert \"\n\t\t\t\"auth_tok->session_key.encrypted_key to scatterlist; \"\n\t\t\t\"expected rc = 1; got rc = [%d]. \"\n\t\t       \"auth_tok->session_key.encrypted_key_size = [%d]\\n\", rc,\n\t\t\tauth_tok->session_key.encrypted_key_size);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.decrypted_key_size =\n\t\tauth_tok->session_key.encrypted_key_size;\n\trc = virt_to_scatterlist(auth_tok->session_key.decrypted_key,\n\t\t\t\t auth_tok->session_key.decrypted_key_size,\n\t\t\t\t dst_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to convert \"\n\t\t\t\"auth_tok->session_key.decrypted_key to scatterlist; \"\n\t\t\t\"expected rc = 1; got rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(tfm_mutex);\n\trc = crypto_blkcipher_setkey(\n\t\tdesc.tfm, auth_tok->token.password.session_key_encryption_key,\n\t\tcrypt_stat->key_size);\n\tif (unlikely(rc < 0)) {\n\t\tmutex_unlock(tfm_mutex);\n\t\tprintk(KERN_ERR \"Error setting key for crypto context\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = crypto_blkcipher_decrypt(&desc, dst_sg, src_sg,\n\t\t\t\t      auth_tok->session_key.encrypted_key_size);\n\tmutex_unlock(tfm_mutex);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Error decrypting; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\tmemcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,\n\t       auth_tok->session_key.decrypted_key_size);\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"FEK of size [%zd]:\\n\",\n\t\t\t\tcrypt_stat->key_size);\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&(auth_tok_key->sem)"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&(candidate_auth_tok->token.password)",
            "&(matching_auth_tok->token.password)",
            "sizeof(struct ecryptfs_password)"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decrypt_pki_encrypted_session_key",
          "args": [
            "candidate_auth_tok",
            "crypt_stat"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "decrypt_pki_encrypted_session_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "1143-1207",
          "snippet": "static int\ndecrypt_pki_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,\n\t\t\t\t  struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tu8 cipher_code = 0;\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tstruct ecryptfs_message *msg = NULL;\n\tchar *auth_tok_sig;\n\tchar *payload = NULL;\n\tsize_t payload_len = 0;\n\tint rc;\n\n\trc = ecryptfs_get_auth_tok_sig(&auth_tok_sig, auth_tok);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Unrecognized auth tok type: [%d]\\n\",\n\t\t       auth_tok->token_type);\n\t\tgoto out;\n\t}\n\trc = write_tag_64_packet(auth_tok_sig, &(auth_tok->session_key),\n\t\t\t\t &payload, &payload_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to write tag 64 packet\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_send_message(payload, payload_len, &msg_ctx);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error sending message to \"\n\t\t\t\t\"ecryptfsd: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_wait_for_response(msg_ctx, &msg);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to receive tag 65 packet \"\n\t\t\t\t\"from the user space daemon\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = parse_tag_65_packet(&(auth_tok->session_key),\n\t\t\t\t &cipher_code, msg);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to parse tag 65 packet; rc = [%d]\\n\",\n\t\t       rc);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\tmemcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,\n\t       auth_tok->session_key.decrypted_key_size);\n\tcrypt_stat->key_size = auth_tok->session_key.decrypted_key_size;\n\trc = ecryptfs_cipher_code_to_string(crypt_stat->cipher, cipher_code);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Cipher code [%d] is invalid\\n\",\n\t\t\t\tcipher_code)\n\t\tgoto out;\n\t}\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Decrypted session key:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\nout:\n\tkfree(msg);\n\tkfree(payload);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\ndecrypt_pki_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,\n\t\t\t\t  struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tu8 cipher_code = 0;\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tstruct ecryptfs_message *msg = NULL;\n\tchar *auth_tok_sig;\n\tchar *payload = NULL;\n\tsize_t payload_len = 0;\n\tint rc;\n\n\trc = ecryptfs_get_auth_tok_sig(&auth_tok_sig, auth_tok);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Unrecognized auth tok type: [%d]\\n\",\n\t\t       auth_tok->token_type);\n\t\tgoto out;\n\t}\n\trc = write_tag_64_packet(auth_tok_sig, &(auth_tok->session_key),\n\t\t\t\t &payload, &payload_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to write tag 64 packet\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_send_message(payload, payload_len, &msg_ctx);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error sending message to \"\n\t\t\t\t\"ecryptfsd: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_wait_for_response(msg_ctx, &msg);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to receive tag 65 packet \"\n\t\t\t\t\"from the user space daemon\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = parse_tag_65_packet(&(auth_tok->session_key),\n\t\t\t\t &cipher_code, msg);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to parse tag 65 packet; rc = [%d]\\n\",\n\t\t       rc);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\tmemcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,\n\t       auth_tok->session_key.decrypted_key_size);\n\tcrypt_stat->key_size = auth_tok->session_key.decrypted_key_size;\n\trc = ecryptfs_cipher_code_to_string(crypt_stat->cipher, cipher_code);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Cipher code [%d] is invalid\\n\",\n\t\t\t\tcipher_code)\n\t\tgoto out;\n\t}\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Decrypted session key:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\nout:\n\tkfree(msg);\n\tkfree(payload);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&(auth_tok_key->sem)"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&(candidate_auth_tok->token.private_key)",
            "&(matching_auth_tok->token.private_key)",
            "sizeof(struct ecryptfs_private_key)"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_find_auth_tok_for_sig",
          "args": [
            "&auth_tok_key",
            "&matching_auth_tok",
            "crypt_stat->mount_crypt_stat",
            "candidate_auth_tok_sig"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_find_auth_tok_for_sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "558-583",
          "snippet": "static int\necryptfs_find_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tchar *sig)\n{\n\tint rc = 0;\n\n\trc = ecryptfs_find_global_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t   mount_crypt_stat, sig);\n\tif (rc == -ENOENT) {\n\t\t/* if the flag ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY is set in the\n\t\t * mount_crypt_stat structure, we prevent to use auth toks that\n\t\t * are not inserted through the ecryptfs_add_global_auth_tok\n\t\t * function.\n\t\t */\n\t\tif (mount_crypt_stat->flags\n\t\t\t\t& ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY)\n\t\t\treturn -EINVAL;\n\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t       sig);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_find_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tchar *sig)\n{\n\tint rc = 0;\n\n\trc = ecryptfs_find_global_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t   mount_crypt_stat, sig);\n\tif (rc == -ENOENT) {\n\t\t/* if the flag ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY is set in the\n\t\t * mount_crypt_stat structure, we prevent to use auth toks that\n\t\t * are not inserted through the ecryptfs_add_global_auth_tok\n\t\t * function.\n\t\t */\n\t\tif (mount_crypt_stat->flags\n\t\t\t\t& ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY)\n\t\t\treturn -EINVAL;\n\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t       sig);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_auth_tok_sig",
          "args": [
            "&candidate_auth_tok_sig",
            "candidate_auth_tok"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_auth_tok_sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "1115-1134",
          "snippet": "static int\necryptfs_get_auth_tok_sig(char **sig, struct ecryptfs_auth_tok *auth_tok)\n{\n\tint rc = 0;\n\n\t(*sig) = NULL;\n\tswitch (auth_tok->token_type) {\n\tcase ECRYPTFS_PASSWORD:\n\t\t(*sig) = auth_tok->token.password.signature;\n\t\tbreak;\n\tcase ECRYPTFS_PRIVATE_KEY:\n\t\t(*sig) = auth_tok->token.private_key.signature;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Cannot get sig for auth_tok of type [%d]\\n\",\n\t\t       auth_tok->token_type);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_get_auth_tok_sig(char **sig, struct ecryptfs_auth_tok *auth_tok)\n{\n\tint rc = 0;\n\n\t(*sig) = NULL;\n\tswitch (auth_tok->token_type) {\n\tcase ECRYPTFS_PASSWORD:\n\t\t(*sig) = auth_tok->token.password.signature;\n\t\tbreak;\n\tcase ECRYPTFS_PRIVATE_KEY:\n\t\t(*sig) = auth_tok->token.private_key.signature;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Cannot get sig for auth_tok of type [%d]\\n\",\n\t\t       auth_tok->token_type);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_dump_auth_tok",
          "args": [
            "candidate_auth_tok"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dump_auth_tok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/debug.c",
          "lines": "32-89",
          "snippet": "void ecryptfs_dump_auth_tok(struct ecryptfs_auth_tok *auth_tok)\n{\n\tchar salt[ECRYPTFS_SALT_SIZE * 2 + 1];\n\tchar sig[ECRYPTFS_SIG_SIZE_HEX + 1];\n\n\tecryptfs_printk(KERN_DEBUG, \"Auth tok at mem loc [%p]:\\n\",\n\t\t\tauth_tok);\n\tif (auth_tok->flags & ECRYPTFS_PRIVATE_KEY) {\n\t\tecryptfs_printk(KERN_DEBUG, \" * private key type\\n\");\n\t} else {\n\t\tecryptfs_printk(KERN_DEBUG, \" * passphrase type\\n\");\n\t\tecryptfs_to_hex(salt, auth_tok->token.password.salt,\n\t\t\t\tECRYPTFS_SALT_SIZE);\n\t\tsalt[ECRYPTFS_SALT_SIZE * 2] = '\\0';\n\t\tecryptfs_printk(KERN_DEBUG, \" * salt = [%s]\\n\", salt);\n\t\tif (auth_tok->token.password.flags &\n\t\t    ECRYPTFS_PERSISTENT_PASSWORD) {\n\t\t\tecryptfs_printk(KERN_DEBUG, \" * persistent\\n\");\n\t\t}\n\t\tmemcpy(sig, auth_tok->token.password.signature,\n\t\t       ECRYPTFS_SIG_SIZE_HEX);\n\t\tsig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\tecryptfs_printk(KERN_DEBUG, \" * signature = [%s]\\n\", sig);\n\t}\n\tecryptfs_printk(KERN_DEBUG, \" * session_key.flags = [0x%x]\\n\",\n\t\t\tauth_tok->session_key.flags);\n\tif (auth_tok->session_key.flags\n\t    & ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT)\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\" * Userspace decrypt request set\\n\");\n\tif (auth_tok->session_key.flags\n\t    & ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT)\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\" * Userspace encrypt request set\\n\");\n\tif (auth_tok->session_key.flags & ECRYPTFS_CONTAINS_DECRYPTED_KEY) {\n\t\tecryptfs_printk(KERN_DEBUG, \" * Contains decrypted key\\n\");\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\" * session_key.decrypted_key_size = [0x%x]\\n\",\n\t\t\t\tauth_tok->session_key.decrypted_key_size);\n\t\tecryptfs_printk(KERN_DEBUG, \" * Decrypted session key \"\n\t\t\t\t\"dump:\\n\");\n\t\tif (ecryptfs_verbosity > 0)\n\t\t\tecryptfs_dump_hex(auth_tok->session_key.decrypted_key,\n\t\t\t\t\t  ECRYPTFS_DEFAULT_KEY_BYTES);\n\t}\n\tif (auth_tok->session_key.flags & ECRYPTFS_CONTAINS_ENCRYPTED_KEY) {\n\t\tecryptfs_printk(KERN_DEBUG, \" * Contains encrypted key\\n\");\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\" * session_key.encrypted_key_size = [0x%x]\\n\",\n\t\t\t\tauth_tok->session_key.encrypted_key_size);\n\t\tecryptfs_printk(KERN_DEBUG, \" * Encrypted session key \"\n\t\t\t\t\"dump:\\n\");\n\t\tif (ecryptfs_verbosity > 0)\n\t\t\tecryptfs_dump_hex(auth_tok->session_key.encrypted_key,\n\t\t\t\t\t  auth_tok->session_key.\n\t\t\t\t\t  encrypted_key_size);\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n\nvoid ecryptfs_dump_auth_tok(struct ecryptfs_auth_tok *auth_tok)\n{\n\tchar salt[ECRYPTFS_SALT_SIZE * 2 + 1];\n\tchar sig[ECRYPTFS_SIG_SIZE_HEX + 1];\n\n\tecryptfs_printk(KERN_DEBUG, \"Auth tok at mem loc [%p]:\\n\",\n\t\t\tauth_tok);\n\tif (auth_tok->flags & ECRYPTFS_PRIVATE_KEY) {\n\t\tecryptfs_printk(KERN_DEBUG, \" * private key type\\n\");\n\t} else {\n\t\tecryptfs_printk(KERN_DEBUG, \" * passphrase type\\n\");\n\t\tecryptfs_to_hex(salt, auth_tok->token.password.salt,\n\t\t\t\tECRYPTFS_SALT_SIZE);\n\t\tsalt[ECRYPTFS_SALT_SIZE * 2] = '\\0';\n\t\tecryptfs_printk(KERN_DEBUG, \" * salt = [%s]\\n\", salt);\n\t\tif (auth_tok->token.password.flags &\n\t\t    ECRYPTFS_PERSISTENT_PASSWORD) {\n\t\t\tecryptfs_printk(KERN_DEBUG, \" * persistent\\n\");\n\t\t}\n\t\tmemcpy(sig, auth_tok->token.password.signature,\n\t\t       ECRYPTFS_SIG_SIZE_HEX);\n\t\tsig[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t\tecryptfs_printk(KERN_DEBUG, \" * signature = [%s]\\n\", sig);\n\t}\n\tecryptfs_printk(KERN_DEBUG, \" * session_key.flags = [0x%x]\\n\",\n\t\t\tauth_tok->session_key.flags);\n\tif (auth_tok->session_key.flags\n\t    & ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT)\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\" * Userspace decrypt request set\\n\");\n\tif (auth_tok->session_key.flags\n\t    & ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT)\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\" * Userspace encrypt request set\\n\");\n\tif (auth_tok->session_key.flags & ECRYPTFS_CONTAINS_DECRYPTED_KEY) {\n\t\tecryptfs_printk(KERN_DEBUG, \" * Contains decrypted key\\n\");\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\" * session_key.decrypted_key_size = [0x%x]\\n\",\n\t\t\t\tauth_tok->session_key.decrypted_key_size);\n\t\tecryptfs_printk(KERN_DEBUG, \" * Decrypted session key \"\n\t\t\t\t\"dump:\\n\");\n\t\tif (ecryptfs_verbosity > 0)\n\t\t\tecryptfs_dump_hex(auth_tok->session_key.decrypted_key,\n\t\t\t\t\t  ECRYPTFS_DEFAULT_KEY_BYTES);\n\t}\n\tif (auth_tok->session_key.flags & ECRYPTFS_CONTAINS_ENCRYPTED_KEY) {\n\t\tecryptfs_printk(KERN_DEBUG, \" * Contains encrypted key\\n\");\n\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\" * session_key.encrypted_key_size = [0x%x]\\n\",\n\t\t\t\tauth_tok->session_key.encrypted_key_size);\n\t\tecryptfs_printk(KERN_DEBUG, \" * Encrypted session key \"\n\t\t\t\t\"dump:\\n\");\n\t\tif (ecryptfs_verbosity > 0)\n\t\t\tecryptfs_dump_hex(auth_tok->session_key.encrypted_key,\n\t\t\t\t\t  auth_tok->session_key.\n\t\t\t\t\t  encrypted_key_size);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ecryptfs_verbosity > 0"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "auth_tok_list_item",
            "&auth_tok_list",
            "list"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&auth_tok_list"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_tag_1_packet",
          "args": [
            "crypt_stat",
            "(unsigned char *)&src[i]",
            "&auth_tok_list",
            "&new_auth_tok",
            "&packet_size",
            "max_packet_size"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "parse_tag_1_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "1241-1353",
          "snippet": "static int\nparse_tag_1_packet(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   unsigned char *data, struct list_head *auth_tok_list,\n\t\t   struct ecryptfs_auth_tok **new_auth_tok,\n\t\t   size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*new_auth_tok) = NULL;\n\t/**\n\t * This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 1\n\t *\n\t * Tag 1 identifier (1 byte)\n\t * Max Tag 1 packet size (max 3 bytes)\n\t * Version (1 byte)\n\t * Key identifier (8 bytes; ECRYPTFS_SIG_SIZE)\n\t * Cipher identifier (1 byte)\n\t * Encrypted key size (arbitrary)\n\t *\n\t * 12 bytes minimum packet size\n\t */\n\tif (unlikely(max_packet_size < 12)) {\n\t\tprintk(KERN_ERR \"Invalid max packet size; must be >=12\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_1_PACKET_TYPE) {\n\t\tprintk(KERN_ERR \"Enter w/ first byte != 0x%.2x\\n\",\n\t\t       ECRYPTFS_TAG_1_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released: wipe_auth_tok_list called in ecryptfs_parse_packet_set or\n\t * at end of function upon failure */\n\tauth_tok_list_item =\n\t\tkmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache,\n\t\t\t\t  GFP_KERNEL);\n\tif (!auth_tok_list_item) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*new_auth_tok) = &auth_tok_list_item->auth_tok;\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Error parsing packet length; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\t\tgoto out_free;\n\t}\n\tif (unlikely(body_size < (ECRYPTFS_SIG_SIZE + 2))) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*packet_size) += length_size;\n\tif (unlikely((*packet_size) + body_size > max_packet_size)) {\n\t\tprintk(KERN_WARNING \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (unlikely(data[(*packet_size)++] != 0x03)) {\n\t\tprintk(KERN_WARNING \"Unknown version number [%d]\\n\",\n\t\t       data[(*packet_size) - 1]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tecryptfs_to_hex((*new_auth_tok)->token.private_key.signature,\n\t\t\t&data[(*packet_size)], ECRYPTFS_SIG_SIZE);\n\t*packet_size += ECRYPTFS_SIG_SIZE;\n\t/* This byte is skipped because the kernel does not need to\n\t * know which public key encryption algorithm was used */\n\t(*packet_size)++;\n\t(*new_auth_tok)->session_key.encrypted_key_size =\n\t\tbody_size - (ECRYPTFS_SIG_SIZE + 2);\n\tif ((*new_auth_tok)->session_key.encrypted_key_size\n\t    > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\tprintk(KERN_WARNING \"Tag 1 packet contains key larger \"\n\t\t       \"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tmemcpy((*new_auth_tok)->session_key.encrypted_key,\n\t       &data[(*packet_size)], (body_size - (ECRYPTFS_SIG_SIZE + 2)));\n\t(*packet_size) += (*new_auth_tok)->session_key.encrypted_key_size;\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\t(*new_auth_tok)->session_key.flags |=\n\t\tECRYPTFS_CONTAINS_ENCRYPTED_KEY;\n\t(*new_auth_tok)->token_type = ECRYPTFS_PRIVATE_KEY;\n\t(*new_auth_tok)->flags = 0;\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\n\tlist_add(&auth_tok_list_item->list, auth_tok_list);\n\tgoto out;\nout_free:\n\t(*new_auth_tok) = NULL;\n\tmemset(auth_tok_list_item, 0,\n\t       sizeof(struct ecryptfs_auth_tok_list_item));\n\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\tauth_tok_list_item);\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_auth_tok_list_item_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_auth_tok_list_item_cache;\n\nstatic int\nparse_tag_1_packet(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   unsigned char *data, struct list_head *auth_tok_list,\n\t\t   struct ecryptfs_auth_tok **new_auth_tok,\n\t\t   size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*new_auth_tok) = NULL;\n\t/**\n\t * This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 1\n\t *\n\t * Tag 1 identifier (1 byte)\n\t * Max Tag 1 packet size (max 3 bytes)\n\t * Version (1 byte)\n\t * Key identifier (8 bytes; ECRYPTFS_SIG_SIZE)\n\t * Cipher identifier (1 byte)\n\t * Encrypted key size (arbitrary)\n\t *\n\t * 12 bytes minimum packet size\n\t */\n\tif (unlikely(max_packet_size < 12)) {\n\t\tprintk(KERN_ERR \"Invalid max packet size; must be >=12\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_1_PACKET_TYPE) {\n\t\tprintk(KERN_ERR \"Enter w/ first byte != 0x%.2x\\n\",\n\t\t       ECRYPTFS_TAG_1_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released: wipe_auth_tok_list called in ecryptfs_parse_packet_set or\n\t * at end of function upon failure */\n\tauth_tok_list_item =\n\t\tkmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache,\n\t\t\t\t  GFP_KERNEL);\n\tif (!auth_tok_list_item) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*new_auth_tok) = &auth_tok_list_item->auth_tok;\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Error parsing packet length; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\t\tgoto out_free;\n\t}\n\tif (unlikely(body_size < (ECRYPTFS_SIG_SIZE + 2))) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*packet_size) += length_size;\n\tif (unlikely((*packet_size) + body_size > max_packet_size)) {\n\t\tprintk(KERN_WARNING \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (unlikely(data[(*packet_size)++] != 0x03)) {\n\t\tprintk(KERN_WARNING \"Unknown version number [%d]\\n\",\n\t\t       data[(*packet_size) - 1]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tecryptfs_to_hex((*new_auth_tok)->token.private_key.signature,\n\t\t\t&data[(*packet_size)], ECRYPTFS_SIG_SIZE);\n\t*packet_size += ECRYPTFS_SIG_SIZE;\n\t/* This byte is skipped because the kernel does not need to\n\t * know which public key encryption algorithm was used */\n\t(*packet_size)++;\n\t(*new_auth_tok)->session_key.encrypted_key_size =\n\t\tbody_size - (ECRYPTFS_SIG_SIZE + 2);\n\tif ((*new_auth_tok)->session_key.encrypted_key_size\n\t    > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\tprintk(KERN_WARNING \"Tag 1 packet contains key larger \"\n\t\t       \"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tmemcpy((*new_auth_tok)->session_key.encrypted_key,\n\t       &data[(*packet_size)], (body_size - (ECRYPTFS_SIG_SIZE + 2)));\n\t(*packet_size) += (*new_auth_tok)->session_key.encrypted_key_size;\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\t(*new_auth_tok)->session_key.flags |=\n\t\tECRYPTFS_CONTAINS_ENCRYPTED_KEY;\n\t(*new_auth_tok)->token_type = ECRYPTFS_PRIVATE_KEY;\n\t(*new_auth_tok)->flags = 0;\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\n\tlist_add(&auth_tok_list_item->list, auth_tok_list);\n\tgoto out;\nout_free:\n\t(*new_auth_tok) = NULL;\n\tmemset(auth_tok_list_item, 0,\n\t       sizeof(struct ecryptfs_auth_tok_list_item));\n\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\tauth_tok_list_item);\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_to_hex",
          "args": [
            "new_auth_tok->token.password.signature",
            "sig_tmp_space",
            "tag_11_contents_size"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_to_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "50-56",
          "snippet": "void ecryptfs_to_hex(char *dst, char *src, size_t src_size)\n{\n\tint x;\n\n\tfor (x = 0; x < src_size; x++)\n\t\tsprintf(&dst[x * 2], \"%.2x\", (unsigned char)src[x]);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_to_hex(char *dst, char *src, size_t src_size)\n{\n\tint x;\n\n\tfor (x = 0; x < src_size; x++)\n\t\tsprintf(&dst[x * 2], \"%.2x\", (unsigned char)src[x]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_tag_11_packet",
          "args": [
            "(unsigned char *)&src[i]",
            "sig_tmp_space",
            "ECRYPTFS_SIG_SIZE",
            "&tag_11_contents_size",
            "&tag_11_packet_size",
            "max_packet_size"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "parse_tag_11_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "1547-1625",
          "snippet": "static int\nparse_tag_11_packet(unsigned char *data, unsigned char *contents,\n\t\t    size_t max_contents_bytes, size_t *tag_11_contents_size,\n\t\t    size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*tag_11_contents_size) = 0;\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 11\n\t *\n\t * Tag 11 identifier (1 byte)\n\t * Max Tag 11 packet size (max 3 bytes)\n\t * Binary format specifier (1 byte)\n\t * Filename length (1 byte)\n\t * Filename (\"_CONSOLE\") (8 bytes)\n\t * Modification date (4 bytes)\n\t * Literal data (arbitrary)\n\t *\n\t * We need at least 16 bytes of data for the packet to even be\n\t * valid.\n\t */\n\tif (max_packet_size < 16) {\n\t\tprintk(KERN_ERR \"Maximum packet size too small\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_11_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\tgoto out;\n\t}\n\tif (body_size < 14) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += length_size;\n\t(*tag_11_contents_size) = (body_size - 14);\n\tif (unlikely((*packet_size) + body_size + 1 > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (unlikely((*tag_11_contents_size) > max_contents_bytes)) {\n\t\tprintk(KERN_ERR \"Literal data section in tag 11 packet exceeds \"\n\t\t       \"expected size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x62) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x08) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += 12; /* Ignore filename and modification date */\n\tmemcpy(contents, &data[(*packet_size)], (*tag_11_contents_size));\n\t(*packet_size) += (*tag_11_contents_size);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*tag_11_contents_size) = 0;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nparse_tag_11_packet(unsigned char *data, unsigned char *contents,\n\t\t    size_t max_contents_bytes, size_t *tag_11_contents_size,\n\t\t    size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*tag_11_contents_size) = 0;\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 11\n\t *\n\t * Tag 11 identifier (1 byte)\n\t * Max Tag 11 packet size (max 3 bytes)\n\t * Binary format specifier (1 byte)\n\t * Filename length (1 byte)\n\t * Filename (\"_CONSOLE\") (8 bytes)\n\t * Modification date (4 bytes)\n\t * Literal data (arbitrary)\n\t *\n\t * We need at least 16 bytes of data for the packet to even be\n\t * valid.\n\t */\n\tif (max_packet_size < 16) {\n\t\tprintk(KERN_ERR \"Maximum packet size too small\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_11_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\tgoto out;\n\t}\n\tif (body_size < 14) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += length_size;\n\t(*tag_11_contents_size) = (body_size - 14);\n\tif (unlikely((*packet_size) + body_size + 1 > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (unlikely((*tag_11_contents_size) > max_contents_bytes)) {\n\t\tprintk(KERN_ERR \"Literal data section in tag 11 packet exceeds \"\n\t\t       \"expected size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x62) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x08) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += 12; /* Ignore filename and modification date */\n\tmemcpy(contents, &data[(*packet_size)], (*tag_11_contents_size));\n\t(*packet_size) += (*tag_11_contents_size);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*tag_11_contents_size) = 0;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_tag_3_packet",
          "args": [
            "crypt_stat",
            "(unsigned char *)&src[i]",
            "&auth_tok_list",
            "&new_auth_tok",
            "&packet_size",
            "max_packet_size"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "parse_tag_3_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "1373-1529",
          "snippet": "static int\nparse_tag_3_packet(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   unsigned char *data, struct list_head *auth_tok_list,\n\t\t   struct ecryptfs_auth_tok **new_auth_tok,\n\t\t   size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*new_auth_tok) = NULL;\n\t/**\n\t *This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 3\n\t *\n\t * Tag 3 identifier (1 byte)\n\t * Max Tag 3 packet size (max 3 bytes)\n\t * Version (1 byte)\n\t * Cipher code (1 byte)\n\t * S2K specifier (1 byte)\n\t * Hash identifier (1 byte)\n\t * Salt (ECRYPTFS_SALT_SIZE)\n\t * Hash iterations (1 byte)\n\t * Encrypted key (arbitrary)\n\t *\n\t * (ECRYPTFS_SALT_SIZE + 7) minimum packet size\n\t */\n\tif (max_packet_size < (ECRYPTFS_SALT_SIZE + 7)) {\n\t\tprintk(KERN_ERR \"Max packet size too large\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_3_PACKET_TYPE) {\n\t\tprintk(KERN_ERR \"First byte != 0x%.2x; invalid packet\\n\",\n\t\t       ECRYPTFS_TAG_3_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released: wipe_auth_tok_list called in ecryptfs_parse_packet_set or\n\t * at end of function upon failure */\n\tauth_tok_list_item =\n\t    kmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache, GFP_KERNEL);\n\tif (!auth_tok_list_item) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*new_auth_tok) = &auth_tok_list_item->auth_tok;\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Error parsing packet length; rc = [%d]\\n\",\n\t\t       rc);\n\t\tgoto out_free;\n\t}\n\tif (unlikely(body_size < (ECRYPTFS_SALT_SIZE + 5))) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*packet_size) += length_size;\n\tif (unlikely((*packet_size) + body_size > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->session_key.encrypted_key_size =\n\t\t(body_size - (ECRYPTFS_SALT_SIZE + 5));\n\tif ((*new_auth_tok)->session_key.encrypted_key_size\n\t    > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\tprintk(KERN_WARNING \"Tag 3 packet contains key larger \"\n\t\t       \"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (unlikely(data[(*packet_size)++] != 0x04)) {\n\t\tprintk(KERN_WARNING \"Unknown version number [%d]\\n\",\n\t\t       data[(*packet_size) - 1]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\trc = ecryptfs_cipher_code_to_string(crypt_stat->cipher,\n\t\t\t\t\t    (u16)data[(*packet_size)]);\n\tif (rc)\n\t\tgoto out_free;\n\t/* A little extra work to differentiate among the AES key\n\t * sizes; see RFC2440 */\n\tswitch(data[(*packet_size)++]) {\n\tcase RFC2440_CIPHER_AES_192:\n\t\tcrypt_stat->key_size = 24;\n\t\tbreak;\n\tdefault:\n\t\tcrypt_stat->key_size =\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t}\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc)\n\t\tgoto out_free;\n\tif (unlikely(data[(*packet_size)++] != 0x03)) {\n\t\tprintk(KERN_WARNING \"Only S2K ID 3 is currently supported\\n\");\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t/* TODO: finish the hash mapping */\n\tswitch (data[(*packet_size)++]) {\n\tcase 0x01: /* See RFC2440 for these numbers and their mappings */\n\t\t/* Choose MD5 */\n\t\tmemcpy((*new_auth_tok)->token.password.salt,\n\t\t       &data[(*packet_size)], ECRYPTFS_SALT_SIZE);\n\t\t(*packet_size) += ECRYPTFS_SALT_SIZE;\n\t\t/* This conversion was taken straight from RFC2440 */\n\t\t(*new_auth_tok)->token.password.hash_iterations =\n\t\t\t((u32) 16 + (data[(*packet_size)] & 15))\n\t\t\t\t<< ((data[(*packet_size)] >> 4) + 6);\n\t\t(*packet_size)++;\n\t\t/* Friendly reminder:\n\t\t * (*new_auth_tok)->session_key.encrypted_key_size =\n\t\t *         (body_size - (ECRYPTFS_SALT_SIZE + 5)); */\n\t\tmemcpy((*new_auth_tok)->session_key.encrypted_key,\n\t\t       &data[(*packet_size)],\n\t\t       (*new_auth_tok)->session_key.encrypted_key_size);\n\t\t(*packet_size) +=\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t\t(*new_auth_tok)->session_key.flags &=\n\t\t\t~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\t\t(*new_auth_tok)->session_key.flags |=\n\t\t\tECRYPTFS_CONTAINS_ENCRYPTED_KEY;\n\t\t(*new_auth_tok)->token.password.hash_algo = 0x01; /* MD5 */\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_ERR, \"Unsupported hash algorithm: \"\n\t\t\t\t\"[%d]\\n\", data[(*packet_size) - 1]);\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->token_type = ECRYPTFS_PASSWORD;\n\t/* TODO: Parametarize; we might actually want userspace to\n\t * decrypt the session key. */\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\n\tlist_add(&auth_tok_list_item->list, auth_tok_list);\n\tgoto out;\nout_free:\n\t(*new_auth_tok) = NULL;\n\tmemset(auth_tok_list_item, 0,\n\t       sizeof(struct ecryptfs_auth_tok_list_item));\n\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\tauth_tok_list_item);\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *ecryptfs_auth_tok_list_item_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_auth_tok_list_item_cache;\n\nstatic int\nparse_tag_3_packet(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   unsigned char *data, struct list_head *auth_tok_list,\n\t\t   struct ecryptfs_auth_tok **new_auth_tok,\n\t\t   size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*new_auth_tok) = NULL;\n\t/**\n\t *This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 3\n\t *\n\t * Tag 3 identifier (1 byte)\n\t * Max Tag 3 packet size (max 3 bytes)\n\t * Version (1 byte)\n\t * Cipher code (1 byte)\n\t * S2K specifier (1 byte)\n\t * Hash identifier (1 byte)\n\t * Salt (ECRYPTFS_SALT_SIZE)\n\t * Hash iterations (1 byte)\n\t * Encrypted key (arbitrary)\n\t *\n\t * (ECRYPTFS_SALT_SIZE + 7) minimum packet size\n\t */\n\tif (max_packet_size < (ECRYPTFS_SALT_SIZE + 7)) {\n\t\tprintk(KERN_ERR \"Max packet size too large\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_3_PACKET_TYPE) {\n\t\tprintk(KERN_ERR \"First byte != 0x%.2x; invalid packet\\n\",\n\t\t       ECRYPTFS_TAG_3_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released: wipe_auth_tok_list called in ecryptfs_parse_packet_set or\n\t * at end of function upon failure */\n\tauth_tok_list_item =\n\t    kmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache, GFP_KERNEL);\n\tif (!auth_tok_list_item) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*new_auth_tok) = &auth_tok_list_item->auth_tok;\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Error parsing packet length; rc = [%d]\\n\",\n\t\t       rc);\n\t\tgoto out_free;\n\t}\n\tif (unlikely(body_size < (ECRYPTFS_SALT_SIZE + 5))) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*packet_size) += length_size;\n\tif (unlikely((*packet_size) + body_size > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->session_key.encrypted_key_size =\n\t\t(body_size - (ECRYPTFS_SALT_SIZE + 5));\n\tif ((*new_auth_tok)->session_key.encrypted_key_size\n\t    > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\tprintk(KERN_WARNING \"Tag 3 packet contains key larger \"\n\t\t       \"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (unlikely(data[(*packet_size)++] != 0x04)) {\n\t\tprintk(KERN_WARNING \"Unknown version number [%d]\\n\",\n\t\t       data[(*packet_size) - 1]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\trc = ecryptfs_cipher_code_to_string(crypt_stat->cipher,\n\t\t\t\t\t    (u16)data[(*packet_size)]);\n\tif (rc)\n\t\tgoto out_free;\n\t/* A little extra work to differentiate among the AES key\n\t * sizes; see RFC2440 */\n\tswitch(data[(*packet_size)++]) {\n\tcase RFC2440_CIPHER_AES_192:\n\t\tcrypt_stat->key_size = 24;\n\t\tbreak;\n\tdefault:\n\t\tcrypt_stat->key_size =\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t}\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc)\n\t\tgoto out_free;\n\tif (unlikely(data[(*packet_size)++] != 0x03)) {\n\t\tprintk(KERN_WARNING \"Only S2K ID 3 is currently supported\\n\");\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t/* TODO: finish the hash mapping */\n\tswitch (data[(*packet_size)++]) {\n\tcase 0x01: /* See RFC2440 for these numbers and their mappings */\n\t\t/* Choose MD5 */\n\t\tmemcpy((*new_auth_tok)->token.password.salt,\n\t\t       &data[(*packet_size)], ECRYPTFS_SALT_SIZE);\n\t\t(*packet_size) += ECRYPTFS_SALT_SIZE;\n\t\t/* This conversion was taken straight from RFC2440 */\n\t\t(*new_auth_tok)->token.password.hash_iterations =\n\t\t\t((u32) 16 + (data[(*packet_size)] & 15))\n\t\t\t\t<< ((data[(*packet_size)] >> 4) + 6);\n\t\t(*packet_size)++;\n\t\t/* Friendly reminder:\n\t\t * (*new_auth_tok)->session_key.encrypted_key_size =\n\t\t *         (body_size - (ECRYPTFS_SALT_SIZE + 5)); */\n\t\tmemcpy((*new_auth_tok)->session_key.encrypted_key,\n\t\t       &data[(*packet_size)],\n\t\t       (*new_auth_tok)->session_key.encrypted_key_size);\n\t\t(*packet_size) +=\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t\t(*new_auth_tok)->session_key.flags &=\n\t\t\t~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\t\t(*new_auth_tok)->session_key.flags |=\n\t\t\tECRYPTFS_CONTAINS_ENCRYPTED_KEY;\n\t\t(*new_auth_tok)->token.password.hash_algo = 0x01; /* MD5 */\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_ERR, \"Unsupported hash algorithm: \"\n\t\t\t\t\"[%d]\\n\", data[(*packet_size) - 1]);\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->token_type = ECRYPTFS_PASSWORD;\n\t/* TODO: Parametarize; we might actually want userspace to\n\t * decrypt the session key. */\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\n\tlist_add(&auth_tok_list_item->list, auth_tok_list);\n\tgoto out;\nout_free:\n\t(*new_auth_tok) = NULL;\n\tmemset(auth_tok_list_item, 0,\n\t       sizeof(struct ecryptfs_auth_tok_list_item));\n\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\tauth_tok_list_item);\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&auth_tok_list"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_auth_tok_list_item_cache;\n\nint ecryptfs_parse_packet_set(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t      unsigned char *src,\n\t\t\t      struct dentry *ecryptfs_dentry)\n{\n\tsize_t i = 0;\n\tsize_t found_auth_tok;\n\tsize_t next_packet_is_auth_tok_packet;\n\tstruct list_head auth_tok_list;\n\tstruct ecryptfs_auth_tok *matching_auth_tok;\n\tstruct ecryptfs_auth_tok *candidate_auth_tok;\n\tchar *candidate_auth_tok_sig;\n\tsize_t packet_size;\n\tstruct ecryptfs_auth_tok *new_auth_tok;\n\tunsigned char sig_tmp_space[ECRYPTFS_SIG_SIZE];\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t tag_11_contents_size;\n\tsize_t tag_11_packet_size;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\tINIT_LIST_HEAD(&auth_tok_list);\n\t/* Parse the header to find as many packets as we can; these will be\n\t * added the our &auth_tok_list */\n\tnext_packet_is_auth_tok_packet = 1;\n\twhile (next_packet_is_auth_tok_packet) {\n\t\tsize_t max_packet_size = ((PAGE_CACHE_SIZE - 8) - i);\n\n\t\tswitch (src[i]) {\n\t\tcase ECRYPTFS_TAG_3_PACKET_TYPE:\n\t\t\trc = parse_tag_3_packet(crypt_stat,\n\t\t\t\t\t\t(unsigned char *)&src[i],\n\t\t\t\t\t\t&auth_tok_list, &new_auth_tok,\n\t\t\t\t\t\t&packet_size, max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error parsing \"\n\t\t\t\t\t\t\"tag 3 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += packet_size;\n\t\t\trc = parse_tag_11_packet((unsigned char *)&src[i],\n\t\t\t\t\t\t sig_tmp_space,\n\t\t\t\t\t\t ECRYPTFS_SIG_SIZE,\n\t\t\t\t\t\t &tag_11_contents_size,\n\t\t\t\t\t\t &tag_11_packet_size,\n\t\t\t\t\t\t max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"No valid \"\n\t\t\t\t\t\t\"(ecryptfs-specific) literal \"\n\t\t\t\t\t\t\"packet containing \"\n\t\t\t\t\t\t\"authentication token \"\n\t\t\t\t\t\t\"signature found after \"\n\t\t\t\t\t\t\"tag 3 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += tag_11_packet_size;\n\t\t\tif (ECRYPTFS_SIG_SIZE != tag_11_contents_size) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Expected \"\n\t\t\t\t\t\t\"signature of size [%d]; \"\n\t\t\t\t\t\t\"read size [%zd]\\n\",\n\t\t\t\t\t\tECRYPTFS_SIG_SIZE,\n\t\t\t\t\t\ttag_11_contents_size);\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\tecryptfs_to_hex(new_auth_tok->token.password.signature,\n\t\t\t\t\tsig_tmp_space, tag_11_contents_size);\n\t\t\tnew_auth_tok->token.password.signature[\n\t\t\t\tECRYPTFS_PASSWORD_SIG_SIZE] = '\\0';\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPTED;\n\t\t\tbreak;\n\t\tcase ECRYPTFS_TAG_1_PACKET_TYPE:\n\t\t\trc = parse_tag_1_packet(crypt_stat,\n\t\t\t\t\t\t(unsigned char *)&src[i],\n\t\t\t\t\t\t&auth_tok_list, &new_auth_tok,\n\t\t\t\t\t\t&packet_size, max_packet_size);\n\t\t\tif (rc) {\n\t\t\t\tecryptfs_printk(KERN_ERR, \"Error parsing \"\n\t\t\t\t\t\t\"tag 1 packet\\n\");\n\t\t\t\trc = -EIO;\n\t\t\t\tgoto out_wipe_list;\n\t\t\t}\n\t\t\ti += packet_size;\n\t\t\tcrypt_stat->flags |= ECRYPTFS_ENCRYPTED;\n\t\t\tbreak;\n\t\tcase ECRYPTFS_TAG_11_PACKET_TYPE:\n\t\t\tecryptfs_printk(KERN_WARNING, \"Invalid packet set \"\n\t\t\t\t\t\"(Tag 11 not allowed by itself)\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto out_wipe_list;\n\t\tdefault:\n\t\t\tecryptfs_printk(KERN_DEBUG, \"No packet at offset [%zd] \"\n\t\t\t\t\t\"of the file header; hex value of \"\n\t\t\t\t\t\"character is [0x%.2x]\\n\", i, src[i]);\n\t\t\tnext_packet_is_auth_tok_packet = 0;\n\t\t}\n\t}\n\tif (list_empty(&auth_tok_list)) {\n\t\tprintk(KERN_ERR \"The lower file appears to be a non-encrypted \"\n\t\t       \"eCryptfs file; this is not supported in this version \"\n\t\t       \"of the eCryptfs kernel module\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* auth_tok_list contains the set of authentication tokens\n\t * parsed from the metadata. We need to find a matching\n\t * authentication token that has the secret component(s)\n\t * necessary to decrypt the EFEK in the auth_tok parsed from\n\t * the metadata. There may be several potential matches, but\n\t * just one will be sufficient to decrypt to get the FEK. */\nfind_next_matching_auth_tok:\n\tfound_auth_tok = 0;\n\tlist_for_each_entry(auth_tok_list_item, &auth_tok_list, list) {\n\t\tcandidate_auth_tok = &auth_tok_list_item->auth_tok;\n\t\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\t\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\t\t\"Considering cadidate auth tok:\\n\");\n\t\t\tecryptfs_dump_auth_tok(candidate_auth_tok);\n\t\t}\n\t\trc = ecryptfs_get_auth_tok_sig(&candidate_auth_tok_sig,\n\t\t\t\t\t       candidate_auth_tok);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"Unrecognized candidate auth tok type: [%d]\\n\",\n\t\t\t       candidate_auth_tok->token_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out_wipe_list;\n\t\t}\n\t\trc = ecryptfs_find_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t       &matching_auth_tok,\n\t\t\t\t\t       crypt_stat->mount_crypt_stat,\n\t\t\t\t\t       candidate_auth_tok_sig);\n\t\tif (!rc) {\n\t\t\tfound_auth_tok = 1;\n\t\t\tgoto found_matching_auth_tok;\n\t\t}\n\t}\n\tif (!found_auth_tok) {\n\t\tecryptfs_printk(KERN_ERR, \"Could not find a usable \"\n\t\t\t\t\"authentication token\\n\");\n\t\trc = -EIO;\n\t\tgoto out_wipe_list;\n\t}\nfound_matching_auth_tok:\n\tif (candidate_auth_tok->token_type == ECRYPTFS_PRIVATE_KEY) {\n\t\tmemcpy(&(candidate_auth_tok->token.private_key),\n\t\t       &(matching_auth_tok->token.private_key),\n\t\t       sizeof(struct ecryptfs_private_key));\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = decrypt_pki_encrypted_session_key(candidate_auth_tok,\n\t\t\t\t\t\t       crypt_stat);\n\t} else if (candidate_auth_tok->token_type == ECRYPTFS_PASSWORD) {\n\t\tmemcpy(&(candidate_auth_tok->token.password),\n\t\t       &(matching_auth_tok->token.password),\n\t\t       sizeof(struct ecryptfs_password));\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = decrypt_passphrase_encrypted_session_key(\n\t\t\tcandidate_auth_tok, crypt_stat);\n\t} else {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t\trc = -EINVAL;\n\t}\n\tif (rc) {\n\t\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;\n\n\t\tecryptfs_printk(KERN_WARNING, \"Error decrypting the \"\n\t\t\t\t\"session key for authentication token with sig \"\n\t\t\t\t\"[%.*s]; rc = [%d]. Removing auth tok \"\n\t\t\t\t\"candidate from the list and searching for \"\n\t\t\t\t\"the next match.\\n\", ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\tcandidate_auth_tok_sig,\trc);\n\t\tlist_for_each_entry_safe(auth_tok_list_item,\n\t\t\t\t\t auth_tok_list_item_tmp,\n\t\t\t\t\t &auth_tok_list, list) {\n\t\t\tif (candidate_auth_tok\n\t\t\t    == &auth_tok_list_item->auth_tok) {\n\t\t\t\tlist_del(&auth_tok_list_item->list);\n\t\t\t\tkmem_cache_free(\n\t\t\t\t\tecryptfs_auth_tok_list_item_cache,\n\t\t\t\t\tauth_tok_list_item);\n\t\t\t\tgoto find_next_matching_auth_tok;\n\t\t\t}\n\t\t}\n\t\tBUG();\n\t}\n\trc = ecryptfs_compute_root_iv(crypt_stat);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error computing \"\n\t\t\t\t\"the root IV\\n\");\n\t\tgoto out_wipe_list;\n\t}\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error initializing crypto \"\n\t\t\t\t\"context for cipher [%s]; rc = [%d]\\n\",\n\t\t\t\tcrypt_stat->cipher, rc);\n\t}\nout_wipe_list:\n\twipe_auth_tok_list(&auth_tok_list);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "decrypt_passphrase_encrypted_session_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "1663-1742",
    "snippet": "static int\ndecrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,\n\t\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tstruct scatterlist dst_sg[2];\n\tstruct scatterlist src_sg[2];\n\tstruct mutex *tfm_mutex;\n\tstruct blkcipher_desc desc = {\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(\n\t\t\tKERN_DEBUG, \"Session key encryption key (size [%d]):\\n\",\n\t\t\tauth_tok->token.password.session_key_encryption_key_bytes);\n\t\tecryptfs_dump_hex(\n\t\t\tauth_tok->token.password.session_key_encryption_key,\n\t\t\tauth_tok->token.password.session_key_encryption_key_bytes);\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\n\t\t\t\t\t\t\tcrypt_stat->cipher);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       crypt_stat->cipher, rc);\n\t\tgoto out;\n\t}\n\trc = virt_to_scatterlist(auth_tok->session_key.encrypted_key,\n\t\t\t\t auth_tok->session_key.encrypted_key_size,\n\t\t\t\t src_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to convert \"\n\t\t\t\"auth_tok->session_key.encrypted_key to scatterlist; \"\n\t\t\t\"expected rc = 1; got rc = [%d]. \"\n\t\t       \"auth_tok->session_key.encrypted_key_size = [%d]\\n\", rc,\n\t\t\tauth_tok->session_key.encrypted_key_size);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.decrypted_key_size =\n\t\tauth_tok->session_key.encrypted_key_size;\n\trc = virt_to_scatterlist(auth_tok->session_key.decrypted_key,\n\t\t\t\t auth_tok->session_key.decrypted_key_size,\n\t\t\t\t dst_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to convert \"\n\t\t\t\"auth_tok->session_key.decrypted_key to scatterlist; \"\n\t\t\t\"expected rc = 1; got rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(tfm_mutex);\n\trc = crypto_blkcipher_setkey(\n\t\tdesc.tfm, auth_tok->token.password.session_key_encryption_key,\n\t\tcrypt_stat->key_size);\n\tif (unlikely(rc < 0)) {\n\t\tmutex_unlock(tfm_mutex);\n\t\tprintk(KERN_ERR \"Error setting key for crypto context\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = crypto_blkcipher_decrypt(&desc, dst_sg, src_sg,\n\t\t\t\t      auth_tok->session_key.encrypted_key_size);\n\tmutex_unlock(tfm_mutex);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Error decrypting; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\tmemcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,\n\t       auth_tok->session_key.decrypted_key_size);\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"FEK of size [%zd]:\\n\",\n\t\t\t\tcrypt_stat->key_size);\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_dump_hex",
          "args": [
            "crypt_stat->key",
            "crypt_stat->key_size"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dump_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/debug.c",
          "lines": "98-120",
          "snippet": "void ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n\nvoid ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_DEBUG",
            "\"FEK of size [%zd]:\\n\"",
            "crypt_stat->key_size"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ecryptfs_verbosity > 0"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "crypt_stat->key",
            "auth_tok->session_key.decrypted_key",
            "auth_tok->session_key.decrypted_key_size"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "tfm_mutex"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_decrypt",
          "args": [
            "&desc",
            "dst_sg",
            "src_sg",
            "auth_tok->session_key.encrypted_key_size"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "tfm_mutex"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc < 0"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_setkey",
          "args": [
            "desc.tfm",
            "auth_tok->token.password.session_key_encryption_key",
            "crypt_stat->key_size"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "tfm_mutex"
          ],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_scatterlist",
          "args": [
            "auth_tok->session_key.decrypted_key",
            "auth_tok->session_key.decrypted_key_size",
            "dst_sg",
            "2"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "virt_to_scatterlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "283-312",
          "snippet": "int virt_to_scatterlist(const void *addr, int size, struct scatterlist *sg,\n\t\t\tint sg_size)\n{\n\tint i = 0;\n\tstruct page *pg;\n\tint offset;\n\tint remainder_of_page;\n\n\tsg_init_table(sg, sg_size);\n\n\twhile (size > 0 && i < sg_size) {\n\t\tpg = virt_to_page(addr);\n\t\toffset = offset_in_page(addr);\n\t\tsg_set_page(&sg[i], pg, 0, offset);\n\t\tremainder_of_page = PAGE_CACHE_SIZE - offset;\n\t\tif (size >= remainder_of_page) {\n\t\t\tsg[i].length = remainder_of_page;\n\t\t\taddr += remainder_of_page;\n\t\t\tsize -= remainder_of_page;\n\t\t} else {\n\t\t\tsg[i].length = size;\n\t\t\taddr += size;\n\t\t\tsize = 0;\n\t\t}\n\t\ti++;\n\t}\n\tif (size > 0)\n\t\treturn -ENOMEM;\n\treturn i;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint virt_to_scatterlist(const void *addr, int size, struct scatterlist *sg,\n\t\t\tint sg_size)\n{\n\tint i = 0;\n\tstruct page *pg;\n\tint offset;\n\tint remainder_of_page;\n\n\tsg_init_table(sg, sg_size);\n\n\twhile (size > 0 && i < sg_size) {\n\t\tpg = virt_to_page(addr);\n\t\toffset = offset_in_page(addr);\n\t\tsg_set_page(&sg[i], pg, 0, offset);\n\t\tremainder_of_page = PAGE_CACHE_SIZE - offset;\n\t\tif (size >= remainder_of_page) {\n\t\t\tsg[i].length = remainder_of_page;\n\t\t\taddr += remainder_of_page;\n\t\t\tsize -= remainder_of_page;\n\t\t} else {\n\t\t\tsg[i].length = size;\n\t\t\taddr += size;\n\t\t\tsize = 0;\n\t\t}\n\t\ti++;\n\t}\n\tif (size > 0)\n\t\treturn -ENOMEM;\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_tfm_and_mutex_for_cipher_name",
          "args": [
            "&desc.tfm",
            "&tfm_mutex",
            "crypt_stat->cipher"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_tfm_and_mutex_for_cipher_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1751-1775",
          "snippet": "int ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mutex key_tfm_list_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct mutex key_tfm_list_mutex;\n\nint ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ecryptfs_verbosity > 0"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\ndecrypt_passphrase_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,\n\t\t\t\t\t struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tstruct scatterlist dst_sg[2];\n\tstruct scatterlist src_sg[2];\n\tstruct mutex *tfm_mutex;\n\tstruct blkcipher_desc desc = {\n\t\t.flags = CRYPTO_TFM_REQ_MAY_SLEEP\n\t};\n\tint rc = 0;\n\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(\n\t\t\tKERN_DEBUG, \"Session key encryption key (size [%d]):\\n\",\n\t\t\tauth_tok->token.password.session_key_encryption_key_bytes);\n\t\tecryptfs_dump_hex(\n\t\t\tauth_tok->token.password.session_key_encryption_key,\n\t\t\tauth_tok->token.password.session_key_encryption_key_bytes);\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\n\t\t\t\t\t\t\tcrypt_stat->cipher);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       crypt_stat->cipher, rc);\n\t\tgoto out;\n\t}\n\trc = virt_to_scatterlist(auth_tok->session_key.encrypted_key,\n\t\t\t\t auth_tok->session_key.encrypted_key_size,\n\t\t\t\t src_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to convert \"\n\t\t\t\"auth_tok->session_key.encrypted_key to scatterlist; \"\n\t\t\t\"expected rc = 1; got rc = [%d]. \"\n\t\t       \"auth_tok->session_key.encrypted_key_size = [%d]\\n\", rc,\n\t\t\tauth_tok->session_key.encrypted_key_size);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.decrypted_key_size =\n\t\tauth_tok->session_key.encrypted_key_size;\n\trc = virt_to_scatterlist(auth_tok->session_key.decrypted_key,\n\t\t\t\t auth_tok->session_key.decrypted_key_size,\n\t\t\t\t dst_sg, 2);\n\tif (rc < 1 || rc > 2) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to convert \"\n\t\t\t\"auth_tok->session_key.decrypted_key to scatterlist; \"\n\t\t\t\"expected rc = 1; got rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(tfm_mutex);\n\trc = crypto_blkcipher_setkey(\n\t\tdesc.tfm, auth_tok->token.password.session_key_encryption_key,\n\t\tcrypt_stat->key_size);\n\tif (unlikely(rc < 0)) {\n\t\tmutex_unlock(tfm_mutex);\n\t\tprintk(KERN_ERR \"Error setting key for crypto context\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = crypto_blkcipher_decrypt(&desc, dst_sg, src_sg,\n\t\t\t\t      auth_tok->session_key.encrypted_key_size);\n\tmutex_unlock(tfm_mutex);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Error decrypting; rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\tmemcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,\n\t       auth_tok->session_key.decrypted_key_size);\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tif (unlikely(ecryptfs_verbosity > 0)) {\n\t\tecryptfs_printk(KERN_DEBUG, \"FEK of size [%zd]:\\n\",\n\t\t\t\tcrypt_stat->key_size);\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_keyring_auth_tok_for_sig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "1627-1654",
    "snippet": "int ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key,\n\t\t\t\t      struct ecryptfs_auth_tok **auth_tok,\n\t\t\t\t      char *sig)\n{\n\tint rc = 0;\n\n\t(*auth_tok_key) = request_key(&key_type_user, sig, NULL);\n\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t(*auth_tok_key) = ecryptfs_get_encrypted_key(sig);\n\t\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t\tprintk(KERN_ERR \"Could not find key with description: [%s]\\n\",\n\t\t\t      sig);\n\t\t\trc = process_request_key_err(PTR_ERR(*auth_tok_key));\n\t\t\t(*auth_tok_key) = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdown_write(&(*auth_tok_key)->sem);\n\trc = ecryptfs_verify_auth_tok_from_key(*auth_tok_key, auth_tok);\n\tif (rc) {\n\t\tup_write(&(*auth_tok_key)->sem);\n\t\tkey_put(*auth_tok_key);\n\t\t(*auth_tok_key) = NULL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "*auth_tok_key"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&(*auth_tok_key)->sem"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_verify_auth_tok_from_key",
          "args": [
            "*auth_tok_key",
            "auth_tok"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_verify_auth_tok_from_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "463-487",
          "snippet": "static int\necryptfs_verify_auth_tok_from_key(struct key *auth_tok_key,\n\t\t\t\t  struct ecryptfs_auth_tok **auth_tok)\n{\n\tint rc = 0;\n\n\t(*auth_tok) = ecryptfs_get_key_payload_data(auth_tok_key);\n\tif (ecryptfs_verify_version((*auth_tok)->version)) {\n\t\tprintk(KERN_ERR \"Data structure version mismatch. Userspace \"\n\t\t       \"tools must match eCryptfs kernel module with major \"\n\t\t       \"version [%d] and minor version [%d]\\n\",\n\t\t       ECRYPTFS_VERSION_MAJOR, ECRYPTFS_VERSION_MINOR);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((*auth_tok)->token_type != ECRYPTFS_PASSWORD\n\t    && (*auth_tok)->token_type != ECRYPTFS_PRIVATE_KEY) {\n\t\tprintk(KERN_ERR \"Invalid auth_tok structure \"\n\t\t       \"returned from key query\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_verify_auth_tok_from_key(struct key *auth_tok_key,\n\t\t\t\t  struct ecryptfs_auth_tok **auth_tok)\n{\n\tint rc = 0;\n\n\t(*auth_tok) = ecryptfs_get_key_payload_data(auth_tok_key);\n\tif (ecryptfs_verify_version((*auth_tok)->version)) {\n\t\tprintk(KERN_ERR \"Data structure version mismatch. Userspace \"\n\t\t       \"tools must match eCryptfs kernel module with major \"\n\t\t       \"version [%d] and minor version [%d]\\n\",\n\t\t       ECRYPTFS_VERSION_MAJOR, ECRYPTFS_VERSION_MINOR);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((*auth_tok)->token_type != ECRYPTFS_PASSWORD\n\t    && (*auth_tok)->token_type != ECRYPTFS_PRIVATE_KEY) {\n\t\tprintk(KERN_ERR \"Invalid auth_tok structure \"\n\t\t       \"returned from key query\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&(*auth_tok_key)->sem"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_request_key_err",
          "args": [
            "PTR_ERR(*auth_tok_key)"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "process_request_key_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "42-65",
          "snippet": "static int process_request_key_err(long err_code)\n{\n\tint rc = 0;\n\n\tswitch (err_code) {\n\tcase -ENOKEY:\n\t\tecryptfs_printk(KERN_WARNING, \"No key\\n\");\n\t\trc = -ENOENT;\n\t\tbreak;\n\tcase -EKEYEXPIRED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key expired\\n\");\n\t\trc = -ETIME;\n\t\tbreak;\n\tcase -EKEYREVOKED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key revoked\\n\");\n\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_WARNING, \"Unknown error code: \"\n\t\t\t\t\"[0x%.16lx]\\n\", err_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int process_request_key_err(long err_code)\n{\n\tint rc = 0;\n\n\tswitch (err_code) {\n\tcase -ENOKEY:\n\t\tecryptfs_printk(KERN_WARNING, \"No key\\n\");\n\t\trc = -ENOENT;\n\t\tbreak;\n\tcase -EKEYEXPIRED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key expired\\n\");\n\t\trc = -ETIME;\n\t\tbreak;\n\tcase -EKEYREVOKED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key revoked\\n\");\n\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_WARNING, \"Unknown error code: \"\n\t\t\t\t\"[0x%.16lx]\\n\", err_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "*auth_tok_key"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Could not find key with description: [%s]\\n\"",
            "sig"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*auth_tok_key"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_encrypted_key",
          "args": [
            "sig"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_encrypted_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "106-109",
          "snippet": "static inline struct key *ecryptfs_get_encrypted_key(char *sig)\n{\n\treturn ERR_PTR(-ENOKEY);\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct key *ecryptfs_get_encrypted_key(char *sig)\n{\n\treturn ERR_PTR(-ENOKEY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*auth_tok_key"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_key",
          "args": [
            "&key_type_user",
            "sig",
            "NULL"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key,\n\t\t\t\t      struct ecryptfs_auth_tok **auth_tok,\n\t\t\t\t      char *sig)\n{\n\tint rc = 0;\n\n\t(*auth_tok_key) = request_key(&key_type_user, sig, NULL);\n\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t(*auth_tok_key) = ecryptfs_get_encrypted_key(sig);\n\t\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t\tprintk(KERN_ERR \"Could not find key with description: [%s]\\n\",\n\t\t\t      sig);\n\t\t\trc = process_request_key_err(PTR_ERR(*auth_tok_key));\n\t\t\t(*auth_tok_key) = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdown_write(&(*auth_tok_key)->sem);\n\trc = ecryptfs_verify_auth_tok_from_key(*auth_tok_key, auth_tok);\n\tif (rc) {\n\t\tup_write(&(*auth_tok_key)->sem);\n\t\tkey_put(*auth_tok_key);\n\t\t(*auth_tok_key) = NULL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "parse_tag_11_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "1547-1625",
    "snippet": "static int\nparse_tag_11_packet(unsigned char *data, unsigned char *contents,\n\t\t    size_t max_contents_bytes, size_t *tag_11_contents_size,\n\t\t    size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*tag_11_contents_size) = 0;\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 11\n\t *\n\t * Tag 11 identifier (1 byte)\n\t * Max Tag 11 packet size (max 3 bytes)\n\t * Binary format specifier (1 byte)\n\t * Filename length (1 byte)\n\t * Filename (\"_CONSOLE\") (8 bytes)\n\t * Modification date (4 bytes)\n\t * Literal data (arbitrary)\n\t *\n\t * We need at least 16 bytes of data for the packet to even be\n\t * valid.\n\t */\n\tif (max_packet_size < 16) {\n\t\tprintk(KERN_ERR \"Maximum packet size too small\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_11_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\tgoto out;\n\t}\n\tif (body_size < 14) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += length_size;\n\t(*tag_11_contents_size) = (body_size - 14);\n\tif (unlikely((*packet_size) + body_size + 1 > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (unlikely((*tag_11_contents_size) > max_contents_bytes)) {\n\t\tprintk(KERN_ERR \"Literal data section in tag 11 packet exceeds \"\n\t\t       \"expected size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x62) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x08) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += 12; /* Ignore filename and modification date */\n\tmemcpy(contents, &data[(*packet_size)], (*tag_11_contents_size));\n\t(*packet_size) += (*tag_11_contents_size);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*tag_11_contents_size) = 0;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "contents",
            "&data[(*packet_size)]",
            "(*tag_11_contents_size)"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Unrecognizable packet\\n\""
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(*tag_11_contents_size) > max_contents_bytes"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(*packet_size) + body_size + 1 > max_packet_size"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_parse_packet_length",
          "args": [
            "&data[(*packet_size)]",
            "&body_size",
            "&length_size"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_parse_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "94-123",
          "snippet": "int ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nparse_tag_11_packet(unsigned char *data, unsigned char *contents,\n\t\t    size_t max_contents_bytes, size_t *tag_11_contents_size,\n\t\t    size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*tag_11_contents_size) = 0;\n\t/* This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 11\n\t *\n\t * Tag 11 identifier (1 byte)\n\t * Max Tag 11 packet size (max 3 bytes)\n\t * Binary format specifier (1 byte)\n\t * Filename length (1 byte)\n\t * Filename (\"_CONSOLE\") (8 bytes)\n\t * Modification date (4 bytes)\n\t * Literal data (arbitrary)\n\t *\n\t * We need at least 16 bytes of data for the packet to even be\n\t * valid.\n\t */\n\tif (max_packet_size < 16) {\n\t\tprintk(KERN_ERR \"Maximum packet size too small\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_11_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\tgoto out;\n\t}\n\tif (body_size < 14) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += length_size;\n\t(*tag_11_contents_size) = (body_size - 14);\n\tif (unlikely((*packet_size) + body_size + 1 > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (unlikely((*tag_11_contents_size) > max_contents_bytes)) {\n\t\tprintk(KERN_ERR \"Literal data section in tag 11 packet exceeds \"\n\t\t       \"expected size\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x62) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x08) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += 12; /* Ignore filename and modification date */\n\tmemcpy(contents, &data[(*packet_size)], (*tag_11_contents_size));\n\t(*packet_size) += (*tag_11_contents_size);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*tag_11_contents_size) = 0;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "parse_tag_3_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "1373-1529",
    "snippet": "static int\nparse_tag_3_packet(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   unsigned char *data, struct list_head *auth_tok_list,\n\t\t   struct ecryptfs_auth_tok **new_auth_tok,\n\t\t   size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*new_auth_tok) = NULL;\n\t/**\n\t *This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 3\n\t *\n\t * Tag 3 identifier (1 byte)\n\t * Max Tag 3 packet size (max 3 bytes)\n\t * Version (1 byte)\n\t * Cipher code (1 byte)\n\t * S2K specifier (1 byte)\n\t * Hash identifier (1 byte)\n\t * Salt (ECRYPTFS_SALT_SIZE)\n\t * Hash iterations (1 byte)\n\t * Encrypted key (arbitrary)\n\t *\n\t * (ECRYPTFS_SALT_SIZE + 7) minimum packet size\n\t */\n\tif (max_packet_size < (ECRYPTFS_SALT_SIZE + 7)) {\n\t\tprintk(KERN_ERR \"Max packet size too large\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_3_PACKET_TYPE) {\n\t\tprintk(KERN_ERR \"First byte != 0x%.2x; invalid packet\\n\",\n\t\t       ECRYPTFS_TAG_3_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released: wipe_auth_tok_list called in ecryptfs_parse_packet_set or\n\t * at end of function upon failure */\n\tauth_tok_list_item =\n\t    kmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache, GFP_KERNEL);\n\tif (!auth_tok_list_item) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*new_auth_tok) = &auth_tok_list_item->auth_tok;\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Error parsing packet length; rc = [%d]\\n\",\n\t\t       rc);\n\t\tgoto out_free;\n\t}\n\tif (unlikely(body_size < (ECRYPTFS_SALT_SIZE + 5))) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*packet_size) += length_size;\n\tif (unlikely((*packet_size) + body_size > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->session_key.encrypted_key_size =\n\t\t(body_size - (ECRYPTFS_SALT_SIZE + 5));\n\tif ((*new_auth_tok)->session_key.encrypted_key_size\n\t    > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\tprintk(KERN_WARNING \"Tag 3 packet contains key larger \"\n\t\t       \"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (unlikely(data[(*packet_size)++] != 0x04)) {\n\t\tprintk(KERN_WARNING \"Unknown version number [%d]\\n\",\n\t\t       data[(*packet_size) - 1]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\trc = ecryptfs_cipher_code_to_string(crypt_stat->cipher,\n\t\t\t\t\t    (u16)data[(*packet_size)]);\n\tif (rc)\n\t\tgoto out_free;\n\t/* A little extra work to differentiate among the AES key\n\t * sizes; see RFC2440 */\n\tswitch(data[(*packet_size)++]) {\n\tcase RFC2440_CIPHER_AES_192:\n\t\tcrypt_stat->key_size = 24;\n\t\tbreak;\n\tdefault:\n\t\tcrypt_stat->key_size =\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t}\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc)\n\t\tgoto out_free;\n\tif (unlikely(data[(*packet_size)++] != 0x03)) {\n\t\tprintk(KERN_WARNING \"Only S2K ID 3 is currently supported\\n\");\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t/* TODO: finish the hash mapping */\n\tswitch (data[(*packet_size)++]) {\n\tcase 0x01: /* See RFC2440 for these numbers and their mappings */\n\t\t/* Choose MD5 */\n\t\tmemcpy((*new_auth_tok)->token.password.salt,\n\t\t       &data[(*packet_size)], ECRYPTFS_SALT_SIZE);\n\t\t(*packet_size) += ECRYPTFS_SALT_SIZE;\n\t\t/* This conversion was taken straight from RFC2440 */\n\t\t(*new_auth_tok)->token.password.hash_iterations =\n\t\t\t((u32) 16 + (data[(*packet_size)] & 15))\n\t\t\t\t<< ((data[(*packet_size)] >> 4) + 6);\n\t\t(*packet_size)++;\n\t\t/* Friendly reminder:\n\t\t * (*new_auth_tok)->session_key.encrypted_key_size =\n\t\t *         (body_size - (ECRYPTFS_SALT_SIZE + 5)); */\n\t\tmemcpy((*new_auth_tok)->session_key.encrypted_key,\n\t\t       &data[(*packet_size)],\n\t\t       (*new_auth_tok)->session_key.encrypted_key_size);\n\t\t(*packet_size) +=\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t\t(*new_auth_tok)->session_key.flags &=\n\t\t\t~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\t\t(*new_auth_tok)->session_key.flags |=\n\t\t\tECRYPTFS_CONTAINS_ENCRYPTED_KEY;\n\t\t(*new_auth_tok)->token.password.hash_algo = 0x01; /* MD5 */\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_ERR, \"Unsupported hash algorithm: \"\n\t\t\t\t\"[%d]\\n\", data[(*packet_size) - 1]);\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->token_type = ECRYPTFS_PASSWORD;\n\t/* TODO: Parametarize; we might actually want userspace to\n\t * decrypt the session key. */\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\n\tlist_add(&auth_tok_list_item->list, auth_tok_list);\n\tgoto out;\nout_free:\n\t(*new_auth_tok) = NULL;\n\tmemset(auth_tok_list_item, 0,\n\t       sizeof(struct ecryptfs_auth_tok_list_item));\n\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\tauth_tok_list_item);\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_auth_tok_list_item_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_auth_tok_list_item_cache",
            "auth_tok_list_item"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "auth_tok_list_item",
            "0",
            "sizeof(struct ecryptfs_auth_tok_list_item)"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&auth_tok_list_item->list",
            "auth_tok_list"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Unsupported hash algorithm: \"\n\t\t\t\t\"[%d]\\n\"",
            "data[(*packet_size) - 1]"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(*new_auth_tok)->session_key.encrypted_key",
            "&data[(*packet_size)]",
            "(*new_auth_tok)->session_key.encrypted_key_size"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(*new_auth_tok)->token.password.salt",
            "&data[(*packet_size)]",
            "ECRYPTFS_SALT_SIZE"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "data[(*packet_size)++] != 0x03"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_init_crypt_ctx",
          "args": [
            "crypt_stat"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_init_crypt_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "607-642",
          "snippet": "int ecryptfs_init_crypt_ctx(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tchar *full_alg_name;\n\tint rc = -EINVAL;\n\n\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\"Initializing cipher [%s]; strlen = [%d]; \"\n\t\t\t\"key_size_bits = [%zd]\\n\",\n\t\t\tcrypt_stat->cipher, (int)strlen(crypt_stat->cipher),\n\t\t\tcrypt_stat->key_size << 3);\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\tif (crypt_stat->tfm) {\n\t\trc = 0;\n\t\tgoto out_unlock;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name,\n\t\t\t\t\t\t    crypt_stat->cipher, \"cbc\");\n\tif (rc)\n\t\tgoto out_unlock;\n\tcrypt_stat->tfm = crypto_alloc_ablkcipher(full_alg_name, 0, 0);\n\tif (IS_ERR(crypt_stat->tfm)) {\n\t\trc = PTR_ERR(crypt_stat->tfm);\n\t\tcrypt_stat->tfm = NULL;\n\t\tecryptfs_printk(KERN_ERR, \"cryptfs: init_crypt_ctx(): \"\n\t\t\t\t\"Error initializing cipher [%s]\\n\",\n\t\t\t\tfull_alg_name);\n\t\tgoto out_free;\n\t}\n\tcrypto_ablkcipher_set_flags(crypt_stat->tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\trc = 0;\nout_free:\n\tkfree(full_alg_name);\nout_unlock:\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint ecryptfs_init_crypt_ctx(struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tchar *full_alg_name;\n\tint rc = -EINVAL;\n\n\tecryptfs_printk(KERN_DEBUG,\n\t\t\t\"Initializing cipher [%s]; strlen = [%d]; \"\n\t\t\t\"key_size_bits = [%zd]\\n\",\n\t\t\tcrypt_stat->cipher, (int)strlen(crypt_stat->cipher),\n\t\t\tcrypt_stat->key_size << 3);\n\tmutex_lock(&crypt_stat->cs_tfm_mutex);\n\tif (crypt_stat->tfm) {\n\t\trc = 0;\n\t\tgoto out_unlock;\n\t}\n\trc = ecryptfs_crypto_api_algify_cipher_name(&full_alg_name,\n\t\t\t\t\t\t    crypt_stat->cipher, \"cbc\");\n\tif (rc)\n\t\tgoto out_unlock;\n\tcrypt_stat->tfm = crypto_alloc_ablkcipher(full_alg_name, 0, 0);\n\tif (IS_ERR(crypt_stat->tfm)) {\n\t\trc = PTR_ERR(crypt_stat->tfm);\n\t\tcrypt_stat->tfm = NULL;\n\t\tecryptfs_printk(KERN_ERR, \"cryptfs: init_crypt_ctx(): \"\n\t\t\t\t\"Error initializing cipher [%s]\\n\",\n\t\t\t\tfull_alg_name);\n\t\tgoto out_free;\n\t}\n\tcrypto_ablkcipher_set_flags(crypt_stat->tfm, CRYPTO_TFM_REQ_WEAK_KEY);\n\trc = 0;\nout_free:\n\tkfree(full_alg_name);\nout_unlock:\n\tmutex_unlock(&crypt_stat->cs_tfm_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_cipher_code_to_string",
          "args": [
            "crypt_stat->cipher",
            "(u16)data[(*packet_size)]"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_cipher_code_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1020-1035",
          "snippet": "int ecryptfs_cipher_code_to_string(char *str, u8 cipher_code)\n{\n\tint rc = 0;\n\tint i;\n\n\tstr[0] = '\\0';\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\tif (cipher_code == ecryptfs_cipher_code_str_map[i].cipher_code)\n\t\t\tstrcpy(str, ecryptfs_cipher_code_str_map[i].cipher_str);\n\tif (str[0] == '\\0') {\n\t\tecryptfs_printk(KERN_WARNING, \"Cipher code not recognized: \"\n\t\t\t\t\"[%d]\\n\", cipher_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};\n\nint ecryptfs_cipher_code_to_string(char *str, u8 cipher_code)\n{\n\tint rc = 0;\n\tint i;\n\n\tstr[0] = '\\0';\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\tif (cipher_code == ecryptfs_cipher_code_str_map[i].cipher_code)\n\t\t\tstrcpy(str, ecryptfs_cipher_code_str_map[i].cipher_str);\n\tif (str[0] == '\\0') {\n\t\tecryptfs_printk(KERN_WARNING, \"Cipher code not recognized: \"\n\t\t\t\t\"[%d]\\n\", cipher_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "data[(*packet_size)++] != 0x04"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(*packet_size) + body_size > max_packet_size"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "body_size < (ECRYPTFS_SALT_SIZE + 5)"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_parse_packet_length",
          "args": [
            "&data[(*packet_size)]",
            "&body_size",
            "&length_size"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_parse_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "94-123",
          "snippet": "int ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "ecryptfs_auth_tok_list_item_cache",
            "GFP_KERNEL"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_auth_tok_list_item_cache;\n\nstatic int\nparse_tag_3_packet(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   unsigned char *data, struct list_head *auth_tok_list,\n\t\t   struct ecryptfs_auth_tok **new_auth_tok,\n\t\t   size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*new_auth_tok) = NULL;\n\t/**\n\t *This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 3\n\t *\n\t * Tag 3 identifier (1 byte)\n\t * Max Tag 3 packet size (max 3 bytes)\n\t * Version (1 byte)\n\t * Cipher code (1 byte)\n\t * S2K specifier (1 byte)\n\t * Hash identifier (1 byte)\n\t * Salt (ECRYPTFS_SALT_SIZE)\n\t * Hash iterations (1 byte)\n\t * Encrypted key (arbitrary)\n\t *\n\t * (ECRYPTFS_SALT_SIZE + 7) minimum packet size\n\t */\n\tif (max_packet_size < (ECRYPTFS_SALT_SIZE + 7)) {\n\t\tprintk(KERN_ERR \"Max packet size too large\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_3_PACKET_TYPE) {\n\t\tprintk(KERN_ERR \"First byte != 0x%.2x; invalid packet\\n\",\n\t\t       ECRYPTFS_TAG_3_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released: wipe_auth_tok_list called in ecryptfs_parse_packet_set or\n\t * at end of function upon failure */\n\tauth_tok_list_item =\n\t    kmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache, GFP_KERNEL);\n\tif (!auth_tok_list_item) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*new_auth_tok) = &auth_tok_list_item->auth_tok;\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Error parsing packet length; rc = [%d]\\n\",\n\t\t       rc);\n\t\tgoto out_free;\n\t}\n\tif (unlikely(body_size < (ECRYPTFS_SALT_SIZE + 5))) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*packet_size) += length_size;\n\tif (unlikely((*packet_size) + body_size > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->session_key.encrypted_key_size =\n\t\t(body_size - (ECRYPTFS_SALT_SIZE + 5));\n\tif ((*new_auth_tok)->session_key.encrypted_key_size\n\t    > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\tprintk(KERN_WARNING \"Tag 3 packet contains key larger \"\n\t\t       \"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (unlikely(data[(*packet_size)++] != 0x04)) {\n\t\tprintk(KERN_WARNING \"Unknown version number [%d]\\n\",\n\t\t       data[(*packet_size) - 1]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\trc = ecryptfs_cipher_code_to_string(crypt_stat->cipher,\n\t\t\t\t\t    (u16)data[(*packet_size)]);\n\tif (rc)\n\t\tgoto out_free;\n\t/* A little extra work to differentiate among the AES key\n\t * sizes; see RFC2440 */\n\tswitch(data[(*packet_size)++]) {\n\tcase RFC2440_CIPHER_AES_192:\n\t\tcrypt_stat->key_size = 24;\n\t\tbreak;\n\tdefault:\n\t\tcrypt_stat->key_size =\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t}\n\trc = ecryptfs_init_crypt_ctx(crypt_stat);\n\tif (rc)\n\t\tgoto out_free;\n\tif (unlikely(data[(*packet_size)++] != 0x03)) {\n\t\tprintk(KERN_WARNING \"Only S2K ID 3 is currently supported\\n\");\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t/* TODO: finish the hash mapping */\n\tswitch (data[(*packet_size)++]) {\n\tcase 0x01: /* See RFC2440 for these numbers and their mappings */\n\t\t/* Choose MD5 */\n\t\tmemcpy((*new_auth_tok)->token.password.salt,\n\t\t       &data[(*packet_size)], ECRYPTFS_SALT_SIZE);\n\t\t(*packet_size) += ECRYPTFS_SALT_SIZE;\n\t\t/* This conversion was taken straight from RFC2440 */\n\t\t(*new_auth_tok)->token.password.hash_iterations =\n\t\t\t((u32) 16 + (data[(*packet_size)] & 15))\n\t\t\t\t<< ((data[(*packet_size)] >> 4) + 6);\n\t\t(*packet_size)++;\n\t\t/* Friendly reminder:\n\t\t * (*new_auth_tok)->session_key.encrypted_key_size =\n\t\t *         (body_size - (ECRYPTFS_SALT_SIZE + 5)); */\n\t\tmemcpy((*new_auth_tok)->session_key.encrypted_key,\n\t\t       &data[(*packet_size)],\n\t\t       (*new_auth_tok)->session_key.encrypted_key_size);\n\t\t(*packet_size) +=\n\t\t\t(*new_auth_tok)->session_key.encrypted_key_size;\n\t\t(*new_auth_tok)->session_key.flags &=\n\t\t\t~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\t\t(*new_auth_tok)->session_key.flags |=\n\t\t\tECRYPTFS_CONTAINS_ENCRYPTED_KEY;\n\t\t(*new_auth_tok)->token.password.hash_algo = 0x01; /* MD5 */\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_ERR, \"Unsupported hash algorithm: \"\n\t\t\t\t\"[%d]\\n\", data[(*packet_size) - 1]);\n\t\trc = -ENOSYS;\n\t\tgoto out_free;\n\t}\n\t(*new_auth_tok)->token_type = ECRYPTFS_PASSWORD;\n\t/* TODO: Parametarize; we might actually want userspace to\n\t * decrypt the session key. */\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\n\t(*new_auth_tok)->session_key.flags &=\n\t\t\t    ~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\n\tlist_add(&auth_tok_list_item->list, auth_tok_list);\n\tgoto out;\nout_free:\n\t(*new_auth_tok) = NULL;\n\tmemset(auth_tok_list_item, 0,\n\t       sizeof(struct ecryptfs_auth_tok_list_item));\n\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\tauth_tok_list_item);\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\treturn rc;\n}"
  },
  {
    "function_name": "parse_tag_1_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "1241-1353",
    "snippet": "static int\nparse_tag_1_packet(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   unsigned char *data, struct list_head *auth_tok_list,\n\t\t   struct ecryptfs_auth_tok **new_auth_tok,\n\t\t   size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*new_auth_tok) = NULL;\n\t/**\n\t * This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 1\n\t *\n\t * Tag 1 identifier (1 byte)\n\t * Max Tag 1 packet size (max 3 bytes)\n\t * Version (1 byte)\n\t * Key identifier (8 bytes; ECRYPTFS_SIG_SIZE)\n\t * Cipher identifier (1 byte)\n\t * Encrypted key size (arbitrary)\n\t *\n\t * 12 bytes minimum packet size\n\t */\n\tif (unlikely(max_packet_size < 12)) {\n\t\tprintk(KERN_ERR \"Invalid max packet size; must be >=12\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_1_PACKET_TYPE) {\n\t\tprintk(KERN_ERR \"Enter w/ first byte != 0x%.2x\\n\",\n\t\t       ECRYPTFS_TAG_1_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released: wipe_auth_tok_list called in ecryptfs_parse_packet_set or\n\t * at end of function upon failure */\n\tauth_tok_list_item =\n\t\tkmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache,\n\t\t\t\t  GFP_KERNEL);\n\tif (!auth_tok_list_item) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*new_auth_tok) = &auth_tok_list_item->auth_tok;\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Error parsing packet length; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\t\tgoto out_free;\n\t}\n\tif (unlikely(body_size < (ECRYPTFS_SIG_SIZE + 2))) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*packet_size) += length_size;\n\tif (unlikely((*packet_size) + body_size > max_packet_size)) {\n\t\tprintk(KERN_WARNING \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (unlikely(data[(*packet_size)++] != 0x03)) {\n\t\tprintk(KERN_WARNING \"Unknown version number [%d]\\n\",\n\t\t       data[(*packet_size) - 1]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tecryptfs_to_hex((*new_auth_tok)->token.private_key.signature,\n\t\t\t&data[(*packet_size)], ECRYPTFS_SIG_SIZE);\n\t*packet_size += ECRYPTFS_SIG_SIZE;\n\t/* This byte is skipped because the kernel does not need to\n\t * know which public key encryption algorithm was used */\n\t(*packet_size)++;\n\t(*new_auth_tok)->session_key.encrypted_key_size =\n\t\tbody_size - (ECRYPTFS_SIG_SIZE + 2);\n\tif ((*new_auth_tok)->session_key.encrypted_key_size\n\t    > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\tprintk(KERN_WARNING \"Tag 1 packet contains key larger \"\n\t\t       \"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tmemcpy((*new_auth_tok)->session_key.encrypted_key,\n\t       &data[(*packet_size)], (body_size - (ECRYPTFS_SIG_SIZE + 2)));\n\t(*packet_size) += (*new_auth_tok)->session_key.encrypted_key_size;\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\t(*new_auth_tok)->session_key.flags |=\n\t\tECRYPTFS_CONTAINS_ENCRYPTED_KEY;\n\t(*new_auth_tok)->token_type = ECRYPTFS_PRIVATE_KEY;\n\t(*new_auth_tok)->flags = 0;\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\n\tlist_add(&auth_tok_list_item->list, auth_tok_list);\n\tgoto out;\nout_free:\n\t(*new_auth_tok) = NULL;\n\tmemset(auth_tok_list_item, 0,\n\t       sizeof(struct ecryptfs_auth_tok_list_item));\n\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\tauth_tok_list_item);\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_auth_tok_list_item_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_auth_tok_list_item_cache",
            "auth_tok_list_item"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "auth_tok_list_item",
            "0",
            "sizeof(struct ecryptfs_auth_tok_list_item)"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&auth_tok_list_item->list",
            "auth_tok_list"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(*new_auth_tok)->session_key.encrypted_key",
            "&data[(*packet_size)]",
            "(body_size - (ECRYPTFS_SIG_SIZE + 2))"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Tag 1 packet contains key larger \"\n\t\t       \"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\""
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_to_hex",
          "args": [
            "(*new_auth_tok)->token.private_key.signature",
            "&data[(*packet_size)]",
            "ECRYPTFS_SIG_SIZE"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_to_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "50-56",
          "snippet": "void ecryptfs_to_hex(char *dst, char *src, size_t src_size)\n{\n\tint x;\n\n\tfor (x = 0; x < src_size; x++)\n\t\tsprintf(&dst[x * 2], \"%.2x\", (unsigned char)src[x]);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_to_hex(char *dst, char *src, size_t src_size)\n{\n\tint x;\n\n\tfor (x = 0; x < src_size; x++)\n\t\tsprintf(&dst[x * 2], \"%.2x\", (unsigned char)src[x]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "data[(*packet_size)++] != 0x03"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(*packet_size) + body_size > max_packet_size"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "body_size < (ECRYPTFS_SIG_SIZE + 2)"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_parse_packet_length",
          "args": [
            "&data[(*packet_size)]",
            "&body_size",
            "&length_size"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_parse_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "94-123",
          "snippet": "int ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "ecryptfs_auth_tok_list_item_cache",
            "GFP_KERNEL"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "max_packet_size < 12"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_auth_tok_list_item_cache;\n\nstatic int\nparse_tag_1_packet(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t   unsigned char *data, struct list_head *auth_tok_list,\n\t\t   struct ecryptfs_auth_tok **new_auth_tok,\n\t\t   size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tsize_t length_size;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*new_auth_tok) = NULL;\n\t/**\n\t * This format is inspired by OpenPGP; see RFC 2440\n\t * packet tag 1\n\t *\n\t * Tag 1 identifier (1 byte)\n\t * Max Tag 1 packet size (max 3 bytes)\n\t * Version (1 byte)\n\t * Key identifier (8 bytes; ECRYPTFS_SIG_SIZE)\n\t * Cipher identifier (1 byte)\n\t * Encrypted key size (arbitrary)\n\t *\n\t * 12 bytes minimum packet size\n\t */\n\tif (unlikely(max_packet_size < 12)) {\n\t\tprintk(KERN_ERR \"Invalid max packet size; must be >=12\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_1_PACKET_TYPE) {\n\t\tprintk(KERN_ERR \"Enter w/ first byte != 0x%.2x\\n\",\n\t\t       ECRYPTFS_TAG_1_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Released: wipe_auth_tok_list called in ecryptfs_parse_packet_set or\n\t * at end of function upon failure */\n\tauth_tok_list_item =\n\t\tkmem_cache_zalloc(ecryptfs_auth_tok_list_item_cache,\n\t\t\t\t  GFP_KERNEL);\n\tif (!auth_tok_list_item) {\n\t\tprintk(KERN_ERR \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\t(*new_auth_tok) = &auth_tok_list_item->auth_tok;\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Error parsing packet length; \"\n\t\t       \"rc = [%d]\\n\", rc);\n\t\tgoto out_free;\n\t}\n\tif (unlikely(body_size < (ECRYPTFS_SIG_SIZE + 2))) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\t(*packet_size) += length_size;\n\tif (unlikely((*packet_size) + body_size > max_packet_size)) {\n\t\tprintk(KERN_WARNING \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (unlikely(data[(*packet_size)++] != 0x03)) {\n\t\tprintk(KERN_WARNING \"Unknown version number [%d]\\n\",\n\t\t       data[(*packet_size) - 1]);\n\t\trc = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tecryptfs_to_hex((*new_auth_tok)->token.private_key.signature,\n\t\t\t&data[(*packet_size)], ECRYPTFS_SIG_SIZE);\n\t*packet_size += ECRYPTFS_SIG_SIZE;\n\t/* This byte is skipped because the kernel does not need to\n\t * know which public key encryption algorithm was used */\n\t(*packet_size)++;\n\t(*new_auth_tok)->session_key.encrypted_key_size =\n\t\tbody_size - (ECRYPTFS_SIG_SIZE + 2);\n\tif ((*new_auth_tok)->session_key.encrypted_key_size\n\t    > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\tprintk(KERN_WARNING \"Tag 1 packet contains key larger \"\n\t\t       \"than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tmemcpy((*new_auth_tok)->session_key.encrypted_key,\n\t       &data[(*packet_size)], (body_size - (ECRYPTFS_SIG_SIZE + 2)));\n\t(*packet_size) += (*new_auth_tok)->session_key.encrypted_key_size;\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\t(*new_auth_tok)->session_key.flags |=\n\t\tECRYPTFS_CONTAINS_ENCRYPTED_KEY;\n\t(*new_auth_tok)->token_type = ECRYPTFS_PRIVATE_KEY;\n\t(*new_auth_tok)->flags = 0;\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_DECRYPT);\n\t(*new_auth_tok)->session_key.flags &=\n\t\t~(ECRYPTFS_USERSPACE_SHOULD_TRY_TO_ENCRYPT);\n\tlist_add(&auth_tok_list_item->list, auth_tok_list);\n\tgoto out;\nout_free:\n\t(*new_auth_tok) = NULL;\n\tmemset(auth_tok_list_item, 0,\n\t       sizeof(struct ecryptfs_auth_tok_list_item));\n\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\tauth_tok_list_item);\nout:\n\tif (rc)\n\t\t(*packet_size) = 0;\n\treturn rc;\n}"
  },
  {
    "function_name": "wipe_auth_tok_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "1209-1220",
    "snippet": "static void wipe_auth_tok_list(struct list_head *auth_tok_list_head)\n{\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;\n\n\tlist_for_each_entry_safe(auth_tok_list_item, auth_tok_list_item_tmp,\n\t\t\t\t auth_tok_list_head, list) {\n\t\tlist_del(&auth_tok_list_item->list);\n\t\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\t\tauth_tok_list_item);\n\t}\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *ecryptfs_auth_tok_list_item_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ecryptfs_auth_tok_list_item_cache",
            "auth_tok_list_item"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&auth_tok_list_item->list"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "auth_tok_list_item",
            "auth_tok_list_item_tmp",
            "auth_tok_list_head",
            "list"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstruct kmem_cache *ecryptfs_auth_tok_list_item_cache;\n\nstatic void wipe_auth_tok_list(struct list_head *auth_tok_list_head)\n{\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item;\n\tstruct ecryptfs_auth_tok_list_item *auth_tok_list_item_tmp;\n\n\tlist_for_each_entry_safe(auth_tok_list_item, auth_tok_list_item_tmp,\n\t\t\t\t auth_tok_list_head, list) {\n\t\tlist_del(&auth_tok_list_item->list);\n\t\tkmem_cache_free(ecryptfs_auth_tok_list_item_cache,\n\t\t\t\tauth_tok_list_item);\n\t}\n}"
  },
  {
    "function_name": "decrypt_pki_encrypted_session_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "1143-1207",
    "snippet": "static int\ndecrypt_pki_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,\n\t\t\t\t  struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tu8 cipher_code = 0;\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tstruct ecryptfs_message *msg = NULL;\n\tchar *auth_tok_sig;\n\tchar *payload = NULL;\n\tsize_t payload_len = 0;\n\tint rc;\n\n\trc = ecryptfs_get_auth_tok_sig(&auth_tok_sig, auth_tok);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Unrecognized auth tok type: [%d]\\n\",\n\t\t       auth_tok->token_type);\n\t\tgoto out;\n\t}\n\trc = write_tag_64_packet(auth_tok_sig, &(auth_tok->session_key),\n\t\t\t\t &payload, &payload_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to write tag 64 packet\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_send_message(payload, payload_len, &msg_ctx);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error sending message to \"\n\t\t\t\t\"ecryptfsd: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_wait_for_response(msg_ctx, &msg);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to receive tag 65 packet \"\n\t\t\t\t\"from the user space daemon\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = parse_tag_65_packet(&(auth_tok->session_key),\n\t\t\t\t &cipher_code, msg);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to parse tag 65 packet; rc = [%d]\\n\",\n\t\t       rc);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\tmemcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,\n\t       auth_tok->session_key.decrypted_key_size);\n\tcrypt_stat->key_size = auth_tok->session_key.decrypted_key_size;\n\trc = ecryptfs_cipher_code_to_string(crypt_stat->cipher, cipher_code);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Cipher code [%d] is invalid\\n\",\n\t\t\t\tcipher_code)\n\t\tgoto out;\n\t}\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Decrypted session key:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\nout:\n\tkfree(msg);\n\tkfree(payload);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "payload"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "msg"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_dump_hex",
          "args": [
            "crypt_stat->key",
            "crypt_stat->key_size"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_dump_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/debug.c",
          "lines": "98-120",
          "snippet": "void ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n\nvoid ecryptfs_dump_hex(char *data, int bytes)\n{\n\tint i = 0;\n\tint add_newline = 1;\n\n\tif (ecryptfs_verbosity < 1)\n\t\treturn;\n\tif (bytes != 0) {\n\t\tprintk(KERN_DEBUG \"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t}\n\twhile (i < bytes) {\n\t\tprintk(\"0x%.2x.\", (unsigned char)data[i]);\n\t\ti++;\n\t\tif (i % 16 == 0) {\n\t\t\tprintk(\"\\n\");\n\t\t\tadd_newline = 0;\n\t\t} else\n\t\t\tadd_newline = 1;\n\t}\n\tif (add_newline)\n\t\tprintk(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_DEBUG",
            "\"Decrypted session key:\\n\""
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_cipher_code_to_string",
          "args": [
            "crypt_stat->cipher",
            "cipher_code"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_cipher_code_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1020-1035",
          "snippet": "int ecryptfs_cipher_code_to_string(char *str, u8 cipher_code)\n{\n\tint rc = 0;\n\tint i;\n\n\tstr[0] = '\\0';\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\tif (cipher_code == ecryptfs_cipher_code_str_map[i].cipher_code)\n\t\t\tstrcpy(str, ecryptfs_cipher_code_str_map[i].cipher_str);\n\tif (str[0] == '\\0') {\n\t\tecryptfs_printk(KERN_WARNING, \"Cipher code not recognized: \"\n\t\t\t\t\"[%d]\\n\", cipher_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};\n\nint ecryptfs_cipher_code_to_string(char *str, u8 cipher_code)\n{\n\tint rc = 0;\n\tint i;\n\n\tstr[0] = '\\0';\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\tif (cipher_code == ecryptfs_cipher_code_str_map[i].cipher_code)\n\t\t\tstrcpy(str, ecryptfs_cipher_code_str_map[i].cipher_str);\n\tif (str[0] == '\\0') {\n\t\tecryptfs_printk(KERN_WARNING, \"Cipher code not recognized: \"\n\t\t\t\t\"[%d]\\n\", cipher_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "crypt_stat->key",
            "auth_tok->session_key.decrypted_key",
            "auth_tok->session_key.decrypted_key_size"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_tag_65_packet",
          "args": [
            "&(auth_tok->session_key)",
            "&cipher_code",
            "msg"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "parse_tag_65_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "211-294",
          "snippet": "static int\nparse_tag_65_packet(struct ecryptfs_session_key *session_key, u8 *cipher_code,\n\t\t    struct ecryptfs_message *msg)\n{\n\tsize_t i = 0;\n\tchar *data;\n\tsize_t data_len;\n\tsize_t m_size;\n\tsize_t message_len;\n\tu16 checksum = 0;\n\tu16 expected_checksum = 0;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 65 Packet Format *****\n\t *         | Content Type             | 1 byte       |\n\t *         | Status Indicator         | 1 byte       |\n\t *         | File Encryption Key Size | 1 or 2 bytes |\n\t *         | File Encryption Key      | arbitrary    |\n\t */\n\tmessage_len = msg->data_len;\n\tdata = msg->data;\n\tif (message_len < 4) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (data[i++] != ECRYPTFS_TAG_65_PACKET_TYPE) {\n\t\tecryptfs_printk(KERN_ERR, \"Type should be ECRYPTFS_TAG_65\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (data[i++]) {\n\t\tecryptfs_printk(KERN_ERR, \"Status indicator has non-zero value \"\n\t\t\t\t\"[%d]\\n\", data[i-1]);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[i], &m_size, &data_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error parsing packet length; \"\n\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\ti += data_len;\n\tif (message_len < (i + m_size)) {\n\t\tecryptfs_printk(KERN_ERR, \"The message received from ecryptfsd \"\n\t\t\t\t\"is shorter than expected\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (m_size < 3) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"The decrypted key is not long enough to \"\n\t\t\t\t\"include a cipher code and checksum\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\t*cipher_code = data[i++];\n\t/* The decrypted key includes 1 byte cipher code and 2 byte checksum */\n\tsession_key->decrypted_key_size = m_size - 3;\n\tif (session_key->decrypted_key_size > ECRYPTFS_MAX_KEY_BYTES) {\n\t\tecryptfs_printk(KERN_ERR, \"key_size [%d] larger than \"\n\t\t\t\t\"the maximum key size [%d]\\n\",\n\t\t\t\tsession_key->decrypted_key_size,\n\t\t\t\tECRYPTFS_MAX_ENCRYPTED_KEY_BYTES);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tmemcpy(session_key->decrypted_key, &data[i],\n\t       session_key->decrypted_key_size);\n\ti += session_key->decrypted_key_size;\n\texpected_checksum += (unsigned char)(data[i++]) << 8;\n\texpected_checksum += (unsigned char)(data[i++]);\n\tfor (i = 0; i < session_key->decrypted_key_size; i++)\n\t\tchecksum += session_key->decrypted_key[i];\n\tif (expected_checksum != checksum) {\n\t\tecryptfs_printk(KERN_ERR, \"Invalid checksum for file \"\n\t\t\t\t\"encryption  key; expected [%x]; calculated \"\n\t\t\t\t\"[%x]\\n\", expected_checksum, checksum);\n\t\trc = -EIO;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nparse_tag_65_packet(struct ecryptfs_session_key *session_key, u8 *cipher_code,\n\t\t    struct ecryptfs_message *msg)\n{\n\tsize_t i = 0;\n\tchar *data;\n\tsize_t data_len;\n\tsize_t m_size;\n\tsize_t message_len;\n\tu16 checksum = 0;\n\tu16 expected_checksum = 0;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 65 Packet Format *****\n\t *         | Content Type             | 1 byte       |\n\t *         | Status Indicator         | 1 byte       |\n\t *         | File Encryption Key Size | 1 or 2 bytes |\n\t *         | File Encryption Key      | arbitrary    |\n\t */\n\tmessage_len = msg->data_len;\n\tdata = msg->data;\n\tif (message_len < 4) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (data[i++] != ECRYPTFS_TAG_65_PACKET_TYPE) {\n\t\tecryptfs_printk(KERN_ERR, \"Type should be ECRYPTFS_TAG_65\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (data[i++]) {\n\t\tecryptfs_printk(KERN_ERR, \"Status indicator has non-zero value \"\n\t\t\t\t\"[%d]\\n\", data[i-1]);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[i], &m_size, &data_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error parsing packet length; \"\n\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\ti += data_len;\n\tif (message_len < (i + m_size)) {\n\t\tecryptfs_printk(KERN_ERR, \"The message received from ecryptfsd \"\n\t\t\t\t\"is shorter than expected\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (m_size < 3) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"The decrypted key is not long enough to \"\n\t\t\t\t\"include a cipher code and checksum\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\t*cipher_code = data[i++];\n\t/* The decrypted key includes 1 byte cipher code and 2 byte checksum */\n\tsession_key->decrypted_key_size = m_size - 3;\n\tif (session_key->decrypted_key_size > ECRYPTFS_MAX_KEY_BYTES) {\n\t\tecryptfs_printk(KERN_ERR, \"key_size [%d] larger than \"\n\t\t\t\t\"the maximum key size [%d]\\n\",\n\t\t\t\tsession_key->decrypted_key_size,\n\t\t\t\tECRYPTFS_MAX_ENCRYPTED_KEY_BYTES);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tmemcpy(session_key->decrypted_key, &data[i],\n\t       session_key->decrypted_key_size);\n\ti += session_key->decrypted_key_size;\n\texpected_checksum += (unsigned char)(data[i++]) << 8;\n\texpected_checksum += (unsigned char)(data[i++]);\n\tfor (i = 0; i < session_key->decrypted_key_size; i++)\n\t\tchecksum += session_key->decrypted_key[i];\n\tif (expected_checksum != checksum) {\n\t\tecryptfs_printk(KERN_ERR, \"Invalid checksum for file \"\n\t\t\t\t\"encryption  key; expected [%x]; calculated \"\n\t\t\t\t\"[%x]\\n\", expected_checksum, checksum);\n\t\trc = -EIO;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_wait_for_response",
          "args": [
            "msg_ctx",
            "&msg"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_wait_for_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "639-643",
          "snippet": "static inline int ecryptfs_wait_for_response(struct ecryptfs_msg_ctx *msg_ctx,\n\t\t\t\t\t     struct ecryptfs_message **emsg)\n{\n\treturn -ENOMSG;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline int ecryptfs_wait_for_response(struct ecryptfs_msg_ctx *msg_ctx,\n\t\t\t\t\t     struct ecryptfs_message **emsg)\n{\n\treturn -ENOMSG;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_send_message",
          "args": [
            "payload",
            "payload_len",
            "&msg_ctx"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_send_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "634-638",
          "snippet": "static inline int ecryptfs_send_message(char *data, int data_len,\n\t\t\t\t\tstruct ecryptfs_msg_ctx **msg_ctx)\n{\n\treturn -ENOTCONN;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline int ecryptfs_send_message(char *data, int data_len,\n\t\t\t\t\tstruct ecryptfs_msg_ctx **msg_ctx)\n{\n\treturn -ENOTCONN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_tag_64_packet",
          "args": [
            "auth_tok_sig",
            "&(auth_tok->session_key)",
            "&payload",
            "&payload_len"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "write_tag_64_packet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "156-209",
          "snippet": "static int\nwrite_tag_64_packet(char *signature, struct ecryptfs_session_key *session_key,\n\t\t    char **packet, size_t *packet_len)\n{\n\tsize_t i = 0;\n\tsize_t data_len;\n\tsize_t packet_size_len;\n\tchar *message;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 64 Packet Format *****\n\t *    | Content Type                       | 1 byte       |\n\t *    | Key Identifier Size                | 1 or 2 bytes |\n\t *    | Key Identifier                     | arbitrary    |\n\t *    | Encrypted File Encryption Key Size | 1 or 2 bytes |\n\t *    | Encrypted File Encryption Key      | arbitrary    |\n\t */\n\tdata_len = (5 + ECRYPTFS_SIG_SIZE_HEX\n\t\t    + session_key->encrypted_key_size);\n\t*packet = kmalloc(data_len, GFP_KERNEL);\n\tmessage = *packet;\n\tif (!message) {\n\t\tecryptfs_printk(KERN_ERR, \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmessage[i++] = ECRYPTFS_TAG_64_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&message[i], ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 64 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], signature, ECRYPTFS_SIG_SIZE_HEX);\n\ti += ECRYPTFS_SIG_SIZE_HEX;\n\trc = ecryptfs_write_packet_length(&message[i],\n\t\t\t\t\t  session_key->encrypted_key_size,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 64 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], session_key->encrypted_key,\n\t       session_key->encrypted_key_size);\n\ti += session_key->encrypted_key_size;\n\t*packet_len = i;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nwrite_tag_64_packet(char *signature, struct ecryptfs_session_key *session_key,\n\t\t    char **packet, size_t *packet_len)\n{\n\tsize_t i = 0;\n\tsize_t data_len;\n\tsize_t packet_size_len;\n\tchar *message;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 64 Packet Format *****\n\t *    | Content Type                       | 1 byte       |\n\t *    | Key Identifier Size                | 1 or 2 bytes |\n\t *    | Key Identifier                     | arbitrary    |\n\t *    | Encrypted File Encryption Key Size | 1 or 2 bytes |\n\t *    | Encrypted File Encryption Key      | arbitrary    |\n\t */\n\tdata_len = (5 + ECRYPTFS_SIG_SIZE_HEX\n\t\t    + session_key->encrypted_key_size);\n\t*packet = kmalloc(data_len, GFP_KERNEL);\n\tmessage = *packet;\n\tif (!message) {\n\t\tecryptfs_printk(KERN_ERR, \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmessage[i++] = ECRYPTFS_TAG_64_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&message[i], ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 64 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], signature, ECRYPTFS_SIG_SIZE_HEX);\n\ti += ECRYPTFS_SIG_SIZE_HEX;\n\trc = ecryptfs_write_packet_length(&message[i],\n\t\t\t\t\t  session_key->encrypted_key_size,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 64 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], session_key->encrypted_key,\n\t       session_key->encrypted_key_size);\n\ti += session_key->encrypted_key_size;\n\t*packet_len = i;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_auth_tok_sig",
          "args": [
            "&auth_tok_sig",
            "auth_tok"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_auth_tok_sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "1115-1134",
          "snippet": "static int\necryptfs_get_auth_tok_sig(char **sig, struct ecryptfs_auth_tok *auth_tok)\n{\n\tint rc = 0;\n\n\t(*sig) = NULL;\n\tswitch (auth_tok->token_type) {\n\tcase ECRYPTFS_PASSWORD:\n\t\t(*sig) = auth_tok->token.password.signature;\n\t\tbreak;\n\tcase ECRYPTFS_PRIVATE_KEY:\n\t\t(*sig) = auth_tok->token.private_key.signature;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Cannot get sig for auth_tok of type [%d]\\n\",\n\t\t       auth_tok->token_type);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_get_auth_tok_sig(char **sig, struct ecryptfs_auth_tok *auth_tok)\n{\n\tint rc = 0;\n\n\t(*sig) = NULL;\n\tswitch (auth_tok->token_type) {\n\tcase ECRYPTFS_PASSWORD:\n\t\t(*sig) = auth_tok->token.password.signature;\n\t\tbreak;\n\tcase ECRYPTFS_PRIVATE_KEY:\n\t\t(*sig) = auth_tok->token.private_key.signature;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Cannot get sig for auth_tok of type [%d]\\n\",\n\t\t       auth_tok->token_type);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\ndecrypt_pki_encrypted_session_key(struct ecryptfs_auth_tok *auth_tok,\n\t\t\t\t  struct ecryptfs_crypt_stat *crypt_stat)\n{\n\tu8 cipher_code = 0;\n\tstruct ecryptfs_msg_ctx *msg_ctx;\n\tstruct ecryptfs_message *msg = NULL;\n\tchar *auth_tok_sig;\n\tchar *payload = NULL;\n\tsize_t payload_len = 0;\n\tint rc;\n\n\trc = ecryptfs_get_auth_tok_sig(&auth_tok_sig, auth_tok);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Unrecognized auth tok type: [%d]\\n\",\n\t\t       auth_tok->token_type);\n\t\tgoto out;\n\t}\n\trc = write_tag_64_packet(auth_tok_sig, &(auth_tok->session_key),\n\t\t\t\t &payload, &payload_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to write tag 64 packet\\n\");\n\t\tgoto out;\n\t}\n\trc = ecryptfs_send_message(payload, payload_len, &msg_ctx);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error sending message to \"\n\t\t\t\t\"ecryptfsd: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_wait_for_response(msg_ctx, &msg);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Failed to receive tag 65 packet \"\n\t\t\t\t\"from the user space daemon\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = parse_tag_65_packet(&(auth_tok->session_key),\n\t\t\t\t &cipher_code, msg);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"Failed to parse tag 65 packet; rc = [%d]\\n\",\n\t\t       rc);\n\t\tgoto out;\n\t}\n\tauth_tok->session_key.flags |= ECRYPTFS_CONTAINS_DECRYPTED_KEY;\n\tmemcpy(crypt_stat->key, auth_tok->session_key.decrypted_key,\n\t       auth_tok->session_key.decrypted_key_size);\n\tcrypt_stat->key_size = auth_tok->session_key.decrypted_key_size;\n\trc = ecryptfs_cipher_code_to_string(crypt_stat->cipher, cipher_code);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Cipher code [%d] is invalid\\n\",\n\t\t\t\tcipher_code)\n\t\tgoto out;\n\t}\n\tcrypt_stat->flags |= ECRYPTFS_KEY_VALID;\n\tif (ecryptfs_verbosity > 0) {\n\t\tecryptfs_printk(KERN_DEBUG, \"Decrypted session key:\\n\");\n\t\tecryptfs_dump_hex(crypt_stat->key,\n\t\t\t\t  crypt_stat->key_size);\n\t}\nout:\n\tkfree(msg);\n\tkfree(payload);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_get_auth_tok_sig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "1115-1134",
    "snippet": "static int\necryptfs_get_auth_tok_sig(char **sig, struct ecryptfs_auth_tok *auth_tok)\n{\n\tint rc = 0;\n\n\t(*sig) = NULL;\n\tswitch (auth_tok->token_type) {\n\tcase ECRYPTFS_PASSWORD:\n\t\t(*sig) = auth_tok->token.password.signature;\n\t\tbreak;\n\tcase ECRYPTFS_PRIVATE_KEY:\n\t\t(*sig) = auth_tok->token.private_key.signature;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Cannot get sig for auth_tok of type [%d]\\n\",\n\t\t       auth_tok->token_type);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Cannot get sig for auth_tok of type [%d]\\n\"",
            "auth_tok->token_type"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_get_auth_tok_sig(char **sig, struct ecryptfs_auth_tok *auth_tok)\n{\n\tint rc = 0;\n\n\t(*sig) = NULL;\n\tswitch (auth_tok->token_type) {\n\tcase ECRYPTFS_PASSWORD:\n\t\t(*sig) = auth_tok->token.password.signature;\n\t\tbreak;\n\tcase ECRYPTFS_PRIVATE_KEY:\n\t\t(*sig) = auth_tok->token.private_key.signature;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Cannot get sig for auth_tok of type [%d]\\n\",\n\t\t       auth_tok->token_type);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_parse_tag_70_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "912-1113",
    "snippet": "int\necryptfs_parse_tag_70_packet(char **filename, size_t *filename_size,\n\t\t\t     size_t *packet_size,\n\t\t\t     struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *data, size_t max_packet_size)\n{\n\tstruct ecryptfs_parse_tag_70_packet_silly_stack *s;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*filename_size) = 0;\n\t(*filename) = NULL;\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst trying to kmalloc \"\n\t\t       \"[%zd] bytes of kernel memory\\n\", __func__, sizeof(*s));\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\ts->desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tif (max_packet_size < ECRYPTFS_TAG_70_MIN_METADATA_SIZE) {\n\t\tprintk(KERN_WARNING \"%s: max_packet_size is [%zd]; it must be \"\n\t\t       \"at least [%d]\\n\", __func__, max_packet_size,\n\t\t       ECRYPTFS_TAG_70_MIN_METADATA_SIZE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Octet 0: Tag 70 identifier\n\t * Octets 1-N1: Tag 70 packet size (includes cipher identifier\n\t *              and block-aligned encrypted filename size)\n\t * Octets N1-N2: FNEK sig (ECRYPTFS_SIG_SIZE)\n\t * Octet N2-N3: Cipher identifier (1 octet)\n\t * Octets N3-N4: Block-aligned encrypted filename\n\t *  - Consists of a minimum number of random numbers, a \\0\n\t *    separator, and then the filename */\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_70_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"%s: Invalid packet tag [0x%.2x]; must be \"\n\t\t       \"tag [0x%.2x]\\n\", __func__,\n\t\t       data[((*packet_size) - 1)], ECRYPTFS_TAG_70_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)],\n\t\t\t\t\t  &s->parsed_tag_70_packet_size,\n\t\t\t\t\t  &s->packet_size_len);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Error parsing packet length; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\ts->block_aligned_filename_size = (s->parsed_tag_70_packet_size\n\t\t\t\t\t  - ECRYPTFS_SIG_SIZE - 1);\n\tif ((1 + s->packet_size_len + s->parsed_tag_70_packet_size)\n\t    > max_packet_size) {\n\t\tprintk(KERN_WARNING \"%s: max_packet_size is [%zd]; real packet \"\n\t\t       \"size is [%zd]\\n\", __func__, max_packet_size,\n\t\t       (1 + s->packet_size_len + 1\n\t\t\t+ s->block_aligned_filename_size));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += s->packet_size_len;\n\tecryptfs_to_hex(s->fnek_sig_hex, &data[(*packet_size)],\n\t\t\tECRYPTFS_SIG_SIZE);\n\ts->fnek_sig_hex[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t(*packet_size) += ECRYPTFS_SIG_SIZE;\n\ts->cipher_code = data[(*packet_size)++];\n\trc = ecryptfs_cipher_code_to_string(s->cipher_string, s->cipher_code);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Cipher code [%d] is invalid\\n\",\n\t\t       __func__, s->cipher_code);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_find_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t    &s->auth_tok, mount_crypt_stat,\n\t\t\t\t\t    s->fnek_sig_hex);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to find auth tok for \"\n\t\t       \"fnek sig [%s]; rc = [%d]\\n\", __func__, s->fnek_sig_hex,\n\t\t       rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&s->desc.tfm,\n\t\t\t\t\t\t\t&s->tfm_mutex,\n\t\t\t\t\t\t\ts->cipher_string);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       s->cipher_string, rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(s->tfm_mutex);\n\trc = virt_to_scatterlist(&data[(*packet_size)],\n\t\t\t\t s->block_aligned_filename_size, s->src_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert encrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_unlock;\n\t}\n\t(*packet_size) += s->block_aligned_filename_size;\n\ts->decrypted_filename = kmalloc(s->block_aligned_filename_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!s->decrypted_filename) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting to \"\n\t\t       \"kmalloc [%zd] bytes\\n\", __func__,\n\t\t       s->block_aligned_filename_size);\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\trc = virt_to_scatterlist(s->decrypted_filename,\n\t\t\t\t s->block_aligned_filename_size, s->dst_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert decrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_free_unlock;\n\t}\n\t/* The characters in the first block effectively do the job of\n\t * the IV here, so we just use 0's for the IV. Note the\n\t * constraint that ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES\n\t * >= ECRYPTFS_MAX_IV_BYTES. */\n\tmemset(s->iv, 0, ECRYPTFS_MAX_IV_BYTES);\n\ts->desc.info = s->iv;\n\t/* TODO: Support other key modules than passphrase for\n\t * filename encryption */\n\tif (s->auth_tok->token_type != ECRYPTFS_PASSWORD) {\n\t\trc = -EOPNOTSUPP;\n\t\tprintk(KERN_INFO \"%s: Filename encryption only supports \"\n\t\t       \"password tokens\\n\", __func__);\n\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_blkcipher_setkey(\n\t\ts->desc.tfm,\n\t\ts->auth_tok->token.password.session_key_encryption_key,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error setting key for crypto context; \"\n\t\t       \"rc = [%d]. s->auth_tok->token.password.session_key_\"\n\t\t       \"encryption_key = [0x%p]; mount_crypt_stat->\"\n\t\t       \"global_default_fn_cipher_key_bytes = [%zd]\\n\", __func__,\n\t\t       rc,\n\t\t       s->auth_tok->token.password.session_key_encryption_key,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_blkcipher_decrypt_iv(&s->desc, s->dst_sg, s->src_sg,\n\t\t\t\t\t s->block_aligned_filename_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to decrypt filename; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free_unlock;\n\t}\n\ts->i = 0;\n\twhile (s->decrypted_filename[s->i] != '\\0'\n\t       && s->i < s->block_aligned_filename_size)\n\t\ts->i++;\n\tif (s->i == s->block_aligned_filename_size) {\n\t\tprintk(KERN_WARNING \"%s: Invalid tag 70 packet; could not \"\n\t\t       \"find valid separator between random characters and \"\n\t\t       \"the filename\\n\", __func__);\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\ts->i++;\n\t(*filename_size) = (s->block_aligned_filename_size - s->i);\n\tif (!((*filename_size) > 0 && (*filename_size < PATH_MAX))) {\n\t\tprintk(KERN_WARNING \"%s: Filename size is [%zd], which is \"\n\t\t       \"invalid\\n\", __func__, (*filename_size));\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\t(*filename) = kmalloc(((*filename_size) + 1), GFP_KERNEL);\n\tif (!(*filename)) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting to \"\n\t\t       \"kmalloc [%zd] bytes\\n\", __func__,\n\t\t       ((*filename_size) + 1));\n\t\trc = -ENOMEM;\n\t\tgoto out_free_unlock;\n\t}\n\tmemcpy((*filename), &s->decrypted_filename[s->i], (*filename_size));\n\t(*filename)[(*filename_size)] = '\\0';\nout_free_unlock:\n\tkfree(s->decrypted_filename);\nout_unlock:\n\tmutex_unlock(s->tfm_mutex);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*filename_size) = 0;\n\t\t(*filename) = NULL;\n\t}\n\tif (auth_tok_key) {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t}\n\tkfree(s);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "auth_tok_key"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&(auth_tok_key->sem)"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "s->tfm_mutex"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s->decrypted_filename"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(*filename)",
            "&s->decrypted_filename[s->i]",
            "(*filename_size)"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Out of memory whilst attempting to \"\n\t\t       \"kmalloc [%zd] bytes\\n\"",
            "__func__",
            "((*filename_size) + 1)"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "((*filename_size) + 1)",
            "GFP_KERNEL"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_decrypt_iv",
          "args": [
            "&s->desc",
            "s->dst_sg",
            "s->src_sg",
            "s->block_aligned_filename_size"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_setkey",
          "args": [
            "s->desc.tfm",
            "s->auth_tok->token.password.session_key_encryption_key",
            "mount_crypt_stat->global_default_fn_cipher_key_bytes"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "s->iv",
            "0",
            "ECRYPTFS_MAX_IV_BYTES"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_scatterlist",
          "args": [
            "s->decrypted_filename",
            "s->block_aligned_filename_size",
            "s->dst_sg",
            "2"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "virt_to_scatterlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "283-312",
          "snippet": "int virt_to_scatterlist(const void *addr, int size, struct scatterlist *sg,\n\t\t\tint sg_size)\n{\n\tint i = 0;\n\tstruct page *pg;\n\tint offset;\n\tint remainder_of_page;\n\n\tsg_init_table(sg, sg_size);\n\n\twhile (size > 0 && i < sg_size) {\n\t\tpg = virt_to_page(addr);\n\t\toffset = offset_in_page(addr);\n\t\tsg_set_page(&sg[i], pg, 0, offset);\n\t\tremainder_of_page = PAGE_CACHE_SIZE - offset;\n\t\tif (size >= remainder_of_page) {\n\t\t\tsg[i].length = remainder_of_page;\n\t\t\taddr += remainder_of_page;\n\t\t\tsize -= remainder_of_page;\n\t\t} else {\n\t\t\tsg[i].length = size;\n\t\t\taddr += size;\n\t\t\tsize = 0;\n\t\t}\n\t\ti++;\n\t}\n\tif (size > 0)\n\t\treturn -ENOMEM;\n\treturn i;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint virt_to_scatterlist(const void *addr, int size, struct scatterlist *sg,\n\t\t\tint sg_size)\n{\n\tint i = 0;\n\tstruct page *pg;\n\tint offset;\n\tint remainder_of_page;\n\n\tsg_init_table(sg, sg_size);\n\n\twhile (size > 0 && i < sg_size) {\n\t\tpg = virt_to_page(addr);\n\t\toffset = offset_in_page(addr);\n\t\tsg_set_page(&sg[i], pg, 0, offset);\n\t\tremainder_of_page = PAGE_CACHE_SIZE - offset;\n\t\tif (size >= remainder_of_page) {\n\t\t\tsg[i].length = remainder_of_page;\n\t\t\taddr += remainder_of_page;\n\t\t\tsize -= remainder_of_page;\n\t\t} else {\n\t\t\tsg[i].length = size;\n\t\t\taddr += size;\n\t\t\tsize = 0;\n\t\t}\n\t\ti++;\n\t}\n\tif (size > 0)\n\t\treturn -ENOMEM;\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "s->tfm_mutex"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_tfm_and_mutex_for_cipher_name",
          "args": [
            "&s->desc.tfm",
            "&s->tfm_mutex",
            "s->cipher_string"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_tfm_and_mutex_for_cipher_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1751-1775",
          "snippet": "int ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mutex key_tfm_list_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct mutex key_tfm_list_mutex;\n\nint ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_find_auth_tok_for_sig",
          "args": [
            "&auth_tok_key",
            "&s->auth_tok",
            "mount_crypt_stat",
            "s->fnek_sig_hex"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_find_auth_tok_for_sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "558-583",
          "snippet": "static int\necryptfs_find_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tchar *sig)\n{\n\tint rc = 0;\n\n\trc = ecryptfs_find_global_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t   mount_crypt_stat, sig);\n\tif (rc == -ENOENT) {\n\t\t/* if the flag ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY is set in the\n\t\t * mount_crypt_stat structure, we prevent to use auth toks that\n\t\t * are not inserted through the ecryptfs_add_global_auth_tok\n\t\t * function.\n\t\t */\n\t\tif (mount_crypt_stat->flags\n\t\t\t\t& ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY)\n\t\t\treturn -EINVAL;\n\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t       sig);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_find_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tchar *sig)\n{\n\tint rc = 0;\n\n\trc = ecryptfs_find_global_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t   mount_crypt_stat, sig);\n\tif (rc == -ENOENT) {\n\t\t/* if the flag ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY is set in the\n\t\t * mount_crypt_stat structure, we prevent to use auth toks that\n\t\t * are not inserted through the ecryptfs_add_global_auth_tok\n\t\t * function.\n\t\t */\n\t\tif (mount_crypt_stat->flags\n\t\t\t\t& ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY)\n\t\t\treturn -EINVAL;\n\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t       sig);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_cipher_code_to_string",
          "args": [
            "s->cipher_string",
            "s->cipher_code"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_cipher_code_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1020-1035",
          "snippet": "int ecryptfs_cipher_code_to_string(char *str, u8 cipher_code)\n{\n\tint rc = 0;\n\tint i;\n\n\tstr[0] = '\\0';\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\tif (cipher_code == ecryptfs_cipher_code_str_map[i].cipher_code)\n\t\t\tstrcpy(str, ecryptfs_cipher_code_str_map[i].cipher_str);\n\tif (str[0] == '\\0') {\n\t\tecryptfs_printk(KERN_WARNING, \"Cipher code not recognized: \"\n\t\t\t\t\"[%d]\\n\", cipher_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};\n\nint ecryptfs_cipher_code_to_string(char *str, u8 cipher_code)\n{\n\tint rc = 0;\n\tint i;\n\n\tstr[0] = '\\0';\n\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\tif (cipher_code == ecryptfs_cipher_code_str_map[i].cipher_code)\n\t\t\tstrcpy(str, ecryptfs_cipher_code_str_map[i].cipher_str);\n\tif (str[0] == '\\0') {\n\t\tecryptfs_printk(KERN_WARNING, \"Cipher code not recognized: \"\n\t\t\t\t\"[%d]\\n\", cipher_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_to_hex",
          "args": [
            "s->fnek_sig_hex",
            "&data[(*packet_size)]",
            "ECRYPTFS_SIG_SIZE"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_to_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "50-56",
          "snippet": "void ecryptfs_to_hex(char *dst, char *src, size_t src_size)\n{\n\tint x;\n\n\tfor (x = 0; x < src_size; x++)\n\t\tsprintf(&dst[x * 2], \"%.2x\", (unsigned char)src[x]);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_to_hex(char *dst, char *src, size_t src_size)\n{\n\tint x;\n\n\tfor (x = 0; x < src_size; x++)\n\t\tsprintf(&dst[x * 2], \"%.2x\", (unsigned char)src[x]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_parse_packet_length",
          "args": [
            "&data[(*packet_size)]",
            "&s->parsed_tag_70_packet_size",
            "&s->packet_size_len"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_parse_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "94-123",
          "snippet": "int ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint\necryptfs_parse_tag_70_packet(char **filename, size_t *filename_size,\n\t\t\t     size_t *packet_size,\n\t\t\t     struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *data, size_t max_packet_size)\n{\n\tstruct ecryptfs_parse_tag_70_packet_silly_stack *s;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\t(*packet_size) = 0;\n\t(*filename_size) = 0;\n\t(*filename) = NULL;\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst trying to kmalloc \"\n\t\t       \"[%zd] bytes of kernel memory\\n\", __func__, sizeof(*s));\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\ts->desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tif (max_packet_size < ECRYPTFS_TAG_70_MIN_METADATA_SIZE) {\n\t\tprintk(KERN_WARNING \"%s: max_packet_size is [%zd]; it must be \"\n\t\t       \"at least [%d]\\n\", __func__, max_packet_size,\n\t\t       ECRYPTFS_TAG_70_MIN_METADATA_SIZE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t/* Octet 0: Tag 70 identifier\n\t * Octets 1-N1: Tag 70 packet size (includes cipher identifier\n\t *              and block-aligned encrypted filename size)\n\t * Octets N1-N2: FNEK sig (ECRYPTFS_SIG_SIZE)\n\t * Octet N2-N3: Cipher identifier (1 octet)\n\t * Octets N3-N4: Block-aligned encrypted filename\n\t *  - Consists of a minimum number of random numbers, a \\0\n\t *    separator, and then the filename */\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_70_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"%s: Invalid packet tag [0x%.2x]; must be \"\n\t\t       \"tag [0x%.2x]\\n\", __func__,\n\t\t       data[((*packet_size) - 1)], ECRYPTFS_TAG_70_PACKET_TYPE);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)],\n\t\t\t\t\t  &s->parsed_tag_70_packet_size,\n\t\t\t\t\t  &s->packet_size_len);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Error parsing packet length; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out;\n\t}\n\ts->block_aligned_filename_size = (s->parsed_tag_70_packet_size\n\t\t\t\t\t  - ECRYPTFS_SIG_SIZE - 1);\n\tif ((1 + s->packet_size_len + s->parsed_tag_70_packet_size)\n\t    > max_packet_size) {\n\t\tprintk(KERN_WARNING \"%s: max_packet_size is [%zd]; real packet \"\n\t\t       \"size is [%zd]\\n\", __func__, max_packet_size,\n\t\t       (1 + s->packet_size_len + 1\n\t\t\t+ s->block_aligned_filename_size));\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += s->packet_size_len;\n\tecryptfs_to_hex(s->fnek_sig_hex, &data[(*packet_size)],\n\t\t\tECRYPTFS_SIG_SIZE);\n\ts->fnek_sig_hex[ECRYPTFS_SIG_SIZE_HEX] = '\\0';\n\t(*packet_size) += ECRYPTFS_SIG_SIZE;\n\ts->cipher_code = data[(*packet_size)++];\n\trc = ecryptfs_cipher_code_to_string(s->cipher_string, s->cipher_code);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"%s: Cipher code [%d] is invalid\\n\",\n\t\t       __func__, s->cipher_code);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_find_auth_tok_for_sig(&auth_tok_key,\n\t\t\t\t\t    &s->auth_tok, mount_crypt_stat,\n\t\t\t\t\t    s->fnek_sig_hex);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to find auth tok for \"\n\t\t       \"fnek sig [%s]; rc = [%d]\\n\", __func__, s->fnek_sig_hex,\n\t\t       rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&s->desc.tfm,\n\t\t\t\t\t\t\t&s->tfm_mutex,\n\t\t\t\t\t\t\ts->cipher_string);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       s->cipher_string, rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(s->tfm_mutex);\n\trc = virt_to_scatterlist(&data[(*packet_size)],\n\t\t\t\t s->block_aligned_filename_size, s->src_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert encrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_unlock;\n\t}\n\t(*packet_size) += s->block_aligned_filename_size;\n\ts->decrypted_filename = kmalloc(s->block_aligned_filename_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!s->decrypted_filename) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting to \"\n\t\t       \"kmalloc [%zd] bytes\\n\", __func__,\n\t\t       s->block_aligned_filename_size);\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\trc = virt_to_scatterlist(s->decrypted_filename,\n\t\t\t\t s->block_aligned_filename_size, s->dst_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert decrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_free_unlock;\n\t}\n\t/* The characters in the first block effectively do the job of\n\t * the IV here, so we just use 0's for the IV. Note the\n\t * constraint that ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES\n\t * >= ECRYPTFS_MAX_IV_BYTES. */\n\tmemset(s->iv, 0, ECRYPTFS_MAX_IV_BYTES);\n\ts->desc.info = s->iv;\n\t/* TODO: Support other key modules than passphrase for\n\t * filename encryption */\n\tif (s->auth_tok->token_type != ECRYPTFS_PASSWORD) {\n\t\trc = -EOPNOTSUPP;\n\t\tprintk(KERN_INFO \"%s: Filename encryption only supports \"\n\t\t       \"password tokens\\n\", __func__);\n\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_blkcipher_setkey(\n\t\ts->desc.tfm,\n\t\ts->auth_tok->token.password.session_key_encryption_key,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error setting key for crypto context; \"\n\t\t       \"rc = [%d]. s->auth_tok->token.password.session_key_\"\n\t\t       \"encryption_key = [0x%p]; mount_crypt_stat->\"\n\t\t       \"global_default_fn_cipher_key_bytes = [%zd]\\n\", __func__,\n\t\t       rc,\n\t\t       s->auth_tok->token.password.session_key_encryption_key,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_blkcipher_decrypt_iv(&s->desc, s->dst_sg, s->src_sg,\n\t\t\t\t\t s->block_aligned_filename_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to decrypt filename; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_free_unlock;\n\t}\n\ts->i = 0;\n\twhile (s->decrypted_filename[s->i] != '\\0'\n\t       && s->i < s->block_aligned_filename_size)\n\t\ts->i++;\n\tif (s->i == s->block_aligned_filename_size) {\n\t\tprintk(KERN_WARNING \"%s: Invalid tag 70 packet; could not \"\n\t\t       \"find valid separator between random characters and \"\n\t\t       \"the filename\\n\", __func__);\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\ts->i++;\n\t(*filename_size) = (s->block_aligned_filename_size - s->i);\n\tif (!((*filename_size) > 0 && (*filename_size < PATH_MAX))) {\n\t\tprintk(KERN_WARNING \"%s: Filename size is [%zd], which is \"\n\t\t       \"invalid\\n\", __func__, (*filename_size));\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\t(*filename) = kmalloc(((*filename_size) + 1), GFP_KERNEL);\n\tif (!(*filename)) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst attempting to \"\n\t\t       \"kmalloc [%zd] bytes\\n\", __func__,\n\t\t       ((*filename_size) + 1));\n\t\trc = -ENOMEM;\n\t\tgoto out_free_unlock;\n\t}\n\tmemcpy((*filename), &s->decrypted_filename[s->i], (*filename_size));\n\t(*filename)[(*filename_size)] = '\\0';\nout_free_unlock:\n\tkfree(s->decrypted_filename);\nout_unlock:\n\tmutex_unlock(s->tfm_mutex);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*filename_size) = 0;\n\t\t(*filename) = NULL;\n\t}\n\tif (auth_tok_key) {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t}\n\tkfree(s);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_write_tag_70_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "622-876",
    "snippet": "int\necryptfs_write_tag_70_packet(char *dest, size_t *remaining_bytes,\n\t\t\t     size_t *packet_size,\n\t\t\t     struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *filename, size_t filename_size)\n{\n\tstruct ecryptfs_write_tag_70_packet_silly_stack *s;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst trying to kmalloc \"\n\t\t       \"[%zd] bytes of kernel memory\\n\", __func__, sizeof(*s));\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\ts->desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\t(*packet_size) = 0;\n\trc = ecryptfs_find_auth_tok_for_sig(\n\t\t&auth_tok_key,\n\t\t&s->auth_tok, mount_crypt_stat,\n\t\tmount_crypt_stat->global_default_fnek_sig);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to find auth tok for \"\n\t\t       \"fnek sig [%s]; rc = [%d]\\n\", __func__,\n\t\t       mount_crypt_stat->global_default_fnek_sig, rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(\n\t\t&s->desc.tfm,\n\t\t&s->tfm_mutex, mount_crypt_stat->global_default_fn_cipher_name);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       mount_crypt_stat->global_default_fn_cipher_name, rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(s->tfm_mutex);\n\ts->block_size = crypto_blkcipher_blocksize(s->desc.tfm);\n\t/* Plus one for the \\0 separator between the random prefix\n\t * and the plaintext filename */\n\ts->num_rand_bytes = (ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES + 1);\n\ts->block_aligned_filename_size = (s->num_rand_bytes + filename_size);\n\tif ((s->block_aligned_filename_size % s->block_size) != 0) {\n\t\ts->num_rand_bytes += (s->block_size\n\t\t\t\t      - (s->block_aligned_filename_size\n\t\t\t\t\t % s->block_size));\n\t\ts->block_aligned_filename_size = (s->num_rand_bytes\n\t\t\t\t\t\t  + filename_size);\n\t}\n\t/* Octet 0: Tag 70 identifier\n\t * Octets 1-N1: Tag 70 packet size (includes cipher identifier\n\t *              and block-aligned encrypted filename size)\n\t * Octets N1-N2: FNEK sig (ECRYPTFS_SIG_SIZE)\n\t * Octet N2-N3: Cipher identifier (1 octet)\n\t * Octets N3-N4: Block-aligned encrypted filename\n\t *  - Consists of a minimum number of random characters, a \\0\n\t *    separator, and then the filename */\n\ts->max_packet_size = (ECRYPTFS_TAG_70_MAX_METADATA_SIZE\n\t\t\t      + s->block_aligned_filename_size);\n\tif (dest == NULL) {\n\t\t(*packet_size) = s->max_packet_size;\n\t\tgoto out_unlock;\n\t}\n\tif (s->max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_WARNING \"%s: Require [%zd] bytes to write; only \"\n\t\t       \"[%zd] available\\n\", __func__, s->max_packet_size,\n\t\t       (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ts->block_aligned_filename = kzalloc(s->block_aligned_filename_size,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!s->block_aligned_filename) {\n\t\tprintk(KERN_ERR \"%s: Out of kernel memory whilst attempting to \"\n\t\t       \"kzalloc [%zd] bytes\\n\", __func__,\n\t\t       s->block_aligned_filename_size);\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\ts->i = 0;\n\tdest[s->i++] = ECRYPTFS_TAG_70_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[s->i],\n\t\t\t\t\t  (ECRYPTFS_SIG_SIZE\n\t\t\t\t\t   + 1 /* Cipher code */\n\t\t\t\t\t   + s->block_aligned_filename_size),\n\t\t\t\t\t  &s->packet_size_len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error generating tag 70 packet \"\n\t\t       \"header; cannot generate packet length; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free_unlock;\n\t}\n\ts->i += s->packet_size_len;\n\tecryptfs_from_hex(&dest[s->i],\n\t\t\t  mount_crypt_stat->global_default_fnek_sig,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\ts->i += ECRYPTFS_SIG_SIZE;\n\ts->cipher_code = ecryptfs_code_for_cipher_string(\n\t\tmount_crypt_stat->global_default_fn_cipher_name,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (s->cipher_code == 0) {\n\t\tprintk(KERN_WARNING \"%s: Unable to generate code for \"\n\t\t       \"cipher [%s] with key bytes [%zd]\\n\", __func__,\n\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\tdest[s->i++] = s->cipher_code;\n\t/* TODO: Support other key modules than passphrase for\n\t * filename encryption */\n\tif (s->auth_tok->token_type != ECRYPTFS_PASSWORD) {\n\t\trc = -EOPNOTSUPP;\n\t\tprintk(KERN_INFO \"%s: Filename encryption only supports \"\n\t\t       \"password tokens\\n\", __func__);\n\t\tgoto out_free_unlock;\n\t}\n\tsg_init_one(\n\t\t&s->hash_sg,\n\t\t(u8 *)s->auth_tok->token.password.session_key_encryption_key,\n\t\ts->auth_tok->token.password.session_key_encryption_key_bytes);\n\ts->hash_desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\ts->hash_desc.tfm = crypto_alloc_hash(ECRYPTFS_TAG_70_DIGEST, 0,\n\t\t\t\t\t     CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(s->hash_desc.tfm)) {\n\t\t\trc = PTR_ERR(s->hash_desc.tfm);\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to \"\n\t\t\t       \"allocate hash crypto context; rc = [%d]\\n\",\n\t\t\t       __func__, rc);\n\t\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_hash_init(&s->hash_desc);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error initializing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = crypto_hash_update(\n\t\t&s->hash_desc, &s->hash_sg,\n\t\ts->auth_tok->token.password.session_key_encryption_key_bytes);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error updating crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = crypto_hash_final(&s->hash_desc, s->hash);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error finalizing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\tfor (s->j = 0; s->j < (s->num_rand_bytes - 1); s->j++) {\n\t\ts->block_aligned_filename[s->j] =\n\t\t\ts->hash[(s->j % ECRYPTFS_TAG_70_DIGEST_SIZE)];\n\t\tif ((s->j % ECRYPTFS_TAG_70_DIGEST_SIZE)\n\t\t    == (ECRYPTFS_TAG_70_DIGEST_SIZE - 1)) {\n\t\t\tsg_init_one(&s->hash_sg, (u8 *)s->hash,\n\t\t\t\t    ECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t\trc = crypto_hash_init(&s->hash_desc);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error initializing crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\trc = crypto_hash_update(&s->hash_desc, &s->hash_sg,\n\t\t\t\t\t\tECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error updating crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\trc = crypto_hash_final(&s->hash_desc, s->tmp_hash);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error finalizing crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\tmemcpy(s->hash, s->tmp_hash,\n\t\t\t       ECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t}\n\t\tif (s->block_aligned_filename[s->j] == '\\0')\n\t\t\ts->block_aligned_filename[s->j] = ECRYPTFS_NON_NULL;\n\t}\n\tmemcpy(&s->block_aligned_filename[s->num_rand_bytes], filename,\n\t       filename_size);\n\trc = virt_to_scatterlist(s->block_aligned_filename,\n\t\t\t\t s->block_aligned_filename_size, s->src_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert filename memory to scatterlist; rc = [%d]. \"\n\t\t       \"block_aligned_filename_size = [%zd]\\n\", __func__, rc,\n\t\t       s->block_aligned_filename_size);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = virt_to_scatterlist(&dest[s->i], s->block_aligned_filename_size,\n\t\t\t\t s->dst_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert encrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_release_free_unlock;\n\t}\n\t/* The characters in the first block effectively do the job\n\t * of the IV here, so we just use 0's for the IV. Note the\n\t * constraint that ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES\n\t * >= ECRYPTFS_MAX_IV_BYTES. */\n\tmemset(s->iv, 0, ECRYPTFS_MAX_IV_BYTES);\n\ts->desc.info = s->iv;\n\trc = crypto_blkcipher_setkey(\n\t\ts->desc.tfm,\n\t\ts->auth_tok->token.password.session_key_encryption_key,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error setting key for crypto context; \"\n\t\t       \"rc = [%d]. s->auth_tok->token.password.session_key_\"\n\t\t       \"encryption_key = [0x%p]; mount_crypt_stat->\"\n\t\t       \"global_default_fn_cipher_key_bytes = [%zd]\\n\", __func__,\n\t\t       rc,\n\t\t       s->auth_tok->token.password.session_key_encryption_key,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = crypto_blkcipher_encrypt_iv(&s->desc, s->dst_sg, s->src_sg,\n\t\t\t\t\t s->block_aligned_filename_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt filename; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\ts->i += s->block_aligned_filename_size;\n\t(*packet_size) = s->i;\n\t(*remaining_bytes) -= (*packet_size);\nout_release_free_unlock:\n\tcrypto_free_hash(s->hash_desc.tfm);\nout_free_unlock:\n\tkzfree(s->block_aligned_filename);\nout_unlock:\n\tmutex_unlock(s->tfm_mutex);\nout:\n\tif (auth_tok_key) {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t}\n\tkfree(s);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "auth_tok_key"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&(auth_tok_key->sem)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "s->tfm_mutex"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "s->block_aligned_filename"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_hash",
          "args": [
            "s->hash_desc.tfm"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Error attempting to encrypt filename; \"\n\t\t       \"rc = [%d]\\n\"",
            "__func__",
            "rc"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_encrypt_iv",
          "args": [
            "&s->desc",
            "s->dst_sg",
            "s->src_sg",
            "s->block_aligned_filename_size"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_setkey",
          "args": [
            "s->desc.tfm",
            "s->auth_tok->token.password.session_key_encryption_key",
            "mount_crypt_stat->global_default_fn_cipher_key_bytes"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "s->iv",
            "0",
            "ECRYPTFS_MAX_IV_BYTES"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_scatterlist",
          "args": [
            "&dest[s->i]",
            "s->block_aligned_filename_size",
            "s->dst_sg",
            "2"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "virt_to_scatterlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "283-312",
          "snippet": "int virt_to_scatterlist(const void *addr, int size, struct scatterlist *sg,\n\t\t\tint sg_size)\n{\n\tint i = 0;\n\tstruct page *pg;\n\tint offset;\n\tint remainder_of_page;\n\n\tsg_init_table(sg, sg_size);\n\n\twhile (size > 0 && i < sg_size) {\n\t\tpg = virt_to_page(addr);\n\t\toffset = offset_in_page(addr);\n\t\tsg_set_page(&sg[i], pg, 0, offset);\n\t\tremainder_of_page = PAGE_CACHE_SIZE - offset;\n\t\tif (size >= remainder_of_page) {\n\t\t\tsg[i].length = remainder_of_page;\n\t\t\taddr += remainder_of_page;\n\t\t\tsize -= remainder_of_page;\n\t\t} else {\n\t\t\tsg[i].length = size;\n\t\t\taddr += size;\n\t\t\tsize = 0;\n\t\t}\n\t\ti++;\n\t}\n\tif (size > 0)\n\t\treturn -ENOMEM;\n\treturn i;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint virt_to_scatterlist(const void *addr, int size, struct scatterlist *sg,\n\t\t\tint sg_size)\n{\n\tint i = 0;\n\tstruct page *pg;\n\tint offset;\n\tint remainder_of_page;\n\n\tsg_init_table(sg, sg_size);\n\n\twhile (size > 0 && i < sg_size) {\n\t\tpg = virt_to_page(addr);\n\t\toffset = offset_in_page(addr);\n\t\tsg_set_page(&sg[i], pg, 0, offset);\n\t\tremainder_of_page = PAGE_CACHE_SIZE - offset;\n\t\tif (size >= remainder_of_page) {\n\t\t\tsg[i].length = remainder_of_page;\n\t\t\taddr += remainder_of_page;\n\t\t\tsize -= remainder_of_page;\n\t\t} else {\n\t\t\tsg[i].length = size;\n\t\t\taddr += size;\n\t\t\tsize = 0;\n\t\t}\n\t\ti++;\n\t}\n\tif (size > 0)\n\t\treturn -ENOMEM;\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&s->block_aligned_filename[s->num_rand_bytes]",
            "filename",
            "filename_size"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->hash",
            "s->tmp_hash",
            "ECRYPTFS_TAG_70_DIGEST_SIZE"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_final",
          "args": [
            "&s->hash_desc",
            "s->tmp_hash"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_update",
          "args": [
            "&s->hash_desc",
            "&s->hash_sg",
            "ECRYPTFS_TAG_70_DIGEST_SIZE"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_init",
          "args": [
            "&s->hash_desc"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_one",
          "args": [
            "&s->hash_sg",
            "(u8 *)s->hash",
            "ECRYPTFS_TAG_70_DIGEST_SIZE"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_final",
          "args": [
            "&s->hash_desc",
            "s->hash"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_update",
          "args": [
            "&s->hash_desc",
            "&s->hash_sg",
            "s->auth_tok->token.password.session_key_encryption_key_bytes"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_hash_init",
          "args": [
            "&s->hash_desc"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "s->hash_desc.tfm"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s->hash_desc.tfm"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_hash",
          "args": [
            "ECRYPTFS_TAG_70_DIGEST",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_one",
          "args": [
            "&s->hash_sg",
            "(u8 *)s->auth_tok->token.password.session_key_encryption_key",
            "s->auth_tok->token.password.session_key_encryption_key_bytes"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_code_for_cipher_string",
          "args": [
            "mount_crypt_stat->global_default_fn_cipher_name",
            "mount_crypt_stat->global_default_fn_cipher_key_bytes"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_code_for_cipher_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "985-1011",
          "snippet": "u8 ecryptfs_code_for_cipher_string(char *cipher_name, size_t key_bytes)\n{\n\tint i;\n\tu8 code = 0;\n\tstruct ecryptfs_cipher_code_str_map_elem *map =\n\t\tecryptfs_cipher_code_str_map;\n\n\tif (strcmp(cipher_name, \"aes\") == 0) {\n\t\tswitch (key_bytes) {\n\t\tcase 16:\n\t\t\tcode = RFC2440_CIPHER_AES_128;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tcode = RFC2440_CIPHER_AES_192;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcode = RFC2440_CIPHER_AES_256;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\t\tif (strcmp(cipher_name, map[i].cipher_str) == 0) {\n\t\t\t\tcode = map[i].cipher_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn code;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct ecryptfs_cipher_code_str_map_elem\necryptfs_cipher_code_str_map[] = {\n\t{\"aes\",RFC2440_CIPHER_AES_128 },\n\t{\"blowfish\", RFC2440_CIPHER_BLOWFISH},\n\t{\"des3_ede\", RFC2440_CIPHER_DES3_EDE},\n\t{\"cast5\", RFC2440_CIPHER_CAST_5},\n\t{\"twofish\", RFC2440_CIPHER_TWOFISH},\n\t{\"cast6\", RFC2440_CIPHER_CAST_6},\n\t{\"aes\", RFC2440_CIPHER_AES_192},\n\t{\"aes\", RFC2440_CIPHER_AES_256}\n};\n\nu8 ecryptfs_code_for_cipher_string(char *cipher_name, size_t key_bytes)\n{\n\tint i;\n\tu8 code = 0;\n\tstruct ecryptfs_cipher_code_str_map_elem *map =\n\t\tecryptfs_cipher_code_str_map;\n\n\tif (strcmp(cipher_name, \"aes\") == 0) {\n\t\tswitch (key_bytes) {\n\t\tcase 16:\n\t\t\tcode = RFC2440_CIPHER_AES_128;\n\t\t\tbreak;\n\t\tcase 24:\n\t\t\tcode = RFC2440_CIPHER_AES_192;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tcode = RFC2440_CIPHER_AES_256;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < ARRAY_SIZE(ecryptfs_cipher_code_str_map); i++)\n\t\t\tif (strcmp(cipher_name, map[i].cipher_str) == 0) {\n\t\t\t\tcode = map[i].cipher_code;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_from_hex",
          "args": [
            "&dest[s->i]",
            "mount_crypt_stat->global_default_fnek_sig",
            "ECRYPTFS_SIG_SIZE"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_from_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "65-75",
          "snippet": "void ecryptfs_from_hex(char *dst, char *src, int dst_size)\n{\n\tint x;\n\tchar tmp[3] = { 0, };\n\n\tfor (x = 0; x < dst_size; x++) {\n\t\ttmp[0] = src[x * 2];\n\t\ttmp[1] = src[x * 2 + 1];\n\t\tdst[x] = (unsigned char)simple_strtol(tmp, NULL, 16);\n\t}\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nvoid ecryptfs_from_hex(char *dst, char *src, int dst_size)\n{\n\tint x;\n\tchar tmp[3] = { 0, };\n\n\tfor (x = 0; x < dst_size; x++) {\n\t\ttmp[0] = src[x * 2];\n\t\ttmp[1] = src[x * 2 + 1];\n\t\tdst[x] = (unsigned char)simple_strtol(tmp, NULL, 16);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_packet_length",
          "args": [
            "&dest[s->i]",
            "(ECRYPTFS_SIG_SIZE\n\t\t\t\t\t   + 1 /* Cipher code */\n\t\t\t\t\t   + s->block_aligned_filename_size)",
            "&s->packet_size_len"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "135-154",
          "snippet": "int ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "s->block_aligned_filename_size",
            "GFP_KERNEL"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_blkcipher_blocksize",
          "args": [
            "s->desc.tfm"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "s->tfm_mutex"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rc"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_tfm_and_mutex_for_cipher_name",
          "args": [
            "&s->desc.tfm",
            "&s->tfm_mutex",
            "mount_crypt_stat->global_default_fn_cipher_name"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_tfm_and_mutex_for_cipher_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/crypto.c",
          "lines": "1751-1775",
          "snippet": "int ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/file.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/key.h>",
            "#include <linux/compiler.h>",
            "#include <linux/random.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mutex key_tfm_list_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/file.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/key.h>\n#include <linux/compiler.h>\n#include <linux/random.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstruct mutex key_tfm_list_mutex;\n\nint ecryptfs_get_tfm_and_mutex_for_cipher_name(struct crypto_blkcipher **tfm,\n\t\t\t\t\t       struct mutex **tfm_mutex,\n\t\t\t\t\t       char *cipher_name)\n{\n\tstruct ecryptfs_key_tfm *key_tfm;\n\tint rc = 0;\n\n\t(*tfm) = NULL;\n\t(*tfm_mutex) = NULL;\n\n\tmutex_lock(&key_tfm_list_mutex);\n\tif (!ecryptfs_tfm_exists(cipher_name, &key_tfm)) {\n\t\trc = ecryptfs_add_new_key_tfm(&key_tfm, cipher_name, 0);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"Error adding new key_tfm to list; \"\n\t\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t(*tfm) = key_tfm->key_tfm;\n\t(*tfm_mutex) = &key_tfm->key_tfm_mutex;\nout:\n\tmutex_unlock(&key_tfm_list_mutex);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_find_auth_tok_for_sig",
          "args": [
            "&auth_tok_key",
            "&s->auth_tok",
            "mount_crypt_stat",
            "mount_crypt_stat->global_default_fnek_sig"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_find_auth_tok_for_sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "558-583",
          "snippet": "static int\necryptfs_find_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tchar *sig)\n{\n\tint rc = 0;\n\n\trc = ecryptfs_find_global_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t   mount_crypt_stat, sig);\n\tif (rc == -ENOENT) {\n\t\t/* if the flag ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY is set in the\n\t\t * mount_crypt_stat structure, we prevent to use auth toks that\n\t\t * are not inserted through the ecryptfs_add_global_auth_tok\n\t\t * function.\n\t\t */\n\t\tif (mount_crypt_stat->flags\n\t\t\t\t& ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY)\n\t\t\treturn -EINVAL;\n\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t       sig);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_find_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tchar *sig)\n{\n\tint rc = 0;\n\n\trc = ecryptfs_find_global_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t   mount_crypt_stat, sig);\n\tif (rc == -ENOENT) {\n\t\t/* if the flag ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY is set in the\n\t\t * mount_crypt_stat structure, we prevent to use auth toks that\n\t\t * are not inserted through the ecryptfs_add_global_auth_tok\n\t\t * function.\n\t\t */\n\t\tif (mount_crypt_stat->flags\n\t\t\t\t& ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY)\n\t\t\treturn -EINVAL;\n\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t       sig);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*s)",
            "GFP_KERNEL"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint\necryptfs_write_tag_70_packet(char *dest, size_t *remaining_bytes,\n\t\t\t     size_t *packet_size,\n\t\t\t     struct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\t\t\t     char *filename, size_t filename_size)\n{\n\tstruct ecryptfs_write_tag_70_packet_silly_stack *s;\n\tstruct key *auth_tok_key = NULL;\n\tint rc = 0;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (!s) {\n\t\tprintk(KERN_ERR \"%s: Out of memory whilst trying to kmalloc \"\n\t\t       \"[%zd] bytes of kernel memory\\n\", __func__, sizeof(*s));\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\ts->desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\t(*packet_size) = 0;\n\trc = ecryptfs_find_auth_tok_for_sig(\n\t\t&auth_tok_key,\n\t\t&s->auth_tok, mount_crypt_stat,\n\t\tmount_crypt_stat->global_default_fnek_sig);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to find auth tok for \"\n\t\t       \"fnek sig [%s]; rc = [%d]\\n\", __func__,\n\t\t       mount_crypt_stat->global_default_fnek_sig, rc);\n\t\tgoto out;\n\t}\n\trc = ecryptfs_get_tfm_and_mutex_for_cipher_name(\n\t\t&s->desc.tfm,\n\t\t&s->tfm_mutex, mount_crypt_stat->global_default_fn_cipher_name);\n\tif (unlikely(rc)) {\n\t\tprintk(KERN_ERR \"Internal error whilst attempting to get \"\n\t\t       \"tfm and mutex for cipher name [%s]; rc = [%d]\\n\",\n\t\t       mount_crypt_stat->global_default_fn_cipher_name, rc);\n\t\tgoto out;\n\t}\n\tmutex_lock(s->tfm_mutex);\n\ts->block_size = crypto_blkcipher_blocksize(s->desc.tfm);\n\t/* Plus one for the \\0 separator between the random prefix\n\t * and the plaintext filename */\n\ts->num_rand_bytes = (ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES + 1);\n\ts->block_aligned_filename_size = (s->num_rand_bytes + filename_size);\n\tif ((s->block_aligned_filename_size % s->block_size) != 0) {\n\t\ts->num_rand_bytes += (s->block_size\n\t\t\t\t      - (s->block_aligned_filename_size\n\t\t\t\t\t % s->block_size));\n\t\ts->block_aligned_filename_size = (s->num_rand_bytes\n\t\t\t\t\t\t  + filename_size);\n\t}\n\t/* Octet 0: Tag 70 identifier\n\t * Octets 1-N1: Tag 70 packet size (includes cipher identifier\n\t *              and block-aligned encrypted filename size)\n\t * Octets N1-N2: FNEK sig (ECRYPTFS_SIG_SIZE)\n\t * Octet N2-N3: Cipher identifier (1 octet)\n\t * Octets N3-N4: Block-aligned encrypted filename\n\t *  - Consists of a minimum number of random characters, a \\0\n\t *    separator, and then the filename */\n\ts->max_packet_size = (ECRYPTFS_TAG_70_MAX_METADATA_SIZE\n\t\t\t      + s->block_aligned_filename_size);\n\tif (dest == NULL) {\n\t\t(*packet_size) = s->max_packet_size;\n\t\tgoto out_unlock;\n\t}\n\tif (s->max_packet_size > (*remaining_bytes)) {\n\t\tprintk(KERN_WARNING \"%s: Require [%zd] bytes to write; only \"\n\t\t       \"[%zd] available\\n\", __func__, s->max_packet_size,\n\t\t       (*remaining_bytes));\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\ts->block_aligned_filename = kzalloc(s->block_aligned_filename_size,\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!s->block_aligned_filename) {\n\t\tprintk(KERN_ERR \"%s: Out of kernel memory whilst attempting to \"\n\t\t       \"kzalloc [%zd] bytes\\n\", __func__,\n\t\t       s->block_aligned_filename_size);\n\t\trc = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\ts->i = 0;\n\tdest[s->i++] = ECRYPTFS_TAG_70_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&dest[s->i],\n\t\t\t\t\t  (ECRYPTFS_SIG_SIZE\n\t\t\t\t\t   + 1 /* Cipher code */\n\t\t\t\t\t   + s->block_aligned_filename_size),\n\t\t\t\t\t  &s->packet_size_len);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error generating tag 70 packet \"\n\t\t       \"header; cannot generate packet length; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_free_unlock;\n\t}\n\ts->i += s->packet_size_len;\n\tecryptfs_from_hex(&dest[s->i],\n\t\t\t  mount_crypt_stat->global_default_fnek_sig,\n\t\t\t  ECRYPTFS_SIG_SIZE);\n\ts->i += ECRYPTFS_SIG_SIZE;\n\ts->cipher_code = ecryptfs_code_for_cipher_string(\n\t\tmount_crypt_stat->global_default_fn_cipher_name,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (s->cipher_code == 0) {\n\t\tprintk(KERN_WARNING \"%s: Unable to generate code for \"\n\t\t       \"cipher [%s] with key bytes [%zd]\\n\", __func__,\n\t\t       mount_crypt_stat->global_default_fn_cipher_name,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\trc = -EINVAL;\n\t\tgoto out_free_unlock;\n\t}\n\tdest[s->i++] = s->cipher_code;\n\t/* TODO: Support other key modules than passphrase for\n\t * filename encryption */\n\tif (s->auth_tok->token_type != ECRYPTFS_PASSWORD) {\n\t\trc = -EOPNOTSUPP;\n\t\tprintk(KERN_INFO \"%s: Filename encryption only supports \"\n\t\t       \"password tokens\\n\", __func__);\n\t\tgoto out_free_unlock;\n\t}\n\tsg_init_one(\n\t\t&s->hash_sg,\n\t\t(u8 *)s->auth_tok->token.password.session_key_encryption_key,\n\t\ts->auth_tok->token.password.session_key_encryption_key_bytes);\n\ts->hash_desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\ts->hash_desc.tfm = crypto_alloc_hash(ECRYPTFS_TAG_70_DIGEST, 0,\n\t\t\t\t\t     CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(s->hash_desc.tfm)) {\n\t\t\trc = PTR_ERR(s->hash_desc.tfm);\n\t\t\tprintk(KERN_ERR \"%s: Error attempting to \"\n\t\t\t       \"allocate hash crypto context; rc = [%d]\\n\",\n\t\t\t       __func__, rc);\n\t\t\tgoto out_free_unlock;\n\t}\n\trc = crypto_hash_init(&s->hash_desc);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error initializing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = crypto_hash_update(\n\t\t&s->hash_desc, &s->hash_sg,\n\t\ts->auth_tok->token.password.session_key_encryption_key_bytes);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error updating crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = crypto_hash_final(&s->hash_desc, s->hash);\n\tif (rc) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Error finalizing crypto hash; rc = [%d]\\n\",\n\t\t       __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\tfor (s->j = 0; s->j < (s->num_rand_bytes - 1); s->j++) {\n\t\ts->block_aligned_filename[s->j] =\n\t\t\ts->hash[(s->j % ECRYPTFS_TAG_70_DIGEST_SIZE)];\n\t\tif ((s->j % ECRYPTFS_TAG_70_DIGEST_SIZE)\n\t\t    == (ECRYPTFS_TAG_70_DIGEST_SIZE - 1)) {\n\t\t\tsg_init_one(&s->hash_sg, (u8 *)s->hash,\n\t\t\t\t    ECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t\trc = crypto_hash_init(&s->hash_desc);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error initializing crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\trc = crypto_hash_update(&s->hash_desc, &s->hash_sg,\n\t\t\t\t\t\tECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error updating crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\trc = crypto_hash_final(&s->hash_desc, s->tmp_hash);\n\t\t\tif (rc) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"%s: Error finalizing crypto hash; \"\n\t\t\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\t\t\tgoto out_release_free_unlock;\n\t\t\t}\n\t\t\tmemcpy(s->hash, s->tmp_hash,\n\t\t\t       ECRYPTFS_TAG_70_DIGEST_SIZE);\n\t\t}\n\t\tif (s->block_aligned_filename[s->j] == '\\0')\n\t\t\ts->block_aligned_filename[s->j] = ECRYPTFS_NON_NULL;\n\t}\n\tmemcpy(&s->block_aligned_filename[s->num_rand_bytes], filename,\n\t       filename_size);\n\trc = virt_to_scatterlist(s->block_aligned_filename,\n\t\t\t\t s->block_aligned_filename_size, s->src_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert filename memory to scatterlist; rc = [%d]. \"\n\t\t       \"block_aligned_filename_size = [%zd]\\n\", __func__, rc,\n\t\t       s->block_aligned_filename_size);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = virt_to_scatterlist(&dest[s->i], s->block_aligned_filename_size,\n\t\t\t\t s->dst_sg, 2);\n\tif (rc < 1) {\n\t\tprintk(KERN_ERR \"%s: Internal error whilst attempting to \"\n\t\t       \"convert encrypted filename memory to scatterlist; \"\n\t\t       \"rc = [%d]. block_aligned_filename_size = [%zd]\\n\",\n\t\t       __func__, rc, s->block_aligned_filename_size);\n\t\tgoto out_release_free_unlock;\n\t}\n\t/* The characters in the first block effectively do the job\n\t * of the IV here, so we just use 0's for the IV. Note the\n\t * constraint that ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES\n\t * >= ECRYPTFS_MAX_IV_BYTES. */\n\tmemset(s->iv, 0, ECRYPTFS_MAX_IV_BYTES);\n\ts->desc.info = s->iv;\n\trc = crypto_blkcipher_setkey(\n\t\ts->desc.tfm,\n\t\ts->auth_tok->token.password.session_key_encryption_key,\n\t\tmount_crypt_stat->global_default_fn_cipher_key_bytes);\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"%s: Error setting key for crypto context; \"\n\t\t       \"rc = [%d]. s->auth_tok->token.password.session_key_\"\n\t\t       \"encryption_key = [0x%p]; mount_crypt_stat->\"\n\t\t       \"global_default_fn_cipher_key_bytes = [%zd]\\n\", __func__,\n\t\t       rc,\n\t\t       s->auth_tok->token.password.session_key_encryption_key,\n\t\t       mount_crypt_stat->global_default_fn_cipher_key_bytes);\n\t\tgoto out_release_free_unlock;\n\t}\n\trc = crypto_blkcipher_encrypt_iv(&s->desc, s->dst_sg, s->src_sg,\n\t\t\t\t\t s->block_aligned_filename_size);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error attempting to encrypt filename; \"\n\t\t       \"rc = [%d]\\n\", __func__, rc);\n\t\tgoto out_release_free_unlock;\n\t}\n\ts->i += s->block_aligned_filename_size;\n\t(*packet_size) = s->i;\n\t(*remaining_bytes) -= (*packet_size);\nout_release_free_unlock:\n\tcrypto_free_hash(s->hash_desc.tfm);\nout_free_unlock:\n\tkzfree(s->block_aligned_filename);\nout_unlock:\n\tmutex_unlock(s->tfm_mutex);\nout:\n\tif (auth_tok_key) {\n\t\tup_write(&(auth_tok_key->sem));\n\t\tkey_put(auth_tok_key);\n\t}\n\tkfree(s);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_find_auth_tok_for_sig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "558-583",
    "snippet": "static int\necryptfs_find_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tchar *sig)\n{\n\tint rc = 0;\n\n\trc = ecryptfs_find_global_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t   mount_crypt_stat, sig);\n\tif (rc == -ENOENT) {\n\t\t/* if the flag ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY is set in the\n\t\t * mount_crypt_stat structure, we prevent to use auth toks that\n\t\t * are not inserted through the ecryptfs_add_global_auth_tok\n\t\t * function.\n\t\t */\n\t\tif (mount_crypt_stat->flags\n\t\t\t\t& ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY)\n\t\t\treturn -EINVAL;\n\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t       sig);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_keyring_auth_tok_for_sig",
          "args": [
            "auth_tok_key",
            "auth_tok",
            "sig"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_keyring_auth_tok_for_sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "1627-1654",
          "snippet": "int ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key,\n\t\t\t\t      struct ecryptfs_auth_tok **auth_tok,\n\t\t\t\t      char *sig)\n{\n\tint rc = 0;\n\n\t(*auth_tok_key) = request_key(&key_type_user, sig, NULL);\n\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t(*auth_tok_key) = ecryptfs_get_encrypted_key(sig);\n\t\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t\tprintk(KERN_ERR \"Could not find key with description: [%s]\\n\",\n\t\t\t      sig);\n\t\t\trc = process_request_key_err(PTR_ERR(*auth_tok_key));\n\t\t\t(*auth_tok_key) = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdown_write(&(*auth_tok_key)->sem);\n\trc = ecryptfs_verify_auth_tok_from_key(*auth_tok_key, auth_tok);\n\tif (rc) {\n\t\tup_write(&(*auth_tok_key)->sem);\n\t\tkey_put(*auth_tok_key);\n\t\t(*auth_tok_key) = NULL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_keyring_auth_tok_for_sig(struct key **auth_tok_key,\n\t\t\t\t      struct ecryptfs_auth_tok **auth_tok,\n\t\t\t\t      char *sig)\n{\n\tint rc = 0;\n\n\t(*auth_tok_key) = request_key(&key_type_user, sig, NULL);\n\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t(*auth_tok_key) = ecryptfs_get_encrypted_key(sig);\n\t\tif (!(*auth_tok_key) || IS_ERR(*auth_tok_key)) {\n\t\t\tprintk(KERN_ERR \"Could not find key with description: [%s]\\n\",\n\t\t\t      sig);\n\t\t\trc = process_request_key_err(PTR_ERR(*auth_tok_key));\n\t\t\t(*auth_tok_key) = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tdown_write(&(*auth_tok_key)->sem);\n\trc = ecryptfs_verify_auth_tok_from_key(*auth_tok_key, auth_tok);\n\tif (rc) {\n\t\tup_write(&(*auth_tok_key)->sem);\n\t\tkey_put(*auth_tok_key);\n\t\t(*auth_tok_key) = NULL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_find_global_auth_tok_for_sig",
          "args": [
            "auth_tok_key",
            "auth_tok",
            "mount_crypt_stat",
            "sig"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_find_global_auth_tok_for_sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "489-541",
          "snippet": "static int\necryptfs_find_global_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat, char *sig)\n{\n\tstruct ecryptfs_global_auth_tok *walker;\n\tint rc = 0;\n\n\t(*auth_tok_key) = NULL;\n\t(*auth_tok) = NULL;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry(walker,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\tif (memcmp(walker->sig, sig, ECRYPTFS_SIG_SIZE_HEX))\n\t\t\tcontinue;\n\n\t\tif (walker->flags & ECRYPTFS_AUTH_TOK_INVALID) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = key_validate(walker->global_auth_tok_key);\n\t\tif (rc) {\n\t\t\tif (rc == -EKEYEXPIRED)\n\t\t\t\tgoto out;\n\t\t\tgoto out_invalid_auth_tok;\n\t\t}\n\n\t\tdown_write(&(walker->global_auth_tok_key->sem));\n\t\trc = ecryptfs_verify_auth_tok_from_key(\n\t\t\t\twalker->global_auth_tok_key, auth_tok);\n\t\tif (rc)\n\t\t\tgoto out_invalid_auth_tok_unlock;\n\n\t\t(*auth_tok_key) = walker->global_auth_tok_key;\n\t\tkey_get(*auth_tok_key);\n\t\tgoto out;\n\t}\n\trc = -ENOENT;\n\tgoto out;\nout_invalid_auth_tok_unlock:\n\tup_write(&(walker->global_auth_tok_key->sem));\nout_invalid_auth_tok:\n\tprintk(KERN_WARNING \"Invalidating auth tok with sig = [%s]\\n\", sig);\n\twalker->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\tkey_put(walker->global_auth_tok_key);\n\twalker->global_auth_tok_key = NULL;\nout:\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_find_global_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat, char *sig)\n{\n\tstruct ecryptfs_global_auth_tok *walker;\n\tint rc = 0;\n\n\t(*auth_tok_key) = NULL;\n\t(*auth_tok) = NULL;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry(walker,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\tif (memcmp(walker->sig, sig, ECRYPTFS_SIG_SIZE_HEX))\n\t\t\tcontinue;\n\n\t\tif (walker->flags & ECRYPTFS_AUTH_TOK_INVALID) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = key_validate(walker->global_auth_tok_key);\n\t\tif (rc) {\n\t\t\tif (rc == -EKEYEXPIRED)\n\t\t\t\tgoto out;\n\t\t\tgoto out_invalid_auth_tok;\n\t\t}\n\n\t\tdown_write(&(walker->global_auth_tok_key->sem));\n\t\trc = ecryptfs_verify_auth_tok_from_key(\n\t\t\t\twalker->global_auth_tok_key, auth_tok);\n\t\tif (rc)\n\t\t\tgoto out_invalid_auth_tok_unlock;\n\n\t\t(*auth_tok_key) = walker->global_auth_tok_key;\n\t\tkey_get(*auth_tok_key);\n\t\tgoto out;\n\t}\n\trc = -ENOENT;\n\tgoto out;\nout_invalid_auth_tok_unlock:\n\tup_write(&(walker->global_auth_tok_key->sem));\nout_invalid_auth_tok:\n\tprintk(KERN_WARNING \"Invalidating auth tok with sig = [%s]\\n\", sig);\n\twalker->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\tkey_put(walker->global_auth_tok_key);\n\twalker->global_auth_tok_key = NULL;\nout:\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_find_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat,\n\tchar *sig)\n{\n\tint rc = 0;\n\n\trc = ecryptfs_find_global_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t   mount_crypt_stat, sig);\n\tif (rc == -ENOENT) {\n\t\t/* if the flag ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY is set in the\n\t\t * mount_crypt_stat structure, we prevent to use auth toks that\n\t\t * are not inserted through the ecryptfs_add_global_auth_tok\n\t\t * function.\n\t\t */\n\t\tif (mount_crypt_stat->flags\n\t\t\t\t& ECRYPTFS_GLOBAL_MOUNT_AUTH_TOK_ONLY)\n\t\t\treturn -EINVAL;\n\n\t\trc = ecryptfs_keyring_auth_tok_for_sig(auth_tok_key, auth_tok,\n\t\t\t\t\t\t       sig);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_find_global_auth_tok_for_sig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "489-541",
    "snippet": "static int\necryptfs_find_global_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat, char *sig)\n{\n\tstruct ecryptfs_global_auth_tok *walker;\n\tint rc = 0;\n\n\t(*auth_tok_key) = NULL;\n\t(*auth_tok) = NULL;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry(walker,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\tif (memcmp(walker->sig, sig, ECRYPTFS_SIG_SIZE_HEX))\n\t\t\tcontinue;\n\n\t\tif (walker->flags & ECRYPTFS_AUTH_TOK_INVALID) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = key_validate(walker->global_auth_tok_key);\n\t\tif (rc) {\n\t\t\tif (rc == -EKEYEXPIRED)\n\t\t\t\tgoto out;\n\t\t\tgoto out_invalid_auth_tok;\n\t\t}\n\n\t\tdown_write(&(walker->global_auth_tok_key->sem));\n\t\trc = ecryptfs_verify_auth_tok_from_key(\n\t\t\t\twalker->global_auth_tok_key, auth_tok);\n\t\tif (rc)\n\t\t\tgoto out_invalid_auth_tok_unlock;\n\n\t\t(*auth_tok_key) = walker->global_auth_tok_key;\n\t\tkey_get(*auth_tok_key);\n\t\tgoto out;\n\t}\n\trc = -ENOENT;\n\tgoto out;\nout_invalid_auth_tok_unlock:\n\tup_write(&(walker->global_auth_tok_key->sem));\nout_invalid_auth_tok:\n\tprintk(KERN_WARNING \"Invalidating auth tok with sig = [%s]\\n\", sig);\n\twalker->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\tkey_put(walker->global_auth_tok_key);\n\twalker->global_auth_tok_key = NULL;\nout:\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mount_crypt_stat->global_auth_tok_list_mutex"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "walker->global_auth_tok_key"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Invalidating auth tok with sig = [%s]\\n\"",
            "sig"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&(walker->global_auth_tok_key->sem)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "*auth_tok_key"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_verify_auth_tok_from_key",
          "args": [
            "walker->global_auth_tok_key",
            "auth_tok"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_verify_auth_tok_from_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "463-487",
          "snippet": "static int\necryptfs_verify_auth_tok_from_key(struct key *auth_tok_key,\n\t\t\t\t  struct ecryptfs_auth_tok **auth_tok)\n{\n\tint rc = 0;\n\n\t(*auth_tok) = ecryptfs_get_key_payload_data(auth_tok_key);\n\tif (ecryptfs_verify_version((*auth_tok)->version)) {\n\t\tprintk(KERN_ERR \"Data structure version mismatch. Userspace \"\n\t\t       \"tools must match eCryptfs kernel module with major \"\n\t\t       \"version [%d] and minor version [%d]\\n\",\n\t\t       ECRYPTFS_VERSION_MAJOR, ECRYPTFS_VERSION_MINOR);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((*auth_tok)->token_type != ECRYPTFS_PASSWORD\n\t    && (*auth_tok)->token_type != ECRYPTFS_PRIVATE_KEY) {\n\t\tprintk(KERN_ERR \"Invalid auth_tok structure \"\n\t\t       \"returned from key query\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_verify_auth_tok_from_key(struct key *auth_tok_key,\n\t\t\t\t  struct ecryptfs_auth_tok **auth_tok)\n{\n\tint rc = 0;\n\n\t(*auth_tok) = ecryptfs_get_key_payload_data(auth_tok_key);\n\tif (ecryptfs_verify_version((*auth_tok)->version)) {\n\t\tprintk(KERN_ERR \"Data structure version mismatch. Userspace \"\n\t\t       \"tools must match eCryptfs kernel module with major \"\n\t\t       \"version [%d] and minor version [%d]\\n\",\n\t\t       ECRYPTFS_VERSION_MAJOR, ECRYPTFS_VERSION_MINOR);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((*auth_tok)->token_type != ECRYPTFS_PASSWORD\n\t    && (*auth_tok)->token_type != ECRYPTFS_PRIVATE_KEY) {\n\t\tprintk(KERN_ERR \"Invalid auth_tok structure \"\n\t\t       \"returned from key query\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&(walker->global_auth_tok_key->sem)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_validate",
          "args": [
            "walker->global_auth_tok_key"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "walker->sig",
            "sig",
            "ECRYPTFS_SIG_SIZE_HEX"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "walker",
            "&mount_crypt_stat->global_auth_tok_list",
            "mount_crypt_stat_list"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mount_crypt_stat->global_auth_tok_list_mutex"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_find_global_auth_tok_for_sig(\n\tstruct key **auth_tok_key,\n\tstruct ecryptfs_auth_tok **auth_tok,\n\tstruct ecryptfs_mount_crypt_stat *mount_crypt_stat, char *sig)\n{\n\tstruct ecryptfs_global_auth_tok *walker;\n\tint rc = 0;\n\n\t(*auth_tok_key) = NULL;\n\t(*auth_tok) = NULL;\n\tmutex_lock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\tlist_for_each_entry(walker,\n\t\t\t    &mount_crypt_stat->global_auth_tok_list,\n\t\t\t    mount_crypt_stat_list) {\n\t\tif (memcmp(walker->sig, sig, ECRYPTFS_SIG_SIZE_HEX))\n\t\t\tcontinue;\n\n\t\tif (walker->flags & ECRYPTFS_AUTH_TOK_INVALID) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = key_validate(walker->global_auth_tok_key);\n\t\tif (rc) {\n\t\t\tif (rc == -EKEYEXPIRED)\n\t\t\t\tgoto out;\n\t\t\tgoto out_invalid_auth_tok;\n\t\t}\n\n\t\tdown_write(&(walker->global_auth_tok_key->sem));\n\t\trc = ecryptfs_verify_auth_tok_from_key(\n\t\t\t\twalker->global_auth_tok_key, auth_tok);\n\t\tif (rc)\n\t\t\tgoto out_invalid_auth_tok_unlock;\n\n\t\t(*auth_tok_key) = walker->global_auth_tok_key;\n\t\tkey_get(*auth_tok_key);\n\t\tgoto out;\n\t}\n\trc = -ENOENT;\n\tgoto out;\nout_invalid_auth_tok_unlock:\n\tup_write(&(walker->global_auth_tok_key->sem));\nout_invalid_auth_tok:\n\tprintk(KERN_WARNING \"Invalidating auth tok with sig = [%s]\\n\", sig);\n\twalker->flags |= ECRYPTFS_AUTH_TOK_INVALID;\n\tkey_put(walker->global_auth_tok_key);\n\twalker->global_auth_tok_key = NULL;\nout:\n\tmutex_unlock(&mount_crypt_stat->global_auth_tok_list_mutex);\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_verify_auth_tok_from_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "463-487",
    "snippet": "static int\necryptfs_verify_auth_tok_from_key(struct key *auth_tok_key,\n\t\t\t\t  struct ecryptfs_auth_tok **auth_tok)\n{\n\tint rc = 0;\n\n\t(*auth_tok) = ecryptfs_get_key_payload_data(auth_tok_key);\n\tif (ecryptfs_verify_version((*auth_tok)->version)) {\n\t\tprintk(KERN_ERR \"Data structure version mismatch. Userspace \"\n\t\t       \"tools must match eCryptfs kernel module with major \"\n\t\t       \"version [%d] and minor version [%d]\\n\",\n\t\t       ECRYPTFS_VERSION_MAJOR, ECRYPTFS_VERSION_MINOR);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((*auth_tok)->token_type != ECRYPTFS_PASSWORD\n\t    && (*auth_tok)->token_type != ECRYPTFS_PRIVATE_KEY) {\n\t\tprintk(KERN_ERR \"Invalid auth_tok structure \"\n\t\t       \"returned from key query\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Invalid auth_tok structure \"\n\t\t       \"returned from key query\\n\""
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_verify_version",
          "args": [
            "(*auth_tok)->version"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_verify_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "430-454",
          "snippet": "static int ecryptfs_verify_version(u16 version)\n{\n\tint rc = 0;\n\tunsigned char major;\n\tunsigned char minor;\n\n\tmajor = ((version >> 8) & 0xFF);\n\tminor = (version & 0xFF);\n\tif (major != ECRYPTFS_VERSION_MAJOR) {\n\t\tecryptfs_printk(KERN_ERR, \"Major version number mismatch. \"\n\t\t\t\t\"Expected [%d]; got [%d]\\n\",\n\t\t\t\tECRYPTFS_VERSION_MAJOR, major);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (minor != ECRYPTFS_VERSION_MINOR) {\n\t\tecryptfs_printk(KERN_ERR, \"Minor version number mismatch. \"\n\t\t\t\t\"Expected [%d]; got [%d]\\n\",\n\t\t\t\tECRYPTFS_VERSION_MINOR, minor);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int ecryptfs_verify_version(u16 version)\n{\n\tint rc = 0;\n\tunsigned char major;\n\tunsigned char minor;\n\n\tmajor = ((version >> 8) & 0xFF);\n\tminor = (version & 0xFF);\n\tif (major != ECRYPTFS_VERSION_MAJOR) {\n\t\tecryptfs_printk(KERN_ERR, \"Major version number mismatch. \"\n\t\t\t\t\"Expected [%d]; got [%d]\\n\",\n\t\t\t\tECRYPTFS_VERSION_MAJOR, major);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (minor != ECRYPTFS_VERSION_MINOR) {\n\t\tecryptfs_printk(KERN_ERR, \"Minor version number mismatch. \"\n\t\t\t\t\"Expected [%d]; got [%d]\\n\",\n\t\t\t\tECRYPTFS_VERSION_MINOR, minor);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_key_payload_data",
          "args": [
            "auth_tok_key"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_key_payload_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/ecryptfs_kernel.h",
          "lines": "113-124",
          "snippet": "static inline struct ecryptfs_auth_tok *\necryptfs_get_key_payload_data(struct key *key)\n{\n\tstruct ecryptfs_auth_tok *auth_tok;\n\n\tauth_tok = ecryptfs_get_encrypted_key_payload_data(key);\n\tif (!auth_tok)\n\t\treturn (struct ecryptfs_auth_tok *)\n\t\t\t(((struct user_key_payload *)key->payload.data)->data);\n\telse\n\t\treturn auth_tok;\n}",
          "includes": [
            "#include <linux/crypto.h>",
            "#include <linux/ecryptfs.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/hash.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/fs.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/user-type.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/crypto.h>\n#include <linux/ecryptfs.h>\n#include <linux/backing-dev.h>\n#include <linux/nsproxy.h>\n#include <linux/hash.h>\n#include <linux/scatterlist.h>\n#include <linux/namei.h>\n#include <linux/fs_stack.h>\n#include <linux/fs.h>\n#include <keys/encrypted-type.h>\n#include <keys/user-type.h>\n\nstatic inline struct ecryptfs_auth_tok *\necryptfs_get_key_payload_data(struct key *key)\n{\n\tstruct ecryptfs_auth_tok *auth_tok;\n\n\tauth_tok = ecryptfs_get_encrypted_key_payload_data(key);\n\tif (!auth_tok)\n\t\treturn (struct ecryptfs_auth_tok *)\n\t\t\t(((struct user_key_payload *)key->payload.data)->data);\n\telse\n\t\treturn auth_tok;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\necryptfs_verify_auth_tok_from_key(struct key *auth_tok_key,\n\t\t\t\t  struct ecryptfs_auth_tok **auth_tok)\n{\n\tint rc = 0;\n\n\t(*auth_tok) = ecryptfs_get_key_payload_data(auth_tok_key);\n\tif (ecryptfs_verify_version((*auth_tok)->version)) {\n\t\tprintk(KERN_ERR \"Data structure version mismatch. Userspace \"\n\t\t       \"tools must match eCryptfs kernel module with major \"\n\t\t       \"version [%d] and minor version [%d]\\n\",\n\t\t       ECRYPTFS_VERSION_MAJOR, ECRYPTFS_VERSION_MINOR);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif ((*auth_tok)->token_type != ECRYPTFS_PASSWORD\n\t    && (*auth_tok)->token_type != ECRYPTFS_PRIVATE_KEY) {\n\t\tprintk(KERN_ERR \"Invalid auth_tok structure \"\n\t\t       \"returned from key query\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_verify_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "430-454",
    "snippet": "static int ecryptfs_verify_version(u16 version)\n{\n\tint rc = 0;\n\tunsigned char major;\n\tunsigned char minor;\n\n\tmajor = ((version >> 8) & 0xFF);\n\tminor = (version & 0xFF);\n\tif (major != ECRYPTFS_VERSION_MAJOR) {\n\t\tecryptfs_printk(KERN_ERR, \"Major version number mismatch. \"\n\t\t\t\t\"Expected [%d]; got [%d]\\n\",\n\t\t\t\tECRYPTFS_VERSION_MAJOR, major);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (minor != ECRYPTFS_VERSION_MINOR) {\n\t\tecryptfs_printk(KERN_ERR, \"Minor version number mismatch. \"\n\t\t\t\t\"Expected [%d]; got [%d]\\n\",\n\t\t\t\tECRYPTFS_VERSION_MINOR, minor);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Minor version number mismatch. \"\n\t\t\t\t\"Expected [%d]; got [%d]\\n\"",
            "ECRYPTFS_VERSION_MINOR",
            "minor"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int ecryptfs_verify_version(u16 version)\n{\n\tint rc = 0;\n\tunsigned char major;\n\tunsigned char minor;\n\n\tmajor = ((version >> 8) & 0xFF);\n\tminor = (version & 0xFF);\n\tif (major != ECRYPTFS_VERSION_MAJOR) {\n\t\tecryptfs_printk(KERN_ERR, \"Major version number mismatch. \"\n\t\t\t\t\"Expected [%d]; got [%d]\\n\",\n\t\t\t\tECRYPTFS_VERSION_MAJOR, major);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (minor != ECRYPTFS_VERSION_MINOR) {\n\t\tecryptfs_printk(KERN_ERR, \"Minor version number mismatch. \"\n\t\t\t\t\"Expected [%d]; got [%d]\\n\",\n\t\t\t\tECRYPTFS_VERSION_MINOR, minor);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "parse_tag_67_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "358-422",
    "snippet": "static int\nparse_tag_67_packet(struct ecryptfs_key_record *key_rec,\n\t\t    struct ecryptfs_message *msg)\n{\n\tsize_t i = 0;\n\tchar *data;\n\tsize_t data_len;\n\tsize_t message_len;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 65 Packet Format *****\n\t *    | Content Type                       | 1 byte       |\n\t *    | Status Indicator                   | 1 byte       |\n\t *    | Encrypted File Encryption Key Size | 1 or 2 bytes |\n\t *    | Encrypted File Encryption Key      | arbitrary    |\n\t */\n\tmessage_len = msg->data_len;\n\tdata = msg->data;\n\t/* verify that everything through the encrypted FEK size is present */\n\tif (message_len < 4) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: message_len is [%zd]; minimum acceptable \"\n\t\t       \"message length is [%d]\\n\", __func__, message_len, 4);\n\t\tgoto out;\n\t}\n\tif (data[i++] != ECRYPTFS_TAG_67_PACKET_TYPE) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Type should be ECRYPTFS_TAG_67\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\tif (data[i++]) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Status indicator has non zero \"\n\t\t       \"value [%d]\\n\", __func__, data[i-1]);\n\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[i], &key_rec->enc_key_size,\n\t\t\t\t\t  &data_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error parsing packet length; \"\n\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\ti += data_len;\n\tif (message_len < (i + key_rec->enc_key_size)) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: message_len [%zd]; max len is [%zd]\\n\",\n\t\t       __func__, message_len, (i + key_rec->enc_key_size));\n\t\tgoto out;\n\t}\n\tif (key_rec->enc_key_size > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Encrypted key_size [%zd] larger than \"\n\t\t       \"the maximum key size [%d]\\n\", __func__,\n\t\t       key_rec->enc_key_size,\n\t\t       ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES);\n\t\tgoto out;\n\t}\n\tmemcpy(key_rec->enc_key, &data[i], key_rec->enc_key_size);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key_rec->enc_key",
            "&data[i]",
            "key_rec->enc_key_size"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: Encrypted key_size [%zd] larger than \"\n\t\t       \"the maximum key size [%d]\\n\"",
            "__func__",
            "key_rec->enc_key_size",
            "ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_parse_packet_length",
          "args": [
            "&data[i]",
            "&key_rec->enc_key_size",
            "&data_len"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_parse_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "94-123",
          "snippet": "int ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nparse_tag_67_packet(struct ecryptfs_key_record *key_rec,\n\t\t    struct ecryptfs_message *msg)\n{\n\tsize_t i = 0;\n\tchar *data;\n\tsize_t data_len;\n\tsize_t message_len;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 65 Packet Format *****\n\t *    | Content Type                       | 1 byte       |\n\t *    | Status Indicator                   | 1 byte       |\n\t *    | Encrypted File Encryption Key Size | 1 or 2 bytes |\n\t *    | Encrypted File Encryption Key      | arbitrary    |\n\t */\n\tmessage_len = msg->data_len;\n\tdata = msg->data;\n\t/* verify that everything through the encrypted FEK size is present */\n\tif (message_len < 4) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: message_len is [%zd]; minimum acceptable \"\n\t\t       \"message length is [%d]\\n\", __func__, message_len, 4);\n\t\tgoto out;\n\t}\n\tif (data[i++] != ECRYPTFS_TAG_67_PACKET_TYPE) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Type should be ECRYPTFS_TAG_67\\n\",\n\t\t       __func__);\n\t\tgoto out;\n\t}\n\tif (data[i++]) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Status indicator has non zero \"\n\t\t       \"value [%d]\\n\", __func__, data[i-1]);\n\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[i], &key_rec->enc_key_size,\n\t\t\t\t\t  &data_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error parsing packet length; \"\n\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\ti += data_len;\n\tif (message_len < (i + key_rec->enc_key_size)) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: message_len [%zd]; max len is [%zd]\\n\",\n\t\t       __func__, message_len, (i + key_rec->enc_key_size));\n\t\tgoto out;\n\t}\n\tif (key_rec->enc_key_size > ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES) {\n\t\trc = -EIO;\n\t\tprintk(KERN_ERR \"%s: Encrypted key_size [%zd] larger than \"\n\t\t       \"the maximum key size [%d]\\n\", __func__,\n\t\t       key_rec->enc_key_size,\n\t\t       ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES);\n\t\tgoto out;\n\t}\n\tmemcpy(key_rec->enc_key, &data[i], key_rec->enc_key_size);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "write_tag_66_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "297-356",
    "snippet": "static int\nwrite_tag_66_packet(char *signature, u8 cipher_code,\n\t\t    struct ecryptfs_crypt_stat *crypt_stat, char **packet,\n\t\t    size_t *packet_len)\n{\n\tsize_t i = 0;\n\tsize_t j;\n\tsize_t data_len;\n\tsize_t checksum = 0;\n\tsize_t packet_size_len;\n\tchar *message;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 66 Packet Format *****\n\t *         | Content Type             | 1 byte       |\n\t *         | Key Identifier Size      | 1 or 2 bytes |\n\t *         | Key Identifier           | arbitrary    |\n\t *         | File Encryption Key Size | 1 or 2 bytes |\n\t *         | File Encryption Key      | arbitrary    |\n\t */\n\tdata_len = (5 + ECRYPTFS_SIG_SIZE_HEX + crypt_stat->key_size);\n\t*packet = kmalloc(data_len, GFP_KERNEL);\n\tmessage = *packet;\n\tif (!message) {\n\t\tecryptfs_printk(KERN_ERR, \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmessage[i++] = ECRYPTFS_TAG_66_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&message[i], ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], signature, ECRYPTFS_SIG_SIZE_HEX);\n\ti += ECRYPTFS_SIG_SIZE_HEX;\n\t/* The encrypted key includes 1 byte cipher code and 2 byte checksum */\n\trc = ecryptfs_write_packet_length(&message[i], crypt_stat->key_size + 3,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmessage[i++] = cipher_code;\n\tmemcpy(&message[i], crypt_stat->key, crypt_stat->key_size);\n\ti += crypt_stat->key_size;\n\tfor (j = 0; j < crypt_stat->key_size; j++)\n\t\tchecksum += crypt_stat->key[j];\n\tmessage[i++] = (checksum / 256) % 256;\n\tmessage[i++] = (checksum % 256);\n\t*packet_len = i;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&message[i]",
            "crypt_stat->key",
            "crypt_stat->key_size"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Error generating tag 66 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\""
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_packet_length",
          "args": [
            "&message[i]",
            "crypt_stat->key_size + 3",
            "&packet_size_len"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "135-154",
          "snippet": "int ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&message[i]",
            "signature",
            "ECRYPTFS_SIG_SIZE_HEX"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "data_len",
            "GFP_KERNEL"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nwrite_tag_66_packet(char *signature, u8 cipher_code,\n\t\t    struct ecryptfs_crypt_stat *crypt_stat, char **packet,\n\t\t    size_t *packet_len)\n{\n\tsize_t i = 0;\n\tsize_t j;\n\tsize_t data_len;\n\tsize_t checksum = 0;\n\tsize_t packet_size_len;\n\tchar *message;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 66 Packet Format *****\n\t *         | Content Type             | 1 byte       |\n\t *         | Key Identifier Size      | 1 or 2 bytes |\n\t *         | Key Identifier           | arbitrary    |\n\t *         | File Encryption Key Size | 1 or 2 bytes |\n\t *         | File Encryption Key      | arbitrary    |\n\t */\n\tdata_len = (5 + ECRYPTFS_SIG_SIZE_HEX + crypt_stat->key_size);\n\t*packet = kmalloc(data_len, GFP_KERNEL);\n\tmessage = *packet;\n\tif (!message) {\n\t\tecryptfs_printk(KERN_ERR, \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmessage[i++] = ECRYPTFS_TAG_66_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&message[i], ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], signature, ECRYPTFS_SIG_SIZE_HEX);\n\ti += ECRYPTFS_SIG_SIZE_HEX;\n\t/* The encrypted key includes 1 byte cipher code and 2 byte checksum */\n\trc = ecryptfs_write_packet_length(&message[i], crypt_stat->key_size + 3,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 66 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmessage[i++] = cipher_code;\n\tmemcpy(&message[i], crypt_stat->key, crypt_stat->key_size);\n\ti += crypt_stat->key_size;\n\tfor (j = 0; j < crypt_stat->key_size; j++)\n\t\tchecksum += crypt_stat->key[j];\n\tmessage[i++] = (checksum / 256) % 256;\n\tmessage[i++] = (checksum % 256);\n\t*packet_len = i;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "parse_tag_65_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "211-294",
    "snippet": "static int\nparse_tag_65_packet(struct ecryptfs_session_key *session_key, u8 *cipher_code,\n\t\t    struct ecryptfs_message *msg)\n{\n\tsize_t i = 0;\n\tchar *data;\n\tsize_t data_len;\n\tsize_t m_size;\n\tsize_t message_len;\n\tu16 checksum = 0;\n\tu16 expected_checksum = 0;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 65 Packet Format *****\n\t *         | Content Type             | 1 byte       |\n\t *         | Status Indicator         | 1 byte       |\n\t *         | File Encryption Key Size | 1 or 2 bytes |\n\t *         | File Encryption Key      | arbitrary    |\n\t */\n\tmessage_len = msg->data_len;\n\tdata = msg->data;\n\tif (message_len < 4) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (data[i++] != ECRYPTFS_TAG_65_PACKET_TYPE) {\n\t\tecryptfs_printk(KERN_ERR, \"Type should be ECRYPTFS_TAG_65\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (data[i++]) {\n\t\tecryptfs_printk(KERN_ERR, \"Status indicator has non-zero value \"\n\t\t\t\t\"[%d]\\n\", data[i-1]);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[i], &m_size, &data_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error parsing packet length; \"\n\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\ti += data_len;\n\tif (message_len < (i + m_size)) {\n\t\tecryptfs_printk(KERN_ERR, \"The message received from ecryptfsd \"\n\t\t\t\t\"is shorter than expected\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (m_size < 3) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"The decrypted key is not long enough to \"\n\t\t\t\t\"include a cipher code and checksum\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\t*cipher_code = data[i++];\n\t/* The decrypted key includes 1 byte cipher code and 2 byte checksum */\n\tsession_key->decrypted_key_size = m_size - 3;\n\tif (session_key->decrypted_key_size > ECRYPTFS_MAX_KEY_BYTES) {\n\t\tecryptfs_printk(KERN_ERR, \"key_size [%d] larger than \"\n\t\t\t\t\"the maximum key size [%d]\\n\",\n\t\t\t\tsession_key->decrypted_key_size,\n\t\t\t\tECRYPTFS_MAX_ENCRYPTED_KEY_BYTES);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tmemcpy(session_key->decrypted_key, &data[i],\n\t       session_key->decrypted_key_size);\n\ti += session_key->decrypted_key_size;\n\texpected_checksum += (unsigned char)(data[i++]) << 8;\n\texpected_checksum += (unsigned char)(data[i++]);\n\tfor (i = 0; i < session_key->decrypted_key_size; i++)\n\t\tchecksum += session_key->decrypted_key[i];\n\tif (expected_checksum != checksum) {\n\t\tecryptfs_printk(KERN_ERR, \"Invalid checksum for file \"\n\t\t\t\t\"encryption  key; expected [%x]; calculated \"\n\t\t\t\t\"[%x]\\n\", expected_checksum, checksum);\n\t\trc = -EIO;\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Invalid checksum for file \"\n\t\t\t\t\"encryption  key; expected [%x]; calculated \"\n\t\t\t\t\"[%x]\\n\"",
            "expected_checksum",
            "checksum"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "session_key->decrypted_key",
            "&data[i]",
            "session_key->decrypted_key_size"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_parse_packet_length",
          "args": [
            "&data[i]",
            "&m_size",
            "&data_len"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_parse_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "94-123",
          "snippet": "int ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nparse_tag_65_packet(struct ecryptfs_session_key *session_key, u8 *cipher_code,\n\t\t    struct ecryptfs_message *msg)\n{\n\tsize_t i = 0;\n\tchar *data;\n\tsize_t data_len;\n\tsize_t m_size;\n\tsize_t message_len;\n\tu16 checksum = 0;\n\tu16 expected_checksum = 0;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 65 Packet Format *****\n\t *         | Content Type             | 1 byte       |\n\t *         | Status Indicator         | 1 byte       |\n\t *         | File Encryption Key Size | 1 or 2 bytes |\n\t *         | File Encryption Key      | arbitrary    |\n\t */\n\tmessage_len = msg->data_len;\n\tdata = msg->data;\n\tif (message_len < 4) {\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (data[i++] != ECRYPTFS_TAG_65_PACKET_TYPE) {\n\t\tecryptfs_printk(KERN_ERR, \"Type should be ECRYPTFS_TAG_65\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (data[i++]) {\n\t\tecryptfs_printk(KERN_ERR, \"Status indicator has non-zero value \"\n\t\t\t\t\"[%d]\\n\", data[i-1]);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[i], &m_size, &data_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_WARNING, \"Error parsing packet length; \"\n\t\t\t\t\"rc = [%d]\\n\", rc);\n\t\tgoto out;\n\t}\n\ti += data_len;\n\tif (message_len < (i + m_size)) {\n\t\tecryptfs_printk(KERN_ERR, \"The message received from ecryptfsd \"\n\t\t\t\t\"is shorter than expected\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tif (m_size < 3) {\n\t\tecryptfs_printk(KERN_ERR,\n\t\t\t\t\"The decrypted key is not long enough to \"\n\t\t\t\t\"include a cipher code and checksum\\n\");\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\t*cipher_code = data[i++];\n\t/* The decrypted key includes 1 byte cipher code and 2 byte checksum */\n\tsession_key->decrypted_key_size = m_size - 3;\n\tif (session_key->decrypted_key_size > ECRYPTFS_MAX_KEY_BYTES) {\n\t\tecryptfs_printk(KERN_ERR, \"key_size [%d] larger than \"\n\t\t\t\t\"the maximum key size [%d]\\n\",\n\t\t\t\tsession_key->decrypted_key_size,\n\t\t\t\tECRYPTFS_MAX_ENCRYPTED_KEY_BYTES);\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\tmemcpy(session_key->decrypted_key, &data[i],\n\t       session_key->decrypted_key_size);\n\ti += session_key->decrypted_key_size;\n\texpected_checksum += (unsigned char)(data[i++]) << 8;\n\texpected_checksum += (unsigned char)(data[i++]);\n\tfor (i = 0; i < session_key->decrypted_key_size; i++)\n\t\tchecksum += session_key->decrypted_key[i];\n\tif (expected_checksum != checksum) {\n\t\tecryptfs_printk(KERN_ERR, \"Invalid checksum for file \"\n\t\t\t\t\"encryption  key; expected [%x]; calculated \"\n\t\t\t\t\"[%x]\\n\", expected_checksum, checksum);\n\t\trc = -EIO;\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "write_tag_64_packet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "156-209",
    "snippet": "static int\nwrite_tag_64_packet(char *signature, struct ecryptfs_session_key *session_key,\n\t\t    char **packet, size_t *packet_len)\n{\n\tsize_t i = 0;\n\tsize_t data_len;\n\tsize_t packet_size_len;\n\tchar *message;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 64 Packet Format *****\n\t *    | Content Type                       | 1 byte       |\n\t *    | Key Identifier Size                | 1 or 2 bytes |\n\t *    | Key Identifier                     | arbitrary    |\n\t *    | Encrypted File Encryption Key Size | 1 or 2 bytes |\n\t *    | Encrypted File Encryption Key      | arbitrary    |\n\t */\n\tdata_len = (5 + ECRYPTFS_SIG_SIZE_HEX\n\t\t    + session_key->encrypted_key_size);\n\t*packet = kmalloc(data_len, GFP_KERNEL);\n\tmessage = *packet;\n\tif (!message) {\n\t\tecryptfs_printk(KERN_ERR, \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmessage[i++] = ECRYPTFS_TAG_64_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&message[i], ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 64 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], signature, ECRYPTFS_SIG_SIZE_HEX);\n\ti += ECRYPTFS_SIG_SIZE_HEX;\n\trc = ecryptfs_write_packet_length(&message[i],\n\t\t\t\t\t  session_key->encrypted_key_size,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 64 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], session_key->encrypted_key,\n\t       session_key->encrypted_key_size);\n\ti += session_key->encrypted_key_size;\n\t*packet_len = i;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&message[i]",
            "session_key->encrypted_key",
            "session_key->encrypted_key_size"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Error generating tag 64 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\""
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_write_packet_length",
          "args": [
            "&message[i]",
            "session_key->encrypted_key_size",
            "&packet_size_len"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_write_packet_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "135-154",
          "snippet": "int ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&message[i]",
            "signature",
            "ECRYPTFS_SIG_SIZE_HEX"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "data_len",
            "GFP_KERNEL"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int\nwrite_tag_64_packet(char *signature, struct ecryptfs_session_key *session_key,\n\t\t    char **packet, size_t *packet_len)\n{\n\tsize_t i = 0;\n\tsize_t data_len;\n\tsize_t packet_size_len;\n\tchar *message;\n\tint rc;\n\n\t/*\n\t *              ***** TAG 64 Packet Format *****\n\t *    | Content Type                       | 1 byte       |\n\t *    | Key Identifier Size                | 1 or 2 bytes |\n\t *    | Key Identifier                     | arbitrary    |\n\t *    | Encrypted File Encryption Key Size | 1 or 2 bytes |\n\t *    | Encrypted File Encryption Key      | arbitrary    |\n\t */\n\tdata_len = (5 + ECRYPTFS_SIG_SIZE_HEX\n\t\t    + session_key->encrypted_key_size);\n\t*packet = kmalloc(data_len, GFP_KERNEL);\n\tmessage = *packet;\n\tif (!message) {\n\t\tecryptfs_printk(KERN_ERR, \"Unable to allocate memory\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmessage[i++] = ECRYPTFS_TAG_64_PACKET_TYPE;\n\trc = ecryptfs_write_packet_length(&message[i], ECRYPTFS_SIG_SIZE_HEX,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 64 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], signature, ECRYPTFS_SIG_SIZE_HEX);\n\ti += ECRYPTFS_SIG_SIZE_HEX;\n\trc = ecryptfs_write_packet_length(&message[i],\n\t\t\t\t\t  session_key->encrypted_key_size,\n\t\t\t\t\t  &packet_size_len);\n\tif (rc) {\n\t\tecryptfs_printk(KERN_ERR, \"Error generating tag 64 packet \"\n\t\t\t\t\"header; cannot generate packet length\\n\");\n\t\tgoto out;\n\t}\n\ti += packet_size_len;\n\tmemcpy(&message[i], session_key->encrypted_key,\n\t       session_key->encrypted_key_size);\n\ti += session_key->encrypted_key_size;\n\t*packet_len = i;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_write_packet_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "135-154",
    "snippet": "int ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_WARNING",
            "\"Unsupported packet size: [%zd]\\n\"",
            "size"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_write_packet_length(char *dest, size_t size,\n\t\t\t\t size_t *packet_size_length)\n{\n\tint rc = 0;\n\n\tif (size < 192) {\n\t\tdest[0] = size;\n\t\t(*packet_size_length) = 1;\n\t} else if (size < 65536) {\n\t\tdest[0] = (((size - 192) / 256) + 192);\n\t\tdest[1] = ((size - 192) % 256);\n\t\t(*packet_size_length) = 2;\n\t} else {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\trc = -EINVAL;\n\t\tecryptfs_printk(KERN_WARNING,\n\t\t\t\t\"Unsupported packet size: [%zd]\\n\", size);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "ecryptfs_parse_packet_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "94-123",
    "snippet": "int ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_ERR",
            "\"Error parsing packet length\\n\""
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nint ecryptfs_parse_packet_length(unsigned char *data, size_t *size,\n\t\t\t\t size_t *length_size)\n{\n\tint rc = 0;\n\n\t(*length_size) = 0;\n\t(*size) = 0;\n\tif (data[0] < 192) {\n\t\t/* One-byte length */\n\t\t(*size) = data[0];\n\t\t(*length_size) = 1;\n\t} else if (data[0] < 224) {\n\t\t/* Two-byte length */\n\t\t(*size) = (data[0] - 192) * 256;\n\t\t(*size) += data[1] + 192;\n\t\t(*length_size) = 2;\n\t} else if (data[0] == 255) {\n\t\t/* If support is added, adjust ECRYPTFS_MAX_PKT_LEN_SIZE */\n\t\tecryptfs_printk(KERN_ERR, \"Five-byte packet length not \"\n\t\t\t\t\"supported\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t} else {\n\t\tecryptfs_printk(KERN_ERR, \"Error parsing packet length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "process_find_global_auth_tok_for_sig_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "67-83",
    "snippet": "static int process_find_global_auth_tok_for_sig_err(int err_code)\n{\n\tint rc = err_code;\n\n\tswitch (err_code) {\n\tcase -ENOENT:\n\t\tecryptfs_printk(KERN_WARNING, \"Missing auth tok\\n\");\n\t\tbreak;\n\tcase -EINVAL:\n\t\tecryptfs_printk(KERN_WARNING, \"Invalid auth tok\\n\");\n\t\tbreak;\n\tdefault:\n\t\trc = process_request_key_err(err_code);\n\t\tbreak;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "process_request_key_err",
          "args": [
            "err_code"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "process_request_key_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
          "lines": "42-65",
          "snippet": "static int process_request_key_err(long err_code)\n{\n\tint rc = 0;\n\n\tswitch (err_code) {\n\tcase -ENOKEY:\n\t\tecryptfs_printk(KERN_WARNING, \"No key\\n\");\n\t\trc = -ENOENT;\n\t\tbreak;\n\tcase -EKEYEXPIRED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key expired\\n\");\n\t\trc = -ETIME;\n\t\tbreak;\n\tcase -EKEYREVOKED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key revoked\\n\");\n\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_WARNING, \"Unknown error code: \"\n\t\t\t\t\"[0x%.16lx]\\n\", err_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/slab.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/random.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int process_request_key_err(long err_code)\n{\n\tint rc = 0;\n\n\tswitch (err_code) {\n\tcase -ENOKEY:\n\t\tecryptfs_printk(KERN_WARNING, \"No key\\n\");\n\t\trc = -ENOENT;\n\t\tbreak;\n\tcase -EKEYEXPIRED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key expired\\n\");\n\t\trc = -ETIME;\n\t\tbreak;\n\tcase -EKEYREVOKED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key revoked\\n\");\n\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_WARNING, \"Unknown error code: \"\n\t\t\t\t\"[0x%.16lx]\\n\", err_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_WARNING",
            "\"Invalid auth tok\\n\""
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int process_find_global_auth_tok_for_sig_err(int err_code)\n{\n\tint rc = err_code;\n\n\tswitch (err_code) {\n\tcase -ENOENT:\n\t\tecryptfs_printk(KERN_WARNING, \"Missing auth tok\\n\");\n\t\tbreak;\n\tcase -EINVAL:\n\t\tecryptfs_printk(KERN_WARNING, \"Invalid auth tok\\n\");\n\t\tbreak;\n\tdefault:\n\t\trc = process_request_key_err(err_code);\n\t\tbreak;\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "process_request_key_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/keystore.c",
    "lines": "42-65",
    "snippet": "static int process_request_key_err(long err_code)\n{\n\tint rc = 0;\n\n\tswitch (err_code) {\n\tcase -ENOKEY:\n\t\tecryptfs_printk(KERN_WARNING, \"No key\\n\");\n\t\trc = -ENOENT;\n\t\tbreak;\n\tcase -EKEYEXPIRED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key expired\\n\");\n\t\trc = -ETIME;\n\t\tbreak;\n\tcase -EKEYREVOKED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key revoked\\n\");\n\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_WARNING, \"Unknown error code: \"\n\t\t\t\t\"[0x%.16lx]\\n\", err_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"ecryptfs_kernel.h\"",
      "#include <linux/slab.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/random.h>",
      "#include <linux/key.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ecryptfs_printk",
          "args": [
            "KERN_WARNING",
            "\"Unknown error code: \"\n\t\t\t\t\"[0x%.16lx]\\n\"",
            "err_code"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "__ecryptfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ecryptfs/main.c",
          "lines": "86-96",
          "snippet": "void __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"ecryptfs_kernel.h\"",
            "#include <linux/magic.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_stack.h>",
            "#include <linux/parser.h>",
            "#include <linux/key.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/crypto.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/file.h>",
            "#include <linux/dcache.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ecryptfs_verbosity = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/magic.h>\n#include <linux/slab.h>\n#include <linux/fs_stack.h>\n#include <linux/parser.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/crypto.h>\n#include <linux/skbuff.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/file.h>\n#include <linux/dcache.h>\n\nint ecryptfs_verbosity = 0;\n\nvoid __ecryptfs_printk(const char *fmt, ...)\n{\n\tva_list args;\n\tva_start(args, fmt);\n\tif (fmt[1] == '7') { /* KERN_DEBUG */\n\t\tif (ecryptfs_verbosity >= 1)\n\t\t\tvprintk(fmt, args);\n\t} else\n\t\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_kernel.h\"\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/random.h>\n#include <linux/key.h>\n#include <linux/pagemap.h>\n#include <linux/string.h>\n\nstatic int process_request_key_err(long err_code)\n{\n\tint rc = 0;\n\n\tswitch (err_code) {\n\tcase -ENOKEY:\n\t\tecryptfs_printk(KERN_WARNING, \"No key\\n\");\n\t\trc = -ENOENT;\n\t\tbreak;\n\tcase -EKEYEXPIRED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key expired\\n\");\n\t\trc = -ETIME;\n\t\tbreak;\n\tcase -EKEYREVOKED:\n\t\tecryptfs_printk(KERN_WARNING, \"Key revoked\\n\");\n\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tecryptfs_printk(KERN_WARNING, \"Unknown error code: \"\n\t\t\t\t\"[0x%.16lx]\\n\", err_code);\n\t\trc = -EINVAL;\n\t}\n\treturn rc;\n}"
  }
]