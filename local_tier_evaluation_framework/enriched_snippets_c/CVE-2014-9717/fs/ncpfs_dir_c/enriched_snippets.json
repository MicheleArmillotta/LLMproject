[
  {
    "function_name": "ncp_date_unix2dos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "1213-1237",
    "snippet": "void\nncp_date_unix2dos(int unix_date, __le16 *time, __le16 *date)\n{\n\tint day, year, nl_day, month;\n\n\tunix_date = utc2local(unix_date);\n\t*time = cpu_to_le16(\n\t\t(unix_date % 60) / 2 + (((unix_date / 60) % 60) << 5) +\n\t\t(((unix_date / 3600) % 24) << 11));\n\tday = unix_date / 86400 - 3652;\n\tyear = day / 365;\n\tif ((year + 3) / 4 + 365 * year > day)\n\t\tyear--;\n\tday -= (year + 3) / 4 + 365 * year;\n\tif (day == 59 && !(year & 3)) {\n\t\tnl_day = day;\n\t\tmonth = 2;\n\t} else {\n\t\tnl_day = (year & 3) || day <= 59 ? day : day - 1;\n\t\tfor (month = 1; month < 12; month++)\n\t\t\tif (day_n[month] > nl_day)\n\t\t\t\tbreak;\n\t}\n\t*date = cpu_to_le16(nl_day - day_n[month - 1] + 1 + (month << 5) + (year << 9));\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int day_n[] =\n{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0, 0};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "nl_day - day_n[month - 1] + 1 + (month << 5) + (year << 9)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(unix_date % 60) / 2 + (((unix_date / 60) % 60) << 5) +\n\t\t(((unix_date / 3600) % 24) << 11)"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utc2local",
          "args": [
            "unix_date"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "utc2local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "1183-1186",
          "snippet": "static int utc2local(int time)\n{\n\treturn time - sys_tz.tz_minuteswest * 60;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int utc2local(int time)\n{\n\treturn time - sys_tz.tz_minuteswest * 60;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int day_n[] =\n{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0, 0};\n\nvoid\nncp_date_unix2dos(int unix_date, __le16 *time, __le16 *date)\n{\n\tint day, year, nl_day, month;\n\n\tunix_date = utc2local(unix_date);\n\t*time = cpu_to_le16(\n\t\t(unix_date % 60) / 2 + (((unix_date / 60) % 60) << 5) +\n\t\t(((unix_date / 3600) % 24) << 11));\n\tday = unix_date / 86400 - 3652;\n\tyear = day / 365;\n\tif ((year + 3) / 4 + 365 * year > day)\n\t\tyear--;\n\tday -= (year + 3) / 4 + 365 * year;\n\tif (day == 59 && !(year & 3)) {\n\t\tnl_day = day;\n\t\tmonth = 2;\n\t} else {\n\t\tnl_day = (year & 3) || day <= 59 ? day : day - 1;\n\t\tfor (month = 1; month < 12; month++)\n\t\t\tif (day_n[month] > nl_day)\n\t\t\t\tbreak;\n\t}\n\t*date = cpu_to_le16(nl_day - day_n[month - 1] + 1 + (month << 5) + (year << 9));\n}"
  },
  {
    "function_name": "ncp_date_dos2unix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "1194-1209",
    "snippet": "int\nncp_date_dos2unix(__le16 t, __le16 d)\n{\n\tunsigned short time = le16_to_cpu(t), date = le16_to_cpu(d);\n\tint month, year, secs;\n\n\t/* first subtract and mask after that... Otherwise, if\n\t   date == 0, bad things happen */\n\tmonth = ((date >> 5) - 1) & 15;\n\tyear = date >> 9;\n\tsecs = (time & 31) * 2 + 60 * ((time >> 5) & 63) + (time >> 11) * 3600 +\n\t\t86400 * ((date & 31) - 1 + day_n[month] + (year / 4) + \n\t\tyear * 365 - ((year & 3) == 0 && month < 2 ? 1 : 0) + 3653);\n\t/* days since 1.1.70 plus 80's leap day */\n\treturn local2utc(secs);\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int day_n[] =\n{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0, 0};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local2utc",
          "args": [
            "secs"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "local2utc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "1188-1191",
          "snippet": "static int local2utc(int time)\n{\n\treturn time + sys_tz.tz_minuteswest * 60;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int local2utc(int time)\n{\n\treturn time + sys_tz.tz_minuteswest * 60;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "d"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int day_n[] =\n{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0, 0};\n\nint\nncp_date_dos2unix(__le16 t, __le16 d)\n{\n\tunsigned short time = le16_to_cpu(t), date = le16_to_cpu(d);\n\tint month, year, secs;\n\n\t/* first subtract and mask after that... Otherwise, if\n\t   date == 0, bad things happen */\n\tmonth = ((date >> 5) - 1) & 15;\n\tyear = date >> 9;\n\tsecs = (time & 31) * 2 + 60 * ((time >> 5) & 63) + (time >> 11) * 3600 +\n\t\t86400 * ((date & 31) - 1 + day_n[month] + (year / 4) + \n\t\tyear * 365 - ((year & 3) == 0 && month < 2 ? 1 : 0) + 3653);\n\t/* days since 1.1.70 plus 80's leap day */\n\treturn local2utc(secs);\n}"
  },
  {
    "function_name": "local2utc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "1188-1191",
    "snippet": "static int local2utc(int time)\n{\n\treturn time + sys_tz.tz_minuteswest * 60;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int local2utc(int time)\n{\n\treturn time + sys_tz.tz_minuteswest * 60;\n}"
  },
  {
    "function_name": "utc2local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "1183-1186",
    "snippet": "static int utc2local(int time)\n{\n\treturn time - sys_tz.tz_minuteswest * 60;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int utc2local(int time)\n{\n\treturn time - sys_tz.tz_minuteswest * 60;\n}"
  },
  {
    "function_name": "ncp_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "1163-1173",
    "snippet": "static int ncp_mknod(struct inode * dir, struct dentry *dentry,\n\t\t     umode_t mode, dev_t rdev)\n{\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\tif (ncp_is_nfs_extras(NCP_SERVER(dir), NCP_FINFO(dir)->volNumber)) {\n\t\tncp_dbg(1, \"mode = 0%ho\\n\", mode);\n\t\treturn ncp_create_new(dir, dentry, mode, rdev, 0);\n\t}\n\treturn -EPERM; /* Strange, but true */\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ncp_create(struct inode *, struct dentry *, umode_t, bool);",
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_mkdir(struct inode *, struct dentry *, umode_t);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_mknod(struct inode * dir, struct dentry *dentry,\n\t\t     umode_t mode, dev_t rdev);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_create_new",
          "args": [
            "dir",
            "dentry",
            "mode",
            "rdev",
            "0"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_create_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "910-966",
          "snippet": "int ncp_create_new(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t   dev_t rdev, __le32 attributes)\n{\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct ncp_entry_info finfo;\n\tint error, result, len;\n\tint opmode;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\t\n\tncp_vdbg(\"creating %pd2, mode=%hx\\n\", dentry, mode);\n\n\tncp_age_dentry(server, dentry);\n\tlen = sizeof(__name);\n\terror = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t   dentry->d_name.len, !ncp_preserve_case(dir));\n\tif (error)\n\t\tgoto out;\n\n\terror = -EACCES;\n\t\n\tif (S_ISREG(mode) && \n\t    (server->m.flags & NCP_MOUNT_EXTRAS) && \n\t    (mode & S_IXUGO))\n\t\tattributes |= aSYSTEM | aSHARED;\n\t\n\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_READ | AR_WRITE, &finfo);\n\topmode = O_RDWR;\n\tif (result) {\n\t\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_WRITE, &finfo);\n\t\tif (result) {\n\t\t\tif (result == 0x87)\n\t\t\t\terror = -ENAMETOOLONG;\n\t\t\telse if (result < 0)\n\t\t\t\terror = result;\n\t\t\tncp_dbg(1, \"%pd2 failed\\n\", dentry);\n\t\t\tgoto out;\n\t\t}\n\t\topmode = O_WRONLY;\n\t}\n\tfinfo.access = opmode;\n\tif (ncp_is_nfs_extras(server, finfo.volume)) {\n\t\tfinfo.i.nfs.mode = mode;\n\t\tfinfo.i.nfs.rdev = new_encode_dev(rdev);\n\t\tif (ncp_modify_nfs_info(server, finfo.volume,\n\t\t\t\t\tfinfo.i.dirEntNum,\n\t\t\t\t\tmode, new_encode_dev(rdev)) != 0)\n\t\t\tgoto out;\n\t}\n\n\terror = ncp_instantiate(dir, dentry, &finfo);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ncp_create(struct inode *, struct dentry *, umode_t, bool);",
            "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
            "static int ncp_unlink(struct inode *, struct dentry *);",
            "static int ncp_mkdir(struct inode *, struct dentry *, umode_t);",
            "static int ncp_rmdir(struct inode *, struct dentry *);",
            "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
            "static int ncp_mknod(struct inode * dir, struct dentry *dentry,\n\t\t     umode_t mode, dev_t rdev);",
            "static int ncp_lookup_validate(struct dentry *, unsigned int);",
            "static int ncp_delete_dentry(const struct dentry *);",
            "static void ncp_d_prune(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_create(struct inode *, struct dentry *, umode_t, bool);\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_mkdir(struct inode *, struct dentry *, umode_t);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_mknod(struct inode * dir, struct dentry *dentry,\n\t\t     umode_t mode, dev_t rdev);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nint ncp_create_new(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t   dev_t rdev, __le32 attributes)\n{\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct ncp_entry_info finfo;\n\tint error, result, len;\n\tint opmode;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\t\n\tncp_vdbg(\"creating %pd2, mode=%hx\\n\", dentry, mode);\n\n\tncp_age_dentry(server, dentry);\n\tlen = sizeof(__name);\n\terror = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t   dentry->d_name.len, !ncp_preserve_case(dir));\n\tif (error)\n\t\tgoto out;\n\n\terror = -EACCES;\n\t\n\tif (S_ISREG(mode) && \n\t    (server->m.flags & NCP_MOUNT_EXTRAS) && \n\t    (mode & S_IXUGO))\n\t\tattributes |= aSYSTEM | aSHARED;\n\t\n\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_READ | AR_WRITE, &finfo);\n\topmode = O_RDWR;\n\tif (result) {\n\t\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_WRITE, &finfo);\n\t\tif (result) {\n\t\t\tif (result == 0x87)\n\t\t\t\terror = -ENAMETOOLONG;\n\t\t\telse if (result < 0)\n\t\t\t\terror = result;\n\t\t\tncp_dbg(1, \"%pd2 failed\\n\", dentry);\n\t\t\tgoto out;\n\t\t}\n\t\topmode = O_WRONLY;\n\t}\n\tfinfo.access = opmode;\n\tif (ncp_is_nfs_extras(server, finfo.volume)) {\n\t\tfinfo.i.nfs.mode = mode;\n\t\tfinfo.i.nfs.rdev = new_encode_dev(rdev);\n\t\tif (ncp_modify_nfs_info(server, finfo.volume,\n\t\t\t\t\tfinfo.i.dirEntNum,\n\t\t\t\t\tmode, new_encode_dev(rdev)) != 0)\n\t\t\tgoto out;\n\t}\n\n\terror = ncp_instantiate(dir, dentry, &finfo);\nout:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"mode = 0%ho\\n\"",
            "mode"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_is_nfs_extras",
          "args": [
            "NCP_SERVER(dir)",
            "NCP_FINFO(dir)->volNumber"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_is_nfs_extras",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "119-126",
          "snippet": "static inline int ncp_is_nfs_extras(struct ncp_server* server, unsigned int volnum) {\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn (server->m.flags & NCP_MOUNT_NFS_EXTRAS) &&\n\t       (server->name_space[volnum] == NW_NS_NFS);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ncp_is_nfs_extras(struct ncp_server* server, unsigned int volnum) {\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn (server->m.flags & NCP_MOUNT_NFS_EXTRAS) &&\n\t       (server->name_space[volnum] == NW_NS_NFS);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "dir"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_create(struct inode *, struct dentry *, umode_t, bool);\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_mkdir(struct inode *, struct dentry *, umode_t);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_mknod(struct inode * dir, struct dentry *dentry,\n\t\t     umode_t mode, dev_t rdev);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int ncp_mknod(struct inode * dir, struct dentry *dentry,\n\t\t     umode_t mode, dev_t rdev)\n{\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\tif (ncp_is_nfs_extras(NCP_SERVER(dir), NCP_FINFO(dir)->volNumber)) {\n\t\tncp_dbg(1, \"mode = 0%ho\\n\", mode);\n\t\treturn ncp_create_new(dir, dentry, mode, rdev, 0);\n\t}\n\treturn -EPERM; /* Strange, but true */\n}"
  },
  {
    "function_name": "ncp_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "1108-1161",
    "snippet": "static int ncp_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct ncp_server *server = NCP_SERVER(old_dir);\n\tint error;\n\tint old_len, new_len;\n\t__u8 __old_name[NCP_MAXPATHLEN + 1], __new_name[NCP_MAXPATHLEN + 1];\n\n\tncp_dbg(1, \"%pd2 to %pd2\\n\", old_dentry, new_dentry);\n\n\tncp_age_dentry(server, old_dentry);\n\tncp_age_dentry(server, new_dentry);\n\n\told_len = sizeof(__old_name);\n\terror = ncp_io2vol(server, __old_name, &old_len,\n\t\t\t   old_dentry->d_name.name, old_dentry->d_name.len,\n\t\t\t   !ncp_preserve_case(old_dir));\n\tif (error)\n\t\tgoto out;\n\n\tnew_len = sizeof(__new_name);\n\terror = ncp_io2vol(server, __new_name, &new_len,\n\t\t\t   new_dentry->d_name.name, new_dentry->d_name.len,\n\t\t\t   !ncp_preserve_case(new_dir));\n\tif (error)\n\t\tgoto out;\n\n\terror = ncp_ren_or_mov_file_or_subdir(server, old_dir, __old_name,\n\t\t\t\t\t\t      new_dir, __new_name);\n#ifdef CONFIG_NCPFS_STRONG\n\tif ((error == 0x90 || error == 0x8B || error == -EACCES) &&\n\t\t\tserver->m.flags & NCP_MOUNT_STRONG) {\t/* RO */\n\t\terror = ncp_force_rename(old_dir, old_dentry, __old_name,\n\t\t\t\t\t new_dir, new_dentry, __new_name);\n\t}\n#endif\n\tswitch (error) {\n\t\tcase 0x00:\n\t\t\tncp_dbg(1, \"renamed %pd -> %pd\\n\",\n\t\t\t\told_dentry, new_dentry);\n\t\t\tbreak;\n\t\tcase 0x9E:\n\t\t\terror = -ENAMETOOLONG;\n\t\t\tbreak;\n\t\tcase 0xFF:\n\t\t\terror = -ENOENT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = error < 0 ? error : -EACCES;\n\t\t\tbreak;\n\t}\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"renamed %pd -> %pd\\n\"",
            "old_dentry",
            "new_dentry"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_force_rename",
          "args": [
            "old_dir",
            "old_dentry",
            "__old_name",
            "new_dir",
            "new_dentry",
            "__new_name"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_force_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "251-306",
          "snippet": "static int\nncp_force_rename(struct inode *old_dir, struct dentry* old_dentry, char *_old_name,\n                 struct inode *new_dir, struct dentry* new_dentry, char *_new_name)\n{\n\tstruct nw_modify_dos_info info;\n        int res=0x90,res2;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\t__le32 old_nwattr = NCP_FINFO(old_inode)->nwattr;\n\t__le32 new_nwattr = 0; /* shut compiler warning */\n\tint old_nwattr_changed = 0;\n\tint new_nwattr_changed = 0;\n\n\tmemset(&info, 0, sizeof(info));\n\t\n        /* remove the Read-Only flag on the NW server */\n\n\tinfo.attributes = old_nwattr & ~(aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);\n\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(old_inode), old_inode, NULL, DM_ATTRIBUTES, &info);\n\tif (!res2)\n\t\told_nwattr_changed = 1;\n\tif (new_dentry && new_dentry->d_inode) {\n\t\tnew_nwattr = NCP_FINFO(new_dentry->d_inode)->nwattr;\n\t\tinfo.attributes = new_nwattr & ~(aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(new_dir), new_dir, _new_name, DM_ATTRIBUTES, &info);\n\t\tif (!res2)\n\t\t\tnew_nwattr_changed = 1;\n\t}\n        /* now try again the rename operation */\n\t/* but only if something really happened */\n\tif (new_nwattr_changed || old_nwattr_changed) {\n\t        res = ncp_ren_or_mov_file_or_subdir(NCP_SERVER(old_dir),\n        \t                                    old_dir, _old_name,\n                \t                            new_dir, _new_name);\n\t} \n\tif (res)\n\t\tgoto leave_me;\n\t/* file was successfully renamed, so:\n\t   do not set attributes on old file - it no longer exists\n\t   copy attributes from old file to new */\n\tnew_nwattr_changed = old_nwattr_changed;\n\tnew_nwattr = old_nwattr;\n\told_nwattr_changed = 0;\n\t\nleave_me:;\n\tif (old_nwattr_changed) {\n\t\tinfo.attributes = old_nwattr;\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(old_inode), old_inode, NULL, DM_ATTRIBUTES, &info);\n\t\t/* ignore errors */\n\t}\n\tif (new_nwattr_changed)\t{\n\t\tinfo.attributes = new_nwattr;\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(new_dir), new_dir, _new_name, DM_ATTRIBUTES, &info);\n\t\t/* ignore errors */\n\t}\n        return(res);\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
            "static int ncp_unlink(struct inode *, struct dentry *);",
            "static int ncp_rmdir(struct inode *, struct dentry *);",
            "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
            "static int ncp_lookup_validate(struct dentry *, unsigned int);",
            "static int ncp_delete_dentry(const struct dentry *);",
            "static void ncp_d_prune(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int\nncp_force_rename(struct inode *old_dir, struct dentry* old_dentry, char *_old_name,\n                 struct inode *new_dir, struct dentry* new_dentry, char *_new_name)\n{\n\tstruct nw_modify_dos_info info;\n        int res=0x90,res2;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\t__le32 old_nwattr = NCP_FINFO(old_inode)->nwattr;\n\t__le32 new_nwattr = 0; /* shut compiler warning */\n\tint old_nwattr_changed = 0;\n\tint new_nwattr_changed = 0;\n\n\tmemset(&info, 0, sizeof(info));\n\t\n        /* remove the Read-Only flag on the NW server */\n\n\tinfo.attributes = old_nwattr & ~(aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);\n\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(old_inode), old_inode, NULL, DM_ATTRIBUTES, &info);\n\tif (!res2)\n\t\told_nwattr_changed = 1;\n\tif (new_dentry && new_dentry->d_inode) {\n\t\tnew_nwattr = NCP_FINFO(new_dentry->d_inode)->nwattr;\n\t\tinfo.attributes = new_nwattr & ~(aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(new_dir), new_dir, _new_name, DM_ATTRIBUTES, &info);\n\t\tif (!res2)\n\t\t\tnew_nwattr_changed = 1;\n\t}\n        /* now try again the rename operation */\n\t/* but only if something really happened */\n\tif (new_nwattr_changed || old_nwattr_changed) {\n\t        res = ncp_ren_or_mov_file_or_subdir(NCP_SERVER(old_dir),\n        \t                                    old_dir, _old_name,\n                \t                            new_dir, _new_name);\n\t} \n\tif (res)\n\t\tgoto leave_me;\n\t/* file was successfully renamed, so:\n\t   do not set attributes on old file - it no longer exists\n\t   copy attributes from old file to new */\n\tnew_nwattr_changed = old_nwattr_changed;\n\tnew_nwattr = old_nwattr;\n\told_nwattr_changed = 0;\n\t\nleave_me:;\n\tif (old_nwattr_changed) {\n\t\tinfo.attributes = old_nwattr;\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(old_inode), old_inode, NULL, DM_ATTRIBUTES, &info);\n\t\t/* ignore errors */\n\t}\n\tif (new_nwattr_changed)\t{\n\t\tinfo.attributes = new_nwattr;\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(new_dir), new_dir, _new_name, DM_ATTRIBUTES, &info);\n\t\t/* ignore errors */\n\t}\n        return(res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_ren_or_mov_file_or_subdir",
          "args": [
            "server",
            "old_dir",
            "__old_name",
            "new_dir",
            "__new_name"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_ren_or_mov_file_or_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "940-962",
          "snippet": "int ncp_ren_or_mov_file_or_subdir(struct ncp_server *server,\n\t\t\t\tstruct inode *old_dir, const char *old_name,\n\t\t\t\tstruct inode *new_dir, const char *new_name)\n{\n        int result;\n        __le16 old_type = cpu_to_le16(0x06);\n\n/* If somebody can do it atomic, call me... vandrove@vc.cvut.cz */\n\tresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\n\t                                   new_dir, new_name);\n        if (result == 0xFF)\t/* File Not Found, try directory */\n\t{\n\t\told_type = cpu_to_le16(0x16);\n\t\tresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\n\t\t\t\t\t\t   new_dir, new_name);\n\t}\n\tif (result != 0x92) return result;\t/* All except NO_FILES_RENAMED */\n\tresult = ncp_del_file_or_subdir(server, new_dir, new_name);\n\tif (result != 0) return -EACCES;\n\tresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\n\t\t\t\t\t   new_dir, new_name);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_ren_or_mov_file_or_subdir(struct ncp_server *server,\n\t\t\t\tstruct inode *old_dir, const char *old_name,\n\t\t\t\tstruct inode *new_dir, const char *new_name)\n{\n        int result;\n        __le16 old_type = cpu_to_le16(0x06);\n\n/* If somebody can do it atomic, call me... vandrove@vc.cvut.cz */\n\tresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\n\t                                   new_dir, new_name);\n        if (result == 0xFF)\t/* File Not Found, try directory */\n\t{\n\t\told_type = cpu_to_le16(0x16);\n\t\tresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\n\t\t\t\t\t\t   new_dir, new_name);\n\t}\n\tif (result != 0x92) return result;\t/* All except NO_FILES_RENAMED */\n\tresult = ncp_del_file_or_subdir(server, new_dir, new_name);\n\tif (result != 0) return -EACCES;\n\tresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\n\t\t\t\t\t   new_dir, new_name);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_io2vol",
          "args": [
            "server",
            "__new_name",
            "&new_len",
            "new_dentry->d_name.name",
            "new_dentry->d_name.len",
            "!ncp_preserve_case(new_dir)"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_preserve_case",
          "args": [
            "new_dir"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_io2vol",
          "args": [
            "server",
            "__old_name",
            "&old_len",
            "old_dentry->d_name.name",
            "old_dentry->d_name.len",
            "!ncp_preserve_case(old_dir)"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_preserve_case",
          "args": [
            "old_dir"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_age_dentry",
          "args": [
            "server",
            "new_dentry"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_age_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "175-179",
          "snippet": "static inline void\nncp_age_dentry(struct ncp_server* server, struct dentry* dentry)\n{\n\tdentry->d_time = jiffies - NCP_MAX_AGE(server);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void\nncp_age_dentry(struct ncp_server* server, struct dentry* dentry)\n{\n\tdentry->d_time = jiffies - NCP_MAX_AGE(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"%pd2 to %pd2\\n\"",
            "old_dentry",
            "new_dentry"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "old_dir"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int ncp_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct ncp_server *server = NCP_SERVER(old_dir);\n\tint error;\n\tint old_len, new_len;\n\t__u8 __old_name[NCP_MAXPATHLEN + 1], __new_name[NCP_MAXPATHLEN + 1];\n\n\tncp_dbg(1, \"%pd2 to %pd2\\n\", old_dentry, new_dentry);\n\n\tncp_age_dentry(server, old_dentry);\n\tncp_age_dentry(server, new_dentry);\n\n\told_len = sizeof(__old_name);\n\terror = ncp_io2vol(server, __old_name, &old_len,\n\t\t\t   old_dentry->d_name.name, old_dentry->d_name.len,\n\t\t\t   !ncp_preserve_case(old_dir));\n\tif (error)\n\t\tgoto out;\n\n\tnew_len = sizeof(__new_name);\n\terror = ncp_io2vol(server, __new_name, &new_len,\n\t\t\t   new_dentry->d_name.name, new_dentry->d_name.len,\n\t\t\t   !ncp_preserve_case(new_dir));\n\tif (error)\n\t\tgoto out;\n\n\terror = ncp_ren_or_mov_file_or_subdir(server, old_dir, __old_name,\n\t\t\t\t\t\t      new_dir, __new_name);\n#ifdef CONFIG_NCPFS_STRONG\n\tif ((error == 0x90 || error == 0x8B || error == -EACCES) &&\n\t\t\tserver->m.flags & NCP_MOUNT_STRONG) {\t/* RO */\n\t\terror = ncp_force_rename(old_dir, old_dentry, __old_name,\n\t\t\t\t\t new_dir, new_dentry, __new_name);\n\t}\n#endif\n\tswitch (error) {\n\t\tcase 0x00:\n\t\t\tncp_dbg(1, \"renamed %pd -> %pd\\n\",\n\t\t\t\told_dentry, new_dentry);\n\t\t\tbreak;\n\t\tcase 0x9E:\n\t\t\terror = -ENAMETOOLONG;\n\t\t\tbreak;\n\t\tcase 0xFF:\n\t\t\terror = -ENOENT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = error < 0 ? error : -EACCES;\n\t\t\tbreak;\n\t}\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "ncp_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "1056-1106",
    "snippet": "static int ncp_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ncp_server *server;\n\tint error;\n\n\tserver = NCP_SERVER(dir);\n\tncp_dbg(1, \"unlinking %pd2\\n\", dentry);\n\t\n\t/*\n\t * Check whether to close the file ...\n\t */\n\tif (inode) {\n\t\tncp_vdbg(\"closing file\\n\");\n\t\tncp_make_closed(inode);\n\t}\n\n\terror = ncp_del_file_or_subdir2(server, dentry);\n#ifdef CONFIG_NCPFS_STRONG\n\t/* 9C is Invalid path.. It should be 8F, 90 - read only, but\n\t   it is not :-( */\n\tif ((error == 0x9C || error == 0x90) && server->m.flags & NCP_MOUNT_STRONG) { /* R/O */\n\t\terror = ncp_force_unlink(dir, dentry);\n\t}\n#endif\n\tswitch (error) {\n\t\tcase 0x00:\n\t\t\tncp_dbg(1, \"removed %pd2\\n\", dentry);\n\t\t\tbreak;\n\t\tcase 0x85:\n\t\tcase 0x8A:\n\t\t\terror = -EACCES;\n\t\t\tbreak;\n\t\tcase 0x8D:\t/* some files in use */\n\t\tcase 0x8E:\t/* all files in use */\n\t\t\terror = -EBUSY;\n\t\t\tbreak;\n\t\tcase 0x8F:\t/* some read only */\n\t\tcase 0x90:\t/* all read only */\n\t\tcase 0x9C:\t/* !!! returned when in-use or read-only by NW4 */\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\tcase 0xFF:\n\t\t\terror = -ENOENT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = error < 0 ? error : -EACCES;\n\t\t\tbreak;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"removed %pd2\\n\"",
            "dentry"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_force_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_force_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "216-247",
          "snippet": "static int\nncp_force_unlink(struct inode *dir, struct dentry* dentry)\n{\n        int res=0x9c,res2;\n\tstruct nw_modify_dos_info info;\n\t__le32 old_nwattr;\n\tstruct inode *inode;\n\n\tmemset(&info, 0, sizeof(info));\n\t\n        /* remove the Read-Only flag on the NW server */\n\tinode = dentry->d_inode;\n\n\told_nwattr = NCP_FINFO(inode)->nwattr;\n\tinfo.attributes = old_nwattr & ~(aRONLY|aDELETEINHIBIT|aRENAMEINHIBIT);\n\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(inode), inode, NULL, DM_ATTRIBUTES, &info);\n\tif (res2)\n\t\tgoto leave_me;\n\n        /* now try again the delete operation */\n        res = ncp_del_file_or_subdir2(NCP_SERVER(dir), dentry);\n\n        if (res)  /* delete failed, set R bit again */\n        {\n\t\tinfo.attributes = old_nwattr;\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(inode), inode, NULL, DM_ATTRIBUTES, &info);\n\t\tif (res2)\n                        goto leave_me;\n        }\nleave_me:\n        return(res);\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
            "static int ncp_unlink(struct inode *, struct dentry *);",
            "static int ncp_rmdir(struct inode *, struct dentry *);",
            "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
            "static int ncp_lookup_validate(struct dentry *, unsigned int);",
            "static int ncp_delete_dentry(const struct dentry *);",
            "static void ncp_d_prune(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int\nncp_force_unlink(struct inode *dir, struct dentry* dentry)\n{\n        int res=0x9c,res2;\n\tstruct nw_modify_dos_info info;\n\t__le32 old_nwattr;\n\tstruct inode *inode;\n\n\tmemset(&info, 0, sizeof(info));\n\t\n        /* remove the Read-Only flag on the NW server */\n\tinode = dentry->d_inode;\n\n\told_nwattr = NCP_FINFO(inode)->nwattr;\n\tinfo.attributes = old_nwattr & ~(aRONLY|aDELETEINHIBIT|aRENAMEINHIBIT);\n\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(inode), inode, NULL, DM_ATTRIBUTES, &info);\n\tif (res2)\n\t\tgoto leave_me;\n\n        /* now try again the delete operation */\n        res = ncp_del_file_or_subdir2(NCP_SERVER(dir), dentry);\n\n        if (res)  /* delete failed, set R bit again */\n        {\n\t\tinfo.attributes = old_nwattr;\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(inode), inode, NULL, DM_ATTRIBUTES, &info);\n\t\tif (res2)\n                        goto leave_me;\n        }\nleave_me:\n        return(res);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_del_file_or_subdir2",
          "args": [
            "server",
            "dentry"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_del_file_or_subdir2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "726-740",
          "snippet": "int\nncp_del_file_or_subdir2(struct ncp_server *server,\n\t\t\tstruct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\t__u8  volnum;\n\t__le32 dirent;\n\n\tif (!inode) {\n\t\treturn 0xFF;\t/* Any error */\n\t}\n\tvolnum = NCP_FINFO(inode)->volNumber;\n\tdirent = NCP_FINFO(inode)->DosDirNum;\n\treturn ncp_DeleteNSEntry(server, 1, volnum, dirent, NULL, NW_NS_DOS, cpu_to_le16(0x8006));\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_del_file_or_subdir2(struct ncp_server *server,\n\t\t\tstruct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\t__u8  volnum;\n\t__le32 dirent;\n\n\tif (!inode) {\n\t\treturn 0xFF;\t/* Any error */\n\t}\n\tvolnum = NCP_FINFO(inode)->volNumber;\n\tdirent = NCP_FINFO(inode)->DosDirNum;\n\treturn ncp_DeleteNSEntry(server, 1, volnum, dirent, NULL, NW_NS_DOS, cpu_to_le16(0x8006));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_make_closed",
          "args": [
            "inode"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_make_closed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "286-304",
          "snippet": "int\nncp_make_closed(struct inode *inode)\n{\n\tint err;\n\n\terr = 0;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 0);\n\t\terr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\n\n\t\tif (!err)\n\t\t\tncp_vdbg(\"volnum=%d, dirent=%u, error=%d\\n\",\n\t\t\t\t NCP_FINFO(inode)->volNumber,\n\t\t\t\t NCP_FINFO(inode)->dirEntNum, err);\n\t}\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\n\treturn err;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_make_closed(struct inode *inode)\n{\n\tint err;\n\n\terr = 0;\n\tmutex_lock(&NCP_FINFO(inode)->open_mutex);\n\tif (atomic_read(&NCP_FINFO(inode)->opened) == 1) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, 0);\n\t\terr = ncp_close_file(NCP_SERVER(inode), NCP_FINFO(inode)->file_handle);\n\n\t\tif (!err)\n\t\t\tncp_vdbg(\"volnum=%d, dirent=%u, error=%d\\n\",\n\t\t\t\t NCP_FINFO(inode)->volNumber,\n\t\t\t\t NCP_FINFO(inode)->dirEntNum, err);\n\t}\n\tmutex_unlock(&NCP_FINFO(inode)->open_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_vdbg",
          "args": [
            "\"closing file\\n\""
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"unlinking %pd2\\n\"",
            "dentry"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int ncp_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ncp_server *server;\n\tint error;\n\n\tserver = NCP_SERVER(dir);\n\tncp_dbg(1, \"unlinking %pd2\\n\", dentry);\n\t\n\t/*\n\t * Check whether to close the file ...\n\t */\n\tif (inode) {\n\t\tncp_vdbg(\"closing file\\n\");\n\t\tncp_make_closed(inode);\n\t}\n\n\terror = ncp_del_file_or_subdir2(server, dentry);\n#ifdef CONFIG_NCPFS_STRONG\n\t/* 9C is Invalid path.. It should be 8F, 90 - read only, but\n\t   it is not :-( */\n\tif ((error == 0x9C || error == 0x90) && server->m.flags & NCP_MOUNT_STRONG) { /* R/O */\n\t\terror = ncp_force_unlink(dir, dentry);\n\t}\n#endif\n\tswitch (error) {\n\t\tcase 0x00:\n\t\t\tncp_dbg(1, \"removed %pd2\\n\", dentry);\n\t\t\tbreak;\n\t\tcase 0x85:\n\t\tcase 0x8A:\n\t\t\terror = -EACCES;\n\t\t\tbreak;\n\t\tcase 0x8D:\t/* some files in use */\n\t\tcase 0x8E:\t/* all files in use */\n\t\t\terror = -EBUSY;\n\t\t\tbreak;\n\t\tcase 0x8F:\t/* some read only */\n\t\tcase 0x90:\t/* all read only */\n\t\tcase 0x9C:\t/* !!! returned when in-use or read-only by NW4 */\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\tcase 0xFF:\n\t\t\terror = -ENOENT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = error < 0 ? error : -EACCES;\n\t\t\tbreak;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "ncp_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "1012-1054",
    "snippet": "static int ncp_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tint error, result, len;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tncp_dbg(1, \"removing %pd2\\n\", dentry);\n\n\tlen = sizeof(__name);\n\terror = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t   dentry->d_name.len, !ncp_preserve_case(dir));\n\tif (error)\n\t\tgoto out;\n\n\tresult = ncp_del_file_or_subdir(server, dir, __name);\n\tswitch (result) {\n\t\tcase 0x00:\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\tcase 0x85:\t/* unauthorized to delete file */\n\t\tcase 0x8A:\t/* unauthorized to delete file */\n\t\t\terror = -EACCES;\n\t\t\tbreak;\n\t\tcase 0x8F:\n\t\tcase 0x90:\t/* read only */\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\tcase 0x9F:\t/* in use by another client */\n\t\t\terror = -EBUSY;\n\t\t\tbreak;\n\t\tcase 0xA0:\t/* directory not empty */\n\t\t\terror = -ENOTEMPTY;\n\t\t\tbreak;\n\t\tcase 0xFF:\t/* someone deleted file */\n\t\t\terror = -ENOENT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = result < 0 ? result : -EACCES;\n\t\t\tbreak;\n       \t}\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_del_file_or_subdir",
          "args": [
            "server",
            "dir",
            "__name"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_del_file_or_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "742-763",
          "snippet": "int\nncp_del_file_or_subdir(struct ncp_server *server,\n\t\t       struct inode *dir, const char *name)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint name_space;\n\n\tname_space = server->name_space[volnum];\n#ifdef CONFIG_NCPFS_NFS_NS\n\tif (name_space == NW_NS_NFS)\n \t{\n \t\tint result;\n \n\t\tresult=ncp_obtain_DOS_dir_base(server, name_space, volnum, dirent, name, &dirent);\n \t\tif (result) return result;\n\t\tname = NULL;\n\t\tname_space = NW_NS_DOS;\n \t}\n#endif\t/* CONFIG_NCPFS_NFS_NS */\n\treturn ncp_DeleteNSEntry(server, 1, volnum, dirent, name, name_space, cpu_to_le16(0x8006));\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_del_file_or_subdir(struct ncp_server *server,\n\t\t       struct inode *dir, const char *name)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint name_space;\n\n\tname_space = server->name_space[volnum];\n#ifdef CONFIG_NCPFS_NFS_NS\n\tif (name_space == NW_NS_NFS)\n \t{\n \t\tint result;\n \n\t\tresult=ncp_obtain_DOS_dir_base(server, name_space, volnum, dirent, name, &dirent);\n \t\tif (result) return result;\n\t\tname = NULL;\n\t\tname_space = NW_NS_DOS;\n \t}\n#endif\t/* CONFIG_NCPFS_NFS_NS */\n\treturn ncp_DeleteNSEntry(server, 1, volnum, dirent, name, name_space, cpu_to_le16(0x8006));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_io2vol",
          "args": [
            "server",
            "__name",
            "&len",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "!ncp_preserve_case(dir)"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_preserve_case",
          "args": [
            "dir"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"removing %pd2\\n\"",
            "dentry"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int ncp_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tint error, result, len;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tncp_dbg(1, \"removing %pd2\\n\", dentry);\n\n\tlen = sizeof(__name);\n\terror = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t   dentry->d_name.len, !ncp_preserve_case(dir));\n\tif (error)\n\t\tgoto out;\n\n\tresult = ncp_del_file_or_subdir(server, dir, __name);\n\tswitch (result) {\n\t\tcase 0x00:\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\tcase 0x85:\t/* unauthorized to delete file */\n\t\tcase 0x8A:\t/* unauthorized to delete file */\n\t\t\terror = -EACCES;\n\t\t\tbreak;\n\t\tcase 0x8F:\n\t\tcase 0x90:\t/* read only */\n\t\t\terror = -EPERM;\n\t\t\tbreak;\n\t\tcase 0x9F:\t/* in use by another client */\n\t\t\terror = -EBUSY;\n\t\t\tbreak;\n\t\tcase 0xA0:\t/* directory not empty */\n\t\t\terror = -ENOTEMPTY;\n\t\t\tbreak;\n\t\tcase 0xFF:\t/* someone deleted file */\n\t\t\terror = -ENOENT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = result < 0 ? result : -EACCES;\n\t\t\tbreak;\n       \t}\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "ncp_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "974-1010",
    "snippet": "static int ncp_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct ncp_entry_info finfo;\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tint error, len;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tncp_dbg(1, \"making %pd2\\n\", dentry);\n\n\tncp_age_dentry(server, dentry);\n\tlen = sizeof(__name);\n\terror = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t   dentry->d_name.len, !ncp_preserve_case(dir));\n\tif (error)\n\t\tgoto out;\n\n\terror = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\t\t   OC_MODE_CREATE, aDIR,\n\t\t\t\t\t   cpu_to_le16(0xffff),\n\t\t\t\t\t   &finfo);\n\tif (error == 0) {\n\t\tif (ncp_is_nfs_extras(server, finfo.volume)) {\n\t\t\tmode |= S_IFDIR;\n\t\t\tfinfo.i.nfs.mode = mode;\n\t\t\tif (ncp_modify_nfs_info(server,\n\t\t\t\t\t\tfinfo.volume,\n\t\t\t\t\t\tfinfo.i.dirEntNum,\n\t\t\t\t\t\tmode, 0) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\terror = ncp_instantiate(dir, dentry, &finfo);\n\t} else if (error > 0) {\n\t\terror = -EACCES;\n\t}\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ncp_create(struct inode *, struct dentry *, umode_t, bool);",
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_mkdir(struct inode *, struct dentry *, umode_t);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_instantiate",
          "args": [
            "dir",
            "dentry",
            "&finfo"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "889-908",
          "snippet": "static int ncp_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\tstruct ncp_entry_info *finfo)\n{\n\tstruct inode *inode;\n\tint error = -EINVAL;\n\n\tfinfo->ino = iunique(dir->i_sb, 2);\n\tinode = ncp_iget(dir->i_sb, finfo);\n\tif (!inode)\n\t\tgoto out_close;\n\td_instantiate(dentry,inode);\n\terror = 0;\nout:\n\treturn error;\n\nout_close:\n\tncp_vdbg(\"%pd2 failed, closing file\\n\", dentry);\n\tncp_close_file(NCP_SERVER(dir), finfo->file_handle);\n\tgoto out;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
            "static int ncp_unlink(struct inode *, struct dentry *);",
            "static int ncp_rmdir(struct inode *, struct dentry *);",
            "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
            "static int ncp_lookup_validate(struct dentry *, unsigned int);",
            "static int ncp_delete_dentry(const struct dentry *);",
            "static void ncp_d_prune(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int ncp_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\tstruct ncp_entry_info *finfo)\n{\n\tstruct inode *inode;\n\tint error = -EINVAL;\n\n\tfinfo->ino = iunique(dir->i_sb, 2);\n\tinode = ncp_iget(dir->i_sb, finfo);\n\tif (!inode)\n\t\tgoto out_close;\n\td_instantiate(dentry,inode);\n\terror = 0;\nout:\n\treturn error;\n\nout_close:\n\tncp_vdbg(\"%pd2 failed, closing file\\n\", dentry);\n\tncp_close_file(NCP_SERVER(dir), finfo->file_handle);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_modify_nfs_info",
          "args": [
            "server",
            "finfo.volume",
            "finfo.i.dirEntNum",
            "mode",
            "0"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_modify_nfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "680-703",
          "snippet": "int ncp_modify_nfs_info(struct ncp_server *server, __u8 volnum, __le32 dirent,\n\t\t\t       __u32 mode, __u32 rdev)\n\n{\n\tint result = 0;\n\n\tncp_init_request(server);\n\tif (server->name_space[volnum] == NW_NS_NFS) {\n\t\tncp_add_byte(server, 25);\t/* subfunction */\n\t\tncp_add_byte(server, server->name_space[volnum]);\n\t\tncp_add_byte(server, NW_NS_NFS);\n\t\tncp_add_byte(server, volnum);\n\t\tncp_add_dword(server, dirent);\n\t\t/* we must always operate on both nlinks and rdev, otherwise\n\t\t   rdev is not set */\n\t\tncp_add_dword_lh(server, NSIBM_NFS_MODE | NSIBM_NFS_NLINKS | NSIBM_NFS_RDEV);\n\t\tncp_add_dword_lh(server, mode);\n\t\tncp_add_dword_lh(server, 1);\t/* nlinks */\n\t\tncp_add_dword_lh(server, rdev);\n\t\tresult = ncp_request(server, 87);\n\t}\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_modify_nfs_info(struct ncp_server *server, __u8 volnum, __le32 dirent,\n\t\t\t       __u32 mode, __u32 rdev)\n\n{\n\tint result = 0;\n\n\tncp_init_request(server);\n\tif (server->name_space[volnum] == NW_NS_NFS) {\n\t\tncp_add_byte(server, 25);\t/* subfunction */\n\t\tncp_add_byte(server, server->name_space[volnum]);\n\t\tncp_add_byte(server, NW_NS_NFS);\n\t\tncp_add_byte(server, volnum);\n\t\tncp_add_dword(server, dirent);\n\t\t/* we must always operate on both nlinks and rdev, otherwise\n\t\t   rdev is not set */\n\t\tncp_add_dword_lh(server, NSIBM_NFS_MODE | NSIBM_NFS_NLINKS | NSIBM_NFS_RDEV);\n\t\tncp_add_dword_lh(server, mode);\n\t\tncp_add_dword_lh(server, 1);\t/* nlinks */\n\t\tncp_add_dword_lh(server, rdev);\n\t\tresult = ncp_request(server, 87);\n\t}\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_is_nfs_extras",
          "args": [
            "server",
            "finfo.volume"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_is_nfs_extras",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "119-126",
          "snippet": "static inline int ncp_is_nfs_extras(struct ncp_server* server, unsigned int volnum) {\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn (server->m.flags & NCP_MOUNT_NFS_EXTRAS) &&\n\t       (server->name_space[volnum] == NW_NS_NFS);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ncp_is_nfs_extras(struct ncp_server* server, unsigned int volnum) {\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn (server->m.flags & NCP_MOUNT_NFS_EXTRAS) &&\n\t       (server->name_space[volnum] == NW_NS_NFS);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_open_create_file_or_subdir",
          "args": [
            "server",
            "dir",
            "__name",
            "OC_MODE_CREATE",
            "aDIR",
            "cpu_to_le16(0xffff)",
            "&finfo"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_open_create_file_or_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "776-826",
          "snippet": "int ncp_open_create_file_or_subdir(struct ncp_server *server,\n\t\t\t\t   struct inode *dir, const char *name,\n\t\t\t\t   int open_create_mode,\n\t\t\t\t   __le32 create_attributes,\n\t\t\t\t   __le16 desired_acc_rights,\n\t\t\t\t   struct ncp_entry_info *target)\n{\n\t__le16 search_attribs = cpu_to_le16(0x0006);\n\t__u8  volnum;\n\t__le32 dirent;\n\tint result;\n\n\tvolnum = NCP_FINFO(dir)->volNumber;\n\tdirent = NCP_FINFO(dir)->dirEntNum;\n\n\tif ((create_attributes & aDIR) != 0) {\n\t\tsearch_attribs |= cpu_to_le16(0x8000);\n\t}\n\tncp_init_request(server);\n\tncp_add_byte(server, 1);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, open_create_mode);\n\tncp_add_word(server, search_attribs);\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_dword(server, create_attributes);\n\t/* The desired acc rights seem to be the inherited rights mask\n\t   for directories */\n\tncp_add_word(server, desired_acc_rights);\n\tncp_add_handle_path(server, volnum, dirent, 1, name);\n\n\tif ((result = ncp_request(server, 87)) != 0)\n\t\tgoto out;\n\tif (!(create_attributes & aDIR))\n\t\ttarget->opened = 1;\n\n\t/* in target there's a new finfo to fill */\n\tncp_extract_file_info(ncp_reply_data(server, 6), &(target->i));\n\ttarget->volume = target->i.volNumber;\n\tConvertToNWfromDWORD(ncp_reply_le16(server, 0),\n\t\t\t     ncp_reply_le16(server, 2),\n\t\t\t     target->file_handle);\n\t\n\tncp_unlock_server(server);\n\n\t(void)ncp_obtain_nfs_info(server, &(target->i));\n\treturn 0;\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_open_create_file_or_subdir(struct ncp_server *server,\n\t\t\t\t   struct inode *dir, const char *name,\n\t\t\t\t   int open_create_mode,\n\t\t\t\t   __le32 create_attributes,\n\t\t\t\t   __le16 desired_acc_rights,\n\t\t\t\t   struct ncp_entry_info *target)\n{\n\t__le16 search_attribs = cpu_to_le16(0x0006);\n\t__u8  volnum;\n\t__le32 dirent;\n\tint result;\n\n\tvolnum = NCP_FINFO(dir)->volNumber;\n\tdirent = NCP_FINFO(dir)->dirEntNum;\n\n\tif ((create_attributes & aDIR) != 0) {\n\t\tsearch_attribs |= cpu_to_le16(0x8000);\n\t}\n\tncp_init_request(server);\n\tncp_add_byte(server, 1);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, open_create_mode);\n\tncp_add_word(server, search_attribs);\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_dword(server, create_attributes);\n\t/* The desired acc rights seem to be the inherited rights mask\n\t   for directories */\n\tncp_add_word(server, desired_acc_rights);\n\tncp_add_handle_path(server, volnum, dirent, 1, name);\n\n\tif ((result = ncp_request(server, 87)) != 0)\n\t\tgoto out;\n\tif (!(create_attributes & aDIR))\n\t\ttarget->opened = 1;\n\n\t/* in target there's a new finfo to fill */\n\tncp_extract_file_info(ncp_reply_data(server, 6), &(target->i));\n\ttarget->volume = target->i.volNumber;\n\tConvertToNWfromDWORD(ncp_reply_le16(server, 0),\n\t\t\t     ncp_reply_le16(server, 2),\n\t\t\t     target->file_handle);\n\t\n\tncp_unlock_server(server);\n\n\t(void)ncp_obtain_nfs_info(server, &(target->i));\n\treturn 0;\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0xffff"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_io2vol",
          "args": [
            "server",
            "__name",
            "&len",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "!ncp_preserve_case(dir)"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_preserve_case",
          "args": [
            "dir"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_age_dentry",
          "args": [
            "server",
            "dentry"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_age_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "175-179",
          "snippet": "static inline void\nncp_age_dentry(struct ncp_server* server, struct dentry* dentry)\n{\n\tdentry->d_time = jiffies - NCP_MAX_AGE(server);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void\nncp_age_dentry(struct ncp_server* server, struct dentry* dentry)\n{\n\tdentry->d_time = jiffies - NCP_MAX_AGE(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"making %pd2\\n\"",
            "dentry"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_create(struct inode *, struct dentry *, umode_t, bool);\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_mkdir(struct inode *, struct dentry *, umode_t);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int ncp_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct ncp_entry_info finfo;\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tint error, len;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tncp_dbg(1, \"making %pd2\\n\", dentry);\n\n\tncp_age_dentry(server, dentry);\n\tlen = sizeof(__name);\n\terror = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t   dentry->d_name.len, !ncp_preserve_case(dir));\n\tif (error)\n\t\tgoto out;\n\n\terror = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\t\t   OC_MODE_CREATE, aDIR,\n\t\t\t\t\t   cpu_to_le16(0xffff),\n\t\t\t\t\t   &finfo);\n\tif (error == 0) {\n\t\tif (ncp_is_nfs_extras(server, finfo.volume)) {\n\t\t\tmode |= S_IFDIR;\n\t\t\tfinfo.i.nfs.mode = mode;\n\t\t\tif (ncp_modify_nfs_info(server,\n\t\t\t\t\t\tfinfo.volume,\n\t\t\t\t\t\tfinfo.i.dirEntNum,\n\t\t\t\t\t\tmode, 0) != 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\terror = ncp_instantiate(dir, dentry, &finfo);\n\t} else if (error > 0) {\n\t\terror = -EACCES;\n\t}\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "ncp_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "968-972",
    "snippet": "static int ncp_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool excl)\n{\n\treturn ncp_create_new(dir, dentry, mode, 0, 0);\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ncp_create(struct inode *, struct dentry *, umode_t, bool);",
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_mkdir(struct inode *, struct dentry *, umode_t);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_create_new",
          "args": [
            "dir",
            "dentry",
            "mode",
            "0",
            "0"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_create_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "910-966",
          "snippet": "int ncp_create_new(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t   dev_t rdev, __le32 attributes)\n{\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct ncp_entry_info finfo;\n\tint error, result, len;\n\tint opmode;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\t\n\tncp_vdbg(\"creating %pd2, mode=%hx\\n\", dentry, mode);\n\n\tncp_age_dentry(server, dentry);\n\tlen = sizeof(__name);\n\terror = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t   dentry->d_name.len, !ncp_preserve_case(dir));\n\tif (error)\n\t\tgoto out;\n\n\terror = -EACCES;\n\t\n\tif (S_ISREG(mode) && \n\t    (server->m.flags & NCP_MOUNT_EXTRAS) && \n\t    (mode & S_IXUGO))\n\t\tattributes |= aSYSTEM | aSHARED;\n\t\n\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_READ | AR_WRITE, &finfo);\n\topmode = O_RDWR;\n\tif (result) {\n\t\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_WRITE, &finfo);\n\t\tif (result) {\n\t\t\tif (result == 0x87)\n\t\t\t\terror = -ENAMETOOLONG;\n\t\t\telse if (result < 0)\n\t\t\t\terror = result;\n\t\t\tncp_dbg(1, \"%pd2 failed\\n\", dentry);\n\t\t\tgoto out;\n\t\t}\n\t\topmode = O_WRONLY;\n\t}\n\tfinfo.access = opmode;\n\tif (ncp_is_nfs_extras(server, finfo.volume)) {\n\t\tfinfo.i.nfs.mode = mode;\n\t\tfinfo.i.nfs.rdev = new_encode_dev(rdev);\n\t\tif (ncp_modify_nfs_info(server, finfo.volume,\n\t\t\t\t\tfinfo.i.dirEntNum,\n\t\t\t\t\tmode, new_encode_dev(rdev)) != 0)\n\t\t\tgoto out;\n\t}\n\n\terror = ncp_instantiate(dir, dentry, &finfo);\nout:\n\treturn error;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ncp_create(struct inode *, struct dentry *, umode_t, bool);",
            "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
            "static int ncp_unlink(struct inode *, struct dentry *);",
            "static int ncp_mkdir(struct inode *, struct dentry *, umode_t);",
            "static int ncp_rmdir(struct inode *, struct dentry *);",
            "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
            "static int ncp_mknod(struct inode * dir, struct dentry *dentry,\n\t\t     umode_t mode, dev_t rdev);",
            "static int ncp_lookup_validate(struct dentry *, unsigned int);",
            "static int ncp_delete_dentry(const struct dentry *);",
            "static void ncp_d_prune(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_create(struct inode *, struct dentry *, umode_t, bool);\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_mkdir(struct inode *, struct dentry *, umode_t);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_mknod(struct inode * dir, struct dentry *dentry,\n\t\t     umode_t mode, dev_t rdev);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nint ncp_create_new(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t   dev_t rdev, __le32 attributes)\n{\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct ncp_entry_info finfo;\n\tint error, result, len;\n\tint opmode;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\t\n\tncp_vdbg(\"creating %pd2, mode=%hx\\n\", dentry, mode);\n\n\tncp_age_dentry(server, dentry);\n\tlen = sizeof(__name);\n\terror = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t   dentry->d_name.len, !ncp_preserve_case(dir));\n\tif (error)\n\t\tgoto out;\n\n\terror = -EACCES;\n\t\n\tif (S_ISREG(mode) && \n\t    (server->m.flags & NCP_MOUNT_EXTRAS) && \n\t    (mode & S_IXUGO))\n\t\tattributes |= aSYSTEM | aSHARED;\n\t\n\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_READ | AR_WRITE, &finfo);\n\topmode = O_RDWR;\n\tif (result) {\n\t\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_WRITE, &finfo);\n\t\tif (result) {\n\t\t\tif (result == 0x87)\n\t\t\t\terror = -ENAMETOOLONG;\n\t\t\telse if (result < 0)\n\t\t\t\terror = result;\n\t\t\tncp_dbg(1, \"%pd2 failed\\n\", dentry);\n\t\t\tgoto out;\n\t\t}\n\t\topmode = O_WRONLY;\n\t}\n\tfinfo.access = opmode;\n\tif (ncp_is_nfs_extras(server, finfo.volume)) {\n\t\tfinfo.i.nfs.mode = mode;\n\t\tfinfo.i.nfs.rdev = new_encode_dev(rdev);\n\t\tif (ncp_modify_nfs_info(server, finfo.volume,\n\t\t\t\t\tfinfo.i.dirEntNum,\n\t\t\t\t\tmode, new_encode_dev(rdev)) != 0)\n\t\t\tgoto out;\n\t}\n\n\terror = ncp_instantiate(dir, dentry, &finfo);\nout:\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_create(struct inode *, struct dentry *, umode_t, bool);\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_mkdir(struct inode *, struct dentry *, umode_t);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int ncp_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\tbool excl)\n{\n\treturn ncp_create_new(dir, dentry, mode, 0, 0);\n}"
  },
  {
    "function_name": "ncp_create_new",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "910-966",
    "snippet": "int ncp_create_new(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t   dev_t rdev, __le32 attributes)\n{\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct ncp_entry_info finfo;\n\tint error, result, len;\n\tint opmode;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\t\n\tncp_vdbg(\"creating %pd2, mode=%hx\\n\", dentry, mode);\n\n\tncp_age_dentry(server, dentry);\n\tlen = sizeof(__name);\n\terror = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t   dentry->d_name.len, !ncp_preserve_case(dir));\n\tif (error)\n\t\tgoto out;\n\n\terror = -EACCES;\n\t\n\tif (S_ISREG(mode) && \n\t    (server->m.flags & NCP_MOUNT_EXTRAS) && \n\t    (mode & S_IXUGO))\n\t\tattributes |= aSYSTEM | aSHARED;\n\t\n\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_READ | AR_WRITE, &finfo);\n\topmode = O_RDWR;\n\tif (result) {\n\t\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_WRITE, &finfo);\n\t\tif (result) {\n\t\t\tif (result == 0x87)\n\t\t\t\terror = -ENAMETOOLONG;\n\t\t\telse if (result < 0)\n\t\t\t\terror = result;\n\t\t\tncp_dbg(1, \"%pd2 failed\\n\", dentry);\n\t\t\tgoto out;\n\t\t}\n\t\topmode = O_WRONLY;\n\t}\n\tfinfo.access = opmode;\n\tif (ncp_is_nfs_extras(server, finfo.volume)) {\n\t\tfinfo.i.nfs.mode = mode;\n\t\tfinfo.i.nfs.rdev = new_encode_dev(rdev);\n\t\tif (ncp_modify_nfs_info(server, finfo.volume,\n\t\t\t\t\tfinfo.i.dirEntNum,\n\t\t\t\t\tmode, new_encode_dev(rdev)) != 0)\n\t\t\tgoto out;\n\t}\n\n\terror = ncp_instantiate(dir, dentry, &finfo);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ncp_create(struct inode *, struct dentry *, umode_t, bool);",
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_mkdir(struct inode *, struct dentry *, umode_t);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_mknod(struct inode * dir, struct dentry *dentry,\n\t\t     umode_t mode, dev_t rdev);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_instantiate",
          "args": [
            "dir",
            "dentry",
            "&finfo"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "889-908",
          "snippet": "static int ncp_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\tstruct ncp_entry_info *finfo)\n{\n\tstruct inode *inode;\n\tint error = -EINVAL;\n\n\tfinfo->ino = iunique(dir->i_sb, 2);\n\tinode = ncp_iget(dir->i_sb, finfo);\n\tif (!inode)\n\t\tgoto out_close;\n\td_instantiate(dentry,inode);\n\terror = 0;\nout:\n\treturn error;\n\nout_close:\n\tncp_vdbg(\"%pd2 failed, closing file\\n\", dentry);\n\tncp_close_file(NCP_SERVER(dir), finfo->file_handle);\n\tgoto out;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
            "static int ncp_unlink(struct inode *, struct dentry *);",
            "static int ncp_rmdir(struct inode *, struct dentry *);",
            "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
            "static int ncp_lookup_validate(struct dentry *, unsigned int);",
            "static int ncp_delete_dentry(const struct dentry *);",
            "static void ncp_d_prune(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int ncp_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\tstruct ncp_entry_info *finfo)\n{\n\tstruct inode *inode;\n\tint error = -EINVAL;\n\n\tfinfo->ino = iunique(dir->i_sb, 2);\n\tinode = ncp_iget(dir->i_sb, finfo);\n\tif (!inode)\n\t\tgoto out_close;\n\td_instantiate(dentry,inode);\n\terror = 0;\nout:\n\treturn error;\n\nout_close:\n\tncp_vdbg(\"%pd2 failed, closing file\\n\", dentry);\n\tncp_close_file(NCP_SERVER(dir), finfo->file_handle);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_modify_nfs_info",
          "args": [
            "server",
            "finfo.volume",
            "finfo.i.dirEntNum",
            "mode",
            "new_encode_dev(rdev)"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_modify_nfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "680-703",
          "snippet": "int ncp_modify_nfs_info(struct ncp_server *server, __u8 volnum, __le32 dirent,\n\t\t\t       __u32 mode, __u32 rdev)\n\n{\n\tint result = 0;\n\n\tncp_init_request(server);\n\tif (server->name_space[volnum] == NW_NS_NFS) {\n\t\tncp_add_byte(server, 25);\t/* subfunction */\n\t\tncp_add_byte(server, server->name_space[volnum]);\n\t\tncp_add_byte(server, NW_NS_NFS);\n\t\tncp_add_byte(server, volnum);\n\t\tncp_add_dword(server, dirent);\n\t\t/* we must always operate on both nlinks and rdev, otherwise\n\t\t   rdev is not set */\n\t\tncp_add_dword_lh(server, NSIBM_NFS_MODE | NSIBM_NFS_NLINKS | NSIBM_NFS_RDEV);\n\t\tncp_add_dword_lh(server, mode);\n\t\tncp_add_dword_lh(server, 1);\t/* nlinks */\n\t\tncp_add_dword_lh(server, rdev);\n\t\tresult = ncp_request(server, 87);\n\t}\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_modify_nfs_info(struct ncp_server *server, __u8 volnum, __le32 dirent,\n\t\t\t       __u32 mode, __u32 rdev)\n\n{\n\tint result = 0;\n\n\tncp_init_request(server);\n\tif (server->name_space[volnum] == NW_NS_NFS) {\n\t\tncp_add_byte(server, 25);\t/* subfunction */\n\t\tncp_add_byte(server, server->name_space[volnum]);\n\t\tncp_add_byte(server, NW_NS_NFS);\n\t\tncp_add_byte(server, volnum);\n\t\tncp_add_dword(server, dirent);\n\t\t/* we must always operate on both nlinks and rdev, otherwise\n\t\t   rdev is not set */\n\t\tncp_add_dword_lh(server, NSIBM_NFS_MODE | NSIBM_NFS_NLINKS | NSIBM_NFS_RDEV);\n\t\tncp_add_dword_lh(server, mode);\n\t\tncp_add_dword_lh(server, 1);\t/* nlinks */\n\t\tncp_add_dword_lh(server, rdev);\n\t\tresult = ncp_request(server, 87);\n\t}\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "rdev"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_encode_dev",
          "args": [
            "rdev"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_is_nfs_extras",
          "args": [
            "server",
            "finfo.volume"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_is_nfs_extras",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "119-126",
          "snippet": "static inline int ncp_is_nfs_extras(struct ncp_server* server, unsigned int volnum) {\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn (server->m.flags & NCP_MOUNT_NFS_EXTRAS) &&\n\t       (server->name_space[volnum] == NW_NS_NFS);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ncp_is_nfs_extras(struct ncp_server* server, unsigned int volnum) {\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn (server->m.flags & NCP_MOUNT_NFS_EXTRAS) &&\n\t       (server->name_space[volnum] == NW_NS_NFS);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"%pd2 failed\\n\"",
            "dentry"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_open_create_file_or_subdir",
          "args": [
            "server",
            "dir",
            "__name",
            "OC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE",
            "attributes",
            "AR_WRITE",
            "&finfo"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_open_create_file_or_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "776-826",
          "snippet": "int ncp_open_create_file_or_subdir(struct ncp_server *server,\n\t\t\t\t   struct inode *dir, const char *name,\n\t\t\t\t   int open_create_mode,\n\t\t\t\t   __le32 create_attributes,\n\t\t\t\t   __le16 desired_acc_rights,\n\t\t\t\t   struct ncp_entry_info *target)\n{\n\t__le16 search_attribs = cpu_to_le16(0x0006);\n\t__u8  volnum;\n\t__le32 dirent;\n\tint result;\n\n\tvolnum = NCP_FINFO(dir)->volNumber;\n\tdirent = NCP_FINFO(dir)->dirEntNum;\n\n\tif ((create_attributes & aDIR) != 0) {\n\t\tsearch_attribs |= cpu_to_le16(0x8000);\n\t}\n\tncp_init_request(server);\n\tncp_add_byte(server, 1);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, open_create_mode);\n\tncp_add_word(server, search_attribs);\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_dword(server, create_attributes);\n\t/* The desired acc rights seem to be the inherited rights mask\n\t   for directories */\n\tncp_add_word(server, desired_acc_rights);\n\tncp_add_handle_path(server, volnum, dirent, 1, name);\n\n\tif ((result = ncp_request(server, 87)) != 0)\n\t\tgoto out;\n\tif (!(create_attributes & aDIR))\n\t\ttarget->opened = 1;\n\n\t/* in target there's a new finfo to fill */\n\tncp_extract_file_info(ncp_reply_data(server, 6), &(target->i));\n\ttarget->volume = target->i.volNumber;\n\tConvertToNWfromDWORD(ncp_reply_le16(server, 0),\n\t\t\t     ncp_reply_le16(server, 2),\n\t\t\t     target->file_handle);\n\t\n\tncp_unlock_server(server);\n\n\t(void)ncp_obtain_nfs_info(server, &(target->i));\n\treturn 0;\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_open_create_file_or_subdir(struct ncp_server *server,\n\t\t\t\t   struct inode *dir, const char *name,\n\t\t\t\t   int open_create_mode,\n\t\t\t\t   __le32 create_attributes,\n\t\t\t\t   __le16 desired_acc_rights,\n\t\t\t\t   struct ncp_entry_info *target)\n{\n\t__le16 search_attribs = cpu_to_le16(0x0006);\n\t__u8  volnum;\n\t__le32 dirent;\n\tint result;\n\n\tvolnum = NCP_FINFO(dir)->volNumber;\n\tdirent = NCP_FINFO(dir)->dirEntNum;\n\n\tif ((create_attributes & aDIR) != 0) {\n\t\tsearch_attribs |= cpu_to_le16(0x8000);\n\t}\n\tncp_init_request(server);\n\tncp_add_byte(server, 1);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, open_create_mode);\n\tncp_add_word(server, search_attribs);\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_dword(server, create_attributes);\n\t/* The desired acc rights seem to be the inherited rights mask\n\t   for directories */\n\tncp_add_word(server, desired_acc_rights);\n\tncp_add_handle_path(server, volnum, dirent, 1, name);\n\n\tif ((result = ncp_request(server, 87)) != 0)\n\t\tgoto out;\n\tif (!(create_attributes & aDIR))\n\t\ttarget->opened = 1;\n\n\t/* in target there's a new finfo to fill */\n\tncp_extract_file_info(ncp_reply_data(server, 6), &(target->i));\n\ttarget->volume = target->i.volNumber;\n\tConvertToNWfromDWORD(ncp_reply_le16(server, 0),\n\t\t\t     ncp_reply_le16(server, 2),\n\t\t\t     target->file_handle);\n\t\n\tncp_unlock_server(server);\n\n\t(void)ncp_obtain_nfs_info(server, &(target->i));\n\treturn 0;\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_io2vol",
          "args": [
            "server",
            "__name",
            "&len",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "!ncp_preserve_case(dir)"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_preserve_case",
          "args": [
            "dir"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_age_dentry",
          "args": [
            "server",
            "dentry"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_age_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "175-179",
          "snippet": "static inline void\nncp_age_dentry(struct ncp_server* server, struct dentry* dentry)\n{\n\tdentry->d_time = jiffies - NCP_MAX_AGE(server);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void\nncp_age_dentry(struct ncp_server* server, struct dentry* dentry)\n{\n\tdentry->d_time = jiffies - NCP_MAX_AGE(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_vdbg",
          "args": [
            "\"creating %pd2, mode=%hx\\n\"",
            "dentry",
            "mode"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int ncp_create(struct inode *, struct dentry *, umode_t, bool);\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_mkdir(struct inode *, struct dentry *, umode_t);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_mknod(struct inode * dir, struct dentry *dentry,\n\t\t     umode_t mode, dev_t rdev);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nint ncp_create_new(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t   dev_t rdev, __le32 attributes)\n{\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct ncp_entry_info finfo;\n\tint error, result, len;\n\tint opmode;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\t\n\tncp_vdbg(\"creating %pd2, mode=%hx\\n\", dentry, mode);\n\n\tncp_age_dentry(server, dentry);\n\tlen = sizeof(__name);\n\terror = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t   dentry->d_name.len, !ncp_preserve_case(dir));\n\tif (error)\n\t\tgoto out;\n\n\terror = -EACCES;\n\t\n\tif (S_ISREG(mode) && \n\t    (server->m.flags & NCP_MOUNT_EXTRAS) && \n\t    (mode & S_IXUGO))\n\t\tattributes |= aSYSTEM | aSHARED;\n\t\n\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_READ | AR_WRITE, &finfo);\n\topmode = O_RDWR;\n\tif (result) {\n\t\tresult = ncp_open_create_file_or_subdir(server, dir, __name,\n\t\t\t\tOC_MODE_CREATE | OC_MODE_OPEN | OC_MODE_REPLACE,\n\t\t\t\tattributes, AR_WRITE, &finfo);\n\t\tif (result) {\n\t\t\tif (result == 0x87)\n\t\t\t\terror = -ENAMETOOLONG;\n\t\t\telse if (result < 0)\n\t\t\t\terror = result;\n\t\t\tncp_dbg(1, \"%pd2 failed\\n\", dentry);\n\t\t\tgoto out;\n\t\t}\n\t\topmode = O_WRONLY;\n\t}\n\tfinfo.access = opmode;\n\tif (ncp_is_nfs_extras(server, finfo.volume)) {\n\t\tfinfo.i.nfs.mode = mode;\n\t\tfinfo.i.nfs.rdev = new_encode_dev(rdev);\n\t\tif (ncp_modify_nfs_info(server, finfo.volume,\n\t\t\t\t\tfinfo.i.dirEntNum,\n\t\t\t\t\tmode, new_encode_dev(rdev)) != 0)\n\t\t\tgoto out;\n\t}\n\n\terror = ncp_instantiate(dir, dentry, &finfo);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "ncp_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "889-908",
    "snippet": "static int ncp_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\tstruct ncp_entry_info *finfo)\n{\n\tstruct inode *inode;\n\tint error = -EINVAL;\n\n\tfinfo->ino = iunique(dir->i_sb, 2);\n\tinode = ncp_iget(dir->i_sb, finfo);\n\tif (!inode)\n\t\tgoto out_close;\n\td_instantiate(dentry,inode);\n\terror = 0;\nout:\n\treturn error;\n\nout_close:\n\tncp_vdbg(\"%pd2 failed, closing file\\n\", dentry);\n\tncp_close_file(NCP_SERVER(dir), finfo->file_handle);\n\tgoto out;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_close_file",
          "args": [
            "NCP_SERVER(dir)",
            "finfo->file_handle"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_close_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "272-284",
          "snippet": "int\nncp_close_file(struct ncp_server *server, const char *file_id)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\n\tresult = ncp_request(server, 66);\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_close_file(struct ncp_server *server, const char *file_id)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 0);\n\tncp_add_mem(server, file_id, 6);\n\n\tresult = ncp_request(server, 66);\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_vdbg",
          "args": [
            "\"%pd2 failed, closing file\\n\"",
            "dentry"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_iget",
          "args": [
            "dir->i_sb",
            "finfo"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "256-295",
          "snippet": "struct inode * \nncp_iget(struct super_block *sb, struct ncp_entry_info *info)\n{\n\tstruct inode *inode;\n\n\tif (info == NULL) {\n\t\tpr_err(\"%s: info is NULL\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, info->opened);\n\n\t\tinode->i_ino = info->ino;\n\t\tncp_set_attr(inode, info);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_file_inode_operations;\n\t\t\tinode->i_fop = &ncp_file_operations;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_dir_inode_operations;\n\t\t\tinode->i_fop = &ncp_dir_operations;\n#ifdef CONFIG_NCPFS_NFS_NS\n\t\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) || S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tnew_decode_dev(info->i.nfs.rdev));\n#endif\n#if defined(CONFIG_NCPFS_EXTRAS) || defined(CONFIG_NCPFS_NFS_NS)\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &ncp_symlink_aops;\n#endif\n\t\t} else {\n\t\t\tmake_bad_inode(inode);\n\t\t}\n\t\tinsert_inode_hash(inode);\n\t} else\n\t\tpr_err(\"%s: iget failed!\\n\", __func__);\n\treturn inode;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);",
            "static void ncp_put_super(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\nstatic void ncp_put_super(struct super_block *);\n\nstruct inode * \nncp_iget(struct super_block *sb, struct ncp_entry_info *info)\n{\n\tstruct inode *inode;\n\n\tif (info == NULL) {\n\t\tpr_err(\"%s: info is NULL\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, info->opened);\n\n\t\tinode->i_ino = info->ino;\n\t\tncp_set_attr(inode, info);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_file_inode_operations;\n\t\t\tinode->i_fop = &ncp_file_operations;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_dir_inode_operations;\n\t\t\tinode->i_fop = &ncp_dir_operations;\n#ifdef CONFIG_NCPFS_NFS_NS\n\t\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) || S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tnew_decode_dev(info->i.nfs.rdev));\n#endif\n#if defined(CONFIG_NCPFS_EXTRAS) || defined(CONFIG_NCPFS_NFS_NS)\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &ncp_symlink_aops;\n#endif\n\t\t} else {\n\t\t\tmake_bad_inode(inode);\n\t\t}\n\t\tinsert_inode_hash(inode);\n\t} else\n\t\tpr_err(\"%s: iget failed!\\n\", __func__);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iunique",
          "args": [
            "dir->i_sb",
            "2"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1150-1170",
          "snippet": "ino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int ncp_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\tstruct ncp_entry_info *finfo)\n{\n\tstruct inode *inode;\n\tint error = -EINVAL;\n\n\tfinfo->ino = iunique(dir->i_sb, 2);\n\tinode = ncp_iget(dir->i_sb, finfo);\n\tif (!inode)\n\t\tgoto out_close;\n\td_instantiate(dentry,inode);\n\terror = 0;\nout:\n\treturn error;\n\nout_close:\n\tncp_vdbg(\"%pd2 failed, closing file\\n\", dentry);\n\tncp_close_file(NCP_SERVER(dir), finfo->file_handle);\n\tgoto out;\n}"
  },
  {
    "function_name": "ncp_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "830-884",
    "snippet": "static struct dentry *ncp_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct inode *inode = NULL;\n\tstruct ncp_entry_info finfo;\n\tint error, res, len;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\terror = -EIO;\n\tif (!ncp_conn_valid(server))\n\t\tgoto finished;\n\n\tncp_vdbg(\"server lookup for %pd2\\n\", dentry);\n\n\tlen = sizeof(__name);\n\tif (ncp_is_server_root(dir)) {\n\t\tres = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t\t dentry->d_name.len, 1);\n\t\tif (!res)\n\t\t\tres = ncp_lookup_volume(server, __name, &(finfo.i));\n\t\tif (!res)\n\t\t\tncp_update_known_namespace(server, finfo.i.volNumber, NULL);\n\t} else {\n\t\tres = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t\t dentry->d_name.len, !ncp_preserve_case(dir));\n\t\tif (!res)\n\t\t\tres = ncp_obtain_info(server, dir, __name, &(finfo.i));\n\t}\n\tncp_vdbg(\"looked for %pd2, res=%d\\n\", dentry, res);\n\t/*\n\t * If we didn't find an entry, make a negative dentry.\n\t */\n\tif (res)\n\t\tgoto add_entry;\n\n\t/*\n\t * Create an inode for the entry.\n\t */\n\tfinfo.opened = 0;\n\tfinfo.ino = iunique(dir->i_sb, 2);\n\tfinfo.volume = finfo.i.volNumber;\n\terror = -EACCES;\n\tinode = ncp_iget(dir->i_sb, &finfo);\n\n\tif (inode) {\n\t\tncp_new_dentry(dentry);\nadd_entry:\n\t\td_add(dentry, inode);\n\t\terror = 0;\n\t}\n\nfinished:\n\tncp_vdbg(\"result=%d\\n\", error);\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_vdbg",
          "args": [
            "\"result=%d\\n\"",
            "error"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_new_dentry",
          "args": [
            "dentry"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_new_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "181-185",
          "snippet": "static inline void\nncp_new_dentry(struct dentry* dentry)\n{\n\tdentry->d_time = jiffies;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void\nncp_new_dentry(struct dentry* dentry)\n{\n\tdentry->d_time = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_iget",
          "args": [
            "dir->i_sb",
            "&finfo"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "256-295",
          "snippet": "struct inode * \nncp_iget(struct super_block *sb, struct ncp_entry_info *info)\n{\n\tstruct inode *inode;\n\n\tif (info == NULL) {\n\t\tpr_err(\"%s: info is NULL\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, info->opened);\n\n\t\tinode->i_ino = info->ino;\n\t\tncp_set_attr(inode, info);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_file_inode_operations;\n\t\t\tinode->i_fop = &ncp_file_operations;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_dir_inode_operations;\n\t\t\tinode->i_fop = &ncp_dir_operations;\n#ifdef CONFIG_NCPFS_NFS_NS\n\t\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) || S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tnew_decode_dev(info->i.nfs.rdev));\n#endif\n#if defined(CONFIG_NCPFS_EXTRAS) || defined(CONFIG_NCPFS_NFS_NS)\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &ncp_symlink_aops;\n#endif\n\t\t} else {\n\t\t\tmake_bad_inode(inode);\n\t\t}\n\t\tinsert_inode_hash(inode);\n\t} else\n\t\tpr_err(\"%s: iget failed!\\n\", __func__);\n\treturn inode;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);",
            "static void ncp_put_super(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\nstatic void ncp_put_super(struct super_block *);\n\nstruct inode * \nncp_iget(struct super_block *sb, struct ncp_entry_info *info)\n{\n\tstruct inode *inode;\n\n\tif (info == NULL) {\n\t\tpr_err(\"%s: info is NULL\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, info->opened);\n\n\t\tinode->i_ino = info->ino;\n\t\tncp_set_attr(inode, info);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_file_inode_operations;\n\t\t\tinode->i_fop = &ncp_file_operations;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_dir_inode_operations;\n\t\t\tinode->i_fop = &ncp_dir_operations;\n#ifdef CONFIG_NCPFS_NFS_NS\n\t\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) || S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tnew_decode_dev(info->i.nfs.rdev));\n#endif\n#if defined(CONFIG_NCPFS_EXTRAS) || defined(CONFIG_NCPFS_NFS_NS)\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &ncp_symlink_aops;\n#endif\n\t\t} else {\n\t\t\tmake_bad_inode(inode);\n\t\t}\n\t\tinsert_inode_hash(inode);\n\t} else\n\t\tpr_err(\"%s: iget failed!\\n\", __func__);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iunique",
          "args": [
            "dir->i_sb",
            "2"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1150-1170",
          "snippet": "ino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_vdbg",
          "args": [
            "\"looked for %pd2, res=%d\\n\"",
            "dentry",
            "res"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_obtain_info",
          "args": [
            "server",
            "dir",
            "__name",
            "&(finfo.i)"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_obtain_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "419-449",
          "snippet": "int ncp_obtain_info(struct ncp_server *server, struct inode *dir, const char *path,\n\t\t\tstruct nw_info_struct *target)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint result;\n\n\tif (target == NULL) {\n\t\tpr_err(\"%s: invalid call\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tncp_init_request(server);\n\tncp_add_byte(server, 6);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, server->name_space[volnum]); /* N.B. twice ?? */\n\tncp_add_word(server, cpu_to_le16(0x8006));\t/* get all */\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_handle_path(server, volnum, dirent, 1, path);\n\n\tif ((result = ncp_request(server, 87)) != 0)\n\t\tgoto out;\n\tncp_extract_file_info(ncp_reply_data(server, 0), target);\n\tncp_unlock_server(server);\n\t\n\tresult = ncp_obtain_nfs_info(server, target);\n\treturn result;\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_obtain_info(struct ncp_server *server, struct inode *dir, const char *path,\n\t\t\tstruct nw_info_struct *target)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint result;\n\n\tif (target == NULL) {\n\t\tpr_err(\"%s: invalid call\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tncp_init_request(server);\n\tncp_add_byte(server, 6);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, server->name_space[volnum]); /* N.B. twice ?? */\n\tncp_add_word(server, cpu_to_le16(0x8006));\t/* get all */\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_handle_path(server, volnum, dirent, 1, path);\n\n\tif ((result = ncp_request(server, 87)) != 0)\n\t\tgoto out;\n\tncp_extract_file_info(ncp_reply_data(server, 0), target);\n\tncp_unlock_server(server);\n\t\n\tresult = ncp_obtain_nfs_info(server, target);\n\treturn result;\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_io2vol",
          "args": [
            "server",
            "__name",
            "&len",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "!ncp_preserve_case(dir)"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_preserve_case",
          "args": [
            "dir"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_update_known_namespace",
          "args": [
            "server",
            "finfo.i.volNumber",
            "NULL"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_known_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "525-539",
          "snippet": "int\nncp_update_known_namespace(struct ncp_server *server, __u8 volume, int *ret_ns)\n{\n\tint ns = ncp_get_known_namespace(server, volume);\n\n\tif (ret_ns)\n\t\t*ret_ns = ns;\n\n\tncp_dbg(1, \"namespace[%d] = %d\\n\", volume, server->name_space[volume]);\n\n\tif (server->name_space[volume] == ns)\n\t\treturn 0;\n\tserver->name_space[volume] = ns;\n\treturn 1;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_update_known_namespace(struct ncp_server *server, __u8 volume, int *ret_ns)\n{\n\tint ns = ncp_get_known_namespace(server, volume);\n\n\tif (ret_ns)\n\t\t*ret_ns = ns;\n\n\tncp_dbg(1, \"namespace[%d] = %d\\n\", volume, server->name_space[volume]);\n\n\tif (server->name_space[volume] == ns)\n\t\treturn 0;\n\tserver->name_space[volume] = ns;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_lookup_volume",
          "args": [
            "server",
            "__name",
            "&(finfo.i)"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_lookup_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "622-643",
          "snippet": "int\nncp_lookup_volume(struct ncp_server *server,\n\t\t  const char *volname, struct nw_info_struct *target)\n{\n\tint result;\n\n\tmemset(target, 0, sizeof(*target));\n\tresult = ncp_get_volume_root(server, volname,\n\t\t\t&target->volNumber, &target->dirEntNum, &target->DosDirNum);\n\tif (result) {\n\t\treturn result;\n\t}\n\tncp_update_known_namespace(server, target->volNumber, NULL);\n\ttarget->nameLen = strlen(volname);\n\tmemcpy(target->entryName, volname, target->nameLen+1);\n\ttarget->attributes = aDIR;\n\t/* set dates to Jan 1, 1986  00:00 */\n\ttarget->creationTime = target->modifyTime = cpu_to_le16(0x0000);\n\ttarget->creationDate = target->modifyDate = target->lastAccessDate = cpu_to_le16(0x0C21);\n\ttarget->nfs.mode = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_lookup_volume(struct ncp_server *server,\n\t\t  const char *volname, struct nw_info_struct *target)\n{\n\tint result;\n\n\tmemset(target, 0, sizeof(*target));\n\tresult = ncp_get_volume_root(server, volname,\n\t\t\t&target->volNumber, &target->dirEntNum, &target->DosDirNum);\n\tif (result) {\n\t\treturn result;\n\t}\n\tncp_update_known_namespace(server, target->volNumber, NULL);\n\ttarget->nameLen = strlen(volname);\n\tmemcpy(target->entryName, volname, target->nameLen+1);\n\ttarget->attributes = aDIR;\n\t/* set dates to Jan 1, 1986  00:00 */\n\ttarget->creationTime = target->modifyTime = cpu_to_le16(0x0000);\n\ttarget->creationDate = target->modifyDate = target->lastAccessDate = cpu_to_le16(0x0C21);\n\ttarget->nfs.mode = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_io2vol",
          "args": [
            "server",
            "__name",
            "&len",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "1"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_is_server_root",
          "args": [
            "dir"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_is_server_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "201-205",
          "snippet": "static inline int ncp_is_server_root(struct inode *inode)\n{\n\treturn !ncp_single_volume(NCP_SERVER(inode)) &&\n\t\tis_root_inode(inode);\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int ncp_is_server_root(struct inode *inode)\n{\n\treturn !ncp_single_volume(NCP_SERVER(inode)) &&\n\t\tis_root_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_vdbg",
          "args": [
            "\"server lookup for %pd2\\n\"",
            "dentry"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_conn_valid",
          "args": [
            "server"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_conn_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs_sb.h",
          "lines": "164-167",
          "snippet": "static inline int ncp_conn_valid(struct ncp_server *server)\n{\n\treturn ((server->conn_status & 0x11) == 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/net.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/net.h>\n#include <linux/ncp_mount.h>\n#include <linux/types.h>\n\nstatic inline int ncp_conn_valid(struct ncp_server *server)\n{\n\treturn ((server->conn_status & 0x11) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic struct dentry *ncp_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct inode *inode = NULL;\n\tstruct ncp_entry_info finfo;\n\tint error, res, len;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\terror = -EIO;\n\tif (!ncp_conn_valid(server))\n\t\tgoto finished;\n\n\tncp_vdbg(\"server lookup for %pd2\\n\", dentry);\n\n\tlen = sizeof(__name);\n\tif (ncp_is_server_root(dir)) {\n\t\tres = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t\t dentry->d_name.len, 1);\n\t\tif (!res)\n\t\t\tres = ncp_lookup_volume(server, __name, &(finfo.i));\n\t\tif (!res)\n\t\t\tncp_update_known_namespace(server, finfo.i.volNumber, NULL);\n\t} else {\n\t\tres = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t\t dentry->d_name.len, !ncp_preserve_case(dir));\n\t\tif (!res)\n\t\t\tres = ncp_obtain_info(server, dir, __name, &(finfo.i));\n\t}\n\tncp_vdbg(\"looked for %pd2, res=%d\\n\", dentry, res);\n\t/*\n\t * If we didn't find an entry, make a negative dentry.\n\t */\n\tif (res)\n\t\tgoto add_entry;\n\n\t/*\n\t * Create an inode for the entry.\n\t */\n\tfinfo.opened = 0;\n\tfinfo.ino = iunique(dir->i_sb, 2);\n\tfinfo.volume = finfo.i.volNumber;\n\terror = -EACCES;\n\tinode = ncp_iget(dir->i_sb, &finfo);\n\n\tif (inode) {\n\t\tncp_new_dentry(dentry);\nadd_entry:\n\t\td_add(dentry, inode);\n\t\terror = 0;\n\t}\n\nfinished:\n\tncp_vdbg(\"result=%d\\n\", error);\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "ncp_conn_logged_in",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "785-828",
    "snippet": "int ncp_conn_logged_in(struct super_block *sb)\n{\n\tstruct ncp_server* server = NCP_SBP(sb);\n\tint result;\n\n\tif (ncp_single_volume(server)) {\n\t\tint len;\n\t\tstruct dentry* dent;\n\t\t__u32 volNumber;\n\t\t__le32 dirEntNum;\n\t\t__le32 DosDirNum;\n\t\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\t\tlen = sizeof(__name);\n\t\tresult = ncp_io2vol(server, __name, &len, server->m.mounted_vol,\n\t\t\t\t    strlen(server->m.mounted_vol), 1);\n\t\tif (result)\n\t\t\tgoto out;\n\t\tresult = -ENOENT;\n\t\tif (ncp_get_volume_root(server, __name, &volNumber, &dirEntNum, &DosDirNum)) {\n\t\t\tncp_vdbg(\"%s not found\\n\", server->m.mounted_vol);\n\t\t\tgoto out;\n\t\t}\n\t\tdent = sb->s_root;\n\t\tif (dent) {\n\t\t\tstruct inode* ino = dent->d_inode;\n\t\t\tif (ino) {\n\t\t\t\tncp_update_known_namespace(server, volNumber, NULL);\n\t\t\t\tNCP_FINFO(ino)->volNumber = volNumber;\n\t\t\t\tNCP_FINFO(ino)->dirEntNum = dirEntNum;\n\t\t\t\tNCP_FINFO(ino)->DosDirNum = DosDirNum;\n\t\t\t\tresult = 0;\n\t\t\t} else {\n\t\t\t\tncp_dbg(1, \"sb->s_root->d_inode == NULL!\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tncp_dbg(1, \"sb->s_root == NULL!\\n\");\n\t\t}\n\t} else\n\t\tresult = 0;\n\nout:\n\treturn result;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"sb->s_root == NULL!\\n\""
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"sb->s_root->d_inode == NULL!\\n\""
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "ino"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_update_known_namespace",
          "args": [
            "server",
            "volNumber",
            "NULL"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_known_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "525-539",
          "snippet": "int\nncp_update_known_namespace(struct ncp_server *server, __u8 volume, int *ret_ns)\n{\n\tint ns = ncp_get_known_namespace(server, volume);\n\n\tif (ret_ns)\n\t\t*ret_ns = ns;\n\n\tncp_dbg(1, \"namespace[%d] = %d\\n\", volume, server->name_space[volume]);\n\n\tif (server->name_space[volume] == ns)\n\t\treturn 0;\n\tserver->name_space[volume] = ns;\n\treturn 1;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_update_known_namespace(struct ncp_server *server, __u8 volume, int *ret_ns)\n{\n\tint ns = ncp_get_known_namespace(server, volume);\n\n\tif (ret_ns)\n\t\t*ret_ns = ns;\n\n\tncp_dbg(1, \"namespace[%d] = %d\\n\", volume, server->name_space[volume]);\n\n\tif (server->name_space[volume] == ns)\n\t\treturn 0;\n\tserver->name_space[volume] = ns;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_vdbg",
          "args": [
            "\"%s not found\\n\"",
            "server->m.mounted_vol"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_get_volume_root",
          "args": [
            "server",
            "__name",
            "&volNumber",
            "&dirEntNum",
            "&DosDirNum"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_get_volume_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "591-620",
          "snippet": "int \nncp_get_volume_root(struct ncp_server *server,\n\t\t    const char *volname, __u32* volume, __le32* dirent, __le32* dosdirent)\n{\n\tint result;\n\n\tncp_dbg(1, \"looking up vol %s\\n\", volname);\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 22);\t/* Subfunction: Generate dir handle */\n\tncp_add_byte(server, 0);\t/* DOS namespace */\n\tncp_add_byte(server, 0);\t/* reserved */\n\tncp_add_byte(server, 0);\t/* reserved */\n\tncp_add_byte(server, 0);\t/* reserved */\n\n\tncp_add_byte(server, 0);\t/* faked volume number */\n\tncp_add_dword(server, 0);\t/* faked dir_base */\n\tncp_add_byte(server, 0xff);\t/* Don't have a dir_base */\n\tncp_add_byte(server, 1);\t/* 1 path component */\n\tncp_add_pstring(server, volname);\n\n\tif ((result = ncp_request(server, 87)) != 0) {\n\t\tncp_unlock_server(server);\n\t\treturn result;\n\t}\n\t*dirent = *dosdirent = ncp_reply_dword(server, 4);\n\t*volume = ncp_reply_byte(server, 8);\n\tncp_unlock_server(server);\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint \nncp_get_volume_root(struct ncp_server *server,\n\t\t    const char *volname, __u32* volume, __le32* dirent, __le32* dosdirent)\n{\n\tint result;\n\n\tncp_dbg(1, \"looking up vol %s\\n\", volname);\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 22);\t/* Subfunction: Generate dir handle */\n\tncp_add_byte(server, 0);\t/* DOS namespace */\n\tncp_add_byte(server, 0);\t/* reserved */\n\tncp_add_byte(server, 0);\t/* reserved */\n\tncp_add_byte(server, 0);\t/* reserved */\n\n\tncp_add_byte(server, 0);\t/* faked volume number */\n\tncp_add_dword(server, 0);\t/* faked dir_base */\n\tncp_add_byte(server, 0xff);\t/* Don't have a dir_base */\n\tncp_add_byte(server, 1);\t/* 1 path component */\n\tncp_add_pstring(server, volname);\n\n\tif ((result = ncp_request(server, 87)) != 0) {\n\t\tncp_unlock_server(server);\n\t\treturn result;\n\t}\n\t*dirent = *dosdirent = ncp_reply_dword(server, 4);\n\t*volume = ncp_reply_byte(server, 8);\n\tncp_unlock_server(server);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_io2vol",
          "args": [
            "server",
            "__name",
            "&len",
            "server->m.mounted_vol",
            "strlen(server->m.mounted_vol)",
            "1"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "server->m.mounted_vol"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_single_volume",
          "args": [
            "server"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_single_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "195-199",
          "snippet": "static inline int\nncp_single_volume(struct ncp_server *server)\n{\n\treturn (server->m.mounted_vol[0] != '\\0');\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int\nncp_single_volume(struct ncp_server *server)\n{\n\treturn (server->m.mounted_vol[0] != '\\0');\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SBP",
          "args": [
            "sb"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_SBP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "43-46",
          "snippet": "static inline struct ncp_server *NCP_SBP(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_conn_logged_in(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_conn_logged_in(struct super_block *);\n\nstatic inline struct ncp_server *NCP_SBP(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nint ncp_conn_logged_in(struct super_block *sb)\n{\n\tstruct ncp_server* server = NCP_SBP(sb);\n\tint result;\n\n\tif (ncp_single_volume(server)) {\n\t\tint len;\n\t\tstruct dentry* dent;\n\t\t__u32 volNumber;\n\t\t__le32 dirEntNum;\n\t\t__le32 DosDirNum;\n\t\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\t\tlen = sizeof(__name);\n\t\tresult = ncp_io2vol(server, __name, &len, server->m.mounted_vol,\n\t\t\t\t    strlen(server->m.mounted_vol), 1);\n\t\tif (result)\n\t\t\tgoto out;\n\t\tresult = -ENOENT;\n\t\tif (ncp_get_volume_root(server, __name, &volNumber, &dirEntNum, &DosDirNum)) {\n\t\t\tncp_vdbg(\"%s not found\\n\", server->m.mounted_vol);\n\t\t\tgoto out;\n\t\t}\n\t\tdent = sb->s_root;\n\t\tif (dent) {\n\t\t\tstruct inode* ino = dent->d_inode;\n\t\t\tif (ino) {\n\t\t\t\tncp_update_known_namespace(server, volNumber, NULL);\n\t\t\t\tNCP_FINFO(ino)->volNumber = volNumber;\n\t\t\t\tNCP_FINFO(ino)->dirEntNum = dirEntNum;\n\t\t\t\tNCP_FINFO(ino)->DosDirNum = DosDirNum;\n\t\t\t\tresult = 0;\n\t\t\t} else {\n\t\t\t\tncp_dbg(1, \"sb->s_root->d_inode == NULL!\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tncp_dbg(1, \"sb->s_root == NULL!\\n\");\n\t\t}\n\t} else\n\t\tresult = 0;\n\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "ncp_do_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "723-783",
    "snippet": "static void\nncp_do_readdir(struct file *file, struct dir_context *ctx,\n\t\t\t\t\t\tstruct ncp_cache_control *ctl)\n{\n\tstruct inode *dir = file_inode(file);\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct nw_search_sequence seq;\n\tstruct ncp_entry_info entry;\n\tint err;\n\tvoid* buf;\n\tint more;\n\tsize_t bufsize;\n\n\tncp_dbg(1, \"%pD2, fpos=%ld\\n\", file, (unsigned long)ctx->pos);\n\tncp_vdbg(\"init %pD, volnum=%d, dirent=%u\\n\",\n\t\t file, NCP_FINFO(dir)->volNumber, NCP_FINFO(dir)->dirEntNum);\n\n\terr = ncp_initialize_search(server, dir, &seq);\n\tif (err) {\n\t\tncp_dbg(1, \"init failed, err=%d\\n\", err);\n\t\treturn;\n\t}\n\t/* We MUST NOT use server->buffer_size handshaked with server if we are\n\t   using UDP, as for UDP server uses max. buffer size determined by\n\t   MTU, and for TCP server uses hardwired value 65KB (== 66560 bytes). \n\t   So we use 128KB, just to be sure, as there is no way how to know\n\t   this value in advance. */\n\tbufsize = 131072;\n\tbuf = vmalloc(bufsize);\n\tif (!buf)\n\t\treturn;\n\tdo {\n\t\tint cnt;\n\t\tchar* rpl;\n\t\tsize_t rpls;\n\n\t\terr = ncp_search_for_fileset(server, &seq, &more, &cnt, buf, bufsize, &rpl, &rpls);\n\t\tif (err)\t\t/* Error */\n\t\t\tbreak;\n\t\tif (!cnt)\t\t/* prevent endless loop */\n\t\t\tbreak;\n\t\twhile (cnt--) {\n\t\t\tsize_t onerpl;\n\t\t\t\n\t\t\tif (rpls < offsetof(struct nw_info_struct, entryName))\n\t\t\t\tbreak;\t/* short packet */\n\t\t\tncp_extract_file_info(rpl, &entry.i);\n\t\t\tonerpl = offsetof(struct nw_info_struct, entryName) + entry.i.nameLen;\n\t\t\tif (rpls < onerpl)\n\t\t\t\tbreak;\t/* short packet */\n\t\t\t(void)ncp_obtain_nfs_info(server, &entry.i);\n\t\t\trpl += onerpl;\n\t\t\trpls -= onerpl;\n\t\t\tentry.volume = entry.i.volNumber;\n\t\t\tif (!ncp_fill_cache(file, ctx, ctl, &entry, 0))\n\t\t\t\tbreak;\n\t\t}\n\t} while (more);\n\tvfree(buf);\n\treturn;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
      "static void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
      "static int ncp_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "buf"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_fill_cache",
          "args": [
            "file",
            "ctx",
            "ctl",
            "&entry",
            "0"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_fill_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "577-686",
          "snippet": "static int\nncp_fill_cache(struct file *file, struct dir_context *ctx,\n\t\tstruct ncp_cache_control *ctrl, struct ncp_entry_info *entry,\n\t\tint inval_childs)\n{\n\tstruct dentry *newdent, *dentry = file->f_path.dentry;\n\tstruct inode *dir = dentry->d_inode;\n\tstruct ncp_cache_control ctl = *ctrl;\n\tstruct qstr qname;\n\tint valid = 0;\n\tint hashed = 0;\n\tino_t ino = 0;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tqname.len = sizeof(__name);\n\tif (ncp_vol2io(NCP_SERVER(dir), __name, &qname.len,\n\t\t\tentry->i.entryName, entry->i.nameLen,\n\t\t\t!ncp_preserve_entry_case(dir, entry->i.NSCreator)))\n\t\treturn 1; /* I'm not sure */\n\n\tqname.name = __name;\n\n\tnewdent = d_hash_and_lookup(dentry, &qname);\n\tif (unlikely(IS_ERR(newdent)))\n\t\tgoto end_advance;\n\tif (!newdent) {\n\t\tnewdent = d_alloc(dentry, &qname);\n\t\tif (!newdent)\n\t\t\tgoto end_advance;\n\t} else {\n\t\thashed = 1;\n\n\t\t/* If case sensitivity changed for this volume, all entries below this one\n\t\t   should be thrown away.  This entry itself is not affected, as its case\n\t\t   sensitivity is controlled by its own parent. */\n\t\tif (inval_childs)\n\t\t\tshrink_dcache_parent(newdent);\n\n\t\t/*\n\t\t * NetWare's OS2 namespace is case preserving yet case\n\t\t * insensitive.  So we update dentry's name as received from\n\t\t * server. Parent dir's i_mutex is locked because we're in\n\t\t * readdir.\n\t\t */\n\t\tdentry_update_name_case(newdent, &qname);\n\t}\n\n\tif (!newdent->d_inode) {\n\t\tstruct inode *inode;\n\n\t\tentry->opened = 0;\n\t\tentry->ino = iunique(dir->i_sb, 2);\n\t\tinode = ncp_iget(dir->i_sb, entry);\n\t\tif (inode) {\n\t\t\td_instantiate(newdent, inode);\n\t\t\tif (!hashed)\n\t\t\t\td_rehash(newdent);\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tNCP_FINFO(inode)->flags &= ~NCPI_DIR_CACHE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t} else {\n\t\tstruct inode *inode = newdent->d_inode;\n\n\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\tncp_update_inode2(inode, entry);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\tif (ctl.idx >= NCP_DIRCACHE_SIZE) {\n\t\tif (ctl.page) {\n\t\t\tkunmap(ctl.page);\n\t\t\tSetPageUptodate(ctl.page);\n\t\t\tunlock_page(ctl.page);\n\t\t\tpage_cache_release(ctl.page);\n\t\t}\n\t\tctl.cache = NULL;\n\t\tctl.idx  -= NCP_DIRCACHE_SIZE;\n\t\tctl.ofs  += 1;\n\t\tctl.page  = grab_cache_page(&dir->i_data, ctl.ofs);\n\t\tif (ctl.page)\n\t\t\tctl.cache = kmap(ctl.page);\n\t}\n\tif (ctl.cache) {\n\t\tif (newdent->d_inode) {\n\t\t\tnewdent->d_fsdata = newdent;\n\t\t\tctl.cache->dentry[ctl.idx] = newdent;\n\t\t\tino = newdent->d_inode->i_ino;\n\t\t\tncp_new_dentry(newdent);\n\t\t}\n \t\tvalid = 1;\n\t}\n\tdput(newdent);\nend_advance:\n\tif (!valid)\n\t\tctl.valid = 0;\n\tif (!ctl.filled && (ctl.fpos == ctx->pos)) {\n\t\tif (!ino)\n\t\t\tino = iunique(dir->i_sb, 2);\n\t\tctl.filled = !dir_emit(ctx, qname.name, qname.len,\n\t\t\t\t     ino, DT_UNKNOWN);\n\t\tif (!ctl.filled)\n\t\t\tctx->pos += 1;\n\t}\n\tctl.fpos += 1;\n\tctl.idx  += 1;\n\t*ctrl = ctl;\n\treturn (ctl.valid || !ctl.filled);\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
            "static void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
            "static int ncp_readdir(struct file *, struct dir_context *);",
            "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
            "static int ncp_unlink(struct inode *, struct dentry *);",
            "static int ncp_rmdir(struct inode *, struct dentry *);",
            "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
            "static int ncp_lookup_validate(struct dentry *, unsigned int);",
            "static int ncp_hash_dentry(const struct dentry *, struct qstr *);",
            "static int ncp_compare_dentry(const struct dentry *, const struct dentry *,\n\t\tunsigned int, const char *, const struct qstr *);",
            "static int ncp_delete_dentry(const struct dentry *);",
            "static void ncp_d_prune(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic int ncp_readdir(struct file *, struct dir_context *);\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_hash_dentry(const struct dentry *, struct qstr *);\nstatic int ncp_compare_dentry(const struct dentry *, const struct dentry *,\n\t\tunsigned int, const char *, const struct qstr *);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int\nncp_fill_cache(struct file *file, struct dir_context *ctx,\n\t\tstruct ncp_cache_control *ctrl, struct ncp_entry_info *entry,\n\t\tint inval_childs)\n{\n\tstruct dentry *newdent, *dentry = file->f_path.dentry;\n\tstruct inode *dir = dentry->d_inode;\n\tstruct ncp_cache_control ctl = *ctrl;\n\tstruct qstr qname;\n\tint valid = 0;\n\tint hashed = 0;\n\tino_t ino = 0;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tqname.len = sizeof(__name);\n\tif (ncp_vol2io(NCP_SERVER(dir), __name, &qname.len,\n\t\t\tentry->i.entryName, entry->i.nameLen,\n\t\t\t!ncp_preserve_entry_case(dir, entry->i.NSCreator)))\n\t\treturn 1; /* I'm not sure */\n\n\tqname.name = __name;\n\n\tnewdent = d_hash_and_lookup(dentry, &qname);\n\tif (unlikely(IS_ERR(newdent)))\n\t\tgoto end_advance;\n\tif (!newdent) {\n\t\tnewdent = d_alloc(dentry, &qname);\n\t\tif (!newdent)\n\t\t\tgoto end_advance;\n\t} else {\n\t\thashed = 1;\n\n\t\t/* If case sensitivity changed for this volume, all entries below this one\n\t\t   should be thrown away.  This entry itself is not affected, as its case\n\t\t   sensitivity is controlled by its own parent. */\n\t\tif (inval_childs)\n\t\t\tshrink_dcache_parent(newdent);\n\n\t\t/*\n\t\t * NetWare's OS2 namespace is case preserving yet case\n\t\t * insensitive.  So we update dentry's name as received from\n\t\t * server. Parent dir's i_mutex is locked because we're in\n\t\t * readdir.\n\t\t */\n\t\tdentry_update_name_case(newdent, &qname);\n\t}\n\n\tif (!newdent->d_inode) {\n\t\tstruct inode *inode;\n\n\t\tentry->opened = 0;\n\t\tentry->ino = iunique(dir->i_sb, 2);\n\t\tinode = ncp_iget(dir->i_sb, entry);\n\t\tif (inode) {\n\t\t\td_instantiate(newdent, inode);\n\t\t\tif (!hashed)\n\t\t\t\td_rehash(newdent);\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tNCP_FINFO(inode)->flags &= ~NCPI_DIR_CACHE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t} else {\n\t\tstruct inode *inode = newdent->d_inode;\n\n\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\tncp_update_inode2(inode, entry);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\tif (ctl.idx >= NCP_DIRCACHE_SIZE) {\n\t\tif (ctl.page) {\n\t\t\tkunmap(ctl.page);\n\t\t\tSetPageUptodate(ctl.page);\n\t\t\tunlock_page(ctl.page);\n\t\t\tpage_cache_release(ctl.page);\n\t\t}\n\t\tctl.cache = NULL;\n\t\tctl.idx  -= NCP_DIRCACHE_SIZE;\n\t\tctl.ofs  += 1;\n\t\tctl.page  = grab_cache_page(&dir->i_data, ctl.ofs);\n\t\tif (ctl.page)\n\t\t\tctl.cache = kmap(ctl.page);\n\t}\n\tif (ctl.cache) {\n\t\tif (newdent->d_inode) {\n\t\t\tnewdent->d_fsdata = newdent;\n\t\t\tctl.cache->dentry[ctl.idx] = newdent;\n\t\t\tino = newdent->d_inode->i_ino;\n\t\t\tncp_new_dentry(newdent);\n\t\t}\n \t\tvalid = 1;\n\t}\n\tdput(newdent);\nend_advance:\n\tif (!valid)\n\t\tctl.valid = 0;\n\tif (!ctl.filled && (ctl.fpos == ctx->pos)) {\n\t\tif (!ino)\n\t\t\tino = iunique(dir->i_sb, 2);\n\t\tctl.filled = !dir_emit(ctx, qname.name, qname.len,\n\t\t\t\t     ino, DT_UNKNOWN);\n\t\tif (!ctl.filled)\n\t\t\tctx->pos += 1;\n\t}\n\tctl.fpos += 1;\n\tctl.idx  += 1;\n\t*ctrl = ctl;\n\treturn (ctl.valid || !ctl.filled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_obtain_nfs_info",
          "args": [
            "server",
            "&entry.i"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_obtain_nfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "375-413",
          "snippet": "int ncp_obtain_nfs_info(struct ncp_server *server,\n\t\t        struct nw_info_struct *target)\n\n{\n\tint result = 0;\n#ifdef CONFIG_NCPFS_NFS_NS\n\t__u32 volnum = target->volNumber;\n\n\tif (ncp_is_nfs_extras(server, volnum)) {\n\t\tncp_init_request(server);\n\t\tncp_add_byte(server, 19);\t/* subfunction */\n\t\tncp_add_byte(server, server->name_space[volnum]);\n\t\tncp_add_byte(server, NW_NS_NFS);\n\t\tncp_add_byte(server, 0);\n\t\tncp_add_byte(server, volnum);\n\t\tncp_add_dword(server, target->dirEntNum);\n\t\t/* We must retrieve both nlinks and rdev, otherwise some server versions\n\t\t   report zeroes instead of valid data */\n\t\tncp_add_dword_lh(server, NSIBM_NFS_MODE | NSIBM_NFS_NLINKS | NSIBM_NFS_RDEV);\n\n\t\tif ((result = ncp_request(server, 87)) == 0) {\n\t\t\tncp_extract_nfs_info(ncp_reply_data(server, 0), &target->nfs);\n\t\t\tncp_dbg(1, \"(%s) mode=0%o, rdev=0x%x\\n\",\n\t\t\t\ttarget->entryName, target->nfs.mode,\n\t\t\t\ttarget->nfs.rdev);\n\t\t} else {\n\t\t\ttarget->nfs.mode = 0;\n\t\t\ttarget->nfs.rdev = 0;\n\t\t}\n\t        ncp_unlock_server(server);\n\n\t} else\n#endif\n\t{\n\t\ttarget->nfs.mode = 0;\n\t\ttarget->nfs.rdev = 0;\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_obtain_nfs_info(struct ncp_server *server,\n\t\t        struct nw_info_struct *target)\n\n{\n\tint result = 0;\n#ifdef CONFIG_NCPFS_NFS_NS\n\t__u32 volnum = target->volNumber;\n\n\tif (ncp_is_nfs_extras(server, volnum)) {\n\t\tncp_init_request(server);\n\t\tncp_add_byte(server, 19);\t/* subfunction */\n\t\tncp_add_byte(server, server->name_space[volnum]);\n\t\tncp_add_byte(server, NW_NS_NFS);\n\t\tncp_add_byte(server, 0);\n\t\tncp_add_byte(server, volnum);\n\t\tncp_add_dword(server, target->dirEntNum);\n\t\t/* We must retrieve both nlinks and rdev, otherwise some server versions\n\t\t   report zeroes instead of valid data */\n\t\tncp_add_dword_lh(server, NSIBM_NFS_MODE | NSIBM_NFS_NLINKS | NSIBM_NFS_RDEV);\n\n\t\tif ((result = ncp_request(server, 87)) == 0) {\n\t\t\tncp_extract_nfs_info(ncp_reply_data(server, 0), &target->nfs);\n\t\t\tncp_dbg(1, \"(%s) mode=0%o, rdev=0x%x\\n\",\n\t\t\t\ttarget->entryName, target->nfs.mode,\n\t\t\t\ttarget->nfs.rdev);\n\t\t} else {\n\t\t\ttarget->nfs.mode = 0;\n\t\t\ttarget->nfs.rdev = 0;\n\t\t}\n\t        ncp_unlock_server(server);\n\n\t} else\n#endif\n\t{\n\t\ttarget->nfs.mode = 0;\n\t\ttarget->nfs.rdev = 0;\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_extract_file_info",
          "args": [
            "rpl",
            "&entry.i"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_extract_file_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "352-364",
          "snippet": "void ncp_extract_file_info(const void *structure, struct nw_info_struct *target)\n{\n\tconst __u8 *name_len;\n\tconst int info_struct_size = offsetof(struct nw_info_struct, nameLen);\n\n\tmemcpy(target, structure, info_struct_size);\n\tname_len = structure + info_struct_size;\n\ttarget->nameLen = *name_len;\n\tmemcpy(target->entryName, name_len + 1, *name_len);\n\ttarget->entryName[*name_len] = '\\0';\n\ttarget->volNumber = le32_to_cpu(target->volNumber);\n\treturn;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nvoid ncp_extract_file_info(const void *structure, struct nw_info_struct *target)\n{\n\tconst __u8 *name_len;\n\tconst int info_struct_size = offsetof(struct nw_info_struct, nameLen);\n\n\tmemcpy(target, structure, info_struct_size);\n\tname_len = structure + info_struct_size;\n\ttarget->nameLen = *name_len;\n\tmemcpy(target->entryName, name_len + 1, *name_len);\n\ttarget->entryName[*name_len] = '\\0';\n\ttarget->volNumber = le32_to_cpu(target->volNumber);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_search_for_fileset",
          "args": [
            "server",
            "&seq",
            "&more",
            "&cnt",
            "buf",
            "bufsize",
            "&rpl",
            "&rpls"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_search_for_fileset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "852-898",
          "snippet": "int ncp_search_for_fileset(struct ncp_server *server,\n\t\t\t   struct nw_search_sequence *seq,\n\t\t\t   int* more,\n\t\t\t   int* cnt,\n\t\t\t   char* buffer,\n\t\t\t   size_t bufsize,\n\t\t\t   char** rbuf,\n\t\t\t   size_t* rsize)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 20);\n\tncp_add_byte(server, server->name_space[seq->volNumber]);\n\tncp_add_byte(server, 0);\t\t/* datastream */\n\tncp_add_word(server, cpu_to_le16(0x8006));\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_word(server, cpu_to_le16(32767));\t/* max returned items */\n\tncp_add_mem(server, seq, 9);\n#ifdef CONFIG_NCPFS_NFS_NS\n\tif (server->name_space[seq->volNumber] == NW_NS_NFS) {\n\t\tncp_add_byte(server, 0);\t/* 0 byte pattern */\n\t} else \n#endif\n\t{\n\t\tncp_add_byte(server, 2);\t/* 2 byte pattern */\n\t\tncp_add_byte(server, 0xff);\t/* following is a wildcard */\n\t\tncp_add_byte(server, '*');\n\t}\n\tresult = ncp_request2(server, 87, buffer, bufsize);\n\tif (result) {\n\t\tncp_unlock_server(server);\n\t\treturn result;\n\t}\n\tif (server->ncp_reply_size < 12) {\n\t\tncp_unlock_server(server);\n\t\treturn 0xFF;\n\t}\n\t*rsize = server->ncp_reply_size - 12;\n\tncp_unlock_server(server);\n\tbuffer = buffer + sizeof(struct ncp_reply_header);\n\t*rbuf = buffer + 12;\n\t*cnt = WVAL_LH(buffer + 10);\n\t*more = BVAL(buffer + 9);\n\tmemcpy(seq, buffer, 9);\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_search_for_fileset(struct ncp_server *server,\n\t\t\t   struct nw_search_sequence *seq,\n\t\t\t   int* more,\n\t\t\t   int* cnt,\n\t\t\t   char* buffer,\n\t\t\t   size_t bufsize,\n\t\t\t   char** rbuf,\n\t\t\t   size_t* rsize)\n{\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 20);\n\tncp_add_byte(server, server->name_space[seq->volNumber]);\n\tncp_add_byte(server, 0);\t\t/* datastream */\n\tncp_add_word(server, cpu_to_le16(0x8006));\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_word(server, cpu_to_le16(32767));\t/* max returned items */\n\tncp_add_mem(server, seq, 9);\n#ifdef CONFIG_NCPFS_NFS_NS\n\tif (server->name_space[seq->volNumber] == NW_NS_NFS) {\n\t\tncp_add_byte(server, 0);\t/* 0 byte pattern */\n\t} else \n#endif\n\t{\n\t\tncp_add_byte(server, 2);\t/* 2 byte pattern */\n\t\tncp_add_byte(server, 0xff);\t/* following is a wildcard */\n\t\tncp_add_byte(server, '*');\n\t}\n\tresult = ncp_request2(server, 87, buffer, bufsize);\n\tif (result) {\n\t\tncp_unlock_server(server);\n\t\treturn result;\n\t}\n\tif (server->ncp_reply_size < 12) {\n\t\tncp_unlock_server(server);\n\t\treturn 0xFF;\n\t}\n\t*rsize = server->ncp_reply_size - 12;\n\tncp_unlock_server(server);\n\tbuffer = buffer + sizeof(struct ncp_reply_header);\n\t*rbuf = buffer + 12;\n\t*cnt = WVAL_LH(buffer + 10);\n\t*more = BVAL(buffer + 9);\n\tmemcpy(seq, buffer, 9);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "bufsize"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"init failed, err=%d\\n\"",
            "err"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_initialize_search",
          "args": [
            "server",
            "dir",
            "&seq"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_initialize_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "828-850",
          "snippet": "int\nncp_initialize_search(struct ncp_server *server, struct inode *dir,\n\t\t\tstruct nw_search_sequence *target)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 2);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, 0);\t/* reserved */\n\tncp_add_handle_path(server, volnum, dirent, 1, NULL);\n\n\tresult = ncp_request(server, 87);\n\tif (result)\n\t\tgoto out;\n\tmemcpy(target, ncp_reply_data(server, 0), sizeof(*target));\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_initialize_search(struct ncp_server *server, struct inode *dir,\n\t\t\tstruct nw_search_sequence *target)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 2);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, 0);\t/* reserved */\n\tncp_add_handle_path(server, volnum, dirent, 1, NULL);\n\n\tresult = ncp_request(server, 87);\n\tif (result)\n\t\tgoto out;\n\tmemcpy(target, ncp_reply_data(server, 0), sizeof(*target));\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_vdbg",
          "args": [
            "\"init %pD, volnum=%d, dirent=%u\\n\"",
            "file",
            "NCP_FINFO(dir)->volNumber",
            "NCP_FINFO(dir)->dirEntNum"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "dir"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"%pD2, fpos=%ld\\n\"",
            "file",
            "(unsigned long)ctx->pos"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic int ncp_readdir(struct file *, struct dir_context *);\n\nstatic void\nncp_do_readdir(struct file *file, struct dir_context *ctx,\n\t\t\t\t\t\tstruct ncp_cache_control *ctl)\n{\n\tstruct inode *dir = file_inode(file);\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct nw_search_sequence seq;\n\tstruct ncp_entry_info entry;\n\tint err;\n\tvoid* buf;\n\tint more;\n\tsize_t bufsize;\n\n\tncp_dbg(1, \"%pD2, fpos=%ld\\n\", file, (unsigned long)ctx->pos);\n\tncp_vdbg(\"init %pD, volnum=%d, dirent=%u\\n\",\n\t\t file, NCP_FINFO(dir)->volNumber, NCP_FINFO(dir)->dirEntNum);\n\n\terr = ncp_initialize_search(server, dir, &seq);\n\tif (err) {\n\t\tncp_dbg(1, \"init failed, err=%d\\n\", err);\n\t\treturn;\n\t}\n\t/* We MUST NOT use server->buffer_size handshaked with server if we are\n\t   using UDP, as for UDP server uses max. buffer size determined by\n\t   MTU, and for TCP server uses hardwired value 65KB (== 66560 bytes). \n\t   So we use 128KB, just to be sure, as there is no way how to know\n\t   this value in advance. */\n\tbufsize = 131072;\n\tbuf = vmalloc(bufsize);\n\tif (!buf)\n\t\treturn;\n\tdo {\n\t\tint cnt;\n\t\tchar* rpl;\n\t\tsize_t rpls;\n\n\t\terr = ncp_search_for_fileset(server, &seq, &more, &cnt, buf, bufsize, &rpl, &rpls);\n\t\tif (err)\t\t/* Error */\n\t\t\tbreak;\n\t\tif (!cnt)\t\t/* prevent endless loop */\n\t\t\tbreak;\n\t\twhile (cnt--) {\n\t\t\tsize_t onerpl;\n\t\t\t\n\t\t\tif (rpls < offsetof(struct nw_info_struct, entryName))\n\t\t\t\tbreak;\t/* short packet */\n\t\t\tncp_extract_file_info(rpl, &entry.i);\n\t\t\tonerpl = offsetof(struct nw_info_struct, entryName) + entry.i.nameLen;\n\t\t\tif (rpls < onerpl)\n\t\t\t\tbreak;\t/* short packet */\n\t\t\t(void)ncp_obtain_nfs_info(server, &entry.i);\n\t\t\trpl += onerpl;\n\t\t\trpls -= onerpl;\n\t\t\tentry.volume = entry.i.volNumber;\n\t\t\tif (!ncp_fill_cache(file, ctx, ctl, &entry, 0))\n\t\t\t\tbreak;\n\t\t}\n\t} while (more);\n\tvfree(buf);\n\treturn;\n}"
  },
  {
    "function_name": "ncp_read_volume_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "688-721",
    "snippet": "static void\nncp_read_volume_list(struct file *file, struct dir_context *ctx,\n\t\t\tstruct ncp_cache_control *ctl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tstruct ncp_volume_info info;\n\tstruct ncp_entry_info entry;\n\tint i;\n\n\tncp_dbg(1, \"pos=%ld\\n\", (unsigned long)ctx->pos);\n\n\tfor (i = 0; i < NCP_NUMBER_OF_VOLUMES; i++) {\n\t\tint inval_dentry;\n\n\t\tif (ncp_get_volume_info_with_number(server, i, &info) != 0)\n\t\t\treturn;\n\t\tif (!strlen(info.volume_name))\n\t\t\tcontinue;\n\n\t\tncp_dbg(1, \"found vol: %s\\n\", info.volume_name);\n\n\t\tif (ncp_lookup_volume(server, info.volume_name,\n\t\t\t\t\t&entry.i)) {\n\t\t\tncp_dbg(1, \"could not lookup vol %s\\n\",\n\t\t\t\tinfo.volume_name);\n\t\t\tcontinue;\n\t\t}\n\t\tinval_dentry = ncp_update_known_namespace(server, entry.i.volNumber, NULL);\n\t\tentry.volume = entry.i.volNumber;\n\t\tif (!ncp_fill_cache(file, ctx, ctl, &entry, inval_dentry))\n\t\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
      "static void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
      "static int ncp_readdir(struct file *, struct dir_context *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_fill_cache",
          "args": [
            "file",
            "ctx",
            "ctl",
            "&entry",
            "inval_dentry"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_fill_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "577-686",
          "snippet": "static int\nncp_fill_cache(struct file *file, struct dir_context *ctx,\n\t\tstruct ncp_cache_control *ctrl, struct ncp_entry_info *entry,\n\t\tint inval_childs)\n{\n\tstruct dentry *newdent, *dentry = file->f_path.dentry;\n\tstruct inode *dir = dentry->d_inode;\n\tstruct ncp_cache_control ctl = *ctrl;\n\tstruct qstr qname;\n\tint valid = 0;\n\tint hashed = 0;\n\tino_t ino = 0;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tqname.len = sizeof(__name);\n\tif (ncp_vol2io(NCP_SERVER(dir), __name, &qname.len,\n\t\t\tentry->i.entryName, entry->i.nameLen,\n\t\t\t!ncp_preserve_entry_case(dir, entry->i.NSCreator)))\n\t\treturn 1; /* I'm not sure */\n\n\tqname.name = __name;\n\n\tnewdent = d_hash_and_lookup(dentry, &qname);\n\tif (unlikely(IS_ERR(newdent)))\n\t\tgoto end_advance;\n\tif (!newdent) {\n\t\tnewdent = d_alloc(dentry, &qname);\n\t\tif (!newdent)\n\t\t\tgoto end_advance;\n\t} else {\n\t\thashed = 1;\n\n\t\t/* If case sensitivity changed for this volume, all entries below this one\n\t\t   should be thrown away.  This entry itself is not affected, as its case\n\t\t   sensitivity is controlled by its own parent. */\n\t\tif (inval_childs)\n\t\t\tshrink_dcache_parent(newdent);\n\n\t\t/*\n\t\t * NetWare's OS2 namespace is case preserving yet case\n\t\t * insensitive.  So we update dentry's name as received from\n\t\t * server. Parent dir's i_mutex is locked because we're in\n\t\t * readdir.\n\t\t */\n\t\tdentry_update_name_case(newdent, &qname);\n\t}\n\n\tif (!newdent->d_inode) {\n\t\tstruct inode *inode;\n\n\t\tentry->opened = 0;\n\t\tentry->ino = iunique(dir->i_sb, 2);\n\t\tinode = ncp_iget(dir->i_sb, entry);\n\t\tif (inode) {\n\t\t\td_instantiate(newdent, inode);\n\t\t\tif (!hashed)\n\t\t\t\td_rehash(newdent);\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tNCP_FINFO(inode)->flags &= ~NCPI_DIR_CACHE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t} else {\n\t\tstruct inode *inode = newdent->d_inode;\n\n\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\tncp_update_inode2(inode, entry);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\tif (ctl.idx >= NCP_DIRCACHE_SIZE) {\n\t\tif (ctl.page) {\n\t\t\tkunmap(ctl.page);\n\t\t\tSetPageUptodate(ctl.page);\n\t\t\tunlock_page(ctl.page);\n\t\t\tpage_cache_release(ctl.page);\n\t\t}\n\t\tctl.cache = NULL;\n\t\tctl.idx  -= NCP_DIRCACHE_SIZE;\n\t\tctl.ofs  += 1;\n\t\tctl.page  = grab_cache_page(&dir->i_data, ctl.ofs);\n\t\tif (ctl.page)\n\t\t\tctl.cache = kmap(ctl.page);\n\t}\n\tif (ctl.cache) {\n\t\tif (newdent->d_inode) {\n\t\t\tnewdent->d_fsdata = newdent;\n\t\t\tctl.cache->dentry[ctl.idx] = newdent;\n\t\t\tino = newdent->d_inode->i_ino;\n\t\t\tncp_new_dentry(newdent);\n\t\t}\n \t\tvalid = 1;\n\t}\n\tdput(newdent);\nend_advance:\n\tif (!valid)\n\t\tctl.valid = 0;\n\tif (!ctl.filled && (ctl.fpos == ctx->pos)) {\n\t\tif (!ino)\n\t\t\tino = iunique(dir->i_sb, 2);\n\t\tctl.filled = !dir_emit(ctx, qname.name, qname.len,\n\t\t\t\t     ino, DT_UNKNOWN);\n\t\tif (!ctl.filled)\n\t\t\tctx->pos += 1;\n\t}\n\tctl.fpos += 1;\n\tctl.idx  += 1;\n\t*ctrl = ctl;\n\treturn (ctl.valid || !ctl.filled);\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
            "static void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
            "static int ncp_readdir(struct file *, struct dir_context *);",
            "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
            "static int ncp_unlink(struct inode *, struct dentry *);",
            "static int ncp_rmdir(struct inode *, struct dentry *);",
            "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
            "static int ncp_lookup_validate(struct dentry *, unsigned int);",
            "static int ncp_hash_dentry(const struct dentry *, struct qstr *);",
            "static int ncp_compare_dentry(const struct dentry *, const struct dentry *,\n\t\tunsigned int, const char *, const struct qstr *);",
            "static int ncp_delete_dentry(const struct dentry *);",
            "static void ncp_d_prune(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic int ncp_readdir(struct file *, struct dir_context *);\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_hash_dentry(const struct dentry *, struct qstr *);\nstatic int ncp_compare_dentry(const struct dentry *, const struct dentry *,\n\t\tunsigned int, const char *, const struct qstr *);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int\nncp_fill_cache(struct file *file, struct dir_context *ctx,\n\t\tstruct ncp_cache_control *ctrl, struct ncp_entry_info *entry,\n\t\tint inval_childs)\n{\n\tstruct dentry *newdent, *dentry = file->f_path.dentry;\n\tstruct inode *dir = dentry->d_inode;\n\tstruct ncp_cache_control ctl = *ctrl;\n\tstruct qstr qname;\n\tint valid = 0;\n\tint hashed = 0;\n\tino_t ino = 0;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tqname.len = sizeof(__name);\n\tif (ncp_vol2io(NCP_SERVER(dir), __name, &qname.len,\n\t\t\tentry->i.entryName, entry->i.nameLen,\n\t\t\t!ncp_preserve_entry_case(dir, entry->i.NSCreator)))\n\t\treturn 1; /* I'm not sure */\n\n\tqname.name = __name;\n\n\tnewdent = d_hash_and_lookup(dentry, &qname);\n\tif (unlikely(IS_ERR(newdent)))\n\t\tgoto end_advance;\n\tif (!newdent) {\n\t\tnewdent = d_alloc(dentry, &qname);\n\t\tif (!newdent)\n\t\t\tgoto end_advance;\n\t} else {\n\t\thashed = 1;\n\n\t\t/* If case sensitivity changed for this volume, all entries below this one\n\t\t   should be thrown away.  This entry itself is not affected, as its case\n\t\t   sensitivity is controlled by its own parent. */\n\t\tif (inval_childs)\n\t\t\tshrink_dcache_parent(newdent);\n\n\t\t/*\n\t\t * NetWare's OS2 namespace is case preserving yet case\n\t\t * insensitive.  So we update dentry's name as received from\n\t\t * server. Parent dir's i_mutex is locked because we're in\n\t\t * readdir.\n\t\t */\n\t\tdentry_update_name_case(newdent, &qname);\n\t}\n\n\tif (!newdent->d_inode) {\n\t\tstruct inode *inode;\n\n\t\tentry->opened = 0;\n\t\tentry->ino = iunique(dir->i_sb, 2);\n\t\tinode = ncp_iget(dir->i_sb, entry);\n\t\tif (inode) {\n\t\t\td_instantiate(newdent, inode);\n\t\t\tif (!hashed)\n\t\t\t\td_rehash(newdent);\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tNCP_FINFO(inode)->flags &= ~NCPI_DIR_CACHE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t} else {\n\t\tstruct inode *inode = newdent->d_inode;\n\n\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\tncp_update_inode2(inode, entry);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\tif (ctl.idx >= NCP_DIRCACHE_SIZE) {\n\t\tif (ctl.page) {\n\t\t\tkunmap(ctl.page);\n\t\t\tSetPageUptodate(ctl.page);\n\t\t\tunlock_page(ctl.page);\n\t\t\tpage_cache_release(ctl.page);\n\t\t}\n\t\tctl.cache = NULL;\n\t\tctl.idx  -= NCP_DIRCACHE_SIZE;\n\t\tctl.ofs  += 1;\n\t\tctl.page  = grab_cache_page(&dir->i_data, ctl.ofs);\n\t\tif (ctl.page)\n\t\t\tctl.cache = kmap(ctl.page);\n\t}\n\tif (ctl.cache) {\n\t\tif (newdent->d_inode) {\n\t\t\tnewdent->d_fsdata = newdent;\n\t\t\tctl.cache->dentry[ctl.idx] = newdent;\n\t\t\tino = newdent->d_inode->i_ino;\n\t\t\tncp_new_dentry(newdent);\n\t\t}\n \t\tvalid = 1;\n\t}\n\tdput(newdent);\nend_advance:\n\tif (!valid)\n\t\tctl.valid = 0;\n\tif (!ctl.filled && (ctl.fpos == ctx->pos)) {\n\t\tif (!ino)\n\t\t\tino = iunique(dir->i_sb, 2);\n\t\tctl.filled = !dir_emit(ctx, qname.name, qname.len,\n\t\t\t\t     ino, DT_UNKNOWN);\n\t\tif (!ctl.filled)\n\t\t\tctx->pos += 1;\n\t}\n\tctl.fpos += 1;\n\tctl.idx  += 1;\n\t*ctrl = ctl;\n\treturn (ctl.valid || !ctl.filled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_update_known_namespace",
          "args": [
            "server",
            "entry.i.volNumber",
            "NULL"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_known_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "525-539",
          "snippet": "int\nncp_update_known_namespace(struct ncp_server *server, __u8 volume, int *ret_ns)\n{\n\tint ns = ncp_get_known_namespace(server, volume);\n\n\tif (ret_ns)\n\t\t*ret_ns = ns;\n\n\tncp_dbg(1, \"namespace[%d] = %d\\n\", volume, server->name_space[volume]);\n\n\tif (server->name_space[volume] == ns)\n\t\treturn 0;\n\tserver->name_space[volume] = ns;\n\treturn 1;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_update_known_namespace(struct ncp_server *server, __u8 volume, int *ret_ns)\n{\n\tint ns = ncp_get_known_namespace(server, volume);\n\n\tif (ret_ns)\n\t\t*ret_ns = ns;\n\n\tncp_dbg(1, \"namespace[%d] = %d\\n\", volume, server->name_space[volume]);\n\n\tif (server->name_space[volume] == ns)\n\t\treturn 0;\n\tserver->name_space[volume] = ns;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"could not lookup vol %s\\n\"",
            "info.volume_name"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_lookup_volume",
          "args": [
            "server",
            "info.volume_name",
            "&entry.i"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_lookup_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "622-643",
          "snippet": "int\nncp_lookup_volume(struct ncp_server *server,\n\t\t  const char *volname, struct nw_info_struct *target)\n{\n\tint result;\n\n\tmemset(target, 0, sizeof(*target));\n\tresult = ncp_get_volume_root(server, volname,\n\t\t\t&target->volNumber, &target->dirEntNum, &target->DosDirNum);\n\tif (result) {\n\t\treturn result;\n\t}\n\tncp_update_known_namespace(server, target->volNumber, NULL);\n\ttarget->nameLen = strlen(volname);\n\tmemcpy(target->entryName, volname, target->nameLen+1);\n\ttarget->attributes = aDIR;\n\t/* set dates to Jan 1, 1986  00:00 */\n\ttarget->creationTime = target->modifyTime = cpu_to_le16(0x0000);\n\ttarget->creationDate = target->modifyDate = target->lastAccessDate = cpu_to_le16(0x0C21);\n\ttarget->nfs.mode = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_lookup_volume(struct ncp_server *server,\n\t\t  const char *volname, struct nw_info_struct *target)\n{\n\tint result;\n\n\tmemset(target, 0, sizeof(*target));\n\tresult = ncp_get_volume_root(server, volname,\n\t\t\t&target->volNumber, &target->dirEntNum, &target->DosDirNum);\n\tif (result) {\n\t\treturn result;\n\t}\n\tncp_update_known_namespace(server, target->volNumber, NULL);\n\ttarget->nameLen = strlen(volname);\n\tmemcpy(target->entryName, volname, target->nameLen+1);\n\ttarget->attributes = aDIR;\n\t/* set dates to Jan 1, 1986  00:00 */\n\ttarget->creationTime = target->modifyTime = cpu_to_le16(0x0000);\n\ttarget->creationDate = target->modifyDate = target->lastAccessDate = cpu_to_le16(0x0C21);\n\ttarget->nfs.mode = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"found vol: %s\\n\"",
            "info.volume_name"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "info.volume_name"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_get_volume_info_with_number",
          "args": [
            "server",
            "i",
            "&info"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_get_volume_info_with_number",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "204-236",
          "snippet": "int ncp_get_volume_info_with_number(struct ncp_server* server,\n\t\t\t     int n, struct ncp_volume_info* target) {\n\tint result;\n\tint len;\n\n\tncp_init_request_s(server, 44);\n\tncp_add_byte(server, n);\n\n\tif ((result = ncp_request(server, 22)) != 0) {\n\t\tgoto out;\n\t}\n\ttarget->total_blocks = ncp_reply_dword_lh(server, 0);\n\ttarget->free_blocks = ncp_reply_dword_lh(server, 4);\n\ttarget->purgeable_blocks = ncp_reply_dword_lh(server, 8);\n\ttarget->not_yet_purgeable_blocks = ncp_reply_dword_lh(server, 12);\n\ttarget->total_dir_entries = ncp_reply_dword_lh(server, 16);\n\ttarget->available_dir_entries = ncp_reply_dword_lh(server, 20);\n\ttarget->sectors_per_block = ncp_reply_byte(server, 28);\n\n\tmemset(&(target->volume_name), 0, sizeof(target->volume_name));\n\n\tresult = -EIO;\n\tlen = ncp_reply_byte(server, 29);\n\tif (len > NCP_VOLNAME_LEN) {\n\t\tncp_dbg(1, \"volume name too long: %d\\n\", len);\n\t\tgoto out;\n\t}\n\tmemcpy(&(target->volume_name), ncp_reply_data(server, 30), len);\n\tresult = 0;\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_get_volume_info_with_number(struct ncp_server* server,\n\t\t\t     int n, struct ncp_volume_info* target) {\n\tint result;\n\tint len;\n\n\tncp_init_request_s(server, 44);\n\tncp_add_byte(server, n);\n\n\tif ((result = ncp_request(server, 22)) != 0) {\n\t\tgoto out;\n\t}\n\ttarget->total_blocks = ncp_reply_dword_lh(server, 0);\n\ttarget->free_blocks = ncp_reply_dword_lh(server, 4);\n\ttarget->purgeable_blocks = ncp_reply_dword_lh(server, 8);\n\ttarget->not_yet_purgeable_blocks = ncp_reply_dword_lh(server, 12);\n\ttarget->total_dir_entries = ncp_reply_dword_lh(server, 16);\n\ttarget->available_dir_entries = ncp_reply_dword_lh(server, 20);\n\ttarget->sectors_per_block = ncp_reply_byte(server, 28);\n\n\tmemset(&(target->volume_name), 0, sizeof(target->volume_name));\n\n\tresult = -EIO;\n\tlen = ncp_reply_byte(server, 29);\n\tif (len > NCP_VOLNAME_LEN) {\n\t\tncp_dbg(1, \"volume name too long: %d\\n\", len);\n\t\tgoto out;\n\t}\n\tmemcpy(&(target->volume_name), ncp_reply_data(server, 30), len);\n\tresult = 0;\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "1",
            "\"pos=%ld\\n\"",
            "(unsigned long)ctx->pos"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic int ncp_readdir(struct file *, struct dir_context *);\n\nstatic void\nncp_read_volume_list(struct file *file, struct dir_context *ctx,\n\t\t\tstruct ncp_cache_control *ctl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tstruct ncp_volume_info info;\n\tstruct ncp_entry_info entry;\n\tint i;\n\n\tncp_dbg(1, \"pos=%ld\\n\", (unsigned long)ctx->pos);\n\n\tfor (i = 0; i < NCP_NUMBER_OF_VOLUMES; i++) {\n\t\tint inval_dentry;\n\n\t\tif (ncp_get_volume_info_with_number(server, i, &info) != 0)\n\t\t\treturn;\n\t\tif (!strlen(info.volume_name))\n\t\t\tcontinue;\n\n\t\tncp_dbg(1, \"found vol: %s\\n\", info.volume_name);\n\n\t\tif (ncp_lookup_volume(server, info.volume_name,\n\t\t\t\t\t&entry.i)) {\n\t\t\tncp_dbg(1, \"could not lookup vol %s\\n\",\n\t\t\t\tinfo.volume_name);\n\t\t\tcontinue;\n\t\t}\n\t\tinval_dentry = ncp_update_known_namespace(server, entry.i.volNumber, NULL);\n\t\tentry.volume = entry.i.volNumber;\n\t\tif (!ncp_fill_cache(file, ctx, ctl, &entry, inval_dentry))\n\t\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "ncp_fill_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "577-686",
    "snippet": "static int\nncp_fill_cache(struct file *file, struct dir_context *ctx,\n\t\tstruct ncp_cache_control *ctrl, struct ncp_entry_info *entry,\n\t\tint inval_childs)\n{\n\tstruct dentry *newdent, *dentry = file->f_path.dentry;\n\tstruct inode *dir = dentry->d_inode;\n\tstruct ncp_cache_control ctl = *ctrl;\n\tstruct qstr qname;\n\tint valid = 0;\n\tint hashed = 0;\n\tino_t ino = 0;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tqname.len = sizeof(__name);\n\tif (ncp_vol2io(NCP_SERVER(dir), __name, &qname.len,\n\t\t\tentry->i.entryName, entry->i.nameLen,\n\t\t\t!ncp_preserve_entry_case(dir, entry->i.NSCreator)))\n\t\treturn 1; /* I'm not sure */\n\n\tqname.name = __name;\n\n\tnewdent = d_hash_and_lookup(dentry, &qname);\n\tif (unlikely(IS_ERR(newdent)))\n\t\tgoto end_advance;\n\tif (!newdent) {\n\t\tnewdent = d_alloc(dentry, &qname);\n\t\tif (!newdent)\n\t\t\tgoto end_advance;\n\t} else {\n\t\thashed = 1;\n\n\t\t/* If case sensitivity changed for this volume, all entries below this one\n\t\t   should be thrown away.  This entry itself is not affected, as its case\n\t\t   sensitivity is controlled by its own parent. */\n\t\tif (inval_childs)\n\t\t\tshrink_dcache_parent(newdent);\n\n\t\t/*\n\t\t * NetWare's OS2 namespace is case preserving yet case\n\t\t * insensitive.  So we update dentry's name as received from\n\t\t * server. Parent dir's i_mutex is locked because we're in\n\t\t * readdir.\n\t\t */\n\t\tdentry_update_name_case(newdent, &qname);\n\t}\n\n\tif (!newdent->d_inode) {\n\t\tstruct inode *inode;\n\n\t\tentry->opened = 0;\n\t\tentry->ino = iunique(dir->i_sb, 2);\n\t\tinode = ncp_iget(dir->i_sb, entry);\n\t\tif (inode) {\n\t\t\td_instantiate(newdent, inode);\n\t\t\tif (!hashed)\n\t\t\t\td_rehash(newdent);\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tNCP_FINFO(inode)->flags &= ~NCPI_DIR_CACHE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t} else {\n\t\tstruct inode *inode = newdent->d_inode;\n\n\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\tncp_update_inode2(inode, entry);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\tif (ctl.idx >= NCP_DIRCACHE_SIZE) {\n\t\tif (ctl.page) {\n\t\t\tkunmap(ctl.page);\n\t\t\tSetPageUptodate(ctl.page);\n\t\t\tunlock_page(ctl.page);\n\t\t\tpage_cache_release(ctl.page);\n\t\t}\n\t\tctl.cache = NULL;\n\t\tctl.idx  -= NCP_DIRCACHE_SIZE;\n\t\tctl.ofs  += 1;\n\t\tctl.page  = grab_cache_page(&dir->i_data, ctl.ofs);\n\t\tif (ctl.page)\n\t\t\tctl.cache = kmap(ctl.page);\n\t}\n\tif (ctl.cache) {\n\t\tif (newdent->d_inode) {\n\t\t\tnewdent->d_fsdata = newdent;\n\t\t\tctl.cache->dentry[ctl.idx] = newdent;\n\t\t\tino = newdent->d_inode->i_ino;\n\t\t\tncp_new_dentry(newdent);\n\t\t}\n \t\tvalid = 1;\n\t}\n\tdput(newdent);\nend_advance:\n\tif (!valid)\n\t\tctl.valid = 0;\n\tif (!ctl.filled && (ctl.fpos == ctx->pos)) {\n\t\tif (!ino)\n\t\t\tino = iunique(dir->i_sb, 2);\n\t\tctl.filled = !dir_emit(ctx, qname.name, qname.len,\n\t\t\t\t     ino, DT_UNKNOWN);\n\t\tif (!ctl.filled)\n\t\t\tctx->pos += 1;\n\t}\n\tctl.fpos += 1;\n\tctl.idx  += 1;\n\t*ctrl = ctl;\n\treturn (ctl.valid || !ctl.filled);\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
      "static void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
      "static int ncp_readdir(struct file *, struct dir_context *);",
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_hash_dentry(const struct dentry *, struct qstr *);",
      "static int ncp_compare_dentry(const struct dentry *, const struct dentry *,\n\t\tunsigned int, const char *, const struct qstr *);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "qname.name",
            "qname.len",
            "ino",
            "DT_UNKNOWN"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iunique",
          "args": [
            "dir->i_sb",
            "2"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "iunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1150-1170",
          "snippet": "ino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nino_t iunique(struct super_block *sb, ino_t max_reserved)\n{\n\t/*\n\t * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW\n\t * error if st_ino won't fit in target struct field. Use 32bit counter\n\t * here to attempt to avoid that.\n\t */\n\tstatic DEFINE_SPINLOCK(iunique_lock);\n\tstatic unsigned int counter;\n\tino_t res;\n\n\tspin_lock(&iunique_lock);\n\tdo {\n\t\tif (counter <= max_reserved)\n\t\t\tcounter = max_reserved + 1;\n\t\tres = counter++;\n\t} while (!test_inode_iunique(sb, res));\n\tspin_unlock(&iunique_lock);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "newdent"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_new_dentry",
          "args": [
            "newdent"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_new_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "181-185",
          "snippet": "static inline void\nncp_new_dentry(struct dentry* dentry)\n{\n\tdentry->d_time = jiffies;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void\nncp_new_dentry(struct dentry* dentry)\n{\n\tdentry->d_time = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "ctl.page"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "&dir->i_data",
            "ctl.ofs"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "ctl.page"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "ctl.page"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "ctl.page"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "ctl.page"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_update_inode2",
          "args": [
            "inode",
            "entry"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_inode2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "211-221",
          "snippet": "void ncp_update_inode2(struct inode* inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->flags = 0;\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tNCP_FINFO(inode)->nwattr = nwinfo->i.attributes;\n\t\tncp_update_attrs(inode, nwinfo);\n\t}\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_dirent(inode, nwinfo);\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nvoid ncp_update_inode2(struct inode* inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->flags = 0;\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tNCP_FINFO(inode)->nwattr = nwinfo->i.attributes;\n\t\tncp_update_attrs(inode, nwinfo);\n\t}\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_dirent(inode, nwinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&inode->i_mutex",
            "I_MUTEX_CHILD"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_rehash",
          "args": [
            "newdent"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2403-2408",
          "snippet": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "newdent",
            "inode"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_iget",
          "args": [
            "dir->i_sb",
            "entry"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "256-295",
          "snippet": "struct inode * \nncp_iget(struct super_block *sb, struct ncp_entry_info *info)\n{\n\tstruct inode *inode;\n\n\tif (info == NULL) {\n\t\tpr_err(\"%s: info is NULL\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, info->opened);\n\n\t\tinode->i_ino = info->ino;\n\t\tncp_set_attr(inode, info);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_file_inode_operations;\n\t\t\tinode->i_fop = &ncp_file_operations;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_dir_inode_operations;\n\t\t\tinode->i_fop = &ncp_dir_operations;\n#ifdef CONFIG_NCPFS_NFS_NS\n\t\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) || S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tnew_decode_dev(info->i.nfs.rdev));\n#endif\n#if defined(CONFIG_NCPFS_EXTRAS) || defined(CONFIG_NCPFS_NFS_NS)\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &ncp_symlink_aops;\n#endif\n\t\t} else {\n\t\t\tmake_bad_inode(inode);\n\t\t}\n\t\tinsert_inode_hash(inode);\n\t} else\n\t\tpr_err(\"%s: iget failed!\\n\", __func__);\n\treturn inode;\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);",
            "static void ncp_put_super(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\nstatic void ncp_put_super(struct super_block *);\n\nstruct inode * \nncp_iget(struct super_block *sb, struct ncp_entry_info *info)\n{\n\tstruct inode *inode;\n\n\tif (info == NULL) {\n\t\tpr_err(\"%s: info is NULL\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\tinode = new_inode(sb);\n\tif (inode) {\n\t\tatomic_set(&NCP_FINFO(inode)->opened, info->opened);\n\n\t\tinode->i_ino = info->ino;\n\t\tncp_set_attr(inode, info);\n\t\tif (S_ISREG(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_file_inode_operations;\n\t\t\tinode->i_fop = &ncp_file_operations;\n\t\t} else if (S_ISDIR(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_dir_inode_operations;\n\t\t\tinode->i_fop = &ncp_dir_operations;\n#ifdef CONFIG_NCPFS_NFS_NS\n\t\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) || S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\tnew_decode_dev(info->i.nfs.rdev));\n#endif\n#if defined(CONFIG_NCPFS_EXTRAS) || defined(CONFIG_NCPFS_NFS_NS)\n\t\t} else if (S_ISLNK(inode->i_mode)) {\n\t\t\tinode->i_op = &ncp_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &ncp_symlink_aops;\n#endif\n\t\t} else {\n\t\t\tmake_bad_inode(inode);\n\t\t}\n\t\tinsert_inode_hash(inode);\n\t} else\n\t\tpr_err(\"%s: iget failed!\\n\", __func__);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dentry_update_name_case",
          "args": [
            "newdent",
            "&qname"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_update_name_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2425-2435",
          "snippet": "void dentry_update_name_case(struct dentry *dentry, struct qstr *name)\n{\n\tBUG_ON(!mutex_is_locked(&dentry->d_parent->d_inode->i_mutex));\n\tBUG_ON(dentry->d_name.len != name->len); /* d_lookup gives this */\n\n\tspin_lock(&dentry->d_lock);\n\twrite_seqcount_begin(&dentry->d_seq);\n\tmemcpy((unsigned char *)dentry->d_name.name, name->name, name->len);\n\twrite_seqcount_end(&dentry->d_seq);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dentry_update_name_case(struct dentry *dentry, struct qstr *name)\n{\n\tBUG_ON(!mutex_is_locked(&dentry->d_parent->d_inode->i_mutex));\n\tBUG_ON(dentry->d_name.len != name->len); /* d_lookup gives this */\n\n\tspin_lock(&dentry->d_lock);\n\twrite_seqcount_begin(&dentry->d_seq);\n\tmemcpy((unsigned char *)dentry->d_name.name, name->name, name->len);\n\twrite_seqcount_end(&dentry->d_seq);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shrink_dcache_parent",
          "args": [
            "newdent"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_dcache_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1361-1377",
          "snippet": "void shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid shrink_dcache_parent(struct dentry *parent)\n{\n\tfor (;;) {\n\t\tstruct select_data data;\n\n\t\tINIT_LIST_HEAD(&data.dispose);\n\t\tdata.start = parent;\n\t\tdata.found = 0;\n\n\t\td_walk(parent, &data, select_collect, NULL);\n\t\tif (!data.found)\n\t\t\tbreak;\n\n\t\tshrink_dentry_list(&data.dispose);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "dentry",
            "&qname"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "IS_ERR(newdent)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "newdent"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_hash_and_lookup",
          "args": [
            "dentry",
            "&qname"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_vol2io",
          "args": [
            "NCP_SERVER(dir)",
            "__name",
            "&qname.len",
            "entry->i.entryName",
            "entry->i.nameLen",
            "!ncp_preserve_entry_case(dir, entry->i.NSCreator)"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_preserve_entry_case",
          "args": [
            "dir",
            "entry->i.NSCreator"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_preserve_entry_case",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "93-106",
          "snippet": "static inline int ncp_preserve_entry_case(struct inode *i, __u32 nscreator)\n{\n#ifdef CONFIG_NCPFS_SMALLDOS\n\tint ns = ncp_namespace(i);\n\n\tif ((ns == NW_NS_DOS)\n#ifdef CONFIG_NCPFS_OS2_NS\n\t\t|| ((ns == NW_NS_OS2) && (nscreator == NW_NS_DOS))\n#endif /* CONFIG_NCPFS_OS2_NS */\n\t   )\n\t\treturn 0;\n#endif /* CONFIG_NCPFS_SMALLDOS */\n\treturn 1;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int ncp_preserve_entry_case(struct inode *i, __u32 nscreator)\n{\n#ifdef CONFIG_NCPFS_SMALLDOS\n\tint ns = ncp_namespace(i);\n\n\tif ((ns == NW_NS_DOS)\n#ifdef CONFIG_NCPFS_OS2_NS\n\t\t|| ((ns == NW_NS_OS2) && (nscreator == NW_NS_DOS))\n#endif /* CONFIG_NCPFS_OS2_NS */\n\t   )\n\t\treturn 0;\n#endif /* CONFIG_NCPFS_SMALLDOS */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic int ncp_readdir(struct file *, struct dir_context *);\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_hash_dentry(const struct dentry *, struct qstr *);\nstatic int ncp_compare_dentry(const struct dentry *, const struct dentry *,\n\t\tunsigned int, const char *, const struct qstr *);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int\nncp_fill_cache(struct file *file, struct dir_context *ctx,\n\t\tstruct ncp_cache_control *ctrl, struct ncp_entry_info *entry,\n\t\tint inval_childs)\n{\n\tstruct dentry *newdent, *dentry = file->f_path.dentry;\n\tstruct inode *dir = dentry->d_inode;\n\tstruct ncp_cache_control ctl = *ctrl;\n\tstruct qstr qname;\n\tint valid = 0;\n\tint hashed = 0;\n\tino_t ino = 0;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tqname.len = sizeof(__name);\n\tif (ncp_vol2io(NCP_SERVER(dir), __name, &qname.len,\n\t\t\tentry->i.entryName, entry->i.nameLen,\n\t\t\t!ncp_preserve_entry_case(dir, entry->i.NSCreator)))\n\t\treturn 1; /* I'm not sure */\n\n\tqname.name = __name;\n\n\tnewdent = d_hash_and_lookup(dentry, &qname);\n\tif (unlikely(IS_ERR(newdent)))\n\t\tgoto end_advance;\n\tif (!newdent) {\n\t\tnewdent = d_alloc(dentry, &qname);\n\t\tif (!newdent)\n\t\t\tgoto end_advance;\n\t} else {\n\t\thashed = 1;\n\n\t\t/* If case sensitivity changed for this volume, all entries below this one\n\t\t   should be thrown away.  This entry itself is not affected, as its case\n\t\t   sensitivity is controlled by its own parent. */\n\t\tif (inval_childs)\n\t\t\tshrink_dcache_parent(newdent);\n\n\t\t/*\n\t\t * NetWare's OS2 namespace is case preserving yet case\n\t\t * insensitive.  So we update dentry's name as received from\n\t\t * server. Parent dir's i_mutex is locked because we're in\n\t\t * readdir.\n\t\t */\n\t\tdentry_update_name_case(newdent, &qname);\n\t}\n\n\tif (!newdent->d_inode) {\n\t\tstruct inode *inode;\n\n\t\tentry->opened = 0;\n\t\tentry->ino = iunique(dir->i_sb, 2);\n\t\tinode = ncp_iget(dir->i_sb, entry);\n\t\tif (inode) {\n\t\t\td_instantiate(newdent, inode);\n\t\t\tif (!hashed)\n\t\t\t\td_rehash(newdent);\n\t\t} else {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tNCP_FINFO(inode)->flags &= ~NCPI_DIR_CACHE;\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t}\n\t} else {\n\t\tstruct inode *inode = newdent->d_inode;\n\n\t\tmutex_lock_nested(&inode->i_mutex, I_MUTEX_CHILD);\n\t\tncp_update_inode2(inode, entry);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\n\tif (ctl.idx >= NCP_DIRCACHE_SIZE) {\n\t\tif (ctl.page) {\n\t\t\tkunmap(ctl.page);\n\t\t\tSetPageUptodate(ctl.page);\n\t\t\tunlock_page(ctl.page);\n\t\t\tpage_cache_release(ctl.page);\n\t\t}\n\t\tctl.cache = NULL;\n\t\tctl.idx  -= NCP_DIRCACHE_SIZE;\n\t\tctl.ofs  += 1;\n\t\tctl.page  = grab_cache_page(&dir->i_data, ctl.ofs);\n\t\tif (ctl.page)\n\t\t\tctl.cache = kmap(ctl.page);\n\t}\n\tif (ctl.cache) {\n\t\tif (newdent->d_inode) {\n\t\t\tnewdent->d_fsdata = newdent;\n\t\t\tctl.cache->dentry[ctl.idx] = newdent;\n\t\t\tino = newdent->d_inode->i_ino;\n\t\t\tncp_new_dentry(newdent);\n\t\t}\n \t\tvalid = 1;\n\t}\n\tdput(newdent);\nend_advance:\n\tif (!valid)\n\t\tctl.valid = 0;\n\tif (!ctl.filled && (ctl.fpos == ctx->pos)) {\n\t\tif (!ino)\n\t\t\tino = iunique(dir->i_sb, 2);\n\t\tctl.filled = !dir_emit(ctx, qname.name, qname.len,\n\t\t\t\t     ino, DT_UNKNOWN);\n\t\tif (!ctl.filled)\n\t\t\tctx->pos += 1;\n\t}\n\tctl.fpos += 1;\n\tctl.idx  += 1;\n\t*ctrl = ctl;\n\treturn (ctl.valid || !ctl.filled);\n}"
  },
  {
    "function_name": "ncp_d_prune",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "570-575",
    "snippet": "static void ncp_d_prune(struct dentry *dentry)\n{\n\tif (!dentry->d_fsdata)\t/* not referenced from page cache */\n\t\treturn;\n\tNCP_FINFO(dentry->d_parent->d_inode)->flags &= ~NCPI_DIR_CACHE;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "dentry->d_parent->d_inode"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic void ncp_d_prune(struct dentry *dentry)\n{\n\tif (!dentry->d_fsdata)\t/* not referenced from page cache */\n\t\treturn;\n\tNCP_FINFO(dentry->d_parent->d_inode)->flags &= ~NCPI_DIR_CACHE;\n}"
  },
  {
    "function_name": "ncp_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "418-568",
    "snippet": "static int ncp_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct page *page = NULL;\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tunion  ncp_dir_cache *cache = NULL;\n\tstruct ncp_cache_control ctl;\n\tint result, mtime_valid = 0;\n\ttime_t mtime = 0;\n\n\tctl.page  = NULL;\n\tctl.cache = NULL;\n\n\tncp_dbg(2, \"reading %pD2, pos=%d\\n\", file, (int)ctx->pos);\n\n\tresult = -EIO;\n\t/* Do not generate '.' and '..' when server is dead. */\n\tif (!ncp_conn_valid(server))\n\t\tgoto out;\n\n\tresult = 0;\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tpage = grab_cache_page(&inode->i_data, 0);\n\tif (!page)\n\t\tgoto read_really;\n\n\tctl.cache = cache = kmap(page);\n\tctl.head  = cache->head;\n\n\tif (!PageUptodate(page) || !ctl.head.eof)\n\t\tgoto init_cache;\n\n\tif (ctx->pos == 2) {\n\t\tif (jiffies - ctl.head.time >= NCP_MAX_AGE(server))\n\t\t\tgoto init_cache;\n\n\t\tmtime = ncp_obtain_mtime(dentry);\n\t\tmtime_valid = 1;\n\t\tif ((!mtime) || (mtime != ctl.head.mtime))\n\t\t\tgoto init_cache;\n\t}\n\n\tif (ctx->pos > ctl.head.end)\n\t\tgoto finished;\n\n\tctl.fpos = ctx->pos + (NCP_DIRCACHE_START - 2);\n\tctl.ofs  = ctl.fpos / NCP_DIRCACHE_SIZE;\n\tctl.idx  = ctl.fpos % NCP_DIRCACHE_SIZE;\n\n\tfor (;;) {\n\t\tif (ctl.ofs != 0) {\n\t\t\tctl.page = find_lock_page(&inode->i_data, ctl.ofs);\n\t\t\tif (!ctl.page)\n\t\t\t\tgoto invalid_cache;\n\t\t\tctl.cache = kmap(ctl.page);\n\t\t\tif (!PageUptodate(ctl.page))\n\t\t\t\tgoto invalid_cache;\n\t\t}\n\t\twhile (ctl.idx < NCP_DIRCACHE_SIZE) {\n\t\t\tstruct dentry *dent;\n\t\t\tbool over;\n\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tif (!(NCP_FINFO(inode)->flags & NCPI_DIR_CACHE)) { \n\t\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\t\tgoto invalid_cache;\n\t\t\t}\n\t\t\tdent = ctl.cache->dentry[ctl.idx];\n\t\t\tif (unlikely(!lockref_get_not_dead(&dent->d_lockref))) {\n\t\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\t\tgoto invalid_cache;\n\t\t\t}\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (!dent->d_inode) {\n\t\t\t\tdput(dent);\n\t\t\t\tgoto invalid_cache;\n\t\t\t}\n\t\t\tover = !dir_emit(ctx, dent->d_name.name,\n\t\t\t\t\tdent->d_name.len,\n\t\t\t\t\tdent->d_inode->i_ino, DT_UNKNOWN);\n\t\t\tdput(dent);\n\t\t\tif (over)\n\t\t\t\tgoto finished;\n\t\t\tctx->pos += 1;\n\t\t\tctl.idx += 1;\n\t\t\tif (ctx->pos > ctl.head.end)\n\t\t\t\tgoto finished;\n\t\t}\n\t\tif (ctl.page) {\n\t\t\tkunmap(ctl.page);\n\t\t\tSetPageUptodate(ctl.page);\n\t\t\tunlock_page(ctl.page);\n\t\t\tpage_cache_release(ctl.page);\n\t\t\tctl.page = NULL;\n\t\t}\n\t\tctl.idx  = 0;\n\t\tctl.ofs += 1;\n\t}\ninvalid_cache:\n\tif (ctl.page) {\n\t\tkunmap(ctl.page);\n\t\tunlock_page(ctl.page);\n\t\tpage_cache_release(ctl.page);\n\t\tctl.page = NULL;\n\t}\n\tctl.cache = cache;\ninit_cache:\n\tncp_invalidate_dircache_entries(dentry);\n\tif (!mtime_valid) {\n\t\tmtime = ncp_obtain_mtime(dentry);\n\t\tmtime_valid = 1;\n\t}\n\tctl.head.mtime = mtime;\n\tctl.head.time = jiffies;\n\tctl.head.eof = 0;\n\tctl.fpos = 2;\n\tctl.ofs = 0;\n\tctl.idx = NCP_DIRCACHE_START;\n\tctl.filled = 0;\n\tctl.valid  = 1;\nread_really:\n\tspin_lock(&dentry->d_lock);\n\tNCP_FINFO(inode)->flags |= NCPI_DIR_CACHE;\n\tspin_unlock(&dentry->d_lock);\n\tif (ncp_is_server_root(inode)) {\n\t\tncp_read_volume_list(file, ctx, &ctl);\n\t} else {\n\t\tncp_do_readdir(file, ctx, &ctl);\n\t}\n\tctl.head.end = ctl.fpos - 1;\n\tctl.head.eof = ctl.valid;\nfinished:\n\tif (ctl.page) {\n\t\tkunmap(ctl.page);\n\t\tSetPageUptodate(ctl.page);\n\t\tunlock_page(ctl.page);\n\t\tpage_cache_release(ctl.page);\n\t}\n\tif (page) {\n\t\tcache->head = ctl.head;\n\t\tkunmap(page);\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\nout:\n\treturn result;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
      "static void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
      "static int ncp_readdir(struct file *, struct dir_context *);",
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "ctl.page"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "ctl.page"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "ctl.page"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_do_readdir",
          "args": [
            "file",
            "ctx",
            "&ctl"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_do_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "723-783",
          "snippet": "static void\nncp_do_readdir(struct file *file, struct dir_context *ctx,\n\t\t\t\t\t\tstruct ncp_cache_control *ctl)\n{\n\tstruct inode *dir = file_inode(file);\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct nw_search_sequence seq;\n\tstruct ncp_entry_info entry;\n\tint err;\n\tvoid* buf;\n\tint more;\n\tsize_t bufsize;\n\n\tncp_dbg(1, \"%pD2, fpos=%ld\\n\", file, (unsigned long)ctx->pos);\n\tncp_vdbg(\"init %pD, volnum=%d, dirent=%u\\n\",\n\t\t file, NCP_FINFO(dir)->volNumber, NCP_FINFO(dir)->dirEntNum);\n\n\terr = ncp_initialize_search(server, dir, &seq);\n\tif (err) {\n\t\tncp_dbg(1, \"init failed, err=%d\\n\", err);\n\t\treturn;\n\t}\n\t/* We MUST NOT use server->buffer_size handshaked with server if we are\n\t   using UDP, as for UDP server uses max. buffer size determined by\n\t   MTU, and for TCP server uses hardwired value 65KB (== 66560 bytes). \n\t   So we use 128KB, just to be sure, as there is no way how to know\n\t   this value in advance. */\n\tbufsize = 131072;\n\tbuf = vmalloc(bufsize);\n\tif (!buf)\n\t\treturn;\n\tdo {\n\t\tint cnt;\n\t\tchar* rpl;\n\t\tsize_t rpls;\n\n\t\terr = ncp_search_for_fileset(server, &seq, &more, &cnt, buf, bufsize, &rpl, &rpls);\n\t\tif (err)\t\t/* Error */\n\t\t\tbreak;\n\t\tif (!cnt)\t\t/* prevent endless loop */\n\t\t\tbreak;\n\t\twhile (cnt--) {\n\t\t\tsize_t onerpl;\n\t\t\t\n\t\t\tif (rpls < offsetof(struct nw_info_struct, entryName))\n\t\t\t\tbreak;\t/* short packet */\n\t\t\tncp_extract_file_info(rpl, &entry.i);\n\t\t\tonerpl = offsetof(struct nw_info_struct, entryName) + entry.i.nameLen;\n\t\t\tif (rpls < onerpl)\n\t\t\t\tbreak;\t/* short packet */\n\t\t\t(void)ncp_obtain_nfs_info(server, &entry.i);\n\t\t\trpl += onerpl;\n\t\t\trpls -= onerpl;\n\t\t\tentry.volume = entry.i.volNumber;\n\t\t\tif (!ncp_fill_cache(file, ctx, ctl, &entry, 0))\n\t\t\t\tbreak;\n\t\t}\n\t} while (more);\n\tvfree(buf);\n\treturn;\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
            "static void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
            "static int ncp_readdir(struct file *, struct dir_context *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic int ncp_readdir(struct file *, struct dir_context *);\n\nstatic void\nncp_do_readdir(struct file *file, struct dir_context *ctx,\n\t\t\t\t\t\tstruct ncp_cache_control *ctl)\n{\n\tstruct inode *dir = file_inode(file);\n\tstruct ncp_server *server = NCP_SERVER(dir);\n\tstruct nw_search_sequence seq;\n\tstruct ncp_entry_info entry;\n\tint err;\n\tvoid* buf;\n\tint more;\n\tsize_t bufsize;\n\n\tncp_dbg(1, \"%pD2, fpos=%ld\\n\", file, (unsigned long)ctx->pos);\n\tncp_vdbg(\"init %pD, volnum=%d, dirent=%u\\n\",\n\t\t file, NCP_FINFO(dir)->volNumber, NCP_FINFO(dir)->dirEntNum);\n\n\terr = ncp_initialize_search(server, dir, &seq);\n\tif (err) {\n\t\tncp_dbg(1, \"init failed, err=%d\\n\", err);\n\t\treturn;\n\t}\n\t/* We MUST NOT use server->buffer_size handshaked with server if we are\n\t   using UDP, as for UDP server uses max. buffer size determined by\n\t   MTU, and for TCP server uses hardwired value 65KB (== 66560 bytes). \n\t   So we use 128KB, just to be sure, as there is no way how to know\n\t   this value in advance. */\n\tbufsize = 131072;\n\tbuf = vmalloc(bufsize);\n\tif (!buf)\n\t\treturn;\n\tdo {\n\t\tint cnt;\n\t\tchar* rpl;\n\t\tsize_t rpls;\n\n\t\terr = ncp_search_for_fileset(server, &seq, &more, &cnt, buf, bufsize, &rpl, &rpls);\n\t\tif (err)\t\t/* Error */\n\t\t\tbreak;\n\t\tif (!cnt)\t\t/* prevent endless loop */\n\t\t\tbreak;\n\t\twhile (cnt--) {\n\t\t\tsize_t onerpl;\n\t\t\t\n\t\t\tif (rpls < offsetof(struct nw_info_struct, entryName))\n\t\t\t\tbreak;\t/* short packet */\n\t\t\tncp_extract_file_info(rpl, &entry.i);\n\t\t\tonerpl = offsetof(struct nw_info_struct, entryName) + entry.i.nameLen;\n\t\t\tif (rpls < onerpl)\n\t\t\t\tbreak;\t/* short packet */\n\t\t\t(void)ncp_obtain_nfs_info(server, &entry.i);\n\t\t\trpl += onerpl;\n\t\t\trpls -= onerpl;\n\t\t\tentry.volume = entry.i.volNumber;\n\t\t\tif (!ncp_fill_cache(file, ctx, ctl, &entry, 0))\n\t\t\t\tbreak;\n\t\t}\n\t} while (more);\n\tvfree(buf);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_read_volume_list",
          "args": [
            "file",
            "ctx",
            "&ctl"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_read_volume_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "688-721",
          "snippet": "static void\nncp_read_volume_list(struct file *file, struct dir_context *ctx,\n\t\t\tstruct ncp_cache_control *ctl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tstruct ncp_volume_info info;\n\tstruct ncp_entry_info entry;\n\tint i;\n\n\tncp_dbg(1, \"pos=%ld\\n\", (unsigned long)ctx->pos);\n\n\tfor (i = 0; i < NCP_NUMBER_OF_VOLUMES; i++) {\n\t\tint inval_dentry;\n\n\t\tif (ncp_get_volume_info_with_number(server, i, &info) != 0)\n\t\t\treturn;\n\t\tif (!strlen(info.volume_name))\n\t\t\tcontinue;\n\n\t\tncp_dbg(1, \"found vol: %s\\n\", info.volume_name);\n\n\t\tif (ncp_lookup_volume(server, info.volume_name,\n\t\t\t\t\t&entry.i)) {\n\t\t\tncp_dbg(1, \"could not lookup vol %s\\n\",\n\t\t\t\tinfo.volume_name);\n\t\t\tcontinue;\n\t\t}\n\t\tinval_dentry = ncp_update_known_namespace(server, entry.i.volNumber, NULL);\n\t\tentry.volume = entry.i.volNumber;\n\t\tif (!ncp_fill_cache(file, ctx, ctl, &entry, inval_dentry))\n\t\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
            "static void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);",
            "static int ncp_readdir(struct file *, struct dir_context *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic int ncp_readdir(struct file *, struct dir_context *);\n\nstatic void\nncp_read_volume_list(struct file *file, struct dir_context *ctx,\n\t\t\tstruct ncp_cache_control *ctl)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tstruct ncp_volume_info info;\n\tstruct ncp_entry_info entry;\n\tint i;\n\n\tncp_dbg(1, \"pos=%ld\\n\", (unsigned long)ctx->pos);\n\n\tfor (i = 0; i < NCP_NUMBER_OF_VOLUMES; i++) {\n\t\tint inval_dentry;\n\n\t\tif (ncp_get_volume_info_with_number(server, i, &info) != 0)\n\t\t\treturn;\n\t\tif (!strlen(info.volume_name))\n\t\t\tcontinue;\n\n\t\tncp_dbg(1, \"found vol: %s\\n\", info.volume_name);\n\n\t\tif (ncp_lookup_volume(server, info.volume_name,\n\t\t\t\t\t&entry.i)) {\n\t\t\tncp_dbg(1, \"could not lookup vol %s\\n\",\n\t\t\t\tinfo.volume_name);\n\t\t\tcontinue;\n\t\t}\n\t\tinval_dentry = ncp_update_known_namespace(server, entry.i.volNumber, NULL);\n\t\tentry.volume = entry.i.volNumber;\n\t\tif (!ncp_fill_cache(file, ctx, ctl, &entry, inval_dentry))\n\t\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_is_server_root",
          "args": [
            "inode"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_is_server_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "201-205",
          "snippet": "static inline int ncp_is_server_root(struct inode *inode)\n{\n\treturn !ncp_single_volume(NCP_SERVER(inode)) &&\n\t\tis_root_inode(inode);\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int ncp_is_server_root(struct inode *inode)\n{\n\treturn !ncp_single_volume(NCP_SERVER(inode)) &&\n\t\tis_root_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_obtain_mtime",
          "args": [
            "dentry"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_obtain_mtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "389-402",
          "snippet": "static time_t ncp_obtain_mtime(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tstruct nw_info_struct i;\n\n\tif (!ncp_conn_valid(server) || ncp_is_server_root(inode))\n\t\treturn 0;\n\n\tif (ncp_obtain_info(server, inode, NULL, &i))\n\t\treturn 0;\n\n\treturn ncp_date_dos2unix(i.modifyTime, i.modifyDate);\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
            "static int ncp_unlink(struct inode *, struct dentry *);",
            "static int ncp_rmdir(struct inode *, struct dentry *);",
            "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
            "static int ncp_lookup_validate(struct dentry *, unsigned int);",
            "static int ncp_delete_dentry(const struct dentry *);",
            "static void ncp_d_prune(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic time_t ncp_obtain_mtime(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tstruct nw_info_struct i;\n\n\tif (!ncp_conn_valid(server) || ncp_is_server_root(inode))\n\t\treturn 0;\n\n\tif (ncp_obtain_info(server, inode, NULL, &i))\n\t\treturn 0;\n\n\treturn ncp_date_dos2unix(i.modifyTime, i.modifyDate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_invalidate_dircache_entries",
          "args": [
            "dentry"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_invalidate_dircache_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "404-416",
          "snippet": "static inline void\nncp_invalidate_dircache_entries(struct dentry *parent)\n{\n\tstruct ncp_server *server = NCP_SERVER(parent->d_inode);\n\tstruct dentry *dentry;\n\n\tspin_lock(&parent->d_lock);\n\tlist_for_each_entry(dentry, &parent->d_subdirs, d_child) {\n\t\tdentry->d_fsdata = NULL;\n\t\tncp_age_dentry(server, dentry);\n\t}\n\tspin_unlock(&parent->d_lock);\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
            "static int ncp_unlink(struct inode *, struct dentry *);",
            "static int ncp_rmdir(struct inode *, struct dentry *);",
            "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
            "static int ncp_lookup_validate(struct dentry *, unsigned int);",
            "static int ncp_delete_dentry(const struct dentry *);",
            "static void ncp_d_prune(struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic inline void\nncp_invalidate_dircache_entries(struct dentry *parent)\n{\n\tstruct ncp_server *server = NCP_SERVER(parent->d_inode);\n\tstruct dentry *dentry;\n\n\tspin_lock(&parent->d_lock);\n\tlist_for_each_entry(dentry, &parent->d_subdirs, d_child) {\n\t\tdentry->d_fsdata = NULL;\n\t\tncp_age_dentry(server, dentry);\n\t}\n\tspin_unlock(&parent->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "ctl.page"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "ctl.page"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "ctl.page"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "ctl.page"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "ctl.page"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dent"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "dent->d_name.name",
            "dent->d_name.len",
            "dent->d_inode->i_ino",
            "DT_UNKNOWN"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!lockref_get_not_dead(&dent->d_lockref)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockref_get_not_dead",
          "args": [
            "&dent->d_lockref"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "ctl.page"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "ctl.page"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "&inode->i_data",
            "ctl.ofs"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_MAX_AGE",
          "args": [
            "server"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "&inode->i_data",
            "0"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_conn_valid",
          "args": [
            "server"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_conn_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs_sb.h",
          "lines": "164-167",
          "snippet": "static inline int ncp_conn_valid(struct ncp_server *server)\n{\n\treturn ((server->conn_status & 0x11) == 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/net.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/net.h>\n#include <linux/ncp_mount.h>\n#include <linux/types.h>\n\nstatic inline int ncp_conn_valid(struct ncp_server *server)\n{\n\treturn ((server->conn_status & 0x11) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "2",
            "\"reading %pD2, pos=%d\\n\"",
            "file",
            "(int)ctx->pos"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic void ncp_read_volume_list(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic void ncp_do_readdir(struct file *, struct dir_context *,\n\t\t\t\tstruct ncp_cache_control *);\nstatic int ncp_readdir(struct file *, struct dir_context *);\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int ncp_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct page *page = NULL;\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tunion  ncp_dir_cache *cache = NULL;\n\tstruct ncp_cache_control ctl;\n\tint result, mtime_valid = 0;\n\ttime_t mtime = 0;\n\n\tctl.page  = NULL;\n\tctl.cache = NULL;\n\n\tncp_dbg(2, \"reading %pD2, pos=%d\\n\", file, (int)ctx->pos);\n\n\tresult = -EIO;\n\t/* Do not generate '.' and '..' when server is dead. */\n\tif (!ncp_conn_valid(server))\n\t\tgoto out;\n\n\tresult = 0;\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tpage = grab_cache_page(&inode->i_data, 0);\n\tif (!page)\n\t\tgoto read_really;\n\n\tctl.cache = cache = kmap(page);\n\tctl.head  = cache->head;\n\n\tif (!PageUptodate(page) || !ctl.head.eof)\n\t\tgoto init_cache;\n\n\tif (ctx->pos == 2) {\n\t\tif (jiffies - ctl.head.time >= NCP_MAX_AGE(server))\n\t\t\tgoto init_cache;\n\n\t\tmtime = ncp_obtain_mtime(dentry);\n\t\tmtime_valid = 1;\n\t\tif ((!mtime) || (mtime != ctl.head.mtime))\n\t\t\tgoto init_cache;\n\t}\n\n\tif (ctx->pos > ctl.head.end)\n\t\tgoto finished;\n\n\tctl.fpos = ctx->pos + (NCP_DIRCACHE_START - 2);\n\tctl.ofs  = ctl.fpos / NCP_DIRCACHE_SIZE;\n\tctl.idx  = ctl.fpos % NCP_DIRCACHE_SIZE;\n\n\tfor (;;) {\n\t\tif (ctl.ofs != 0) {\n\t\t\tctl.page = find_lock_page(&inode->i_data, ctl.ofs);\n\t\t\tif (!ctl.page)\n\t\t\t\tgoto invalid_cache;\n\t\t\tctl.cache = kmap(ctl.page);\n\t\t\tif (!PageUptodate(ctl.page))\n\t\t\t\tgoto invalid_cache;\n\t\t}\n\t\twhile (ctl.idx < NCP_DIRCACHE_SIZE) {\n\t\t\tstruct dentry *dent;\n\t\t\tbool over;\n\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tif (!(NCP_FINFO(inode)->flags & NCPI_DIR_CACHE)) { \n\t\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\t\tgoto invalid_cache;\n\t\t\t}\n\t\t\tdent = ctl.cache->dentry[ctl.idx];\n\t\t\tif (unlikely(!lockref_get_not_dead(&dent->d_lockref))) {\n\t\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\t\tgoto invalid_cache;\n\t\t\t}\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tif (!dent->d_inode) {\n\t\t\t\tdput(dent);\n\t\t\t\tgoto invalid_cache;\n\t\t\t}\n\t\t\tover = !dir_emit(ctx, dent->d_name.name,\n\t\t\t\t\tdent->d_name.len,\n\t\t\t\t\tdent->d_inode->i_ino, DT_UNKNOWN);\n\t\t\tdput(dent);\n\t\t\tif (over)\n\t\t\t\tgoto finished;\n\t\t\tctx->pos += 1;\n\t\t\tctl.idx += 1;\n\t\t\tif (ctx->pos > ctl.head.end)\n\t\t\t\tgoto finished;\n\t\t}\n\t\tif (ctl.page) {\n\t\t\tkunmap(ctl.page);\n\t\t\tSetPageUptodate(ctl.page);\n\t\t\tunlock_page(ctl.page);\n\t\t\tpage_cache_release(ctl.page);\n\t\t\tctl.page = NULL;\n\t\t}\n\t\tctl.idx  = 0;\n\t\tctl.ofs += 1;\n\t}\ninvalid_cache:\n\tif (ctl.page) {\n\t\tkunmap(ctl.page);\n\t\tunlock_page(ctl.page);\n\t\tpage_cache_release(ctl.page);\n\t\tctl.page = NULL;\n\t}\n\tctl.cache = cache;\ninit_cache:\n\tncp_invalidate_dircache_entries(dentry);\n\tif (!mtime_valid) {\n\t\tmtime = ncp_obtain_mtime(dentry);\n\t\tmtime_valid = 1;\n\t}\n\tctl.head.mtime = mtime;\n\tctl.head.time = jiffies;\n\tctl.head.eof = 0;\n\tctl.fpos = 2;\n\tctl.ofs = 0;\n\tctl.idx = NCP_DIRCACHE_START;\n\tctl.filled = 0;\n\tctl.valid  = 1;\nread_really:\n\tspin_lock(&dentry->d_lock);\n\tNCP_FINFO(inode)->flags |= NCPI_DIR_CACHE;\n\tspin_unlock(&dentry->d_lock);\n\tif (ncp_is_server_root(inode)) {\n\t\tncp_read_volume_list(file, ctx, &ctl);\n\t} else {\n\t\tncp_do_readdir(file, ctx, &ctl);\n\t}\n\tctl.head.end = ctl.fpos - 1;\n\tctl.head.eof = ctl.valid;\nfinished:\n\tif (ctl.page) {\n\t\tkunmap(ctl.page);\n\t\tSetPageUptodate(ctl.page);\n\t\tunlock_page(ctl.page);\n\t\tpage_cache_release(ctl.page);\n\t}\n\tif (page) {\n\t\tcache->head = ctl.head;\n\t\tkunmap(page);\n\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\nout:\n\treturn result;\n}"
  },
  {
    "function_name": "ncp_invalidate_dircache_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "404-416",
    "snippet": "static inline void\nncp_invalidate_dircache_entries(struct dentry *parent)\n{\n\tstruct ncp_server *server = NCP_SERVER(parent->d_inode);\n\tstruct dentry *dentry;\n\n\tspin_lock(&parent->d_lock);\n\tlist_for_each_entry(dentry, &parent->d_subdirs, d_child) {\n\t\tdentry->d_fsdata = NULL;\n\t\tncp_age_dentry(server, dentry);\n\t}\n\tspin_unlock(&parent->d_lock);\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_age_dentry",
          "args": [
            "server",
            "dentry"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_age_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "175-179",
          "snippet": "static inline void\nncp_age_dentry(struct ncp_server* server, struct dentry* dentry)\n{\n\tdentry->d_time = jiffies - NCP_MAX_AGE(server);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void\nncp_age_dentry(struct ncp_server* server, struct dentry* dentry)\n{\n\tdentry->d_time = jiffies - NCP_MAX_AGE(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dentry",
            "&parent->d_subdirs",
            "d_child"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&parent->d_lock"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "parent->d_inode"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic inline void\nncp_invalidate_dircache_entries(struct dentry *parent)\n{\n\tstruct ncp_server *server = NCP_SERVER(parent->d_inode);\n\tstruct dentry *dentry;\n\n\tspin_lock(&parent->d_lock);\n\tlist_for_each_entry(dentry, &parent->d_subdirs, d_child) {\n\t\tdentry->d_fsdata = NULL;\n\t\tncp_age_dentry(server, dentry);\n\t}\n\tspin_unlock(&parent->d_lock);\n}"
  },
  {
    "function_name": "ncp_obtain_mtime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "389-402",
    "snippet": "static time_t ncp_obtain_mtime(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tstruct nw_info_struct i;\n\n\tif (!ncp_conn_valid(server) || ncp_is_server_root(inode))\n\t\treturn 0;\n\n\tif (ncp_obtain_info(server, inode, NULL, &i))\n\t\treturn 0;\n\n\treturn ncp_date_dos2unix(i.modifyTime, i.modifyDate);\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_date_dos2unix",
          "args": [
            "i.modifyTime",
            "i.modifyDate"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_date_dos2unix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "1194-1209",
          "snippet": "int\nncp_date_dos2unix(__le16 t, __le16 d)\n{\n\tunsigned short time = le16_to_cpu(t), date = le16_to_cpu(d);\n\tint month, year, secs;\n\n\t/* first subtract and mask after that... Otherwise, if\n\t   date == 0, bad things happen */\n\tmonth = ((date >> 5) - 1) & 15;\n\tyear = date >> 9;\n\tsecs = (time & 31) * 2 + 60 * ((time >> 5) & 63) + (time >> 11) * 3600 +\n\t\t86400 * ((date & 31) - 1 + day_n[month] + (year / 4) + \n\t\tyear * 365 - ((year & 3) == 0 && month < 2 ? 1 : 0) + 3653);\n\t/* days since 1.1.70 plus 80's leap day */\n\treturn local2utc(secs);\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int day_n[] =\n{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0, 0};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic int day_n[] =\n{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 0, 0, 0, 0};\n\nint\nncp_date_dos2unix(__le16 t, __le16 d)\n{\n\tunsigned short time = le16_to_cpu(t), date = le16_to_cpu(d);\n\tint month, year, secs;\n\n\t/* first subtract and mask after that... Otherwise, if\n\t   date == 0, bad things happen */\n\tmonth = ((date >> 5) - 1) & 15;\n\tyear = date >> 9;\n\tsecs = (time & 31) * 2 + 60 * ((time >> 5) & 63) + (time >> 11) * 3600 +\n\t\t86400 * ((date & 31) - 1 + day_n[month] + (year / 4) + \n\t\tyear * 365 - ((year & 3) == 0 && month < 2 ? 1 : 0) + 3653);\n\t/* days since 1.1.70 plus 80's leap day */\n\treturn local2utc(secs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_obtain_info",
          "args": [
            "server",
            "inode",
            "NULL",
            "&i"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_obtain_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "419-449",
          "snippet": "int ncp_obtain_info(struct ncp_server *server, struct inode *dir, const char *path,\n\t\t\tstruct nw_info_struct *target)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint result;\n\n\tif (target == NULL) {\n\t\tpr_err(\"%s: invalid call\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tncp_init_request(server);\n\tncp_add_byte(server, 6);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, server->name_space[volnum]); /* N.B. twice ?? */\n\tncp_add_word(server, cpu_to_le16(0x8006));\t/* get all */\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_handle_path(server, volnum, dirent, 1, path);\n\n\tif ((result = ncp_request(server, 87)) != 0)\n\t\tgoto out;\n\tncp_extract_file_info(ncp_reply_data(server, 0), target);\n\tncp_unlock_server(server);\n\t\n\tresult = ncp_obtain_nfs_info(server, target);\n\treturn result;\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_obtain_info(struct ncp_server *server, struct inode *dir, const char *path,\n\t\t\tstruct nw_info_struct *target)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint result;\n\n\tif (target == NULL) {\n\t\tpr_err(\"%s: invalid call\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tncp_init_request(server);\n\tncp_add_byte(server, 6);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, server->name_space[volnum]); /* N.B. twice ?? */\n\tncp_add_word(server, cpu_to_le16(0x8006));\t/* get all */\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_handle_path(server, volnum, dirent, 1, path);\n\n\tif ((result = ncp_request(server, 87)) != 0)\n\t\tgoto out;\n\tncp_extract_file_info(ncp_reply_data(server, 0), target);\n\tncp_unlock_server(server);\n\t\n\tresult = ncp_obtain_nfs_info(server, target);\n\treturn result;\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_is_server_root",
          "args": [
            "inode"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_is_server_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "201-205",
          "snippet": "static inline int ncp_is_server_root(struct inode *inode)\n{\n\treturn !ncp_single_volume(NCP_SERVER(inode)) &&\n\t\tis_root_inode(inode);\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int ncp_is_server_root(struct inode *inode)\n{\n\treturn !ncp_single_volume(NCP_SERVER(inode)) &&\n\t\tis_root_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_conn_valid",
          "args": [
            "server"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_conn_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs_sb.h",
          "lines": "164-167",
          "snippet": "static inline int ncp_conn_valid(struct ncp_server *server)\n{\n\treturn ((server->conn_status & 0x11) == 0);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mutex.h>",
            "#include <linux/net.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/backing-dev.h>\n#include <linux/mutex.h>\n#include <linux/net.h>\n#include <linux/ncp_mount.h>\n#include <linux/types.h>\n\nstatic inline int ncp_conn_valid(struct ncp_server *server)\n{\n\treturn ((server->conn_status & 0x11) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic time_t ncp_obtain_mtime(struct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct ncp_server *server = NCP_SERVER(inode);\n\tstruct nw_info_struct i;\n\n\tif (!ncp_conn_valid(server) || ncp_is_server_root(inode))\n\t\treturn 0;\n\n\tif (ncp_obtain_info(server, inode, NULL, &i))\n\t\treturn 0;\n\n\treturn ncp_date_dos2unix(i.modifyTime, i.modifyDate);\n}"
  },
  {
    "function_name": "ncp_lookup_validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "310-387",
    "snippet": "static int\nncp_lookup_validate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct ncp_server *server;\n\tstruct dentry *parent;\n\tstruct inode *dir;\n\tstruct ncp_entry_info finfo;\n\tint res, val = 0, len;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tif (dentry == dentry->d_sb->s_root)\n\t\treturn 1;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tparent = dget_parent(dentry);\n\tdir = parent->d_inode;\n\n\tif (!dentry->d_inode)\n\t\tgoto finished;\n\n\tserver = NCP_SERVER(dir);\n\n\t/*\n\t * Inspired by smbfs:\n\t * The default validation is based on dentry age:\n\t * We set the max age at mount time.  (But each\n\t * successful server lookup renews the timestamp.)\n\t */\n\tval = NCP_TEST_AGE(server, dentry);\n\tif (val)\n\t\tgoto finished;\n\n\tncp_dbg(2, \"%pd2 not valid, age=%ld, server lookup\\n\",\n\t\tdentry, NCP_GET_AGE(dentry));\n\n\tlen = sizeof(__name);\n\tif (ncp_is_server_root(dir)) {\n\t\tres = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t\t dentry->d_name.len, 1);\n\t\tif (!res) {\n\t\t\tres = ncp_lookup_volume(server, __name, &(finfo.i));\n\t\t\tif (!res)\n\t\t\t\tncp_update_known_namespace(server, finfo.i.volNumber, NULL);\n\t\t}\n\t} else {\n\t\tres = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t\t dentry->d_name.len, !ncp_preserve_case(dir));\n\t\tif (!res)\n\t\t\tres = ncp_obtain_info(server, dir, __name, &(finfo.i));\n\t}\n\tfinfo.volume = finfo.i.volNumber;\n\tncp_dbg(2, \"looked for %pd/%s, res=%d\\n\",\n\t\tdentry->d_parent, __name, res);\n\t/*\n\t * If we didn't find it, or if it has a different dirEntNum to\n\t * what we remember, it's not valid any more.\n\t */\n\tif (!res) {\n\t\tstruct inode *inode = dentry->d_inode;\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (finfo.i.dirEntNum == NCP_FINFO(inode)->dirEntNum) {\n\t\t\tncp_new_dentry(dentry);\n\t\t\tval=1;\n\t\t} else\n\t\t\tncp_dbg(2, \"found, but dirEntNum changed\\n\");\n\n\t\tncp_update_inode2(inode, &finfo);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\nfinished:\n\tncp_dbg(2, \"result=%d\\n\", val);\n\tdput(parent);\n\treturn val;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "2",
            "\"result=%d\\n\"",
            "val"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_update_inode2",
          "args": [
            "inode",
            "&finfo"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_inode2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/inode.c",
          "lines": "211-221",
          "snippet": "void ncp_update_inode2(struct inode* inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->flags = 0;\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tNCP_FINFO(inode)->nwattr = nwinfo->i.attributes;\n\t\tncp_update_attrs(inode, nwinfo);\n\t}\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_dirent(inode, nwinfo);\n}",
          "includes": [
            "#include \"getopt.h\"",
            "#include \"ncp_fs.h\"",
            "#include <net/sock.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/vfs.h>",
            "#include <linux/init.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/time.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ncp_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"getopt.h\"\n#include \"ncp_fs.h\"\n#include <net/sock.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/vfs.h>\n#include <linux/init.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/time.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n\nstatic void ncp_evict_inode(struct inode *);\n\nvoid ncp_update_inode2(struct inode* inode, struct ncp_entry_info *nwinfo)\n{\n\tNCP_FINFO(inode)->flags = 0;\n\tif (!atomic_read(&NCP_FINFO(inode)->opened)) {\n\t\tNCP_FINFO(inode)->nwattr = nwinfo->i.attributes;\n\t\tncp_update_attrs(inode, nwinfo);\n\t}\n\n\tncp_update_dates(inode, &nwinfo->i);\n\tncp_update_dirent(inode, nwinfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "2",
            "\"found, but dirEntNum changed\\n\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_new_dentry",
          "args": [
            "dentry"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_new_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "181-185",
          "snippet": "static inline void\nncp_new_dentry(struct dentry* dentry)\n{\n\tdentry->d_time = jiffies;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void\nncp_new_dentry(struct dentry* dentry)\n{\n\tdentry->d_time = jiffies;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "2",
            "\"looked for %pd/%s, res=%d\\n\"",
            "dentry->d_parent",
            "__name",
            "res"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_obtain_info",
          "args": [
            "server",
            "dir",
            "__name",
            "&(finfo.i)"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_obtain_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "419-449",
          "snippet": "int ncp_obtain_info(struct ncp_server *server, struct inode *dir, const char *path,\n\t\t\tstruct nw_info_struct *target)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint result;\n\n\tif (target == NULL) {\n\t\tpr_err(\"%s: invalid call\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tncp_init_request(server);\n\tncp_add_byte(server, 6);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, server->name_space[volnum]); /* N.B. twice ?? */\n\tncp_add_word(server, cpu_to_le16(0x8006));\t/* get all */\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_handle_path(server, volnum, dirent, 1, path);\n\n\tif ((result = ncp_request(server, 87)) != 0)\n\t\tgoto out;\n\tncp_extract_file_info(ncp_reply_data(server, 0), target);\n\tncp_unlock_server(server);\n\t\n\tresult = ncp_obtain_nfs_info(server, target);\n\treturn result;\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_obtain_info(struct ncp_server *server, struct inode *dir, const char *path,\n\t\t\tstruct nw_info_struct *target)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint result;\n\n\tif (target == NULL) {\n\t\tpr_err(\"%s: invalid call\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tncp_init_request(server);\n\tncp_add_byte(server, 6);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, server->name_space[volnum]); /* N.B. twice ?? */\n\tncp_add_word(server, cpu_to_le16(0x8006));\t/* get all */\n\tncp_add_dword(server, RIM_ALL);\n\tncp_add_handle_path(server, volnum, dirent, 1, path);\n\n\tif ((result = ncp_request(server, 87)) != 0)\n\t\tgoto out;\n\tncp_extract_file_info(ncp_reply_data(server, 0), target);\n\tncp_unlock_server(server);\n\t\n\tresult = ncp_obtain_nfs_info(server, target);\n\treturn result;\n\nout:\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_io2vol",
          "args": [
            "server",
            "__name",
            "&len",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "!ncp_preserve_case(dir)"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_preserve_case",
          "args": [
            "dir"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_update_known_namespace",
          "args": [
            "server",
            "finfo.i.volNumber",
            "NULL"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_update_known_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "525-539",
          "snippet": "int\nncp_update_known_namespace(struct ncp_server *server, __u8 volume, int *ret_ns)\n{\n\tint ns = ncp_get_known_namespace(server, volume);\n\n\tif (ret_ns)\n\t\t*ret_ns = ns;\n\n\tncp_dbg(1, \"namespace[%d] = %d\\n\", volume, server->name_space[volume]);\n\n\tif (server->name_space[volume] == ns)\n\t\treturn 0;\n\tserver->name_space[volume] = ns;\n\treturn 1;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_update_known_namespace(struct ncp_server *server, __u8 volume, int *ret_ns)\n{\n\tint ns = ncp_get_known_namespace(server, volume);\n\n\tif (ret_ns)\n\t\t*ret_ns = ns;\n\n\tncp_dbg(1, \"namespace[%d] = %d\\n\", volume, server->name_space[volume]);\n\n\tif (server->name_space[volume] == ns)\n\t\treturn 0;\n\tserver->name_space[volume] = ns;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_lookup_volume",
          "args": [
            "server",
            "__name",
            "&(finfo.i)"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_lookup_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "622-643",
          "snippet": "int\nncp_lookup_volume(struct ncp_server *server,\n\t\t  const char *volname, struct nw_info_struct *target)\n{\n\tint result;\n\n\tmemset(target, 0, sizeof(*target));\n\tresult = ncp_get_volume_root(server, volname,\n\t\t\t&target->volNumber, &target->dirEntNum, &target->DosDirNum);\n\tif (result) {\n\t\treturn result;\n\t}\n\tncp_update_known_namespace(server, target->volNumber, NULL);\n\ttarget->nameLen = strlen(volname);\n\tmemcpy(target->entryName, volname, target->nameLen+1);\n\ttarget->attributes = aDIR;\n\t/* set dates to Jan 1, 1986  00:00 */\n\ttarget->creationTime = target->modifyTime = cpu_to_le16(0x0000);\n\ttarget->creationDate = target->modifyDate = target->lastAccessDate = cpu_to_le16(0x0C21);\n\ttarget->nfs.mode = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_lookup_volume(struct ncp_server *server,\n\t\t  const char *volname, struct nw_info_struct *target)\n{\n\tint result;\n\n\tmemset(target, 0, sizeof(*target));\n\tresult = ncp_get_volume_root(server, volname,\n\t\t\t&target->volNumber, &target->dirEntNum, &target->DosDirNum);\n\tif (result) {\n\t\treturn result;\n\t}\n\tncp_update_known_namespace(server, target->volNumber, NULL);\n\ttarget->nameLen = strlen(volname);\n\tmemcpy(target->entryName, volname, target->nameLen+1);\n\ttarget->attributes = aDIR;\n\t/* set dates to Jan 1, 1986  00:00 */\n\ttarget->creationTime = target->modifyTime = cpu_to_le16(0x0000);\n\ttarget->creationDate = target->modifyDate = target->lastAccessDate = cpu_to_le16(0x0C21);\n\ttarget->nfs.mode = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_io2vol",
          "args": [
            "server",
            "__name",
            "&len",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "1"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_is_server_root",
          "args": [
            "dir"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_is_server_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "201-205",
          "snippet": "static inline int ncp_is_server_root(struct inode *inode)\n{\n\treturn !ncp_single_volume(NCP_SERVER(inode)) &&\n\t\tis_root_inode(inode);\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int ncp_is_server_root(struct inode *inode)\n{\n\treturn !ncp_single_volume(NCP_SERVER(inode)) &&\n\t\tis_root_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ncp_dbg",
          "args": [
            "2",
            "\"%pd2 not valid, age=%ld, server lookup\\n\"",
            "dentry",
            "NCP_GET_AGE(dentry)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_GET_AGE",
          "args": [
            "dentry"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_TEST_AGE",
          "args": [
            "server",
            "dentry"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int\nncp_lookup_validate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct ncp_server *server;\n\tstruct dentry *parent;\n\tstruct inode *dir;\n\tstruct ncp_entry_info finfo;\n\tint res, val = 0, len;\n\t__u8 __name[NCP_MAXPATHLEN + 1];\n\n\tif (dentry == dentry->d_sb->s_root)\n\t\treturn 1;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tparent = dget_parent(dentry);\n\tdir = parent->d_inode;\n\n\tif (!dentry->d_inode)\n\t\tgoto finished;\n\n\tserver = NCP_SERVER(dir);\n\n\t/*\n\t * Inspired by smbfs:\n\t * The default validation is based on dentry age:\n\t * We set the max age at mount time.  (But each\n\t * successful server lookup renews the timestamp.)\n\t */\n\tval = NCP_TEST_AGE(server, dentry);\n\tif (val)\n\t\tgoto finished;\n\n\tncp_dbg(2, \"%pd2 not valid, age=%ld, server lookup\\n\",\n\t\tdentry, NCP_GET_AGE(dentry));\n\n\tlen = sizeof(__name);\n\tif (ncp_is_server_root(dir)) {\n\t\tres = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t\t dentry->d_name.len, 1);\n\t\tif (!res) {\n\t\t\tres = ncp_lookup_volume(server, __name, &(finfo.i));\n\t\t\tif (!res)\n\t\t\t\tncp_update_known_namespace(server, finfo.i.volNumber, NULL);\n\t\t}\n\t} else {\n\t\tres = ncp_io2vol(server, __name, &len, dentry->d_name.name,\n\t\t\t\t dentry->d_name.len, !ncp_preserve_case(dir));\n\t\tif (!res)\n\t\t\tres = ncp_obtain_info(server, dir, __name, &(finfo.i));\n\t}\n\tfinfo.volume = finfo.i.volNumber;\n\tncp_dbg(2, \"looked for %pd/%s, res=%d\\n\",\n\t\tdentry->d_parent, __name, res);\n\t/*\n\t * If we didn't find it, or if it has a different dirEntNum to\n\t * what we remember, it's not valid any more.\n\t */\n\tif (!res) {\n\t\tstruct inode *inode = dentry->d_inode;\n\n\t\tmutex_lock(&inode->i_mutex);\n\t\tif (finfo.i.dirEntNum == NCP_FINFO(inode)->dirEntNum) {\n\t\t\tncp_new_dentry(dentry);\n\t\t\tval=1;\n\t\t} else\n\t\t\tncp_dbg(2, \"found, but dirEntNum changed\\n\");\n\n\t\tncp_update_inode2(inode, &finfo);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\nfinished:\n\tncp_dbg(2, \"result=%d\\n\", val);\n\tdput(parent);\n\treturn val;\n}"
  },
  {
    "function_name": "ncp_force_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "251-306",
    "snippet": "static int\nncp_force_rename(struct inode *old_dir, struct dentry* old_dentry, char *_old_name,\n                 struct inode *new_dir, struct dentry* new_dentry, char *_new_name)\n{\n\tstruct nw_modify_dos_info info;\n        int res=0x90,res2;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\t__le32 old_nwattr = NCP_FINFO(old_inode)->nwattr;\n\t__le32 new_nwattr = 0; /* shut compiler warning */\n\tint old_nwattr_changed = 0;\n\tint new_nwattr_changed = 0;\n\n\tmemset(&info, 0, sizeof(info));\n\t\n        /* remove the Read-Only flag on the NW server */\n\n\tinfo.attributes = old_nwattr & ~(aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);\n\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(old_inode), old_inode, NULL, DM_ATTRIBUTES, &info);\n\tif (!res2)\n\t\told_nwattr_changed = 1;\n\tif (new_dentry && new_dentry->d_inode) {\n\t\tnew_nwattr = NCP_FINFO(new_dentry->d_inode)->nwattr;\n\t\tinfo.attributes = new_nwattr & ~(aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(new_dir), new_dir, _new_name, DM_ATTRIBUTES, &info);\n\t\tif (!res2)\n\t\t\tnew_nwattr_changed = 1;\n\t}\n        /* now try again the rename operation */\n\t/* but only if something really happened */\n\tif (new_nwattr_changed || old_nwattr_changed) {\n\t        res = ncp_ren_or_mov_file_or_subdir(NCP_SERVER(old_dir),\n        \t                                    old_dir, _old_name,\n                \t                            new_dir, _new_name);\n\t} \n\tif (res)\n\t\tgoto leave_me;\n\t/* file was successfully renamed, so:\n\t   do not set attributes on old file - it no longer exists\n\t   copy attributes from old file to new */\n\tnew_nwattr_changed = old_nwattr_changed;\n\tnew_nwattr = old_nwattr;\n\told_nwattr_changed = 0;\n\t\nleave_me:;\n\tif (old_nwattr_changed) {\n\t\tinfo.attributes = old_nwattr;\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(old_inode), old_inode, NULL, DM_ATTRIBUTES, &info);\n\t\t/* ignore errors */\n\t}\n\tif (new_nwattr_changed)\t{\n\t\tinfo.attributes = new_nwattr;\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(new_dir), new_dir, _new_name, DM_ATTRIBUTES, &info);\n\t\t/* ignore errors */\n\t}\n        return(res);\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_modify_file_or_subdir_dos_info_path",
          "args": [
            "NCP_SERVER(new_dir)",
            "new_dir",
            "_new_name",
            "DM_ATTRIBUTES",
            "&info"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_modify_file_or_subdir_dos_info_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "645-668",
          "snippet": "int ncp_modify_file_or_subdir_dos_info_path(struct ncp_server *server,\n\t\t\t\t\t    struct inode *dir,\n\t\t\t\t\t    const char *path,\n\t\t\t\t\t    __le32 info_mask,\n\t\t\t\t\t    const struct nw_modify_dos_info *info)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 7);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, 0);\t/* reserved */\n\tncp_add_word(server, cpu_to_le16(0x8006));\t/* search attribs: all */\n\n\tncp_add_dword(server, info_mask);\n\tncp_add_mem(server, info, sizeof(*info));\n\tncp_add_handle_path(server, volnum, dirent, 1, path);\n\n\tresult = ncp_request(server, 87);\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_modify_file_or_subdir_dos_info_path(struct ncp_server *server,\n\t\t\t\t\t    struct inode *dir,\n\t\t\t\t\t    const char *path,\n\t\t\t\t\t    __le32 info_mask,\n\t\t\t\t\t    const struct nw_modify_dos_info *info)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 7);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, 0);\t/* reserved */\n\tncp_add_word(server, cpu_to_le16(0x8006));\t/* search attribs: all */\n\n\tncp_add_dword(server, info_mask);\n\tncp_add_mem(server, info, sizeof(*info));\n\tncp_add_handle_path(server, volnum, dirent, 1, path);\n\n\tresult = ncp_request(server, 87);\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "new_dir"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "old_inode"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_ren_or_mov_file_or_subdir",
          "args": [
            "NCP_SERVER(old_dir)",
            "old_dir",
            "_old_name",
            "new_dir",
            "_new_name"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_ren_or_mov_file_or_subdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "940-962",
          "snippet": "int ncp_ren_or_mov_file_or_subdir(struct ncp_server *server,\n\t\t\t\tstruct inode *old_dir, const char *old_name,\n\t\t\t\tstruct inode *new_dir, const char *new_name)\n{\n        int result;\n        __le16 old_type = cpu_to_le16(0x06);\n\n/* If somebody can do it atomic, call me... vandrove@vc.cvut.cz */\n\tresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\n\t                                   new_dir, new_name);\n        if (result == 0xFF)\t/* File Not Found, try directory */\n\t{\n\t\told_type = cpu_to_le16(0x16);\n\t\tresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\n\t\t\t\t\t\t   new_dir, new_name);\n\t}\n\tif (result != 0x92) return result;\t/* All except NO_FILES_RENAMED */\n\tresult = ncp_del_file_or_subdir(server, new_dir, new_name);\n\tif (result != 0) return -EACCES;\n\tresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\n\t\t\t\t\t   new_dir, new_name);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_ren_or_mov_file_or_subdir(struct ncp_server *server,\n\t\t\t\tstruct inode *old_dir, const char *old_name,\n\t\t\t\tstruct inode *new_dir, const char *new_name)\n{\n        int result;\n        __le16 old_type = cpu_to_le16(0x06);\n\n/* If somebody can do it atomic, call me... vandrove@vc.cvut.cz */\n\tresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\n\t                                   new_dir, new_name);\n        if (result == 0xFF)\t/* File Not Found, try directory */\n\t{\n\t\told_type = cpu_to_le16(0x16);\n\t\tresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\n\t\t\t\t\t\t   new_dir, new_name);\n\t}\n\tif (result != 0x92) return result;\t/* All except NO_FILES_RENAMED */\n\tresult = ncp_del_file_or_subdir(server, new_dir, new_name);\n\tif (result != 0) return -EACCES;\n\tresult = ncp_RenameNSEntry(server, old_dir, old_name, old_type,\n\t\t\t\t\t   new_dir, new_name);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "old_dir"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "new_dir"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "new_dentry->d_inode"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "old_inode"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int\nncp_force_rename(struct inode *old_dir, struct dentry* old_dentry, char *_old_name,\n                 struct inode *new_dir, struct dentry* new_dentry, char *_new_name)\n{\n\tstruct nw_modify_dos_info info;\n        int res=0x90,res2;\n\tstruct inode *old_inode = old_dentry->d_inode;\n\t__le32 old_nwattr = NCP_FINFO(old_inode)->nwattr;\n\t__le32 new_nwattr = 0; /* shut compiler warning */\n\tint old_nwattr_changed = 0;\n\tint new_nwattr_changed = 0;\n\n\tmemset(&info, 0, sizeof(info));\n\t\n        /* remove the Read-Only flag on the NW server */\n\n\tinfo.attributes = old_nwattr & ~(aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);\n\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(old_inode), old_inode, NULL, DM_ATTRIBUTES, &info);\n\tif (!res2)\n\t\told_nwattr_changed = 1;\n\tif (new_dentry && new_dentry->d_inode) {\n\t\tnew_nwattr = NCP_FINFO(new_dentry->d_inode)->nwattr;\n\t\tinfo.attributes = new_nwattr & ~(aRONLY|aRENAMEINHIBIT|aDELETEINHIBIT);\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(new_dir), new_dir, _new_name, DM_ATTRIBUTES, &info);\n\t\tif (!res2)\n\t\t\tnew_nwattr_changed = 1;\n\t}\n        /* now try again the rename operation */\n\t/* but only if something really happened */\n\tif (new_nwattr_changed || old_nwattr_changed) {\n\t        res = ncp_ren_or_mov_file_or_subdir(NCP_SERVER(old_dir),\n        \t                                    old_dir, _old_name,\n                \t                            new_dir, _new_name);\n\t} \n\tif (res)\n\t\tgoto leave_me;\n\t/* file was successfully renamed, so:\n\t   do not set attributes on old file - it no longer exists\n\t   copy attributes from old file to new */\n\tnew_nwattr_changed = old_nwattr_changed;\n\tnew_nwattr = old_nwattr;\n\told_nwattr_changed = 0;\n\t\nleave_me:;\n\tif (old_nwattr_changed) {\n\t\tinfo.attributes = old_nwattr;\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(old_inode), old_inode, NULL, DM_ATTRIBUTES, &info);\n\t\t/* ignore errors */\n\t}\n\tif (new_nwattr_changed)\t{\n\t\tinfo.attributes = new_nwattr;\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(new_dir), new_dir, _new_name, DM_ATTRIBUTES, &info);\n\t\t/* ignore errors */\n\t}\n        return(res);\n}"
  },
  {
    "function_name": "ncp_force_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "216-247",
    "snippet": "static int\nncp_force_unlink(struct inode *dir, struct dentry* dentry)\n{\n        int res=0x9c,res2;\n\tstruct nw_modify_dos_info info;\n\t__le32 old_nwattr;\n\tstruct inode *inode;\n\n\tmemset(&info, 0, sizeof(info));\n\t\n        /* remove the Read-Only flag on the NW server */\n\tinode = dentry->d_inode;\n\n\told_nwattr = NCP_FINFO(inode)->nwattr;\n\tinfo.attributes = old_nwattr & ~(aRONLY|aDELETEINHIBIT|aRENAMEINHIBIT);\n\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(inode), inode, NULL, DM_ATTRIBUTES, &info);\n\tif (res2)\n\t\tgoto leave_me;\n\n        /* now try again the delete operation */\n        res = ncp_del_file_or_subdir2(NCP_SERVER(dir), dentry);\n\n        if (res)  /* delete failed, set R bit again */\n        {\n\t\tinfo.attributes = old_nwattr;\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(inode), inode, NULL, DM_ATTRIBUTES, &info);\n\t\tif (res2)\n                        goto leave_me;\n        }\nleave_me:\n        return(res);\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_modify_file_or_subdir_dos_info_path",
          "args": [
            "NCP_SERVER(inode)",
            "inode",
            "NULL",
            "DM_ATTRIBUTES",
            "&info"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_modify_file_or_subdir_dos_info_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "645-668",
          "snippet": "int ncp_modify_file_or_subdir_dos_info_path(struct ncp_server *server,\n\t\t\t\t\t    struct inode *dir,\n\t\t\t\t\t    const char *path,\n\t\t\t\t\t    __le32 info_mask,\n\t\t\t\t\t    const struct nw_modify_dos_info *info)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 7);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, 0);\t/* reserved */\n\tncp_add_word(server, cpu_to_le16(0x8006));\t/* search attribs: all */\n\n\tncp_add_dword(server, info_mask);\n\tncp_add_mem(server, info, sizeof(*info));\n\tncp_add_handle_path(server, volnum, dirent, 1, path);\n\n\tresult = ncp_request(server, 87);\n\tncp_unlock_server(server);\n\treturn result;\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint ncp_modify_file_or_subdir_dos_info_path(struct ncp_server *server,\n\t\t\t\t\t    struct inode *dir,\n\t\t\t\t\t    const char *path,\n\t\t\t\t\t    __le32 info_mask,\n\t\t\t\t\t    const struct nw_modify_dos_info *info)\n{\n\t__u8  volnum = NCP_FINFO(dir)->volNumber;\n\t__le32 dirent = NCP_FINFO(dir)->dirEntNum;\n\tint result;\n\n\tncp_init_request(server);\n\tncp_add_byte(server, 7);\t/* subfunction */\n\tncp_add_byte(server, server->name_space[volnum]);\n\tncp_add_byte(server, 0);\t/* reserved */\n\tncp_add_word(server, cpu_to_le16(0x8006));\t/* search attribs: all */\n\n\tncp_add_dword(server, info_mask);\n\tncp_add_mem(server, info, sizeof(*info));\n\tncp_add_handle_path(server, volnum, dirent, 1, path);\n\n\tresult = ncp_request(server, 87);\n\tncp_unlock_server(server);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_del_file_or_subdir2",
          "args": [
            "NCP_SERVER(dir)",
            "dentry"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_del_file_or_subdir2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.c",
          "lines": "726-740",
          "snippet": "int\nncp_del_file_or_subdir2(struct ncp_server *server,\n\t\t\tstruct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\t__u8  volnum;\n\t__le32 dirent;\n\n\tif (!inode) {\n\t\treturn 0xFF;\t/* Any error */\n\t}\n\tvolnum = NCP_FINFO(inode)->volNumber;\n\tdirent = NCP_FINFO(inode)->DosDirNum;\n\treturn ncp_DeleteNSEntry(server, 1, volnum, dirent, NULL, NW_NS_DOS, cpu_to_le16(0x8006));\n}",
          "includes": [
            "#include \"ncp_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n\nint\nncp_del_file_or_subdir2(struct ncp_server *server,\n\t\t\tstruct dentry *dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\t__u8  volnum;\n\t__le32 dirent;\n\n\tif (!inode) {\n\t\treturn 0xFF;\t/* Any error */\n\t}\n\tvolnum = NCP_FINFO(inode)->volNumber;\n\tdirent = NCP_FINFO(inode)->DosDirNum;\n\treturn ncp_DeleteNSEntry(server, 1, volnum, dirent, NULL, NW_NS_DOS, cpu_to_le16(0x8006));\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "dir"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_FINFO",
          "args": [
            "inode"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "NCP_FINFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncp_fs.h",
          "lines": "49-52",
          "snippet": "static inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"ncplib_kernel.h\"",
            "#include \"ncp_fs_sb.h\"",
            "#include \"ncp_fs_i.h\"",
            "#include <linux/ncp_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ncp_make_open(struct inode *, int);",
            "int ncp_make_closed(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ncplib_kernel.h\"\n#include \"ncp_fs_sb.h\"\n#include \"ncp_fs_i.h\"\n#include <linux/ncp_fs.h>\n\nint ncp_make_open(struct inode *, int);\nint ncp_make_closed(struct inode *);\n\nstatic inline struct ncp_inode_info *NCP_FINFO(const struct inode *inode)\n{\n\treturn container_of(inode, struct ncp_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int\nncp_force_unlink(struct inode *dir, struct dentry* dentry)\n{\n        int res=0x9c,res2;\n\tstruct nw_modify_dos_info info;\n\t__le32 old_nwattr;\n\tstruct inode *inode;\n\n\tmemset(&info, 0, sizeof(info));\n\t\n        /* remove the Read-Only flag on the NW server */\n\tinode = dentry->d_inode;\n\n\told_nwattr = NCP_FINFO(inode)->nwattr;\n\tinfo.attributes = old_nwattr & ~(aRONLY|aDELETEINHIBIT|aRENAMEINHIBIT);\n\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(inode), inode, NULL, DM_ATTRIBUTES, &info);\n\tif (res2)\n\t\tgoto leave_me;\n\n        /* now try again the delete operation */\n        res = ncp_del_file_or_subdir2(NCP_SERVER(dir), dentry);\n\n        if (res)  /* delete failed, set R bit again */\n        {\n\t\tinfo.attributes = old_nwattr;\n\t\tres2 = ncp_modify_file_or_subdir_dos_info_path(NCP_SERVER(inode), inode, NULL, DM_ATTRIBUTES, &info);\n\t\tif (res2)\n                        goto leave_me;\n        }\nleave_me:\n        return(res);\n}"
  },
  {
    "function_name": "ncp_is_server_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "201-205",
    "snippet": "static inline int ncp_is_server_root(struct inode *inode)\n{\n\treturn !ncp_single_volume(NCP_SERVER(inode)) &&\n\t\tis_root_inode(inode);\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_root_inode",
          "args": [
            "inode"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_single_volume",
          "args": [
            "NCP_SERVER(inode)"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_single_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "195-199",
          "snippet": "static inline int\nncp_single_volume(struct ncp_server *server)\n{\n\treturn (server->m.mounted_vol[0] != '\\0');\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int\nncp_single_volume(struct ncp_server *server)\n{\n\treturn (server->m.mounted_vol[0] != '\\0');\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_SERVER",
          "args": [
            "inode"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int ncp_is_server_root(struct inode *inode)\n{\n\treturn !ncp_single_volume(NCP_SERVER(inode)) &&\n\t\tis_root_inode(inode);\n}"
  },
  {
    "function_name": "ncp_single_volume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "195-199",
    "snippet": "static inline int\nncp_single_volume(struct ncp_server *server)\n{\n\treturn (server->m.mounted_vol[0] != '\\0');\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int\nncp_single_volume(struct ncp_server *server)\n{\n\treturn (server->m.mounted_vol[0] != '\\0');\n}"
  },
  {
    "function_name": "ncp_delete_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "180-193",
    "snippet": "static int\nncp_delete_dentry(const struct dentry * dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (inode) {\n\t\tif (is_bad_inode(inode))\n\t\t\treturn 1;\n\t} else\n\t{\n\t/* N.B. Unhash negative dentries? */\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "inode"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int\nncp_delete_dentry(const struct dentry * dentry)\n{\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (inode) {\n\t\tif (is_bad_inode(inode))\n\t\t\treturn 1;\n\t} else\n\t{\n\t/* N.B. Unhash negative dentries? */\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ncp_compare_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "156-173",
    "snippet": "static int\nncp_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct inode *pinode;\n\n\tif (len != name->len)\n\t\treturn 1;\n\n\tpinode = ACCESS_ONCE(parent->d_inode);\n\tif (!pinode)\n\t\treturn 1;\n\n\tif (ncp_case_sensitive(pinode))\n\t\treturn strncmp(str, name->name, len);\n\n\treturn ncp_strnicmp(NCP_IO_TABLE(pinode->i_sb), str, name->name, len);\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_hash_dentry(const struct dentry *, struct qstr *);",
      "static int ncp_compare_dentry(const struct dentry *, const struct dentry *,\n\t\tunsigned int, const char *, const struct qstr *);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_strnicmp",
          "args": [
            "NCP_IO_TABLE(pinode->i_sb)",
            "str",
            "name->name",
            "len"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_strnicmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/ncplib_kernel.h",
          "lines": "158-167",
          "snippet": "static inline int ncp_strnicmp(const struct nls_table *t,\n\t\tconst unsigned char *s1, const unsigned char *s2, int len)\n{\n\twhile (len--) {\n\t\tif (tolower(*s1++) != tolower(*s2++))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/nls.h>",
            "#include <asm/string.h>",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <asm/string.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline int ncp_strnicmp(const struct nls_table *t,\n\t\tconst unsigned char *s1, const unsigned char *s2, int len)\n{\n\twhile (len--) {\n\t\tif (tolower(*s1++) != tolower(*s2++))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NCP_IO_TABLE",
          "args": [
            "pinode->i_sb"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "name->name",
            "len"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_case_sensitive",
          "args": [
            "pinode"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_case_sensitive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "110-117",
          "snippet": "static inline int ncp_case_sensitive(const struct inode *i)\n{\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn ncp_namespace(i) == NW_NS_NFS;\n#else\n\treturn 0;\n#endif /* CONFIG_NCPFS_NFS_NS */\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int ncp_case_sensitive(const struct inode *i)\n{\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn ncp_namespace(i) == NW_NS_NFS;\n#else\n\treturn 0;\n#endif /* CONFIG_NCPFS_NFS_NS */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "parent->d_inode"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_hash_dentry(const struct dentry *, struct qstr *);\nstatic int ncp_compare_dentry(const struct dentry *, const struct dentry *,\n\t\tunsigned int, const char *, const struct qstr *);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int\nncp_compare_dentry(const struct dentry *parent, const struct dentry *dentry,\n\t\tunsigned int len, const char *str, const struct qstr *name)\n{\n\tstruct inode *pinode;\n\n\tif (len != name->len)\n\t\treturn 1;\n\n\tpinode = ACCESS_ONCE(parent->d_inode);\n\tif (!pinode)\n\t\treturn 1;\n\n\tif (ncp_case_sensitive(pinode))\n\t\treturn strncmp(str, name->name, len);\n\n\treturn ncp_strnicmp(NCP_IO_TABLE(pinode->i_sb), str, name->name, len);\n}"
  },
  {
    "function_name": "ncp_hash_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "127-149",
    "snippet": "static int \nncp_hash_dentry(const struct dentry *dentry, struct qstr *this)\n{\n\tstruct inode *inode = ACCESS_ONCE(dentry->d_inode);\n\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!ncp_case_sensitive(inode)) {\n\t\tstruct super_block *sb = dentry->d_sb;\n\t\tstruct nls_table *t;\n\t\tunsigned long hash;\n\t\tint i;\n\n\t\tt = NCP_IO_TABLE(sb);\n\t\thash = init_name_hash();\n\t\tfor (i=0; i<this->len ; i++)\n\t\t\thash = partial_name_hash(ncp_tolower(t, this->name[i]),\n\t\t\t\t\t\t\t\t\thash);\n\t\tthis->hash = end_name_hash(hash);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);",
      "static int ncp_unlink(struct inode *, struct dentry *);",
      "static int ncp_rmdir(struct inode *, struct dentry *);",
      "static int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);",
      "static int ncp_lookup_validate(struct dentry *, unsigned int);",
      "static int ncp_hash_dentry(const struct dentry *, struct qstr *);",
      "static int ncp_compare_dentry(const struct dentry *, const struct dentry *,\n\t\tunsigned int, const char *, const struct qstr *);",
      "static int ncp_delete_dentry(const struct dentry *);",
      "static void ncp_d_prune(struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "end_name_hash",
          "args": [
            "hash"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "partial_name_hash",
          "args": [
            "ncp_tolower(t, this->name[i])",
            "hash"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_tolower",
          "args": [
            "t",
            "this->name[i]"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_name_hash",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NCP_IO_TABLE",
          "args": [
            "sb"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ncp_case_sensitive",
          "args": [
            "inode"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ncp_case_sensitive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
          "lines": "110-117",
          "snippet": "static inline int ncp_case_sensitive(const struct inode *i)\n{\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn ncp_namespace(i) == NW_NS_NFS;\n#else\n\treturn 0;\n#endif /* CONFIG_NCPFS_NFS_NS */\n}",
          "includes": [
            "#include \"ncp_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int ncp_case_sensitive(const struct inode *i)\n{\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn ncp_namespace(i) == NW_NS_NFS;\n#else\n\treturn 0;\n#endif /* CONFIG_NCPFS_NFS_NS */\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "dentry->d_inode"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic struct dentry *ncp_lookup(struct inode *, struct dentry *, unsigned int);\nstatic int ncp_unlink(struct inode *, struct dentry *);\nstatic int ncp_rmdir(struct inode *, struct dentry *);\nstatic int ncp_rename(struct inode *, struct dentry *,\n\t  \t      struct inode *, struct dentry *);\nstatic int ncp_lookup_validate(struct dentry *, unsigned int);\nstatic int ncp_hash_dentry(const struct dentry *, struct qstr *);\nstatic int ncp_compare_dentry(const struct dentry *, const struct dentry *,\n\t\tunsigned int, const char *, const struct qstr *);\nstatic int ncp_delete_dentry(const struct dentry *);\nstatic void ncp_d_prune(struct dentry *dentry);\n\nstatic int \nncp_hash_dentry(const struct dentry *dentry, struct qstr *this)\n{\n\tstruct inode *inode = ACCESS_ONCE(dentry->d_inode);\n\n\tif (!inode)\n\t\treturn 0;\n\n\tif (!ncp_case_sensitive(inode)) {\n\t\tstruct super_block *sb = dentry->d_sb;\n\t\tstruct nls_table *t;\n\t\tunsigned long hash;\n\t\tint i;\n\n\t\tt = NCP_IO_TABLE(sb);\n\t\thash = init_name_hash();\n\t\tfor (i=0; i<this->len ; i++)\n\t\t\thash = partial_name_hash(ncp_tolower(t, this->name[i]),\n\t\t\t\t\t\t\t\t\thash);\n\t\tthis->hash = end_name_hash(hash);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ncp_case_sensitive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "110-117",
    "snippet": "static inline int ncp_case_sensitive(const struct inode *i)\n{\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn ncp_namespace(i) == NW_NS_NFS;\n#else\n\treturn 0;\n#endif /* CONFIG_NCPFS_NFS_NS */\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_namespace",
          "args": [
            "i"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int ncp_case_sensitive(const struct inode *i)\n{\n#ifdef CONFIG_NCPFS_NFS_NS\n\treturn ncp_namespace(i) == NW_NS_NFS;\n#else\n\treturn 0;\n#endif /* CONFIG_NCPFS_NFS_NS */\n}"
  },
  {
    "function_name": "ncp_preserve_entry_case",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ncpfs/dir.c",
    "lines": "93-106",
    "snippet": "static inline int ncp_preserve_entry_case(struct inode *i, __u32 nscreator)\n{\n#ifdef CONFIG_NCPFS_SMALLDOS\n\tint ns = ncp_namespace(i);\n\n\tif ((ns == NW_NS_DOS)\n#ifdef CONFIG_NCPFS_OS2_NS\n\t\t|| ((ns == NW_NS_OS2) && (nscreator == NW_NS_DOS))\n#endif /* CONFIG_NCPFS_OS2_NS */\n\t   )\n\t\treturn 0;\n#endif /* CONFIG_NCPFS_SMALLDOS */\n\treturn 1;\n}",
    "includes": [
      "#include \"ncp_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/namei.h>",
      "#include <linux/mm.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stat.h>",
      "#include <linux/errno.h>",
      "#include <linux/time.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ncp_namespace",
          "args": [
            "i"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ncp_fs.h\"\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n\nstatic inline int ncp_preserve_entry_case(struct inode *i, __u32 nscreator)\n{\n#ifdef CONFIG_NCPFS_SMALLDOS\n\tint ns = ncp_namespace(i);\n\n\tif ((ns == NW_NS_DOS)\n#ifdef CONFIG_NCPFS_OS2_NS\n\t\t|| ((ns == NW_NS_OS2) && (nscreator == NW_NS_DOS))\n#endif /* CONFIG_NCPFS_OS2_NS */\n\t   )\n\t\treturn 0;\n#endif /* CONFIG_NCPFS_SMALLDOS */\n\treturn 1;\n}"
  }
]