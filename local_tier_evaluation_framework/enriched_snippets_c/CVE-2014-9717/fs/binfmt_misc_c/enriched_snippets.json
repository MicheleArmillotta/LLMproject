[
  {
    "function_name": "xit_misc_binfmt(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "839-843",
    "snippet": "tatic void __exit exit_misc_binfmt(void)\n{\n\tunregister_binfmt(&misc_format);\n\tunregister_filesystem(&bm_fs_type);\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct file_system_type bm_fs_type;",
      "tatic struct linux_binfmt misc_format = {\n\t.module = THIS_MODULE,\n\t.load_binary = load_misc_binary,\n};",
      "tatic struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.mount\t\t= bm_mount,\n\t.kill_sb\t= kill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nregister_filesystem(",
          "args": [
            "bm_fs_type)"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nregister_binfmt(",
          "args": [
            "misc_format)"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic struct file_system_type bm_fs_type;\ntatic struct linux_binfmt misc_format = {\n\t.module = THIS_MODULE,\n\t.load_binary = load_misc_binary,\n};\ntatic struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.mount\t\t= bm_mount,\n\t.kill_sb\t= kill_litter_super,\n};\n\ntatic void __exit exit_misc_binfmt(void)\n{\n\tunregister_binfmt(&misc_format);\n\tunregister_filesystem(&bm_fs_type);\n}"
  },
  {
    "function_name": "nit_misc_binfmt(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "831-837",
    "snippet": "tatic int __init init_misc_binfmt(void)\n{\n\tint err = register_filesystem(&bm_fs_type);\n\tif (!err)\n\t\tinsert_binfmt(&misc_format);\n\treturn err;\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic struct file_system_type bm_fs_type;",
      "tatic struct linux_binfmt misc_format = {\n\t.module = THIS_MODULE,\n\t.load_binary = load_misc_binary,\n};",
      "tatic struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.mount\t\t= bm_mount,\n\t.kill_sb\t= kill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nsert_binfmt(",
          "args": [
            "misc_format)"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "egister_filesystem(",
          "args": [
            "bm_fs_type)"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic struct file_system_type bm_fs_type;\ntatic struct linux_binfmt misc_format = {\n\t.module = THIS_MODULE,\n\t.load_binary = load_misc_binary,\n};\ntatic struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.mount\t\t= bm_mount,\n\t.kill_sb\t= kill_litter_super,\n};\n\ntatic int __init init_misc_binfmt(void)\n{\n\tint err = register_filesystem(&bm_fs_type);\n\tif (!err)\n\t\tinsert_binfmt(&misc_format);\n\treturn err;\n}"
  },
  {
    "function_name": "m_mount(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "812-816",
    "snippet": "tatic struct dentry *bm_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, bm_fill_super);\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ount_single(",
          "args": [
            "s_type,",
            "lags,",
            "ata,",
            "m_fill_super)"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "ount_single(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "1066-1087",
          "snippet": "truct dentry *mount_single(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct super_block *s;\n\tint error;\n\n\ts = sget(fs_type, compare_single, set_anon_super, flags, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\tif (!s->s_root) {\n\t\terror = fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\ts->s_flags |= MS_ACTIVE;\n\t} else {\n\t\tdo_remount_sb(s, flags, data, 0);\n\t}\n\treturn dget(s->s_root);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntruct dentry *mount_single(struct file_system_type *fs_type,\n\tint flags, void *data,\n\tint (*fill_super)(struct super_block *, void *, int))\n{\n\tstruct super_block *s;\n\tint error;\n\n\ts = sget(fs_type, compare_single, set_anon_super, flags, NULL);\n\tif (IS_ERR(s))\n\t\treturn ERR_CAST(s);\n\tif (!s->s_root) {\n\t\terror = fill_super(s, data, flags & MS_SILENT ? 1 : 0);\n\t\tif (error) {\n\t\t\tdeactivate_locked_super(s);\n\t\t\treturn ERR_PTR(error);\n\t\t}\n\t\ts->s_flags |= MS_ACTIVE;\n\t} else {\n\t\tdo_remount_sb(s, flags, data, 0);\n\t}\n\treturn dget(s->s_root);\n}"
        }
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic struct dentry *bm_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, bm_fill_super);\n}"
  },
  {
    "function_name": "m_fill_super(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "797-810",
    "snippet": "tatic int bm_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tint err;\n\tstatic struct tree_descr bm_files[] = {\n\t\t[2] = {\"status\", &bm_status_operations, S_IWUSR|S_IRUGO},\n\t\t[3] = {\"register\", &bm_register_operations, S_IWUSR},\n\t\t/* last one */ {\"\"}\n\t};\n\n\terr = simple_fill_super(sb, BINFMTFS_MAGIC, bm_files);\n\tif (!err)\n\t\tsb->s_op = &s_ops;\n\treturn err;\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic const struct file_operations bm_register_operations = {\n\t.write\t\t= bm_register_write,\n\t.llseek\t\t= noop_llseek,\n};",
      "tatic const struct file_operations bm_status_operations = {\n\t.read\t\t= bm_status_read,\n\t.write\t\t= bm_status_write,\n\t.llseek\t\t= default_llseek,\n};",
      "tatic const struct super_operations s_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.evict_inode\t= bm_evict_inode,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "imple_fill_super(",
          "args": [
            "b,",
            "INFMTFS_MAGIC,",
            "m_files)"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic const struct file_operations bm_register_operations = {\n\t.write\t\t= bm_register_write,\n\t.llseek\t\t= noop_llseek,\n};\ntatic const struct file_operations bm_status_operations = {\n\t.read\t\t= bm_status_read,\n\t.write\t\t= bm_status_write,\n\t.llseek\t\t= default_llseek,\n};\ntatic const struct super_operations s_ops = {\n\t.statfs\t\t= simple_statfs,\n\t.evict_inode\t= bm_evict_inode,\n};\n\ntatic int bm_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tint err;\n\tstatic struct tree_descr bm_files[] = {\n\t\t[2] = {\"status\", &bm_status_operations, S_IWUSR|S_IRUGO},\n\t\t[3] = {\"register\", &bm_register_operations, S_IWUSR},\n\t\t/* last one */ {\"\"}\n\t};\n\n\terr = simple_fill_super(sb, BINFMTFS_MAGIC, bm_files);\n\tif (!err)\n\t\tsb->s_op = &s_ops;\n\treturn err;\n}"
  },
  {
    "function_name": "m_status_write(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "751-782",
    "snippet": "tatic ssize_t bm_status_write(struct file *file, const char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tint res = parse_command(buffer, count);\n\tstruct dentry *root;\n\n\tswitch (res) {\n\tcase 1:\n\t\t/* Disable all handlers. */\n\t\tenabled = 0;\n\t\tbreak;\n\tcase 2:\n\t\t/* Enable all handlers. */\n\t\tenabled = 1;\n\t\tbreak;\n\tcase 3:\n\t\t/* Delete all handlers. */\n\t\troot = dget(file->f_path.dentry->d_sb->s_root);\n\t\tmutex_lock(&root->d_inode->i_mutex);\n\n\t\twhile (!list_empty(&entries))\n\t\t\tkill_node(list_entry(entries.next, Node, list));\n\n\t\tmutex_unlock(&root->d_inode->i_mutex);\n\t\tdput(root);\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic LIST_HEAD(entries);",
      "tatic int enabled = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "oot)"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "root->d_inode->i_mutex)"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ill_node(",
          "args": [
            "ist_entry(entries.next, Node, list))"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "ill_node(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
          "lines": "593-611",
          "snippet": "tatic void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tdentry = e->dentry;\n\tif (dentry) {\n\t\tlist_del_init(&e->list);\n\t\te->dentry = NULL;\n\t}\n\twrite_unlock(&entries_lock);\n\n\tif (dentry) {\n\t\tdrop_nlink(dentry->d_inode);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t\tsimple_release_fs(&bm_mnt, &entry_count);\n\t}\n}",
          "includes": [
            "include <linux/uaccess.h>",
            "include <linux/fs.h>\n#",
            "include <linux/syscalls.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/namei.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/file.h>\n#",
            "include <linux/string_helpers.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/binfmts.h>\n#",
            "include <linux/magic.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/module.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_RWLOCK(entries_lock);",
            "tatic struct vfsmount *bm_mnt;",
            "tatic int entry_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic DEFINE_RWLOCK(entries_lock);\ntatic struct vfsmount *bm_mnt;\ntatic int entry_count;\n\ntatic void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tdentry = e->dentry;\n\tif (dentry) {\n\t\tlist_del_init(&e->list);\n\t\te->dentry = NULL;\n\t}\n\twrite_unlock(&entries_lock);\n\n\tif (dentry) {\n\t\tdrop_nlink(dentry->d_inode);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t\tsimple_release_fs(&bm_mnt, &entry_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ist_entry(",
          "args": [
            "ntries.next,",
            "ode,",
            "ist)"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_empty(",
          "args": [
            "entries)"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "root->d_inode->i_mutex)"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get(",
          "args": [
            "ile->f_path.dentry->d_sb->s_root)"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "ing_page_budget(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
          "lines": "214-219",
          "snippet": "elease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int",
          "includes": [
            "ux/slab.h>\n\nstatic int r",
            "ux/namei.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/aio.h>\n#include <lin",
            "fs.h\"\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nelease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int"
        }
      },
      {
        "call_info": {
          "callee": "arse_command(",
          "args": [
            "uffer,",
            "ount)"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "arse_command(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
          "lines": "499-518",
          "snippet": "tatic int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}",
          "includes": [
            "include <linux/uaccess.h>",
            "include <linux/fs.h>\n#",
            "include <linux/syscalls.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/namei.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/file.h>\n#",
            "include <linux/string_helpers.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/binfmts.h>\n#",
            "include <linux/magic.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/module.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic LIST_HEAD(entries);\ntatic int enabled = 1;\n\ntatic ssize_t bm_status_write(struct file *file, const char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tint res = parse_command(buffer, count);\n\tstruct dentry *root;\n\n\tswitch (res) {\n\tcase 1:\n\t\t/* Disable all handlers. */\n\t\tenabled = 0;\n\t\tbreak;\n\tcase 2:\n\t\t/* Enable all handlers. */\n\t\tenabled = 1;\n\t\tbreak;\n\tcase 3:\n\t\t/* Delete all handlers. */\n\t\troot = dget(file->f_path.dentry->d_sb->s_root);\n\t\tmutex_lock(&root->d_inode->i_mutex);\n\n\t\twhile (!list_empty(&entries))\n\t\t\tkill_node(list_entry(entries.next, Node, list));\n\n\t\tmutex_unlock(&root->d_inode->i_mutex);\n\t\tdput(root);\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "m_status_read(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "743-749",
    "snippet": "tatic ssize_t\nbm_status_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\n{\n\tchar *s = enabled ? \"enabled\\n\" : \"disabled\\n\";\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, s, strlen(s));\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int enabled = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "imple_read_from_buffer(",
          "args": [
            "uf,",
            "bytes,",
            "pos,",
            ",",
            "trlen(s))"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            ")"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic int enabled = 1;\n\ntatic ssize_t\nbm_status_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\n{\n\tchar *s = enabled ? \"enabled\\n\" : \"disabled\\n\";\n\n\treturn simple_read_from_buffer(buf, nbytes, ppos, s, strlen(s));\n}"
  },
  {
    "function_name": "m_register_write(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "675-734",
    "snippet": "tatic ssize_t bm_register_write(struct file *file, const char __user *buffer,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tNode *e;\n\tstruct inode *inode;\n\tstruct dentry *root, *dentry;\n\tstruct super_block *sb = file->f_path.dentry->d_sb;\n\tint err = 0;\n\n\te = create_entry(buffer, count);\n\n\tif (IS_ERR(e))\n\t\treturn PTR_ERR(e);\n\n\troot = dget(sb->s_root);\n\tmutex_lock(&root->d_inode->i_mutex);\n\tdentry = lookup_one_len(e->name, root, strlen(e->name));\n\terr = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\terr = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out2;\n\n\tinode = bm_get_inode(sb, S_IFREG | 0644);\n\n\terr = -ENOMEM;\n\tif (!inode)\n\t\tgoto out2;\n\n\terr = simple_pin_fs(&bm_fs_type, &bm_mnt, &entry_count);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tgoto out2;\n\t}\n\n\te->dentry = dget(dentry);\n\tinode->i_private = e;\n\tinode->i_fop = &bm_entry_operations;\n\n\td_instantiate(dentry, inode);\n\twrite_lock(&entries_lock);\n\tlist_add(&e->list, &entries);\n\twrite_unlock(&entries_lock);\n\n\terr = 0;\nout2:\n\tdput(dentry);\nout:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\tdput(root);\n\n\tif (err) {\n\t\tkfree(e);\n\t\treturn -EINVAL;\n\t}\n\treturn count;\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic LIST_HEAD(entries);",
      "tatic DEFINE_RWLOCK(entries_lock);",
      "tatic struct file_system_type bm_fs_type;",
      "tatic struct vfsmount *bm_mnt;",
      "tatic int entry_count;",
      "tatic const struct file_operations bm_entry_operations = {\n\t.read\t\t= bm_entry_read,\n\t.write\t\t= bm_entry_write,\n\t.llseek\t\t= default_llseek,\n};",
      "tatic struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.mount\t\t= bm_mount,\n\t.kill_sb\t= kill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free(",
          "args": [
            ")"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "oot)"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "root->d_inode->i_mutex)"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "entry)"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rite_unlock(",
          "args": [
            "entries_lock)"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_add(",
          "args": [
            "e->list,",
            "entries)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rite_lock(",
          "args": [
            "entries_lock)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_instantiate(",
          "args": [
            "entry,",
            "node)"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get(",
          "args": [
            "entry)"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "ing_page_budget(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
          "lines": "214-219",
          "snippet": "elease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int",
          "includes": [
            "ux/slab.h>\n\nstatic int r",
            "ux/namei.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/aio.h>\n#include <lin",
            "fs.h\"\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nelease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int"
        }
      },
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "node)"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imple_pin_fs(",
          "args": [
            "bm_fs_type,",
            "bm_mnt,",
            "entry_count)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "m_get_inode(",
          "args": [
            "b,",
            "_IFREG | 0644)"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "m_get_inode(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
          "lines": "574-585",
          "snippet": "tatic struct inode *bm_get_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t}\n\treturn inode;\n}",
          "includes": [
            "include <linux/uaccess.h>",
            "include <linux/fs.h>\n#",
            "include <linux/syscalls.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/namei.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/file.h>\n#",
            "include <linux/string_helpers.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/binfmts.h>\n#",
            "include <linux/magic.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/module.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic struct inode *bm_get_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "entry)"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "entry)"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ookup_one_len(",
          "args": [
            "->name,",
            "oot,",
            "trlen(e->name))"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "->name)"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "root->d_inode->i_mutex)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            ")"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            ")"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reate_entry(",
          "args": [
            "uffer,",
            "ount)"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "reate_entry(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
          "lines": "300-493",
          "snippet": "tatic Node *create_entry(const char __user *buffer, size_t count)\n{\n\tNode *e;\n\tint memsize, err;\n\tchar *buf, *p;\n\tchar del;\n\n\tpr_debug(\"register: received %zu bytes\\n\", count);\n\n\t/* some sanity checks */\n\terr = -EINVAL;\n\tif ((count < 11) || (count > MAX_REGISTER_LENGTH))\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tmemsize = sizeof(Node) + count + 8;\n\te = kmalloc(memsize, GFP_KERNEL);\n\tif (!e)\n\t\tgoto out;\n\n\tp = buf = (char *)e + sizeof(Node);\n\n\tmemset(e, 0, sizeof(Node));\n\tif (copy_from_user(buf, buffer, count))\n\t\tgoto efault;\n\n\tdel = *p++;\t/* delimeter */\n\n\tpr_debug(\"register: delim: %#x {%c}\\n\", del, del);\n\n\t/* Pad the buffer with the delim to simplify parsing below. */\n\tmemset(buf + count, del, 8);\n\n\t/* Parse the 'name' field. */\n\te->name = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->name[0] ||\n\t    !strcmp(e->name, \".\") ||\n\t    !strcmp(e->name, \"..\") ||\n\t    strchr(e->name, '/'))\n\t\tgoto einval;\n\n\tpr_debug(\"register: name: {%s}\\n\", e->name);\n\n\t/* Parse the 'type' field. */\n\tswitch (*p++) {\n\tcase 'E':\n\t\tpr_debug(\"register: type: E (extension)\\n\");\n\t\te->flags = 1 << Enabled;\n\t\tbreak;\n\tcase 'M':\n\t\tpr_debug(\"register: type: M (magic)\\n\");\n\t\te->flags = (1 << Enabled) | (1 << Magic);\n\t\tbreak;\n\tdefault:\n\t\tgoto einval;\n\t}\n\tif (*p++ != del)\n\t\tgoto einval;\n\n\tif (test_bit(Magic, &e->flags)) {\n\t\t/* Handle the 'M' (magic) format. */\n\t\tchar *s;\n\n\t\t/* Parse the 'offset' field. */\n\t\ts = strchr(p, del);\n\t\tif (!s)\n\t\t\tgoto einval;\n\t\t*s++ = '\\0';\n\t\te->offset = simple_strtoul(p, &p, 10);\n\t\tif (*p++)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: offset: %#x\\n\", e->offset);\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->magic[0])\n\t\t\tgoto einval;\n\t\tif (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, p - e->magic);\n\n\t\t/* Parse the 'mask' field. */\n\t\te->mask = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->mask[0]) {\n\t\t\te->mask = NULL;\n\t\t\tpr_debug(\"register:  mask[raw]: none\\n\");\n\t\t} else if (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register:  mask[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->mask, p - e->mask);\n\n\t\t/*\n\t\t * Decode the magic & mask fields.\n\t\t * Note: while we might have accepted embedded NUL bytes from\n\t\t * above, the unescape helpers here will stop at the first one\n\t\t * it encounters.\n\t\t */\n\t\te->size = string_unescape_inplace(e->magic, UNESCAPE_HEX);\n\t\tif (e->mask &&\n\t\t    string_unescape_inplace(e->mask, UNESCAPE_HEX) != e->size)\n\t\t\tgoto einval;\n\t\tif (e->size + e->offset > BINPRM_BUF_SIZE)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: magic/mask length: %i\\n\", e->size);\n\t\tif (USE_DEBUG) {\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[decoded]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, e->size);\n\n\t\t\tif (e->mask) {\n\t\t\t\tint i;\n\t\t\t\tchar *masked = kmalloc(e->size, GFP_KERNEL);\n\n\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\tKBUILD_MODNAME \": register:  mask[decoded]: \",\n\t\t\t\t\tDUMP_PREFIX_NONE, e->mask, e->size);\n\n\t\t\t\tif (masked) {\n\t\t\t\t\tfor (i = 0; i < e->size; ++i)\n\t\t\t\t\t\tmasked[i] = e->magic[i] & e->mask[i];\n\t\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\t\tKBUILD_MODNAME \": register:  magic[masked]: \",\n\t\t\t\t\t\tDUMP_PREFIX_NONE, masked, e->size);\n\n\t\t\t\t\tkfree(masked);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Handle the 'E' (extension) format. */\n\n\t\t/* Skip the 'offset' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t\tif (!e->magic[0] || strchr(e->magic, '/'))\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: extension: {%s}\\n\", e->magic);\n\n\t\t/* Skip the 'mask' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t}\n\n\t/* Parse the 'interpreter' field. */\n\te->interpreter = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->interpreter[0])\n\t\tgoto einval;\n\tpr_debug(\"register: interpreter: {%s}\\n\", e->interpreter);\n\n\t/* Parse the 'flags' field. */\n\tp = check_special_flags(p, e);\n\tif (*p == '\\n')\n\t\tp++;\n\tif (p != buf + count)\n\t\tgoto einval;\n\n\treturn e;\n\nout:\n\treturn ERR_PTR(err);\n\nefault:\n\tkfree(e);\n\treturn ERR_PTR(-EFAULT);\neinval:\n\tkfree(e);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "include <linux/uaccess.h>",
            "include <linux/fs.h>\n#",
            "include <linux/syscalls.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/namei.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/file.h>\n#",
            "include <linux/string_helpers.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/binfmts.h>\n#",
            "include <linux/magic.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/module.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic Node *create_entry(const char __user *buffer, size_t count)\n{\n\tNode *e;\n\tint memsize, err;\n\tchar *buf, *p;\n\tchar del;\n\n\tpr_debug(\"register: received %zu bytes\\n\", count);\n\n\t/* some sanity checks */\n\terr = -EINVAL;\n\tif ((count < 11) || (count > MAX_REGISTER_LENGTH))\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tmemsize = sizeof(Node) + count + 8;\n\te = kmalloc(memsize, GFP_KERNEL);\n\tif (!e)\n\t\tgoto out;\n\n\tp = buf = (char *)e + sizeof(Node);\n\n\tmemset(e, 0, sizeof(Node));\n\tif (copy_from_user(buf, buffer, count))\n\t\tgoto efault;\n\n\tdel = *p++;\t/* delimeter */\n\n\tpr_debug(\"register: delim: %#x {%c}\\n\", del, del);\n\n\t/* Pad the buffer with the delim to simplify parsing below. */\n\tmemset(buf + count, del, 8);\n\n\t/* Parse the 'name' field. */\n\te->name = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->name[0] ||\n\t    !strcmp(e->name, \".\") ||\n\t    !strcmp(e->name, \"..\") ||\n\t    strchr(e->name, '/'))\n\t\tgoto einval;\n\n\tpr_debug(\"register: name: {%s}\\n\", e->name);\n\n\t/* Parse the 'type' field. */\n\tswitch (*p++) {\n\tcase 'E':\n\t\tpr_debug(\"register: type: E (extension)\\n\");\n\t\te->flags = 1 << Enabled;\n\t\tbreak;\n\tcase 'M':\n\t\tpr_debug(\"register: type: M (magic)\\n\");\n\t\te->flags = (1 << Enabled) | (1 << Magic);\n\t\tbreak;\n\tdefault:\n\t\tgoto einval;\n\t}\n\tif (*p++ != del)\n\t\tgoto einval;\n\n\tif (test_bit(Magic, &e->flags)) {\n\t\t/* Handle the 'M' (magic) format. */\n\t\tchar *s;\n\n\t\t/* Parse the 'offset' field. */\n\t\ts = strchr(p, del);\n\t\tif (!s)\n\t\t\tgoto einval;\n\t\t*s++ = '\\0';\n\t\te->offset = simple_strtoul(p, &p, 10);\n\t\tif (*p++)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: offset: %#x\\n\", e->offset);\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->magic[0])\n\t\t\tgoto einval;\n\t\tif (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, p - e->magic);\n\n\t\t/* Parse the 'mask' field. */\n\t\te->mask = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->mask[0]) {\n\t\t\te->mask = NULL;\n\t\t\tpr_debug(\"register:  mask[raw]: none\\n\");\n\t\t} else if (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register:  mask[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->mask, p - e->mask);\n\n\t\t/*\n\t\t * Decode the magic & mask fields.\n\t\t * Note: while we might have accepted embedded NUL bytes from\n\t\t * above, the unescape helpers here will stop at the first one\n\t\t * it encounters.\n\t\t */\n\t\te->size = string_unescape_inplace(e->magic, UNESCAPE_HEX);\n\t\tif (e->mask &&\n\t\t    string_unescape_inplace(e->mask, UNESCAPE_HEX) != e->size)\n\t\t\tgoto einval;\n\t\tif (e->size + e->offset > BINPRM_BUF_SIZE)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: magic/mask length: %i\\n\", e->size);\n\t\tif (USE_DEBUG) {\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[decoded]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, e->size);\n\n\t\t\tif (e->mask) {\n\t\t\t\tint i;\n\t\t\t\tchar *masked = kmalloc(e->size, GFP_KERNEL);\n\n\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\tKBUILD_MODNAME \": register:  mask[decoded]: \",\n\t\t\t\t\tDUMP_PREFIX_NONE, e->mask, e->size);\n\n\t\t\t\tif (masked) {\n\t\t\t\t\tfor (i = 0; i < e->size; ++i)\n\t\t\t\t\t\tmasked[i] = e->magic[i] & e->mask[i];\n\t\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\t\tKBUILD_MODNAME \": register:  magic[masked]: \",\n\t\t\t\t\t\tDUMP_PREFIX_NONE, masked, e->size);\n\n\t\t\t\t\tkfree(masked);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Handle the 'E' (extension) format. */\n\n\t\t/* Skip the 'offset' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t\tif (!e->magic[0] || strchr(e->magic, '/'))\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: extension: {%s}\\n\", e->magic);\n\n\t\t/* Skip the 'mask' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t}\n\n\t/* Parse the 'interpreter' field. */\n\te->interpreter = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->interpreter[0])\n\t\tgoto einval;\n\tpr_debug(\"register: interpreter: {%s}\\n\", e->interpreter);\n\n\t/* Parse the 'flags' field. */\n\tp = check_special_flags(p, e);\n\tif (*p == '\\n')\n\t\tp++;\n\tif (p != buf + count)\n\t\tgoto einval;\n\n\treturn e;\n\nout:\n\treturn ERR_PTR(err);\n\nefault:\n\tkfree(e);\n\treturn ERR_PTR(-EFAULT);\neinval:\n\tkfree(e);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic LIST_HEAD(entries);\ntatic DEFINE_RWLOCK(entries_lock);\ntatic struct file_system_type bm_fs_type;\ntatic struct vfsmount *bm_mnt;\ntatic int entry_count;\ntatic const struct file_operations bm_entry_operations = {\n\t.read\t\t= bm_entry_read,\n\t.write\t\t= bm_entry_write,\n\t.llseek\t\t= default_llseek,\n};\ntatic struct file_system_type bm_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"binfmt_misc\",\n\t.mount\t\t= bm_mount,\n\t.kill_sb\t= kill_litter_super,\n};\n\ntatic ssize_t bm_register_write(struct file *file, const char __user *buffer,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tNode *e;\n\tstruct inode *inode;\n\tstruct dentry *root, *dentry;\n\tstruct super_block *sb = file->f_path.dentry->d_sb;\n\tint err = 0;\n\n\te = create_entry(buffer, count);\n\n\tif (IS_ERR(e))\n\t\treturn PTR_ERR(e);\n\n\troot = dget(sb->s_root);\n\tmutex_lock(&root->d_inode->i_mutex);\n\tdentry = lookup_one_len(e->name, root, strlen(e->name));\n\terr = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\terr = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out2;\n\n\tinode = bm_get_inode(sb, S_IFREG | 0644);\n\n\terr = -ENOMEM;\n\tif (!inode)\n\t\tgoto out2;\n\n\terr = simple_pin_fs(&bm_fs_type, &bm_mnt, &entry_count);\n\tif (err) {\n\t\tiput(inode);\n\t\tinode = NULL;\n\t\tgoto out2;\n\t}\n\n\te->dentry = dget(dentry);\n\tinode->i_private = e;\n\tinode->i_fop = &bm_entry_operations;\n\n\td_instantiate(dentry, inode);\n\twrite_lock(&entries_lock);\n\tlist_add(&e->list, &entries);\n\twrite_unlock(&entries_lock);\n\n\terr = 0;\nout2:\n\tdput(dentry);\nout:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\tdput(root);\n\n\tif (err) {\n\t\tkfree(e);\n\t\treturn -EINVAL;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "m_entry_write(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "634-665",
    "snippet": "tatic ssize_t bm_entry_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct dentry *root;\n\tNode *e = file_inode(file)->i_private;\n\tint res = parse_command(buffer, count);\n\n\tswitch (res) {\n\tcase 1:\n\t\t/* Disable this handler. */\n\t\tclear_bit(Enabled, &e->flags);\n\t\tbreak;\n\tcase 2:\n\t\t/* Enable this handler. */\n\t\tset_bit(Enabled, &e->flags);\n\t\tbreak;\n\tcase 3:\n\t\t/* Delete this handler. */\n\t\troot = dget(file->f_path.dentry->d_sb->s_root);\n\t\tmutex_lock(&root->d_inode->i_mutex);\n\n\t\tkill_node(e);\n\n\t\tmutex_unlock(&root->d_inode->i_mutex);\n\t\tdput(root);\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "oot)"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "utex_unlock(",
          "args": [
            "root->d_inode->i_mutex)"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ill_node(",
          "args": [
            ")"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "ill_node(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
          "lines": "593-611",
          "snippet": "tatic void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tdentry = e->dentry;\n\tif (dentry) {\n\t\tlist_del_init(&e->list);\n\t\te->dentry = NULL;\n\t}\n\twrite_unlock(&entries_lock);\n\n\tif (dentry) {\n\t\tdrop_nlink(dentry->d_inode);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t\tsimple_release_fs(&bm_mnt, &entry_count);\n\t}\n}",
          "includes": [
            "include <linux/uaccess.h>",
            "include <linux/fs.h>\n#",
            "include <linux/syscalls.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/namei.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/file.h>\n#",
            "include <linux/string_helpers.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/binfmts.h>\n#",
            "include <linux/magic.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/module.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_RWLOCK(entries_lock);",
            "tatic struct vfsmount *bm_mnt;",
            "tatic int entry_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic DEFINE_RWLOCK(entries_lock);\ntatic struct vfsmount *bm_mnt;\ntatic int entry_count;\n\ntatic void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tdentry = e->dentry;\n\tif (dentry) {\n\t\tlist_del_init(&e->list);\n\t\te->dentry = NULL;\n\t}\n\twrite_unlock(&entries_lock);\n\n\tif (dentry) {\n\t\tdrop_nlink(dentry->d_inode);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t\tsimple_release_fs(&bm_mnt, &entry_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "utex_lock(",
          "args": [
            "root->d_inode->i_mutex)"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get(",
          "args": [
            "ile->f_path.dentry->d_sb->s_root)"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ing_page_budget(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/file.c",
          "lines": "214-219",
          "snippet": "elease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int",
          "includes": [
            "ux/slab.h>\n\nstatic int r",
            "ux/namei.h>\n#include <lin",
            "ux/mount.h>\n#include <lin",
            "ux/aio.h>\n#include <lin",
            "fs.h\"\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "ux/slab.h>\n\nstatic int r\nux/namei.h>\n#include <lin\nux/mount.h>\n#include <lin\nux/aio.h>\n#include <lin\nfs.h\"\n#include <lin\n\nelease_existing_page_budget(struct ubifs_info *c)\n{\n\tstruct ubifs_budget_req req = { .dd_growth = c->bi.page_budget};\n\n\tubifs_release_budget(c, &req);\n}\n\nstatic int"
        }
      },
      {
        "call_info": {
          "callee": "et_bit(",
          "args": [
            "nabled,",
            "e->flags)"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lear_bit(",
          "args": [
            "nabled,",
            "e->flags)"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arse_command(",
          "args": [
            "uffer,",
            "ount)"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "arse_command(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
          "lines": "499-518",
          "snippet": "tatic int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}",
          "includes": [
            "include <linux/uaccess.h>",
            "include <linux/fs.h>\n#",
            "include <linux/syscalls.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/namei.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/file.h>\n#",
            "include <linux/string_helpers.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/binfmts.h>\n#",
            "include <linux/magic.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/module.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ile_inode(",
          "args": [
            "ile)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic ssize_t bm_entry_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct dentry *root;\n\tNode *e = file_inode(file)->i_private;\n\tint res = parse_command(buffer, count);\n\n\tswitch (res) {\n\tcase 1:\n\t\t/* Disable this handler. */\n\t\tclear_bit(Enabled, &e->flags);\n\t\tbreak;\n\tcase 2:\n\t\t/* Enable this handler. */\n\t\tset_bit(Enabled, &e->flags);\n\t\tbreak;\n\tcase 3:\n\t\t/* Delete this handler. */\n\t\troot = dget(file->f_path.dentry->d_sb->s_root);\n\t\tmutex_lock(&root->d_inode->i_mutex);\n\n\t\tkill_node(e);\n\n\t\tmutex_unlock(&root->d_inode->i_mutex);\n\t\tdput(root);\n\t\tbreak;\n\tdefault:\n\t\treturn res;\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "m_entry_read(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "615-632",
    "snippet": "tatic ssize_t\nbm_entry_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\n{\n\tNode *e = file_inode(file)->i_private;\n\tssize_t res;\n\tchar *page;\n\n\tpage = (char *) __get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tentry_status(e, page);\n\n\tres = simple_read_from_buffer(buf, nbytes, ppos, page, strlen(page));\n\n\tfree_page((unsigned long) page);\n\treturn res;\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree_page(",
          "args": [
            "unsigned long) page)"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imple_read_from_buffer(",
          "args": [
            "uf,",
            "bytes,",
            "pos,",
            "age,",
            "trlen(page))"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "age)"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntry_status(",
          "args": [
            ",",
            "age)"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "ntry_status(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
          "lines": "522-572",
          "snippet": "tatic void entry_status(Node *e, char *page)\n{\n\tchar *dp;\n\tchar *status = \"disabled\";\n\tconst char *flags = \"flags: \";\n\n\tif (test_bit(Enabled, &e->flags))\n\t\tstatus = \"enabled\";\n\n\tif (!VERBOSE_STATUS) {\n\t\tsprintf(page, \"%s\\n\", status);\n\t\treturn;\n\t}\n\n\tsprintf(page, \"%s\\ninterpreter %s\\n\", status, e->interpreter);\n\tdp = page + strlen(page);\n\n\t/* print the special flags */\n\tsprintf(dp, \"%s\", flags);\n\tdp += strlen(flags);\n\tif (e->flags & MISC_FMT_PRESERVE_ARGV0)\n\t\t*dp++ = 'P';\n\tif (e->flags & MISC_FMT_OPEN_BINARY)\n\t\t*dp++ = 'O';\n\tif (e->flags & MISC_FMT_CREDENTIALS)\n\t\t*dp++ = 'C';\n\t*dp++ = '\\n';\n\n\tif (!test_bit(Magic, &e->flags)) {\n\t\tsprintf(dp, \"extension .%s\\n\", e->magic);\n\t} else {\n\t\tint i;\n\n\t\tsprintf(dp, \"offset %i\\nmagic \", e->offset);\n\t\tdp = page + strlen(page);\n\t\tfor (i = 0; i < e->size; i++) {\n\t\t\tsprintf(dp, \"%02x\", 0xff & (int) (e->magic[i]));\n\t\t\tdp += 2;\n\t\t}\n\t\tif (e->mask) {\n\t\t\tsprintf(dp, \"\\nmask \");\n\t\t\tdp += 6;\n\t\t\tfor (i = 0; i < e->size; i++) {\n\t\t\t\tsprintf(dp, \"%02x\", 0xff & (int) (e->mask[i]));\n\t\t\t\tdp += 2;\n\t\t\t}\n\t\t}\n\t\t*dp++ = '\\n';\n\t\t*dp = '\\0';\n\t}\n}",
          "includes": [
            "include <linux/uaccess.h>",
            "include <linux/fs.h>\n#",
            "include <linux/syscalls.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/namei.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/file.h>\n#",
            "include <linux/string_helpers.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/binfmts.h>\n#",
            "include <linux/magic.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/module.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic int enabled = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic int enabled = 1;\n\ntatic void entry_status(Node *e, char *page)\n{\n\tchar *dp;\n\tchar *status = \"disabled\";\n\tconst char *flags = \"flags: \";\n\n\tif (test_bit(Enabled, &e->flags))\n\t\tstatus = \"enabled\";\n\n\tif (!VERBOSE_STATUS) {\n\t\tsprintf(page, \"%s\\n\", status);\n\t\treturn;\n\t}\n\n\tsprintf(page, \"%s\\ninterpreter %s\\n\", status, e->interpreter);\n\tdp = page + strlen(page);\n\n\t/* print the special flags */\n\tsprintf(dp, \"%s\", flags);\n\tdp += strlen(flags);\n\tif (e->flags & MISC_FMT_PRESERVE_ARGV0)\n\t\t*dp++ = 'P';\n\tif (e->flags & MISC_FMT_OPEN_BINARY)\n\t\t*dp++ = 'O';\n\tif (e->flags & MISC_FMT_CREDENTIALS)\n\t\t*dp++ = 'C';\n\t*dp++ = '\\n';\n\n\tif (!test_bit(Magic, &e->flags)) {\n\t\tsprintf(dp, \"extension .%s\\n\", e->magic);\n\t} else {\n\t\tint i;\n\n\t\tsprintf(dp, \"offset %i\\nmagic \", e->offset);\n\t\tdp = page + strlen(page);\n\t\tfor (i = 0; i < e->size; i++) {\n\t\t\tsprintf(dp, \"%02x\", 0xff & (int) (e->magic[i]));\n\t\t\tdp += 2;\n\t\t}\n\t\tif (e->mask) {\n\t\t\tsprintf(dp, \"\\nmask \");\n\t\t\tdp += 6;\n\t\t\tfor (i = 0; i < e->size; i++) {\n\t\t\t\tsprintf(dp, \"%02x\", 0xff & (int) (e->mask[i]));\n\t\t\t\tdp += 2;\n\t\t\t}\n\t\t}\n\t\t*dp++ = '\\n';\n\t\t*dp = '\\0';\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_get_free_page(",
          "args": [
            "FP_KERNEL)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ile_inode(",
          "args": [
            "ile)"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic ssize_t\nbm_entry_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\n{\n\tNode *e = file_inode(file)->i_private;\n\tssize_t res;\n\tchar *page;\n\n\tpage = (char *) __get_free_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tentry_status(e, page);\n\n\tres = simple_read_from_buffer(buf, nbytes, ppos, page, strlen(page));\n\n\tfree_page((unsigned long) page);\n\treturn res;\n}"
  },
  {
    "function_name": "ill_node(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "593-611",
    "snippet": "tatic void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tdentry = e->dentry;\n\tif (dentry) {\n\t\tlist_del_init(&e->list);\n\t\te->dentry = NULL;\n\t}\n\twrite_unlock(&entries_lock);\n\n\tif (dentry) {\n\t\tdrop_nlink(dentry->d_inode);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t\tsimple_release_fs(&bm_mnt, &entry_count);\n\t}\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic DEFINE_RWLOCK(entries_lock);",
      "tatic struct vfsmount *bm_mnt;",
      "tatic int entry_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "imple_release_fs(",
          "args": [
            "bm_mnt,",
            "entry_count)"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "entry)"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_drop(",
          "args": [
            "entry)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rop_nlink(",
          "args": [
            "entry->d_inode)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rite_unlock(",
          "args": [
            "entries_lock)"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_del_init(",
          "args": [
            "e->list)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rite_lock(",
          "args": [
            "entries_lock)"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic DEFINE_RWLOCK(entries_lock);\ntatic struct vfsmount *bm_mnt;\ntatic int entry_count;\n\ntatic void kill_node(Node *e)\n{\n\tstruct dentry *dentry;\n\n\twrite_lock(&entries_lock);\n\tdentry = e->dentry;\n\tif (dentry) {\n\t\tlist_del_init(&e->list);\n\t\te->dentry = NULL;\n\t}\n\twrite_unlock(&entries_lock);\n\n\tif (dentry) {\n\t\tdrop_nlink(dentry->d_inode);\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t\tsimple_release_fs(&bm_mnt, &entry_count);\n\t}\n}"
  },
  {
    "function_name": "m_evict_inode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "587-591",
    "snippet": "tatic void bm_evict_inode(struct inode *inode)\n{\n\tclear_inode(inode);\n\tkfree(inode->i_private);\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free(",
          "args": [
            "node->i_private)"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "lear_inode(",
          "args": [
            "node)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic void bm_evict_inode(struct inode *inode)\n{\n\tclear_inode(inode);\n\tkfree(inode->i_private);\n}"
  },
  {
    "function_name": "m_get_inode(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "574-585",
    "snippet": "tatic struct inode *bm_get_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t}\n\treturn inode;\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "urrent_fs_time(",
          "args": [
            "node->i_sb)"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_next_ino(",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ew_inode(",
          "args": [
            "b)"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic struct inode *bm_get_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *inode = new_inode(sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime =\n\t\t\tcurrent_fs_time(inode->i_sb);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "ntry_status(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "522-572",
    "snippet": "tatic void entry_status(Node *e, char *page)\n{\n\tchar *dp;\n\tchar *status = \"disabled\";\n\tconst char *flags = \"flags: \";\n\n\tif (test_bit(Enabled, &e->flags))\n\t\tstatus = \"enabled\";\n\n\tif (!VERBOSE_STATUS) {\n\t\tsprintf(page, \"%s\\n\", status);\n\t\treturn;\n\t}\n\n\tsprintf(page, \"%s\\ninterpreter %s\\n\", status, e->interpreter);\n\tdp = page + strlen(page);\n\n\t/* print the special flags */\n\tsprintf(dp, \"%s\", flags);\n\tdp += strlen(flags);\n\tif (e->flags & MISC_FMT_PRESERVE_ARGV0)\n\t\t*dp++ = 'P';\n\tif (e->flags & MISC_FMT_OPEN_BINARY)\n\t\t*dp++ = 'O';\n\tif (e->flags & MISC_FMT_CREDENTIALS)\n\t\t*dp++ = 'C';\n\t*dp++ = '\\n';\n\n\tif (!test_bit(Magic, &e->flags)) {\n\t\tsprintf(dp, \"extension .%s\\n\", e->magic);\n\t} else {\n\t\tint i;\n\n\t\tsprintf(dp, \"offset %i\\nmagic \", e->offset);\n\t\tdp = page + strlen(page);\n\t\tfor (i = 0; i < e->size; i++) {\n\t\t\tsprintf(dp, \"%02x\", 0xff & (int) (e->magic[i]));\n\t\t\tdp += 2;\n\t\t}\n\t\tif (e->mask) {\n\t\t\tsprintf(dp, \"\\nmask \");\n\t\t\tdp += 6;\n\t\t\tfor (i = 0; i < e->size; i++) {\n\t\t\t\tsprintf(dp, \"%02x\", 0xff & (int) (e->mask[i]));\n\t\t\t\tdp += 2;\n\t\t\t}\n\t\t}\n\t\t*dp++ = '\\n';\n\t\t*dp = '\\0';\n\t}\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int enabled = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf(",
          "args": [
            "p,",
            "%02x\",",
            "xff & (int) (e->mask[i]))"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf(",
          "args": [
            "p,",
            "\\nmask \")"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf(",
          "args": [
            "p,",
            "%02x\",",
            "xff & (int) (e->magic[i]))"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "age)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf(",
          "args": [
            "p,",
            "offset %i\\nmagic \",",
            "->offset)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf(",
          "args": [
            "p,",
            "extension .%s\\n\",",
            "->magic)"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "est_bit(",
          "args": [
            "agic,",
            "e->flags)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "lags)"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf(",
          "args": [
            "p,",
            "%s\",",
            "lags)"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlen(",
          "args": [
            "age)"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf(",
          "args": [
            "age,",
            "%s\\ninterpreter %s\\n\",",
            "tatus,",
            "->interpreter)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf(",
          "args": [
            "age,",
            "%s\\n\",",
            "tatus)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "est_bit(",
          "args": [
            "nabled,",
            "e->flags)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic int enabled = 1;\n\ntatic void entry_status(Node *e, char *page)\n{\n\tchar *dp;\n\tchar *status = \"disabled\";\n\tconst char *flags = \"flags: \";\n\n\tif (test_bit(Enabled, &e->flags))\n\t\tstatus = \"enabled\";\n\n\tif (!VERBOSE_STATUS) {\n\t\tsprintf(page, \"%s\\n\", status);\n\t\treturn;\n\t}\n\n\tsprintf(page, \"%s\\ninterpreter %s\\n\", status, e->interpreter);\n\tdp = page + strlen(page);\n\n\t/* print the special flags */\n\tsprintf(dp, \"%s\", flags);\n\tdp += strlen(flags);\n\tif (e->flags & MISC_FMT_PRESERVE_ARGV0)\n\t\t*dp++ = 'P';\n\tif (e->flags & MISC_FMT_OPEN_BINARY)\n\t\t*dp++ = 'O';\n\tif (e->flags & MISC_FMT_CREDENTIALS)\n\t\t*dp++ = 'C';\n\t*dp++ = '\\n';\n\n\tif (!test_bit(Magic, &e->flags)) {\n\t\tsprintf(dp, \"extension .%s\\n\", e->magic);\n\t} else {\n\t\tint i;\n\n\t\tsprintf(dp, \"offset %i\\nmagic \", e->offset);\n\t\tdp = page + strlen(page);\n\t\tfor (i = 0; i < e->size; i++) {\n\t\t\tsprintf(dp, \"%02x\", 0xff & (int) (e->magic[i]));\n\t\t\tdp += 2;\n\t\t}\n\t\tif (e->mask) {\n\t\t\tsprintf(dp, \"\\nmask \");\n\t\t\tdp += 6;\n\t\t\tfor (i = 0; i < e->size; i++) {\n\t\t\t\tsprintf(dp, \"%02x\", 0xff & (int) (e->mask[i]));\n\t\t\t\tdp += 2;\n\t\t\t}\n\t\t}\n\t\t*dp++ = '\\n';\n\t\t*dp = '\\0';\n\t}\n}"
  },
  {
    "function_name": "arse_command(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "499-518",
    "snippet": "tatic int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "opy_from_user(",
          "args": [
            ",",
            "uffer,",
            "ount)"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic int parse_command(const char __user *buffer, size_t count)\n{\n\tchar s[4];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\tif (copy_from_user(s, buffer, count))\n\t\treturn -EFAULT;\n\tif (!count)\n\t\treturn 0;\n\tif (s[count - 1] == '\\n')\n\t\tcount--;\n\tif (count == 1 && s[0] == '0')\n\t\treturn 1;\n\tif (count == 1 && s[0] == '1')\n\t\treturn 2;\n\tif (count == 2 && s[0] == '-' && s[1] == '1')\n\t\treturn 3;\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "reate_entry(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "300-493",
    "snippet": "tatic Node *create_entry(const char __user *buffer, size_t count)\n{\n\tNode *e;\n\tint memsize, err;\n\tchar *buf, *p;\n\tchar del;\n\n\tpr_debug(\"register: received %zu bytes\\n\", count);\n\n\t/* some sanity checks */\n\terr = -EINVAL;\n\tif ((count < 11) || (count > MAX_REGISTER_LENGTH))\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tmemsize = sizeof(Node) + count + 8;\n\te = kmalloc(memsize, GFP_KERNEL);\n\tif (!e)\n\t\tgoto out;\n\n\tp = buf = (char *)e + sizeof(Node);\n\n\tmemset(e, 0, sizeof(Node));\n\tif (copy_from_user(buf, buffer, count))\n\t\tgoto efault;\n\n\tdel = *p++;\t/* delimeter */\n\n\tpr_debug(\"register: delim: %#x {%c}\\n\", del, del);\n\n\t/* Pad the buffer with the delim to simplify parsing below. */\n\tmemset(buf + count, del, 8);\n\n\t/* Parse the 'name' field. */\n\te->name = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->name[0] ||\n\t    !strcmp(e->name, \".\") ||\n\t    !strcmp(e->name, \"..\") ||\n\t    strchr(e->name, '/'))\n\t\tgoto einval;\n\n\tpr_debug(\"register: name: {%s}\\n\", e->name);\n\n\t/* Parse the 'type' field. */\n\tswitch (*p++) {\n\tcase 'E':\n\t\tpr_debug(\"register: type: E (extension)\\n\");\n\t\te->flags = 1 << Enabled;\n\t\tbreak;\n\tcase 'M':\n\t\tpr_debug(\"register: type: M (magic)\\n\");\n\t\te->flags = (1 << Enabled) | (1 << Magic);\n\t\tbreak;\n\tdefault:\n\t\tgoto einval;\n\t}\n\tif (*p++ != del)\n\t\tgoto einval;\n\n\tif (test_bit(Magic, &e->flags)) {\n\t\t/* Handle the 'M' (magic) format. */\n\t\tchar *s;\n\n\t\t/* Parse the 'offset' field. */\n\t\ts = strchr(p, del);\n\t\tif (!s)\n\t\t\tgoto einval;\n\t\t*s++ = '\\0';\n\t\te->offset = simple_strtoul(p, &p, 10);\n\t\tif (*p++)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: offset: %#x\\n\", e->offset);\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->magic[0])\n\t\t\tgoto einval;\n\t\tif (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, p - e->magic);\n\n\t\t/* Parse the 'mask' field. */\n\t\te->mask = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->mask[0]) {\n\t\t\te->mask = NULL;\n\t\t\tpr_debug(\"register:  mask[raw]: none\\n\");\n\t\t} else if (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register:  mask[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->mask, p - e->mask);\n\n\t\t/*\n\t\t * Decode the magic & mask fields.\n\t\t * Note: while we might have accepted embedded NUL bytes from\n\t\t * above, the unescape helpers here will stop at the first one\n\t\t * it encounters.\n\t\t */\n\t\te->size = string_unescape_inplace(e->magic, UNESCAPE_HEX);\n\t\tif (e->mask &&\n\t\t    string_unescape_inplace(e->mask, UNESCAPE_HEX) != e->size)\n\t\t\tgoto einval;\n\t\tif (e->size + e->offset > BINPRM_BUF_SIZE)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: magic/mask length: %i\\n\", e->size);\n\t\tif (USE_DEBUG) {\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[decoded]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, e->size);\n\n\t\t\tif (e->mask) {\n\t\t\t\tint i;\n\t\t\t\tchar *masked = kmalloc(e->size, GFP_KERNEL);\n\n\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\tKBUILD_MODNAME \": register:  mask[decoded]: \",\n\t\t\t\t\tDUMP_PREFIX_NONE, e->mask, e->size);\n\n\t\t\t\tif (masked) {\n\t\t\t\t\tfor (i = 0; i < e->size; ++i)\n\t\t\t\t\t\tmasked[i] = e->magic[i] & e->mask[i];\n\t\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\t\tKBUILD_MODNAME \": register:  magic[masked]: \",\n\t\t\t\t\t\tDUMP_PREFIX_NONE, masked, e->size);\n\n\t\t\t\t\tkfree(masked);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Handle the 'E' (extension) format. */\n\n\t\t/* Skip the 'offset' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t\tif (!e->magic[0] || strchr(e->magic, '/'))\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: extension: {%s}\\n\", e->magic);\n\n\t\t/* Skip the 'mask' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t}\n\n\t/* Parse the 'interpreter' field. */\n\te->interpreter = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->interpreter[0])\n\t\tgoto einval;\n\tpr_debug(\"register: interpreter: {%s}\\n\", e->interpreter);\n\n\t/* Parse the 'flags' field. */\n\tp = check_special_flags(p, e);\n\tif (*p == '\\n')\n\t\tp++;\n\tif (p != buf + count)\n\t\tgoto einval;\n\n\treturn e;\n\nout:\n\treturn ERR_PTR(err);\n\nefault:\n\tkfree(e);\n\treturn ERR_PTR(-EFAULT);\neinval:\n\tkfree(e);\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "EINVAL)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free(",
          "args": [
            ")"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "in_free(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/scan.c",
          "lines": "51-60",
          "snippet": "tatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"summary.h\"\n#",
            "include \"nodelist.h\"\n#",
            "include <linux/compiler.h>\n#",
            "include <linux/crc32.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/mtd/mtd.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/kernel.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"summary.h\"\n#\ninclude \"nodelist.h\"\n#\ninclude <linux/compiler.h>\n#\ninclude <linux/crc32.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/mtd/mtd.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/kernel.h>\n#\n\ntatic inline int min_free(struct jffs2_sb_info *c)\n{\n\tuint32_t min = 2 * sizeof(struct jffs2_raw_inode);\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\n\tif (!jffs2_can_mark_obsolete(c) && min < c->wbuf_pagesize)\n\t\treturn c->wbuf_pagesize;\n#endif\n\treturn min;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "EFAULT)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RR_PTR(",
          "args": [
            "rr)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heck_special_flags(",
          "args": [
            ",",
            ")"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "heck_special_flags(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
          "lines": "261-293",
          "snippet": "tatic char *check_special_flags(char *sfs, Node *e)\n{\n\tchar *p = sfs;\n\tint cont = 1;\n\n\t/* special flags */\n\twhile (cont) {\n\t\tswitch (*p) {\n\t\tcase 'P':\n\t\t\tpr_debug(\"register: flag: P (preserve argv0)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_PRESERVE_ARGV0;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tpr_debug(\"register: flag: O (open binary)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_BINARY;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tpr_debug(\"register: flag: C (preserve creds)\\n\");\n\t\t\tp++;\n\t\t\t/* this flags also implies the\n\t\t\t   open-binary flag */\n\t\t\te->flags |= (MISC_FMT_CREDENTIALS |\n\t\t\t\t\tMISC_FMT_OPEN_BINARY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcont = 0;\n\t\t}\n\t}\n\n\treturn p;\n}",
          "includes": [
            "include <linux/uaccess.h>",
            "include <linux/fs.h>\n#",
            "include <linux/syscalls.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/namei.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/file.h>\n#",
            "include <linux/string_helpers.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/binfmts.h>\n#",
            "include <linux/magic.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/module.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic char *check_special_flags(char *sfs, Node *e)\n{\n\tchar *p = sfs;\n\tint cont = 1;\n\n\t/* special flags */\n\twhile (cont) {\n\t\tswitch (*p) {\n\t\tcase 'P':\n\t\t\tpr_debug(\"register: flag: P (preserve argv0)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_PRESERVE_ARGV0;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tpr_debug(\"register: flag: O (open binary)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_BINARY;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tpr_debug(\"register: flag: C (preserve creds)\\n\");\n\t\t\tp++;\n\t\t\t/* this flags also implies the\n\t\t\t   open-binary flag */\n\t\t\te->flags |= (MISC_FMT_CREDENTIALS |\n\t\t\t\t\tMISC_FMT_OPEN_BINARY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcont = 0;\n\t\t}\n\t}\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register: interpreter: {%s}\\n\",",
            "->interpreter)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            ",",
            "el)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            ",",
            "el)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register: extension: {%s}\\n\",",
            "->magic)"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            "->magic,",
            "/')"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            ",",
            "el)"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            ",",
            "el)"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint_hex_dump_bytes(",
          "args": [
            "BUILD_MODNAME \": register:  magic[masked]: \",",
            "UMP_PREFIX_NONE,",
            "asked,",
            "->size)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint_hex_dump_bytes(",
          "args": [
            "BUILD_MODNAME \": register:  mask[decoded]: \",",
            "UMP_PREFIX_NONE,",
            "->mask,",
            "->size)"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc(",
          "args": [
            "->size,",
            "FP_KERNEL)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint_hex_dump_bytes(",
          "args": [
            "BUILD_MODNAME \": register: magic[decoded]: \",",
            "UMP_PREFIX_NONE,",
            "->magic,",
            "->size)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register: magic/mask length: %i\\n\",",
            "->size)"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring_unescape_inplace(",
          "args": [
            "->mask,",
            "NESCAPE_HEX)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tring_unescape_inplace(",
          "args": [
            "->magic,",
            "NESCAPE_HEX)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rint_hex_dump_bytes(",
          "args": [
            "BUILD_MODNAME \": register:  mask[raw]: \",",
            "UMP_PREFIX_NONE,",
            "->mask,",
            "- e->mask)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register:  mask[raw]: none\\n\")"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "canarg(",
          "args": [
            ",",
            "el)"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "canarg(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
          "lines": "244-259",
          "snippet": "tatic char *scanarg(char *s, char del)\n{\n\tchar c;\n\n\twhile ((c = *s++) != del) {\n\t\tif (c == '\\\\' && *s == 'x') {\n\t\t\ts++;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\ts[-1] ='\\0';\n\treturn s;\n}",
          "includes": [
            "include <linux/uaccess.h>",
            "include <linux/fs.h>\n#",
            "include <linux/syscalls.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/namei.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/file.h>\n#",
            "include <linux/string_helpers.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/binfmts.h>\n#",
            "include <linux/magic.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/module.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic char *scanarg(char *s, char del)\n{\n\tchar c;\n\n\twhile ((c = *s++) != del) {\n\t\tif (c == '\\\\' && *s == 'x') {\n\t\t\ts++;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\ts[-1] ='\\0';\n\treturn s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rint_hex_dump_bytes(",
          "args": [
            "BUILD_MODNAME \": register: magic[raw]: \",",
            "UMP_PREFIX_NONE,",
            "->magic,",
            "- e->magic)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register: offset: %#x\\n\",",
            "->offset)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "imple_strtoul(",
          "args": [
            ",",
            "p,",
            "0)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            ",",
            "el)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "est_bit(",
          "args": [
            "agic,",
            "e->flags)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register: type: M (magic)\\n\")"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register: type: E (extension)\\n\")"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register: name: {%s}\\n\",",
            "->name)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            "->name,",
            "/')"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "->name,",
            "..\")"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "->name,",
            ".\")"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trchr(",
          "args": [
            ",",
            "el)"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "uf + count,",
            "el,",
            ")"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register: delim: %#x {%c}\\n\",",
            "el,",
            "el)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_from_user(",
          "args": [
            "uf,",
            "uffer,",
            "ount)"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            ",",
            ",",
            "izeof(Node))"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc(",
          "args": [
            "emsize,",
            "FP_KERNEL)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register: received %zu bytes\\n\",",
            "ount)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic Node *create_entry(const char __user *buffer, size_t count)\n{\n\tNode *e;\n\tint memsize, err;\n\tchar *buf, *p;\n\tchar del;\n\n\tpr_debug(\"register: received %zu bytes\\n\", count);\n\n\t/* some sanity checks */\n\terr = -EINVAL;\n\tif ((count < 11) || (count > MAX_REGISTER_LENGTH))\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tmemsize = sizeof(Node) + count + 8;\n\te = kmalloc(memsize, GFP_KERNEL);\n\tif (!e)\n\t\tgoto out;\n\n\tp = buf = (char *)e + sizeof(Node);\n\n\tmemset(e, 0, sizeof(Node));\n\tif (copy_from_user(buf, buffer, count))\n\t\tgoto efault;\n\n\tdel = *p++;\t/* delimeter */\n\n\tpr_debug(\"register: delim: %#x {%c}\\n\", del, del);\n\n\t/* Pad the buffer with the delim to simplify parsing below. */\n\tmemset(buf + count, del, 8);\n\n\t/* Parse the 'name' field. */\n\te->name = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->name[0] ||\n\t    !strcmp(e->name, \".\") ||\n\t    !strcmp(e->name, \"..\") ||\n\t    strchr(e->name, '/'))\n\t\tgoto einval;\n\n\tpr_debug(\"register: name: {%s}\\n\", e->name);\n\n\t/* Parse the 'type' field. */\n\tswitch (*p++) {\n\tcase 'E':\n\t\tpr_debug(\"register: type: E (extension)\\n\");\n\t\te->flags = 1 << Enabled;\n\t\tbreak;\n\tcase 'M':\n\t\tpr_debug(\"register: type: M (magic)\\n\");\n\t\te->flags = (1 << Enabled) | (1 << Magic);\n\t\tbreak;\n\tdefault:\n\t\tgoto einval;\n\t}\n\tif (*p++ != del)\n\t\tgoto einval;\n\n\tif (test_bit(Magic, &e->flags)) {\n\t\t/* Handle the 'M' (magic) format. */\n\t\tchar *s;\n\n\t\t/* Parse the 'offset' field. */\n\t\ts = strchr(p, del);\n\t\tif (!s)\n\t\t\tgoto einval;\n\t\t*s++ = '\\0';\n\t\te->offset = simple_strtoul(p, &p, 10);\n\t\tif (*p++)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: offset: %#x\\n\", e->offset);\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->magic[0])\n\t\t\tgoto einval;\n\t\tif (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, p - e->magic);\n\n\t\t/* Parse the 'mask' field. */\n\t\te->mask = p;\n\t\tp = scanarg(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\tif (!e->mask[0]) {\n\t\t\te->mask = NULL;\n\t\t\tpr_debug(\"register:  mask[raw]: none\\n\");\n\t\t} else if (USE_DEBUG)\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register:  mask[raw]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->mask, p - e->mask);\n\n\t\t/*\n\t\t * Decode the magic & mask fields.\n\t\t * Note: while we might have accepted embedded NUL bytes from\n\t\t * above, the unescape helpers here will stop at the first one\n\t\t * it encounters.\n\t\t */\n\t\te->size = string_unescape_inplace(e->magic, UNESCAPE_HEX);\n\t\tif (e->mask &&\n\t\t    string_unescape_inplace(e->mask, UNESCAPE_HEX) != e->size)\n\t\t\tgoto einval;\n\t\tif (e->size + e->offset > BINPRM_BUF_SIZE)\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: magic/mask length: %i\\n\", e->size);\n\t\tif (USE_DEBUG) {\n\t\t\tprint_hex_dump_bytes(\n\t\t\t\tKBUILD_MODNAME \": register: magic[decoded]: \",\n\t\t\t\tDUMP_PREFIX_NONE, e->magic, e->size);\n\n\t\t\tif (e->mask) {\n\t\t\t\tint i;\n\t\t\t\tchar *masked = kmalloc(e->size, GFP_KERNEL);\n\n\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\tKBUILD_MODNAME \": register:  mask[decoded]: \",\n\t\t\t\t\tDUMP_PREFIX_NONE, e->mask, e->size);\n\n\t\t\t\tif (masked) {\n\t\t\t\t\tfor (i = 0; i < e->size; ++i)\n\t\t\t\t\t\tmasked[i] = e->magic[i] & e->mask[i];\n\t\t\t\t\tprint_hex_dump_bytes(\n\t\t\t\t\t\tKBUILD_MODNAME \": register:  magic[masked]: \",\n\t\t\t\t\t\tDUMP_PREFIX_NONE, masked, e->size);\n\n\t\t\t\t\tkfree(masked);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Handle the 'E' (extension) format. */\n\n\t\t/* Skip the 'offset' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\n\t\t/* Parse the 'magic' field. */\n\t\te->magic = p;\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t\tif (!e->magic[0] || strchr(e->magic, '/'))\n\t\t\tgoto einval;\n\t\tpr_debug(\"register: extension: {%s}\\n\", e->magic);\n\n\t\t/* Skip the 'mask' field. */\n\t\tp = strchr(p, del);\n\t\tif (!p)\n\t\t\tgoto einval;\n\t\t*p++ = '\\0';\n\t}\n\n\t/* Parse the 'interpreter' field. */\n\te->interpreter = p;\n\tp = strchr(p, del);\n\tif (!p)\n\t\tgoto einval;\n\t*p++ = '\\0';\n\tif (!e->interpreter[0])\n\t\tgoto einval;\n\tpr_debug(\"register: interpreter: {%s}\\n\", e->interpreter);\n\n\t/* Parse the 'flags' field. */\n\tp = check_special_flags(p, e);\n\tif (*p == '\\n')\n\t\tp++;\n\tif (p != buf + count)\n\t\tgoto einval;\n\n\treturn e;\n\nout:\n\treturn ERR_PTR(err);\n\nefault:\n\tkfree(e);\n\treturn ERR_PTR(-EFAULT);\neinval:\n\tkfree(e);\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "heck_special_flags(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "261-293",
    "snippet": "tatic char *check_special_flags(char *sfs, Node *e)\n{\n\tchar *p = sfs;\n\tint cont = 1;\n\n\t/* special flags */\n\twhile (cont) {\n\t\tswitch (*p) {\n\t\tcase 'P':\n\t\t\tpr_debug(\"register: flag: P (preserve argv0)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_PRESERVE_ARGV0;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tpr_debug(\"register: flag: O (open binary)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_BINARY;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tpr_debug(\"register: flag: C (preserve creds)\\n\");\n\t\t\tp++;\n\t\t\t/* this flags also implies the\n\t\t\t   open-binary flag */\n\t\t\te->flags |= (MISC_FMT_CREDENTIALS |\n\t\t\t\t\tMISC_FMT_OPEN_BINARY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcont = 0;\n\t\t}\n\t}\n\n\treturn p;\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register: flag: C (preserve creds)\\n\")"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register: flag: O (open binary)\\n\")"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r_debug(",
          "args": [
            "register: flag: P (preserve argv0)\\n\")"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic char *check_special_flags(char *sfs, Node *e)\n{\n\tchar *p = sfs;\n\tint cont = 1;\n\n\t/* special flags */\n\twhile (cont) {\n\t\tswitch (*p) {\n\t\tcase 'P':\n\t\t\tpr_debug(\"register: flag: P (preserve argv0)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_PRESERVE_ARGV0;\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tpr_debug(\"register: flag: O (open binary)\\n\");\n\t\t\tp++;\n\t\t\te->flags |= MISC_FMT_OPEN_BINARY;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tpr_debug(\"register: flag: C (preserve creds)\\n\");\n\t\t\tp++;\n\t\t\t/* this flags also implies the\n\t\t\t   open-binary flag */\n\t\t\te->flags |= (MISC_FMT_CREDENTIALS |\n\t\t\t\t\tMISC_FMT_OPEN_BINARY);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcont = 0;\n\t\t}\n\t}\n\n\treturn p;\n}"
  },
  {
    "function_name": "canarg(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "244-259",
    "snippet": "tatic char *scanarg(char *s, char del)\n{\n\tchar c;\n\n\twhile ((c = *s++) != del) {\n\t\tif (c == '\\\\' && *s == 'x') {\n\t\t\ts++;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\ts[-1] ='\\0';\n\treturn s;\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sxdigit(",
          "args": [
            "s++)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sxdigit(",
          "args": [
            "s++)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic char *scanarg(char *s, char del)\n{\n\tchar c;\n\n\twhile ((c = *s++) != del) {\n\t\tif (c == '\\\\' && *s == 'x') {\n\t\t\ts++;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t\tif (!isxdigit(*s++))\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\ts[-1] ='\\0';\n\treturn s;\n}"
  },
  {
    "function_name": "oad_misc_binary(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "125-234",
    "snippet": "tatic int load_misc_binary(struct linux_binprm *bprm)\n{\n\tNode *fmt;\n\tstruct file *interp_file = NULL;\n\tchar iname[BINPRM_BUF_SIZE];\n\tconst char *iname_addr = iname;\n\tint retval;\n\tint fd_binary = -1;\n\n\tretval = -ENOEXEC;\n\tif (!enabled)\n\t\tgoto ret;\n\n\t/* to keep locking time low, we copy the interpreter string */\n\tread_lock(&entries_lock);\n\tfmt = check_file(bprm);\n\tif (fmt)\n\t\tstrlcpy(iname, fmt->interpreter, BINPRM_BUF_SIZE);\n\tread_unlock(&entries_lock);\n\tif (!fmt)\n\t\tgoto ret;\n\n\t/* Need to be able to load the file after exec */\n\tif (bprm->interp_flags & BINPRM_FLAGS_PATH_INACCESSIBLE)\n\t\treturn -ENOENT;\n\n\tif (!(fmt->flags & MISC_FMT_PRESERVE_ARGV0)) {\n\t\tretval = remove_arg_zero(bprm);\n\t\tif (retval)\n\t\t\tgoto ret;\n\t}\n\n\tif (fmt->flags & MISC_FMT_OPEN_BINARY) {\n\n\t\t/* if the binary should be opened on behalf of the\n\t\t * interpreter than keep it open and assign descriptor\n\t\t * to it\n\t\t */\n\t\tfd_binary = get_unused_fd_flags(0);\n\t\tif (fd_binary < 0) {\n\t\t\tretval = fd_binary;\n\t\t\tgoto ret;\n\t\t}\n\t\tfd_install(fd_binary, bprm->file);\n\n\t\t/* if the binary is not readable than enforce mm->dumpable=0\n\t\t   regardless of the interpreter's permissions */\n\t\twould_dump(bprm, bprm->file);\n\n\t\tallow_write_access(bprm->file);\n\t\tbprm->file = NULL;\n\n\t\t/* mark the bprm that fd should be passed to interp */\n\t\tbprm->interp_flags |= BINPRM_FLAGS_EXECFD;\n\t\tbprm->interp_data = fd_binary;\n\n\t} else {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t\tbprm->file = NULL;\n\t}\n\t/* make argv[1] be the path to the binary */\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\tbprm->argc++;\n\n\t/* add the interp as argv[0] */\n\tretval = copy_strings_kernel(1, &iname_addr, bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\tbprm->argc++;\n\n\t/* Update interp in case binfmt_script needs it. */\n\tretval = bprm_change_interp(iname, bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tinterp_file = open_exec(iname);\n\tretval = PTR_ERR(interp_file);\n\tif (IS_ERR(interp_file))\n\t\tgoto error;\n\n\tbprm->file = interp_file;\n\tif (fmt->flags & MISC_FMT_CREDENTIALS) {\n\t\t/*\n\t\t * No need to call prepare_binprm(), it's already been\n\t\t * done.  bprm->buf is stale, update from interp_file.\n\t\t */\n\t\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\t\tretval = kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n\t} else\n\t\tretval = prepare_binprm(bprm);\n\n\tif (retval < 0)\n\t\tgoto error;\n\n\tretval = search_binary_handler(bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\nret:\n\treturn retval;\nerror:\n\tif (fd_binary > 0)\n\t\tsys_close(fd_binary);\n\tbprm->interp_flags = 0;\n\tbprm->interp_data = 0;\n\tgoto ret;\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic int enabled = 1;",
      "tatic DEFINE_RWLOCK(entries_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ys_close(",
          "args": [
            "d_binary)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "earch_binary_handler(",
          "args": [
            "prm)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "repare_binprm(",
          "args": [
            "prm)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ernel_read(",
          "args": [
            "prm->file,",
            ",",
            "prm->buf,",
            "INPRM_BUF_SIZE)"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emset(",
          "args": [
            "prm->buf,",
            ",",
            "INPRM_BUF_SIZE)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ERR(",
          "args": [
            "nterp_file)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TR_ERR(",
          "args": [
            "nterp_file)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pen_exec(",
          "args": [
            "name)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prm_change_interp(",
          "args": [
            "name,",
            "prm)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_strings_kernel(",
          "args": [
            ",",
            "iname_addr,",
            "prm)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opy_strings_kernel(",
          "args": [
            ",",
            "bprm->interp,",
            "prm)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put(",
          "args": [
            "prm->file)"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llow_write_access(",
          "args": [
            "prm->file)"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "llow_write_access(",
          "args": [
            "prm->file)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ould_dump(",
          "args": [
            "prm,",
            "prm->file)"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_install(",
          "args": [
            "d_binary,",
            "prm->file)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "et_unused_fd_flags(",
          "args": [
            ")"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "emove_arg_zero(",
          "args": [
            "prm)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ead_unlock(",
          "args": [
            "entries_lock)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trlcpy(",
          "args": [
            "name,",
            "mt->interpreter,",
            "INPRM_BUF_SIZE)"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "heck_file(",
          "args": [
            "prm)"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "heck_file(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
          "lines": "83-120",
          "snippet": "tatic Node *check_file(struct linux_binprm *bprm)\n{\n\tchar *p = strrchr(bprm->interp, '.');\n\tstruct list_head *l;\n\n\t/* Walk all the registered handlers. */\n\tlist_for_each(l, &entries) {\n\t\tNode *e = list_entry(l, Node, list);\n\t\tchar *s;\n\t\tint j;\n\n\t\t/* Make sure this one is currently enabled. */\n\t\tif (!test_bit(Enabled, &e->flags))\n\t\t\tcontinue;\n\n\t\t/* Do matching based on extension if applicable. */\n\t\tif (!test_bit(Magic, &e->flags)) {\n\t\t\tif (p && !strcmp(e->magic, p + 1))\n\t\t\t\treturn e;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do matching based on magic & mask. */\n\t\ts = bprm->buf + e->offset;\n\t\tif (e->mask) {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]) & e->mask[j])\n\t\t\t\t\tbreak;\n\t\t} else {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]))\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif (j == e->size)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "include <linux/uaccess.h>",
            "include <linux/fs.h>\n#",
            "include <linux/syscalls.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/namei.h>\n#",
            "include <linux/pagemap.h>\n#",
            "include <linux/file.h>\n#",
            "include <linux/string_helpers.h>\n#",
            "include <linux/ctype.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/binfmts.h>\n#",
            "include <linux/magic.h>\n#",
            "include <linux/sched.h>\n#",
            "include <linux/init.h>\n#",
            "include <linux/module.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic LIST_HEAD(entries);",
            "tatic int enabled = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic LIST_HEAD(entries);\ntatic int enabled = 1;\n\ntatic Node *check_file(struct linux_binprm *bprm)\n{\n\tchar *p = strrchr(bprm->interp, '.');\n\tstruct list_head *l;\n\n\t/* Walk all the registered handlers. */\n\tlist_for_each(l, &entries) {\n\t\tNode *e = list_entry(l, Node, list);\n\t\tchar *s;\n\t\tint j;\n\n\t\t/* Make sure this one is currently enabled. */\n\t\tif (!test_bit(Enabled, &e->flags))\n\t\t\tcontinue;\n\n\t\t/* Do matching based on extension if applicable. */\n\t\tif (!test_bit(Magic, &e->flags)) {\n\t\t\tif (p && !strcmp(e->magic, p + 1))\n\t\t\t\treturn e;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do matching based on magic & mask. */\n\t\ts = bprm->buf + e->offset;\n\t\tif (e->mask) {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]) & e->mask[j])\n\t\t\t\t\tbreak;\n\t\t} else {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]))\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif (j == e->size)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ead_lock(",
          "args": [
            "entries_lock)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic int enabled = 1;\ntatic DEFINE_RWLOCK(entries_lock);\n\ntatic int load_misc_binary(struct linux_binprm *bprm)\n{\n\tNode *fmt;\n\tstruct file *interp_file = NULL;\n\tchar iname[BINPRM_BUF_SIZE];\n\tconst char *iname_addr = iname;\n\tint retval;\n\tint fd_binary = -1;\n\n\tretval = -ENOEXEC;\n\tif (!enabled)\n\t\tgoto ret;\n\n\t/* to keep locking time low, we copy the interpreter string */\n\tread_lock(&entries_lock);\n\tfmt = check_file(bprm);\n\tif (fmt)\n\t\tstrlcpy(iname, fmt->interpreter, BINPRM_BUF_SIZE);\n\tread_unlock(&entries_lock);\n\tif (!fmt)\n\t\tgoto ret;\n\n\t/* Need to be able to load the file after exec */\n\tif (bprm->interp_flags & BINPRM_FLAGS_PATH_INACCESSIBLE)\n\t\treturn -ENOENT;\n\n\tif (!(fmt->flags & MISC_FMT_PRESERVE_ARGV0)) {\n\t\tretval = remove_arg_zero(bprm);\n\t\tif (retval)\n\t\t\tgoto ret;\n\t}\n\n\tif (fmt->flags & MISC_FMT_OPEN_BINARY) {\n\n\t\t/* if the binary should be opened on behalf of the\n\t\t * interpreter than keep it open and assign descriptor\n\t\t * to it\n\t\t */\n\t\tfd_binary = get_unused_fd_flags(0);\n\t\tif (fd_binary < 0) {\n\t\t\tretval = fd_binary;\n\t\t\tgoto ret;\n\t\t}\n\t\tfd_install(fd_binary, bprm->file);\n\n\t\t/* if the binary is not readable than enforce mm->dumpable=0\n\t\t   regardless of the interpreter's permissions */\n\t\twould_dump(bprm, bprm->file);\n\n\t\tallow_write_access(bprm->file);\n\t\tbprm->file = NULL;\n\n\t\t/* mark the bprm that fd should be passed to interp */\n\t\tbprm->interp_flags |= BINPRM_FLAGS_EXECFD;\n\t\tbprm->interp_data = fd_binary;\n\n\t} else {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t\tbprm->file = NULL;\n\t}\n\t/* make argv[1] be the path to the binary */\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\tbprm->argc++;\n\n\t/* add the interp as argv[0] */\n\tretval = copy_strings_kernel(1, &iname_addr, bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\tbprm->argc++;\n\n\t/* Update interp in case binfmt_script needs it. */\n\tretval = bprm_change_interp(iname, bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\n\tinterp_file = open_exec(iname);\n\tretval = PTR_ERR(interp_file);\n\tif (IS_ERR(interp_file))\n\t\tgoto error;\n\n\tbprm->file = interp_file;\n\tif (fmt->flags & MISC_FMT_CREDENTIALS) {\n\t\t/*\n\t\t * No need to call prepare_binprm(), it's already been\n\t\t * done.  bprm->buf is stale, update from interp_file.\n\t\t */\n\t\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\t\tretval = kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n\t} else\n\t\tretval = prepare_binprm(bprm);\n\n\tif (retval < 0)\n\t\tgoto error;\n\n\tretval = search_binary_handler(bprm);\n\tif (retval < 0)\n\t\tgoto error;\n\nret:\n\treturn retval;\nerror:\n\tif (fd_binary > 0)\n\t\tsys_close(fd_binary);\n\tbprm->interp_flags = 0;\n\tbprm->interp_data = 0;\n\tgoto ret;\n}"
  },
  {
    "function_name": "heck_file(",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/binfmt_misc.c",
    "lines": "83-120",
    "snippet": "tatic Node *check_file(struct linux_binprm *bprm)\n{\n\tchar *p = strrchr(bprm->interp, '.');\n\tstruct list_head *l;\n\n\t/* Walk all the registered handlers. */\n\tlist_for_each(l, &entries) {\n\t\tNode *e = list_entry(l, Node, list);\n\t\tchar *s;\n\t\tint j;\n\n\t\t/* Make sure this one is currently enabled. */\n\t\tif (!test_bit(Enabled, &e->flags))\n\t\t\tcontinue;\n\n\t\t/* Do matching based on extension if applicable. */\n\t\tif (!test_bit(Magic, &e->flags)) {\n\t\t\tif (p && !strcmp(e->magic, p + 1))\n\t\t\t\treturn e;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do matching based on magic & mask. */\n\t\ts = bprm->buf + e->offset;\n\t\tif (e->mask) {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]) & e->mask[j])\n\t\t\t\t\tbreak;\n\t\t} else {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]))\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif (j == e->size)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "include <linux/uaccess.h>",
      "include <linux/fs.h>\n#",
      "include <linux/syscalls.h>\n#",
      "include <linux/mount.h>\n#",
      "include <linux/namei.h>\n#",
      "include <linux/pagemap.h>\n#",
      "include <linux/file.h>\n#",
      "include <linux/string_helpers.h>\n#",
      "include <linux/ctype.h>\n#",
      "include <linux/slab.h>\n#",
      "include <linux/binfmts.h>\n#",
      "include <linux/magic.h>\n#",
      "include <linux/sched.h>\n#",
      "include <linux/init.h>\n#",
      "include <linux/module.h>\n#"
    ],
    "macros_used": [],
    "globals_used": [
      "tatic LIST_HEAD(entries);",
      "tatic int enabled = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trcmp(",
          "args": [
            "->magic,",
            "+ 1)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "est_bit(",
          "args": [
            "agic,",
            "e->flags)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "est_bit(",
          "args": [
            "nabled,",
            "e->flags)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_entry(",
          "args": [
            ",",
            "ode,",
            "ist)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ist_for_each(",
          "args": [
            ",",
            "entries)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trrchr(",
          "args": [
            "prm->interp,",
            ".')"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "include <linux/uaccess.h>\ninclude <linux/fs.h>\n#\ninclude <linux/syscalls.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/namei.h>\n#\ninclude <linux/pagemap.h>\n#\ninclude <linux/file.h>\n#\ninclude <linux/string_helpers.h>\n#\ninclude <linux/ctype.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/binfmts.h>\n#\ninclude <linux/magic.h>\n#\ninclude <linux/sched.h>\n#\ninclude <linux/init.h>\n#\ninclude <linux/module.h>\n#\n\ntatic LIST_HEAD(entries);\ntatic int enabled = 1;\n\ntatic Node *check_file(struct linux_binprm *bprm)\n{\n\tchar *p = strrchr(bprm->interp, '.');\n\tstruct list_head *l;\n\n\t/* Walk all the registered handlers. */\n\tlist_for_each(l, &entries) {\n\t\tNode *e = list_entry(l, Node, list);\n\t\tchar *s;\n\t\tint j;\n\n\t\t/* Make sure this one is currently enabled. */\n\t\tif (!test_bit(Enabled, &e->flags))\n\t\t\tcontinue;\n\n\t\t/* Do matching based on extension if applicable. */\n\t\tif (!test_bit(Magic, &e->flags)) {\n\t\t\tif (p && !strcmp(e->magic, p + 1))\n\t\t\t\treturn e;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Do matching based on magic & mask. */\n\t\ts = bprm->buf + e->offset;\n\t\tif (e->mask) {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]) & e->mask[j])\n\t\t\t\t\tbreak;\n\t\t} else {\n\t\t\tfor (j = 0; j < e->size; j++)\n\t\t\t\tif ((*s++ ^ e->magic[j]))\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif (j == e->size)\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}"
  }
]