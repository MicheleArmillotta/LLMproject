[
  {
    "function_name": "fanotify_free_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.c",
    "lines": "249-264",
    "snippet": "static void fanotify_free_event(struct fsnotify_event *fsn_event)\n{\n\tstruct fanotify_event_info *event;\n\n\tevent = FANOTIFY_E(fsn_event);\n\tpath_put(&event->path);\n\tput_pid(event->tgid);\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tif (fsn_event->mask & FAN_ALL_PERM_EVENTS) {\n\t\tkmem_cache_free(fanotify_perm_event_cachep,\n\t\t\t\tFANOTIFY_PE(fsn_event));\n\t\treturn;\n\t}\n#endif\n\tkmem_cache_free(fanotify_event_cachep, event);\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/kernel.h> /* UINT_MAX */",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fanotify_event_cachep",
            "event"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "fanotify_perm_event_cachep",
            "FANOTIFY_PE(fsn_event)"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FANOTIFY_PE",
          "args": [
            "fsn_event"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "FANOTIFY_PE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.h",
          "lines": "37-41",
          "snippet": "static inline struct fanotify_perm_event_info *\nFANOTIFY_PE(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_perm_event_info, fae.fse);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fsnotify_backend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fsnotify_backend.h>\n\nstatic inline struct fanotify_perm_event_info *\nFANOTIFY_PE(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_perm_event_info, fae.fse);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "event->tgid"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&event->path"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FANOTIFY_E",
          "args": [
            "fsn_event"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "FANOTIFY_E",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.h",
          "lines": "44-47",
          "snippet": "static inline struct fanotify_event_info *FANOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_event_info, fse);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fsnotify_backend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fsnotify_backend.h>\n\nstatic inline struct fanotify_event_info *FANOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_event_info, fse);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/kernel.h> /* UINT_MAX */\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/fanotify.h>\n\nstatic void fanotify_free_event(struct fsnotify_event *fsn_event)\n{\n\tstruct fanotify_event_info *event;\n\n\tevent = FANOTIFY_E(fsn_event);\n\tpath_put(&event->path);\n\tput_pid(event->tgid);\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tif (fsn_event->mask & FAN_ALL_PERM_EVENTS) {\n\t\tkmem_cache_free(fanotify_perm_event_cachep,\n\t\t\t\tFANOTIFY_PE(fsn_event));\n\t\treturn;\n\t}\n#endif\n\tkmem_cache_free(fanotify_event_cachep, event);\n}"
  },
  {
    "function_name": "fanotify_free_group_priv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.c",
    "lines": "240-247",
    "snippet": "static void fanotify_free_group_priv(struct fsnotify_group *group)\n{\n\tstruct user_struct *user;\n\n\tuser = group->fanotify_data.user;\n\tatomic_dec(&user->fanotify_listeners);\n\tfree_uid(user);\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/kernel.h> /* UINT_MAX */",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "user"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&user->fanotify_listeners"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/kernel.h> /* UINT_MAX */\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/fanotify.h>\n\nstatic void fanotify_free_group_priv(struct fsnotify_group *group)\n{\n\tstruct user_struct *user;\n\n\tuser = group->fanotify_data.user;\n\tatomic_dec(&user->fanotify_listeners);\n\tfree_uid(user);\n}"
  },
  {
    "function_name": "fanotify_handle_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.c",
    "lines": "187-238",
    "snippet": "static int fanotify_handle_event(struct fsnotify_group *group,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct fsnotify_mark *inode_mark,\n\t\t\t\t struct fsnotify_mark *fanotify_mark,\n\t\t\t\t u32 mask, void *data, int data_type,\n\t\t\t\t const unsigned char *file_name, u32 cookie)\n{\n\tint ret = 0;\n\tstruct fanotify_event_info *event;\n\tstruct fsnotify_event *fsn_event;\n\n\tBUILD_BUG_ON(FAN_ACCESS != FS_ACCESS);\n\tBUILD_BUG_ON(FAN_MODIFY != FS_MODIFY);\n\tBUILD_BUG_ON(FAN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE);\n\tBUILD_BUG_ON(FAN_CLOSE_WRITE != FS_CLOSE_WRITE);\n\tBUILD_BUG_ON(FAN_OPEN != FS_OPEN);\n\tBUILD_BUG_ON(FAN_EVENT_ON_CHILD != FS_EVENT_ON_CHILD);\n\tBUILD_BUG_ON(FAN_Q_OVERFLOW != FS_Q_OVERFLOW);\n\tBUILD_BUG_ON(FAN_OPEN_PERM != FS_OPEN_PERM);\n\tBUILD_BUG_ON(FAN_ACCESS_PERM != FS_ACCESS_PERM);\n\tBUILD_BUG_ON(FAN_ONDIR != FS_ISDIR);\n\n\tif (!fanotify_should_send_event(inode_mark, fanotify_mark, mask, data,\n\t\t\t\t\tdata_type))\n\t\treturn 0;\n\n\tpr_debug(\"%s: group=%p inode=%p mask=%x\\n\", __func__, group, inode,\n\t\t mask);\n\n\tevent = fanotify_alloc_event(inode, mask, data);\n\tif (unlikely(!event))\n\t\treturn -ENOMEM;\n\n\tfsn_event = &event->fse;\n\tret = fsnotify_add_event(group, fsn_event, fanotify_merge);\n\tif (ret) {\n\t\t/* Permission events shouldn't be merged */\n\t\tBUG_ON(ret == 1 && mask & FAN_ALL_PERM_EVENTS);\n\t\t/* Our event wasn't used in the end. Free it. */\n\t\tfsnotify_destroy_event(group, fsn_event);\n\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tif (mask & FAN_ALL_PERM_EVENTS) {\n\t\tret = fanotify_get_response(group, FANOTIFY_PE(fsn_event));\n\t\tfsnotify_destroy_event(group, fsn_event);\n\t}\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/kernel.h> /* UINT_MAX */",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_destroy_event",
          "args": [
            "group",
            "fsn_event"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_destroy_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "70-79",
          "snippet": "void fsnotify_destroy_event(struct fsnotify_group *group,\n\t\t\t    struct fsnotify_event *event)\n{\n\t/* Overflow events are per-group and we don't want to free them */\n\tif (!event || event->mask == FS_Q_OVERFLOW)\n\t\treturn;\n\t/* If the event is still queued, we have a problem... */\n\tWARN_ON(!list_empty(&event->list));\n\tgroup->ops->free_event(event);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_destroy_event(struct fsnotify_group *group,\n\t\t\t    struct fsnotify_event *event)\n{\n\t/* Overflow events are per-group and we don't want to free them */\n\tif (!event || event->mask == FS_Q_OVERFLOW)\n\t\treturn;\n\t/* If the event is still queued, we have a problem... */\n\tWARN_ON(!list_empty(&event->list));\n\tgroup->ops->free_event(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fanotify_get_response",
          "args": [
            "group",
            "FANOTIFY_PE(fsn_event)"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "fanotify_get_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.c",
          "lines": "63-98",
          "snippet": "static int fanotify_get_response(struct fsnotify_group *group,\n\t\t\t\t struct fanotify_perm_event_info *event)\n{\n\tint ret;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\twait_event(group->fanotify_data.access_waitq, event->response ||\n\t\t\t\tatomic_read(&group->fanotify_data.bypass_perm));\n\n\tif (!event->response) {\t/* bypass_perm set */\n\t\t/*\n\t\t * Event was canceled because group is being destroyed. Remove\n\t\t * it from group's event list because we are responsible for\n\t\t * freeing the permission event.\n\t\t */\n\t\tfsnotify_remove_event(group, &event->fae.fse);\n\t\treturn 0;\n\t}\n\n\t/* userspace responded, convert to something usable */\n\tswitch (event->response) {\n\tcase FAN_ALLOW:\n\t\tret = 0;\n\t\tbreak;\n\tcase FAN_DENY:\n\tdefault:\n\t\tret = -EPERM;\n\t}\n\tevent->response = 0;\n\n\tpr_debug(\"%s: group=%p event=%p about to return ret=%d\\n\", __func__,\n\t\t group, event, ret);\n\t\n\treturn ret;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h> /* UINT_MAX */",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/kernel.h> /* UINT_MAX */\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/fanotify.h>\n\nstatic int fanotify_get_response(struct fsnotify_group *group,\n\t\t\t\t struct fanotify_perm_event_info *event)\n{\n\tint ret;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\twait_event(group->fanotify_data.access_waitq, event->response ||\n\t\t\t\tatomic_read(&group->fanotify_data.bypass_perm));\n\n\tif (!event->response) {\t/* bypass_perm set */\n\t\t/*\n\t\t * Event was canceled because group is being destroyed. Remove\n\t\t * it from group's event list because we are responsible for\n\t\t * freeing the permission event.\n\t\t */\n\t\tfsnotify_remove_event(group, &event->fae.fse);\n\t\treturn 0;\n\t}\n\n\t/* userspace responded, convert to something usable */\n\tswitch (event->response) {\n\tcase FAN_ALLOW:\n\t\tret = 0;\n\t\tbreak;\n\tcase FAN_DENY:\n\tdefault:\n\t\tret = -EPERM;\n\t}\n\tevent->response = 0;\n\n\tpr_debug(\"%s: group=%p event=%p about to return ret=%d\\n\", __func__,\n\t\t group, event, ret);\n\t\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FANOTIFY_PE",
          "args": [
            "fsn_event"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "FANOTIFY_PE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.h",
          "lines": "37-41",
          "snippet": "static inline struct fanotify_perm_event_info *\nFANOTIFY_PE(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_perm_event_info, fae.fse);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fsnotify_backend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fsnotify_backend.h>\n\nstatic inline struct fanotify_perm_event_info *\nFANOTIFY_PE(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_perm_event_info, fae.fse);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == 1 && mask & FAN_ALL_PERM_EVENTS"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_add_event",
          "args": [
            "group",
            "fsn_event",
            "fanotify_merge"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "87-126",
          "snippet": "int fsnotify_add_event(struct fsnotify_group *group,\n\t\t       struct fsnotify_event *event,\n\t\t       int (*merge)(struct list_head *,\n\t\t\t\t    struct fsnotify_event *))\n{\n\tint ret = 0;\n\tstruct list_head *list = &group->notification_list;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tmutex_lock(&group->notification_mutex);\n\n\tif (group->q_len >= group->max_events) {\n\t\tret = 2;\n\t\t/* Queue overflow event only if it isn't already queued */\n\t\tif (!list_empty(&group->overflow_event->list)) {\n\t\t\tmutex_unlock(&group->notification_mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tevent = group->overflow_event;\n\t\tgoto queue;\n\t}\n\n\tif (!list_empty(list) && merge) {\n\t\tret = merge(list, event);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&group->notification_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\nqueue:\n\tgroup->q_len++;\n\tlist_add_tail(&event->list, list);\n\tmutex_unlock(&group->notification_mutex);\n\n\twake_up(&group->notification_waitq);\n\tkill_fasync(&group->fsn_fa, SIGIO, POLL_IN);\n\treturn ret;\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint fsnotify_add_event(struct fsnotify_group *group,\n\t\t       struct fsnotify_event *event,\n\t\t       int (*merge)(struct list_head *,\n\t\t\t\t    struct fsnotify_event *))\n{\n\tint ret = 0;\n\tstruct list_head *list = &group->notification_list;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\tmutex_lock(&group->notification_mutex);\n\n\tif (group->q_len >= group->max_events) {\n\t\tret = 2;\n\t\t/* Queue overflow event only if it isn't already queued */\n\t\tif (!list_empty(&group->overflow_event->list)) {\n\t\t\tmutex_unlock(&group->notification_mutex);\n\t\t\treturn ret;\n\t\t}\n\t\tevent = group->overflow_event;\n\t\tgoto queue;\n\t}\n\n\tif (!list_empty(list) && merge) {\n\t\tret = merge(list, event);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&group->notification_mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\nqueue:\n\tgroup->q_len++;\n\tlist_add_tail(&event->list, list);\n\tmutex_unlock(&group->notification_mutex);\n\n\twake_up(&group->notification_waitq);\n\tkill_fasync(&group->fsn_fa, SIGIO, POLL_IN);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!event"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fanotify_alloc_event",
          "args": [
            "inode",
            "mask",
            "data"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "fanotify_alloc_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.c",
          "lines": "153-185",
          "snippet": "struct fanotify_event_info *fanotify_alloc_event(struct inode *inode, u32 mask,\n\t\t\t\t\t\t struct path *path)\n{\n\tstruct fanotify_event_info *event;\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tif (mask & FAN_ALL_PERM_EVENTS) {\n\t\tstruct fanotify_perm_event_info *pevent;\n\n\t\tpevent = kmem_cache_alloc(fanotify_perm_event_cachep,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!pevent)\n\t\t\treturn NULL;\n\t\tevent = &pevent->fae;\n\t\tpevent->response = 0;\n\t\tgoto init;\n\t}\n#endif\n\tevent = kmem_cache_alloc(fanotify_event_cachep, GFP_KERNEL);\n\tif (!event)\n\t\treturn NULL;\ninit: __maybe_unused\n\tfsnotify_init_event(&event->fse, inode, mask);\n\tevent->tgid = get_pid(task_tgid(current));\n\tif (path) {\n\t\tevent->path = *path;\n\t\tpath_get(&event->path);\n\t} else {\n\t\tevent->path.mnt = NULL;\n\t\tevent->path.dentry = NULL;\n\t}\n\treturn event;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h> /* UINT_MAX */",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/kernel.h> /* UINT_MAX */\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/fanotify.h>\n\nstruct fanotify_event_info *fanotify_alloc_event(struct inode *inode, u32 mask,\n\t\t\t\t\t\t struct path *path)\n{\n\tstruct fanotify_event_info *event;\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tif (mask & FAN_ALL_PERM_EVENTS) {\n\t\tstruct fanotify_perm_event_info *pevent;\n\n\t\tpevent = kmem_cache_alloc(fanotify_perm_event_cachep,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!pevent)\n\t\t\treturn NULL;\n\t\tevent = &pevent->fae;\n\t\tpevent->response = 0;\n\t\tgoto init;\n\t}\n#endif\n\tevent = kmem_cache_alloc(fanotify_event_cachep, GFP_KERNEL);\n\tif (!event)\n\t\treturn NULL;\ninit: __maybe_unused\n\tfsnotify_init_event(&event->fse, inode, mask);\n\tevent->tgid = get_pid(task_tgid(current));\n\tif (path) {\n\t\tevent->path = *path;\n\t\tpath_get(&event->path);\n\t} else {\n\t\tevent->path.mnt = NULL;\n\t\tevent->path.dentry = NULL;\n\t}\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p inode=%p mask=%x\\n\"",
            "__func__",
            "group",
            "inode",
            "mask"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fanotify_should_send_event",
          "args": [
            "inode_mark",
            "fanotify_mark",
            "mask",
            "data",
            "data_type"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "fanotify_should_send_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.c",
          "lines": "101-151",
          "snippet": "static bool fanotify_should_send_event(struct fsnotify_mark *inode_mark,\n\t\t\t\t       struct fsnotify_mark *vfsmnt_mark,\n\t\t\t\t       u32 event_mask,\n\t\t\t\t       void *data, int data_type)\n{\n\t__u32 marks_mask, marks_ignored_mask;\n\tstruct path *path = data;\n\n\tpr_debug(\"%s: inode_mark=%p vfsmnt_mark=%p mask=%x data=%p\"\n\t\t \" data_type=%d\\n\", __func__, inode_mark, vfsmnt_mark,\n\t\t event_mask, data, data_type);\n\n\t/* if we don't have enough info to send an event to userspace say no */\n\tif (data_type != FSNOTIFY_EVENT_PATH)\n\t\treturn false;\n\n\t/* sorry, fanotify only gives a damn about files and dirs */\n\tif (!d_is_reg(path->dentry) &&\n\t    !d_can_lookup(path->dentry))\n\t\treturn false;\n\n\tif (inode_mark && vfsmnt_mark) {\n\t\tmarks_mask = (vfsmnt_mark->mask | inode_mark->mask);\n\t\tmarks_ignored_mask = (vfsmnt_mark->ignored_mask | inode_mark->ignored_mask);\n\t} else if (inode_mark) {\n\t\t/*\n\t\t * if the event is for a child and this inode doesn't care about\n\t\t * events on the child, don't send it!\n\t\t */\n\t\tif ((event_mask & FS_EVENT_ON_CHILD) &&\n\t\t    !(inode_mark->mask & FS_EVENT_ON_CHILD))\n\t\t\treturn false;\n\t\tmarks_mask = inode_mark->mask;\n\t\tmarks_ignored_mask = inode_mark->ignored_mask;\n\t} else if (vfsmnt_mark) {\n\t\tmarks_mask = vfsmnt_mark->mask;\n\t\tmarks_ignored_mask = vfsmnt_mark->ignored_mask;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (d_is_dir(path->dentry) &&\n\t    !(marks_mask & FS_ISDIR & ~marks_ignored_mask))\n\t\treturn false;\n\n\tif (event_mask & FAN_ALL_OUTGOING_EVENTS & marks_mask &\n\t\t\t\t ~marks_ignored_mask)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h> /* UINT_MAX */",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/kernel.h> /* UINT_MAX */\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/fanotify.h>\n\nstatic bool fanotify_should_send_event(struct fsnotify_mark *inode_mark,\n\t\t\t\t       struct fsnotify_mark *vfsmnt_mark,\n\t\t\t\t       u32 event_mask,\n\t\t\t\t       void *data, int data_type)\n{\n\t__u32 marks_mask, marks_ignored_mask;\n\tstruct path *path = data;\n\n\tpr_debug(\"%s: inode_mark=%p vfsmnt_mark=%p mask=%x data=%p\"\n\t\t \" data_type=%d\\n\", __func__, inode_mark, vfsmnt_mark,\n\t\t event_mask, data, data_type);\n\n\t/* if we don't have enough info to send an event to userspace say no */\n\tif (data_type != FSNOTIFY_EVENT_PATH)\n\t\treturn false;\n\n\t/* sorry, fanotify only gives a damn about files and dirs */\n\tif (!d_is_reg(path->dentry) &&\n\t    !d_can_lookup(path->dentry))\n\t\treturn false;\n\n\tif (inode_mark && vfsmnt_mark) {\n\t\tmarks_mask = (vfsmnt_mark->mask | inode_mark->mask);\n\t\tmarks_ignored_mask = (vfsmnt_mark->ignored_mask | inode_mark->ignored_mask);\n\t} else if (inode_mark) {\n\t\t/*\n\t\t * if the event is for a child and this inode doesn't care about\n\t\t * events on the child, don't send it!\n\t\t */\n\t\tif ((event_mask & FS_EVENT_ON_CHILD) &&\n\t\t    !(inode_mark->mask & FS_EVENT_ON_CHILD))\n\t\t\treturn false;\n\t\tmarks_mask = inode_mark->mask;\n\t\tmarks_ignored_mask = inode_mark->ignored_mask;\n\t} else if (vfsmnt_mark) {\n\t\tmarks_mask = vfsmnt_mark->mask;\n\t\tmarks_ignored_mask = vfsmnt_mark->ignored_mask;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (d_is_dir(path->dentry) &&\n\t    !(marks_mask & FS_ISDIR & ~marks_ignored_mask))\n\t\treturn false;\n\n\tif (event_mask & FAN_ALL_OUTGOING_EVENTS & marks_mask &\n\t\t\t\t ~marks_ignored_mask)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "FAN_ONDIR != FS_ISDIR"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "FAN_ACCESS_PERM != FS_ACCESS_PERM"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "FAN_OPEN_PERM != FS_OPEN_PERM"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "FAN_Q_OVERFLOW != FS_Q_OVERFLOW"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "FAN_EVENT_ON_CHILD != FS_EVENT_ON_CHILD"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "FAN_OPEN != FS_OPEN"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "FAN_CLOSE_WRITE != FS_CLOSE_WRITE"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "FAN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "FAN_MODIFY != FS_MODIFY"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "FAN_ACCESS != FS_ACCESS"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/kernel.h> /* UINT_MAX */\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/fanotify.h>\n\nstatic int fanotify_handle_event(struct fsnotify_group *group,\n\t\t\t\t struct inode *inode,\n\t\t\t\t struct fsnotify_mark *inode_mark,\n\t\t\t\t struct fsnotify_mark *fanotify_mark,\n\t\t\t\t u32 mask, void *data, int data_type,\n\t\t\t\t const unsigned char *file_name, u32 cookie)\n{\n\tint ret = 0;\n\tstruct fanotify_event_info *event;\n\tstruct fsnotify_event *fsn_event;\n\n\tBUILD_BUG_ON(FAN_ACCESS != FS_ACCESS);\n\tBUILD_BUG_ON(FAN_MODIFY != FS_MODIFY);\n\tBUILD_BUG_ON(FAN_CLOSE_NOWRITE != FS_CLOSE_NOWRITE);\n\tBUILD_BUG_ON(FAN_CLOSE_WRITE != FS_CLOSE_WRITE);\n\tBUILD_BUG_ON(FAN_OPEN != FS_OPEN);\n\tBUILD_BUG_ON(FAN_EVENT_ON_CHILD != FS_EVENT_ON_CHILD);\n\tBUILD_BUG_ON(FAN_Q_OVERFLOW != FS_Q_OVERFLOW);\n\tBUILD_BUG_ON(FAN_OPEN_PERM != FS_OPEN_PERM);\n\tBUILD_BUG_ON(FAN_ACCESS_PERM != FS_ACCESS_PERM);\n\tBUILD_BUG_ON(FAN_ONDIR != FS_ISDIR);\n\n\tif (!fanotify_should_send_event(inode_mark, fanotify_mark, mask, data,\n\t\t\t\t\tdata_type))\n\t\treturn 0;\n\n\tpr_debug(\"%s: group=%p inode=%p mask=%x\\n\", __func__, group, inode,\n\t\t mask);\n\n\tevent = fanotify_alloc_event(inode, mask, data);\n\tif (unlikely(!event))\n\t\treturn -ENOMEM;\n\n\tfsn_event = &event->fse;\n\tret = fsnotify_add_event(group, fsn_event, fanotify_merge);\n\tif (ret) {\n\t\t/* Permission events shouldn't be merged */\n\t\tBUG_ON(ret == 1 && mask & FAN_ALL_PERM_EVENTS);\n\t\t/* Our event wasn't used in the end. Free it. */\n\t\tfsnotify_destroy_event(group, fsn_event);\n\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tif (mask & FAN_ALL_PERM_EVENTS) {\n\t\tret = fanotify_get_response(group, FANOTIFY_PE(fsn_event));\n\t\tfsnotify_destroy_event(group, fsn_event);\n\t}\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "fanotify_alloc_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.c",
    "lines": "153-185",
    "snippet": "struct fanotify_event_info *fanotify_alloc_event(struct inode *inode, u32 mask,\n\t\t\t\t\t\t struct path *path)\n{\n\tstruct fanotify_event_info *event;\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tif (mask & FAN_ALL_PERM_EVENTS) {\n\t\tstruct fanotify_perm_event_info *pevent;\n\n\t\tpevent = kmem_cache_alloc(fanotify_perm_event_cachep,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!pevent)\n\t\t\treturn NULL;\n\t\tevent = &pevent->fae;\n\t\tpevent->response = 0;\n\t\tgoto init;\n\t}\n#endif\n\tevent = kmem_cache_alloc(fanotify_event_cachep, GFP_KERNEL);\n\tif (!event)\n\t\treturn NULL;\ninit: __maybe_unused\n\tfsnotify_init_event(&event->fse, inode, mask);\n\tevent->tgid = get_pid(task_tgid(current));\n\tif (path) {\n\t\tevent->path = *path;\n\t\tpath_get(&event->path);\n\t} else {\n\t\tevent->path.mnt = NULL;\n\t\tevent->path.dentry = NULL;\n\t}\n\treturn event;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/kernel.h> /* UINT_MAX */",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&event->path"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "task_tgid(current)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "fanotify_event_cachep",
            "GFP_KERNEL"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/kernel.h> /* UINT_MAX */\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/fanotify.h>\n\nstruct fanotify_event_info *fanotify_alloc_event(struct inode *inode, u32 mask,\n\t\t\t\t\t\t struct path *path)\n{\n\tstruct fanotify_event_info *event;\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\tif (mask & FAN_ALL_PERM_EVENTS) {\n\t\tstruct fanotify_perm_event_info *pevent;\n\n\t\tpevent = kmem_cache_alloc(fanotify_perm_event_cachep,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!pevent)\n\t\t\treturn NULL;\n\t\tevent = &pevent->fae;\n\t\tpevent->response = 0;\n\t\tgoto init;\n\t}\n#endif\n\tevent = kmem_cache_alloc(fanotify_event_cachep, GFP_KERNEL);\n\tif (!event)\n\t\treturn NULL;\ninit: __maybe_unused\n\tfsnotify_init_event(&event->fse, inode, mask);\n\tevent->tgid = get_pid(task_tgid(current));\n\tif (path) {\n\t\tevent->path = *path;\n\t\tpath_get(&event->path);\n\t} else {\n\t\tevent->path.mnt = NULL;\n\t\tevent->path.dentry = NULL;\n\t}\n\treturn event;\n}"
  },
  {
    "function_name": "fanotify_should_send_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.c",
    "lines": "101-151",
    "snippet": "static bool fanotify_should_send_event(struct fsnotify_mark *inode_mark,\n\t\t\t\t       struct fsnotify_mark *vfsmnt_mark,\n\t\t\t\t       u32 event_mask,\n\t\t\t\t       void *data, int data_type)\n{\n\t__u32 marks_mask, marks_ignored_mask;\n\tstruct path *path = data;\n\n\tpr_debug(\"%s: inode_mark=%p vfsmnt_mark=%p mask=%x data=%p\"\n\t\t \" data_type=%d\\n\", __func__, inode_mark, vfsmnt_mark,\n\t\t event_mask, data, data_type);\n\n\t/* if we don't have enough info to send an event to userspace say no */\n\tif (data_type != FSNOTIFY_EVENT_PATH)\n\t\treturn false;\n\n\t/* sorry, fanotify only gives a damn about files and dirs */\n\tif (!d_is_reg(path->dentry) &&\n\t    !d_can_lookup(path->dentry))\n\t\treturn false;\n\n\tif (inode_mark && vfsmnt_mark) {\n\t\tmarks_mask = (vfsmnt_mark->mask | inode_mark->mask);\n\t\tmarks_ignored_mask = (vfsmnt_mark->ignored_mask | inode_mark->ignored_mask);\n\t} else if (inode_mark) {\n\t\t/*\n\t\t * if the event is for a child and this inode doesn't care about\n\t\t * events on the child, don't send it!\n\t\t */\n\t\tif ((event_mask & FS_EVENT_ON_CHILD) &&\n\t\t    !(inode_mark->mask & FS_EVENT_ON_CHILD))\n\t\t\treturn false;\n\t\tmarks_mask = inode_mark->mask;\n\t\tmarks_ignored_mask = inode_mark->ignored_mask;\n\t} else if (vfsmnt_mark) {\n\t\tmarks_mask = vfsmnt_mark->mask;\n\t\tmarks_ignored_mask = vfsmnt_mark->ignored_mask;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (d_is_dir(path->dentry) &&\n\t    !(marks_mask & FS_ISDIR & ~marks_ignored_mask))\n\t\treturn false;\n\n\tif (event_mask & FAN_ALL_OUTGOING_EVENTS & marks_mask &\n\t\t\t\t ~marks_ignored_mask)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/kernel.h> /* UINT_MAX */",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "path->dentry"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_can_lookup",
          "args": [
            "path->dentry"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_reg",
          "args": [
            "path->dentry"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: inode_mark=%p vfsmnt_mark=%p mask=%x data=%p\"\n\t\t \" data_type=%d\\n\"",
            "__func__",
            "inode_mark",
            "vfsmnt_mark",
            "event_mask",
            "data",
            "data_type"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/kernel.h> /* UINT_MAX */\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/fanotify.h>\n\nstatic bool fanotify_should_send_event(struct fsnotify_mark *inode_mark,\n\t\t\t\t       struct fsnotify_mark *vfsmnt_mark,\n\t\t\t\t       u32 event_mask,\n\t\t\t\t       void *data, int data_type)\n{\n\t__u32 marks_mask, marks_ignored_mask;\n\tstruct path *path = data;\n\n\tpr_debug(\"%s: inode_mark=%p vfsmnt_mark=%p mask=%x data=%p\"\n\t\t \" data_type=%d\\n\", __func__, inode_mark, vfsmnt_mark,\n\t\t event_mask, data, data_type);\n\n\t/* if we don't have enough info to send an event to userspace say no */\n\tif (data_type != FSNOTIFY_EVENT_PATH)\n\t\treturn false;\n\n\t/* sorry, fanotify only gives a damn about files and dirs */\n\tif (!d_is_reg(path->dentry) &&\n\t    !d_can_lookup(path->dentry))\n\t\treturn false;\n\n\tif (inode_mark && vfsmnt_mark) {\n\t\tmarks_mask = (vfsmnt_mark->mask | inode_mark->mask);\n\t\tmarks_ignored_mask = (vfsmnt_mark->ignored_mask | inode_mark->ignored_mask);\n\t} else if (inode_mark) {\n\t\t/*\n\t\t * if the event is for a child and this inode doesn't care about\n\t\t * events on the child, don't send it!\n\t\t */\n\t\tif ((event_mask & FS_EVENT_ON_CHILD) &&\n\t\t    !(inode_mark->mask & FS_EVENT_ON_CHILD))\n\t\t\treturn false;\n\t\tmarks_mask = inode_mark->mask;\n\t\tmarks_ignored_mask = inode_mark->ignored_mask;\n\t} else if (vfsmnt_mark) {\n\t\tmarks_mask = vfsmnt_mark->mask;\n\t\tmarks_ignored_mask = vfsmnt_mark->ignored_mask;\n\t} else {\n\t\tBUG();\n\t}\n\n\tif (d_is_dir(path->dentry) &&\n\t    !(marks_mask & FS_ISDIR & ~marks_ignored_mask))\n\t\treturn false;\n\n\tif (event_mask & FAN_ALL_OUTGOING_EVENTS & marks_mask &\n\t\t\t\t ~marks_ignored_mask)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "fanotify_get_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.c",
    "lines": "63-98",
    "snippet": "static int fanotify_get_response(struct fsnotify_group *group,\n\t\t\t\t struct fanotify_perm_event_info *event)\n{\n\tint ret;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\twait_event(group->fanotify_data.access_waitq, event->response ||\n\t\t\t\tatomic_read(&group->fanotify_data.bypass_perm));\n\n\tif (!event->response) {\t/* bypass_perm set */\n\t\t/*\n\t\t * Event was canceled because group is being destroyed. Remove\n\t\t * it from group's event list because we are responsible for\n\t\t * freeing the permission event.\n\t\t */\n\t\tfsnotify_remove_event(group, &event->fae.fse);\n\t\treturn 0;\n\t}\n\n\t/* userspace responded, convert to something usable */\n\tswitch (event->response) {\n\tcase FAN_ALLOW:\n\t\tret = 0;\n\t\tbreak;\n\tcase FAN_DENY:\n\tdefault:\n\t\tret = -EPERM;\n\t}\n\tevent->response = 0;\n\n\tpr_debug(\"%s: group=%p event=%p about to return ret=%d\\n\", __func__,\n\t\t group, event, ret);\n\t\n\treturn ret;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/kernel.h> /* UINT_MAX */",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p event=%p about to return ret=%d\\n\"",
            "__func__",
            "group",
            "event",
            "ret"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsnotify_remove_event",
          "args": [
            "group",
            "&event->fae.fse"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "fsnotify_remove_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/notification.c",
          "lines": "132-141",
          "snippet": "void fsnotify_remove_event(struct fsnotify_group *group,\n\t\t\t   struct fsnotify_event *event)\n{\n\tmutex_lock(&group->notification_mutex);\n\tif (!list_empty(&event->list)) {\n\t\tlist_del_init(&event->list);\n\t\tgroup->q_len--;\n\t}\n\tmutex_unlock(&group->notification_mutex);\n}",
          "includes": [
            "#include \"fsnotify.h\"",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fsnotify.h\"\n#include <linux/fsnotify_backend.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid fsnotify_remove_event(struct fsnotify_group *group,\n\t\t\t   struct fsnotify_event *event)\n{\n\tmutex_lock(&group->notification_mutex);\n\tif (!list_empty(&event->list)) {\n\t\tlist_del_init(&event->list);\n\t\tgroup->q_len--;\n\t}\n\tmutex_unlock(&group->notification_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "group->fanotify_data.access_waitq",
            "event->response ||\n\t\t\t\tatomic_read(&group->fanotify_data.bypass_perm)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&group->fanotify_data.bypass_perm"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: group=%p event=%p\\n\"",
            "__func__",
            "group",
            "event"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/kernel.h> /* UINT_MAX */\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/fanotify.h>\n\nstatic int fanotify_get_response(struct fsnotify_group *group,\n\t\t\t\t struct fanotify_perm_event_info *event)\n{\n\tint ret;\n\n\tpr_debug(\"%s: group=%p event=%p\\n\", __func__, group, event);\n\n\twait_event(group->fanotify_data.access_waitq, event->response ||\n\t\t\t\tatomic_read(&group->fanotify_data.bypass_perm));\n\n\tif (!event->response) {\t/* bypass_perm set */\n\t\t/*\n\t\t * Event was canceled because group is being destroyed. Remove\n\t\t * it from group's event list because we are responsible for\n\t\t * freeing the permission event.\n\t\t */\n\t\tfsnotify_remove_event(group, &event->fae.fse);\n\t\treturn 0;\n\t}\n\n\t/* userspace responded, convert to something usable */\n\tswitch (event->response) {\n\tcase FAN_ALLOW:\n\t\tret = 0;\n\t\tbreak;\n\tcase FAN_DENY:\n\tdefault:\n\t\tret = -EPERM;\n\t}\n\tevent->response = 0;\n\n\tpr_debug(\"%s: group=%p event=%p about to return ret=%d\\n\", __func__,\n\t\t group, event, ret);\n\t\n\treturn ret;\n}"
  },
  {
    "function_name": "fanotify_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.c",
    "lines": "31-60",
    "snippet": "static int fanotify_merge(struct list_head *list, struct fsnotify_event *event)\n{\n\tstruct fsnotify_event *test_event;\n\tbool do_merge = false;\n\n\tpr_debug(\"%s: list=%p event=%p\\n\", __func__, list, event);\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\t/*\n\t * Don't merge a permission event with any other event so that we know\n\t * the event structure we have created in fanotify_handle_event() is the\n\t * one we should check for permission response.\n\t */\n\tif (event->mask & FAN_ALL_PERM_EVENTS)\n\t\treturn 0;\n#endif\n\n\tlist_for_each_entry_reverse(test_event, list, list) {\n\t\tif (should_merge(test_event, event)) {\n\t\t\tdo_merge = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!do_merge)\n\t\treturn 0;\n\n\ttest_event->mask |= event->mask;\n\treturn 1;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/kernel.h> /* UINT_MAX */",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "should_merge",
          "args": [
            "test_event",
            "event"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "should_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.c",
          "lines": "14-28",
          "snippet": "static bool should_merge(struct fsnotify_event *old_fsn,\n\t\t\t struct fsnotify_event *new_fsn)\n{\n\tstruct fanotify_event_info *old, *new;\n\n\tpr_debug(\"%s: old=%p new=%p\\n\", __func__, old_fsn, new_fsn);\n\told = FANOTIFY_E(old_fsn);\n\tnew = FANOTIFY_E(new_fsn);\n\n\tif (old_fsn->inode == new_fsn->inode && old->tgid == new->tgid &&\n\t    old->path.mnt == new->path.mnt &&\n\t    old->path.dentry == new->path.dentry)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"fanotify.h\"",
            "#include <linux/wait.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/kernel.h> /* UINT_MAX */",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/fanotify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fanotify.h\"\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/kernel.h> /* UINT_MAX */\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/fanotify.h>\n\nstatic bool should_merge(struct fsnotify_event *old_fsn,\n\t\t\t struct fsnotify_event *new_fsn)\n{\n\tstruct fanotify_event_info *old, *new;\n\n\tpr_debug(\"%s: old=%p new=%p\\n\", __func__, old_fsn, new_fsn);\n\told = FANOTIFY_E(old_fsn);\n\tnew = FANOTIFY_E(new_fsn);\n\n\tif (old_fsn->inode == new_fsn->inode && old->tgid == new->tgid &&\n\t    old->path.mnt == new->path.mnt &&\n\t    old->path.dentry == new->path.dentry)\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "test_event",
            "list",
            "list"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: list=%p event=%p\\n\"",
            "__func__",
            "list",
            "event"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/kernel.h> /* UINT_MAX */\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/fanotify.h>\n\nstatic int fanotify_merge(struct list_head *list, struct fsnotify_event *event)\n{\n\tstruct fsnotify_event *test_event;\n\tbool do_merge = false;\n\n\tpr_debug(\"%s: list=%p event=%p\\n\", __func__, list, event);\n\n#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS\n\t/*\n\t * Don't merge a permission event with any other event so that we know\n\t * the event structure we have created in fanotify_handle_event() is the\n\t * one we should check for permission response.\n\t */\n\tif (event->mask & FAN_ALL_PERM_EVENTS)\n\t\treturn 0;\n#endif\n\n\tlist_for_each_entry_reverse(test_event, list, list) {\n\t\tif (should_merge(test_event, event)) {\n\t\t\tdo_merge = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!do_merge)\n\t\treturn 0;\n\n\ttest_event->mask |= event->mask;\n\treturn 1;\n}"
  },
  {
    "function_name": "should_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.c",
    "lines": "14-28",
    "snippet": "static bool should_merge(struct fsnotify_event *old_fsn,\n\t\t\t struct fsnotify_event *new_fsn)\n{\n\tstruct fanotify_event_info *old, *new;\n\n\tpr_debug(\"%s: old=%p new=%p\\n\", __func__, old_fsn, new_fsn);\n\told = FANOTIFY_E(old_fsn);\n\tnew = FANOTIFY_E(new_fsn);\n\n\tif (old_fsn->inode == new_fsn->inode && old->tgid == new->tgid &&\n\t    old->path.mnt == new->path.mnt &&\n\t    old->path.dentry == new->path.dentry)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include \"fanotify.h\"",
      "#include <linux/wait.h>",
      "#include <linux/types.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/kernel.h> /* UINT_MAX */",
      "#include <linux/jiffies.h>",
      "#include <linux/init.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/fanotify.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FANOTIFY_E",
          "args": [
            "new_fsn"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "FANOTIFY_E",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/notify/fanotify/fanotify.h",
          "lines": "44-47",
          "snippet": "static inline struct fanotify_event_info *FANOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_event_info, fse);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fsnotify_backend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fsnotify_backend.h>\n\nstatic inline struct fanotify_event_info *FANOTIFY_E(struct fsnotify_event *fse)\n{\n\treturn container_of(fse, struct fanotify_event_info, fse);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s: old=%p new=%p\\n\"",
            "__func__",
            "old_fsn",
            "new_fsn"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fanotify.h\"\n#include <linux/wait.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/kernel.h> /* UINT_MAX */\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fdtable.h>\n#include <linux/fanotify.h>\n\nstatic bool should_merge(struct fsnotify_event *old_fsn,\n\t\t\t struct fsnotify_event *new_fsn)\n{\n\tstruct fanotify_event_info *old, *new;\n\n\tpr_debug(\"%s: old=%p new=%p\\n\", __func__, old_fsn, new_fsn);\n\told = FANOTIFY_E(old_fsn);\n\tnew = FANOTIFY_E(new_fsn);\n\n\tif (old_fsn->inode == new_fsn->inode && old->tgid == new->tgid &&\n\t    old->path.mnt == new->path.mnt &&\n\t    old->path.dentry == new->path.dentry)\n\t\treturn true;\n\treturn false;\n}"
  }
]