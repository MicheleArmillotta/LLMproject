[
  {
    "function_name": "hpfs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/namei.c",
    "lines": "518-615",
    "snippet": "static int hpfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tconst unsigned char *old_name = old_dentry->d_name.name;\n\tunsigned old_len = old_dentry->d_name.len;\n\tconst unsigned char *new_name = new_dentry->d_name.name;\n\tunsigned new_len = new_dentry->d_name.len;\n\tstruct inode *i = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct quad_buffer_head qbh, qbh1;\n\tstruct hpfs_dirent *dep, *nde;\n\tstruct hpfs_dirent de;\n\tdnode_secno dno;\n\tint r;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint err;\n\n\tif ((err = hpfs_chk_name(new_name, &new_len))) return err;\n\terr = 0;\n\thpfs_adjust_length(old_name, &old_len);\n\n\thpfs_lock(i->i_sb);\n\t/* order doesn't matter, due to VFS exclusion */\n\t\n\t/* Erm? Moving over the empty non-busy directory is perfectly legal */\n\tif (new_inode && S_ISDIR(new_inode->i_mode)) {\n\t\terr = -EINVAL;\n\t\tgoto end1;\n\t}\n\n\tif (!(dep = map_dirent(old_dir, hpfs_i(old_dir)->i_dno, old_name, old_len, &dno, &qbh))) {\n\t\thpfs_error(i->i_sb, \"lookup succeeded but map dirent failed\");\n\t\terr = -ENOENT;\n\t\tgoto end1;\n\t}\n\tcopy_de(&de, dep);\n\tde.hidden = new_name[0] == '.';\n\n\tif (new_inode) {\n\t\tint r;\n\t\tif ((r = hpfs_remove_dirent(old_dir, dno, dep, &qbh, 1)) != 2) {\n\t\t\tif ((nde = map_dirent(new_dir, hpfs_i(new_dir)->i_dno, new_name, new_len, NULL, &qbh1))) {\n\t\t\t\tclear_nlink(new_inode);\n\t\t\t\tcopy_de(nde, &de);\n\t\t\t\tmemcpy(nde->name, new_name, new_len);\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\thpfs_error(new_dir->i_sb, \"hpfs_rename: could not find dirent\");\n\t\t\terr = -EFSERROR;\n\t\t\tgoto end1;\n\t\t}\n\t\terr = r == 2 ? -ENOSPC : r == 1 ? -EFSERROR : 0;\n\t\tgoto end1;\n\t}\n\n\tif (new_dir == old_dir) hpfs_brelse4(&qbh);\n\n\tif ((r = hpfs_add_dirent(new_dir, new_name, new_len, &de))) {\n\t\tif (r == -1) hpfs_error(new_dir->i_sb, \"hpfs_rename: dirent already exists!\");\n\t\terr = r == 1 ? -ENOSPC : -EFSERROR;\n\t\tif (new_dir != old_dir) hpfs_brelse4(&qbh);\n\t\tgoto end1;\n\t}\n\t\n\tif (new_dir == old_dir)\n\t\tif (!(dep = map_dirent(old_dir, hpfs_i(old_dir)->i_dno, old_name, old_len, &dno, &qbh))) {\n\t\t\thpfs_error(i->i_sb, \"lookup succeeded but map dirent failed at #2\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto end1;\n\t\t}\n\n\tif ((r = hpfs_remove_dirent(old_dir, dno, dep, &qbh, 0))) {\n\t\thpfs_error(i->i_sb, \"hpfs_rename: could not remove dirent\");\n\t\terr = r == 2 ? -ENOSPC : -EFSERROR;\n\t\tgoto end1;\n\t}\n\n\tend:\n\thpfs_i(i)->i_parent_dir = new_dir->i_ino;\n\tif (S_ISDIR(i->i_mode)) {\n\t\tinc_nlink(new_dir);\n\t\tdrop_nlink(old_dir);\n\t}\n\tif ((fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) {\n\t\tfnode->up = cpu_to_le32(new_dir->i_ino);\n\t\tfnode->len = new_len;\n\t\tmemcpy(fnode->name, new_name, new_len>15?15:new_len);\n\t\tif (new_len < 15) memset(&fnode->name[new_len], 0, 15 - new_len);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\nend1:\n\thpfs_unlock(i->i_sb);\n\treturn err;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "i->i_sb"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&fnode->name[new_len]",
            "0",
            "15 - new_len"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fnode->name",
            "new_name",
            "new_len>15?15:new_len"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_dir->i_ino"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "i->i_sb",
            "i->i_ino",
            "&bh"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "old_dir"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "new_dir"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "i->i_mode"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "i"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "i->i_sb",
            "\"hpfs_rename: could not remove dirent\""
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_remove_dirent",
          "args": [
            "old_dir",
            "dno",
            "dep",
            "&qbh",
            "0"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_remove_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "708-739",
          "snippet": "int hpfs_remove_dirent(struct inode *i, dnode_secno dno, struct hpfs_dirent *de,\n\t\t       struct quad_buffer_head *qbh, int depth)\n{\n\tstruct dnode *dnode = qbh->data;\n\tdnode_secno down = 0;\n\tloff_t t;\n\tif (de->first || de->last) {\n\t\thpfs_error(i->i_sb, \"hpfs_remove_dirent: attempt to delete first or last dirent in dnode %08x\", dno);\n\t\thpfs_brelse4(qbh);\n\t\treturn 1;\n\t}\n\tif (de->down) down = de_down_pointer(de);\n\tif (depth && (de->down || (de == dnode_first_de(dnode) && de_next_de(de)->last))) {\n\t\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_DEL)) {\n\t\t\thpfs_brelse4(qbh);\n\t\t\treturn 2;\n\t\t}\n\t}\n\ti->i_version++;\n\tfor_all_poss(i, hpfs_pos_del, (t = get_pos(dnode, de)) + 1, 1);\n\thpfs_delete_de(i->i_sb, dnode, de);\n\thpfs_mark_4buffers_dirty(qbh);\n\thpfs_brelse4(qbh);\n\tif (down) {\n\t\tdnode_secno a = move_to_top(i, down, dno);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t);\n\t\tif (a) delete_empty_dnode(i, a);\n\t\treturn !a;\n\t}\n\tdelete_empty_dnode(i, dno);\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_remove_dirent(struct inode *i, dnode_secno dno, struct hpfs_dirent *de,\n\t\t       struct quad_buffer_head *qbh, int depth)\n{\n\tstruct dnode *dnode = qbh->data;\n\tdnode_secno down = 0;\n\tloff_t t;\n\tif (de->first || de->last) {\n\t\thpfs_error(i->i_sb, \"hpfs_remove_dirent: attempt to delete first or last dirent in dnode %08x\", dno);\n\t\thpfs_brelse4(qbh);\n\t\treturn 1;\n\t}\n\tif (de->down) down = de_down_pointer(de);\n\tif (depth && (de->down || (de == dnode_first_de(dnode) && de_next_de(de)->last))) {\n\t\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_DEL)) {\n\t\t\thpfs_brelse4(qbh);\n\t\t\treturn 2;\n\t\t}\n\t}\n\ti->i_version++;\n\tfor_all_poss(i, hpfs_pos_del, (t = get_pos(dnode, de)) + 1, 1);\n\thpfs_delete_de(i->i_sb, dnode, de);\n\thpfs_mark_4buffers_dirty(qbh);\n\thpfs_brelse4(qbh);\n\tif (down) {\n\t\tdnode_secno a = move_to_top(i, down, dno);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t);\n\t\tif (a) delete_empty_dnode(i, a);\n\t\treturn !a;\n\t}\n\tdelete_empty_dnode(i, dno);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_dirent",
          "args": [
            "old_dir",
            "hpfs_i(old_dir)->i_dno",
            "old_name",
            "old_len",
            "&dno",
            "&qbh"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "map_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "907-940",
          "snippet": "struct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_add_dirent",
          "args": [
            "new_dir",
            "new_name",
            "new_len",
            "&de"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "383-423",
          "snippet": "int hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\ti->i_version++;\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\ti->i_version++;\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_mark_4buffers_dirty",
          "args": [
            "&qbh1"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_mark_4buffers_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "192-204",
          "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nde->name",
            "new_name",
            "new_len"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_de",
          "args": [
            "nde",
            "&de"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "copy_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "169-179",
          "snippet": "static inline void copy_de(struct hpfs_dirent *dst, struct hpfs_dirent *src)\n{\n\tint a;\n\tint n;\n\tif (!dst || !src) return;\n\ta = dst->down;\n\tn = dst->not_8x3;\n\tmemcpy((char *)dst + 2, (char *)src + 2, 28);\n\tdst->down = a;\n\tdst->not_8x3 = n;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_add_dirent(struct inode *, const unsigned char *, unsigned,\n\t\t    struct hpfs_dirent *);\n\nstatic inline void copy_de(struct hpfs_dirent *dst, struct hpfs_dirent *src)\n{\n\tint a;\n\tint n;\n\tif (!dst || !src) return;\n\ta = dst->down;\n\tn = dst->not_8x3;\n\tmemcpy((char *)dst + 2, (char *)src + 2, 28);\n\tdst->down = a;\n\tdst->not_8x3 = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "new_inode"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "new_inode->i_mode"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "i->i_sb"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_adjust_length",
          "args": [
            "old_name",
            "&old_len"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_adjust_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "106-113",
          "snippet": "void hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_name",
          "args": [
            "new_name",
            "&new_len"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "41-51",
          "snippet": "int hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/sched.h>\n\nstatic int hpfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\tstruct inode *new_dir, struct dentry *new_dentry)\n{\n\tconst unsigned char *old_name = old_dentry->d_name.name;\n\tunsigned old_len = old_dentry->d_name.len;\n\tconst unsigned char *new_name = new_dentry->d_name.name;\n\tunsigned new_len = new_dentry->d_name.len;\n\tstruct inode *i = old_dentry->d_inode;\n\tstruct inode *new_inode = new_dentry->d_inode;\n\tstruct quad_buffer_head qbh, qbh1;\n\tstruct hpfs_dirent *dep, *nde;\n\tstruct hpfs_dirent de;\n\tdnode_secno dno;\n\tint r;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tint err;\n\n\tif ((err = hpfs_chk_name(new_name, &new_len))) return err;\n\terr = 0;\n\thpfs_adjust_length(old_name, &old_len);\n\n\thpfs_lock(i->i_sb);\n\t/* order doesn't matter, due to VFS exclusion */\n\t\n\t/* Erm? Moving over the empty non-busy directory is perfectly legal */\n\tif (new_inode && S_ISDIR(new_inode->i_mode)) {\n\t\terr = -EINVAL;\n\t\tgoto end1;\n\t}\n\n\tif (!(dep = map_dirent(old_dir, hpfs_i(old_dir)->i_dno, old_name, old_len, &dno, &qbh))) {\n\t\thpfs_error(i->i_sb, \"lookup succeeded but map dirent failed\");\n\t\terr = -ENOENT;\n\t\tgoto end1;\n\t}\n\tcopy_de(&de, dep);\n\tde.hidden = new_name[0] == '.';\n\n\tif (new_inode) {\n\t\tint r;\n\t\tif ((r = hpfs_remove_dirent(old_dir, dno, dep, &qbh, 1)) != 2) {\n\t\t\tif ((nde = map_dirent(new_dir, hpfs_i(new_dir)->i_dno, new_name, new_len, NULL, &qbh1))) {\n\t\t\t\tclear_nlink(new_inode);\n\t\t\t\tcopy_de(nde, &de);\n\t\t\t\tmemcpy(nde->name, new_name, new_len);\n\t\t\t\thpfs_mark_4buffers_dirty(&qbh1);\n\t\t\t\thpfs_brelse4(&qbh1);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\thpfs_error(new_dir->i_sb, \"hpfs_rename: could not find dirent\");\n\t\t\terr = -EFSERROR;\n\t\t\tgoto end1;\n\t\t}\n\t\terr = r == 2 ? -ENOSPC : r == 1 ? -EFSERROR : 0;\n\t\tgoto end1;\n\t}\n\n\tif (new_dir == old_dir) hpfs_brelse4(&qbh);\n\n\tif ((r = hpfs_add_dirent(new_dir, new_name, new_len, &de))) {\n\t\tif (r == -1) hpfs_error(new_dir->i_sb, \"hpfs_rename: dirent already exists!\");\n\t\terr = r == 1 ? -ENOSPC : -EFSERROR;\n\t\tif (new_dir != old_dir) hpfs_brelse4(&qbh);\n\t\tgoto end1;\n\t}\n\t\n\tif (new_dir == old_dir)\n\t\tif (!(dep = map_dirent(old_dir, hpfs_i(old_dir)->i_dno, old_name, old_len, &dno, &qbh))) {\n\t\t\thpfs_error(i->i_sb, \"lookup succeeded but map dirent failed at #2\");\n\t\t\terr = -ENOENT;\n\t\t\tgoto end1;\n\t\t}\n\n\tif ((r = hpfs_remove_dirent(old_dir, dno, dep, &qbh, 0))) {\n\t\thpfs_error(i->i_sb, \"hpfs_rename: could not remove dirent\");\n\t\terr = r == 2 ? -ENOSPC : -EFSERROR;\n\t\tgoto end1;\n\t}\n\n\tend:\n\thpfs_i(i)->i_parent_dir = new_dir->i_ino;\n\tif (S_ISDIR(i->i_mode)) {\n\t\tinc_nlink(new_dir);\n\t\tdrop_nlink(old_dir);\n\t}\n\tif ((fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) {\n\t\tfnode->up = cpu_to_le32(new_dir->i_ino);\n\t\tfnode->len = new_len;\n\t\tmemcpy(fnode->name, new_name, new_len>15?15:new_len);\n\t\tif (new_len < 15) memset(&fnode->name[new_len], 0, 15 - new_len);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\nend1:\n\thpfs_unlock(i->i_sb);\n\treturn err;\n}"
  },
  {
    "function_name": "hpfs_symlink_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/namei.c",
    "lines": "484-512",
    "snippet": "static int hpfs_symlink_readpage(struct file *file, struct page *page)\n{\n\tchar *link = kmap(page);\n\tstruct inode *i = page->mapping->host;\n\tstruct fnode *fnode;\n\tstruct buffer_head *bh;\n\tint err;\n\n\terr = -EIO;\n\thpfs_lock(i->i_sb);\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh)))\n\t\tgoto fail;\n\terr = hpfs_read_ea(i->i_sb, fnode, \"SYMLINK\", link, PAGE_SIZE);\n\tbrelse(bh);\n\tif (err)\n\t\tgoto fail;\n\thpfs_unlock(i->i_sb);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\nfail:\n\thpfs_unlock(i->i_sb);\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "i->i_sb"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_read_ea",
          "args": [
            "i->i_sb",
            "fnode",
            "\"SYMLINK\"",
            "link",
            "PAGE_SIZE"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_read_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
          "lines": "73-126",
          "snippet": "int hpfs_read_ea(struct super_block *s, struct fnode *fnode, char *key,\n\t\tchar *buf, int size)\n{\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tchar ex[4 + 255 + 1 + 8];\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\tgoto indirect;\n\t\t\tif (ea_valuelen(ea) >= size)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemcpy(buf, ea_data(ea), ea_valuelen(ea));\n\t\t\tbuf[ea_valuelen(ea)] = 0;\n\t\t\treturn 0;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return -EIO;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn -EIO;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\tgoto indirect;\n\t\t\tif (ea_valuelen(ea) >= size)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4 + ea->namelen + 1, ea_valuelen(ea), buf))\n\t\t\t\treturn -EIO;\n\t\t\tbuf[ea_valuelen(ea)] = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\treturn -ENOENT;\nindirect:\n\tif (ea_len(ea) >= size)\n\t\treturn -EINVAL;\n\tif (hpfs_ea_read(s, ea_sec(ea), ea_in_anode(ea), 0, ea_len(ea), buf))\n\t\treturn -EIO;\n\tbuf[ea_len(ea)] = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_read_ea(struct super_block *s, struct fnode *fnode, char *key,\n\t\tchar *buf, int size)\n{\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tchar ex[4 + 255 + 1 + 8];\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\tgoto indirect;\n\t\t\tif (ea_valuelen(ea) >= size)\n\t\t\t\treturn -EINVAL;\n\t\t\tmemcpy(buf, ea_data(ea), ea_valuelen(ea));\n\t\t\tbuf[ea_valuelen(ea)] = 0;\n\t\t\treturn 0;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return -EIO;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn -EIO;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea))\n\t\t\t\tgoto indirect;\n\t\t\tif (ea_valuelen(ea) >= size)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (hpfs_ea_read(s, a, ano, pos + 4 + ea->namelen + 1, ea_valuelen(ea), buf))\n\t\t\t\treturn -EIO;\n\t\t\tbuf[ea_valuelen(ea)] = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\treturn -ENOENT;\nindirect:\n\tif (ea_len(ea) >= size)\n\t\treturn -EINVAL;\n\tif (hpfs_ea_read(s, ea_sec(ea), ea_in_anode(ea), 0, ea_len(ea), buf))\n\t\treturn -EIO;\n\tbuf[ea_len(ea)] = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_map_fnode",
          "args": [
            "i->i_sb",
            "i->i_ino",
            "&bh"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_map_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/map.c",
          "lines": "137-192",
          "snippet": "struct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_map_fnode(struct super_block *s, ino_t ino, struct buffer_head **bhp)\n{\n\tstruct fnode *fnode;\n\tif (hpfs_sb(s)->sb_chk) if (hpfs_chk_sectors(s, ino, 1, \"fnode\")) {\n\t\treturn NULL;\n\t}\n\tif ((fnode = hpfs_map_sector(s, ino, bhp, FNODE_RD_AHEAD))) {\n\t\tif (hpfs_sb(s)->sb_chk) {\n\t\t\tstruct extended_attribute *ea;\n\t\t\tstruct extended_attribute *ea_end;\n\t\t\tif (le32_to_cpu(fnode->magic) != FNODE_MAGIC) {\n\t\t\t\thpfs_error(s, \"bad magic on fnode %08lx\",\n\t\t\t\t\t(unsigned long)ino);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (!fnode_is_dir(fnode)) {\n\t\t\t\tif ((unsigned)fnode->btree.n_used_nodes + (unsigned)fnode->btree.n_free_nodes !=\n\t\t\t\t    (bp_internal(&fnode->btree) ? 12 : 8)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t   \"bad number of nodes in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tif (le16_to_cpu(fnode->btree.first_free) !=\n\t\t\t\t    8 + fnode->btree.n_used_nodes * (bp_internal(&fnode->btree) ? 8 : 12)) {\n\t\t\t\t\thpfs_error(s,\n\t\t\t\t\t    \"bad first_free pointer in fnode %08lx\",\n\t\t\t\t\t    (unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (le16_to_cpu(fnode->ea_size_s) && (le16_to_cpu(fnode->ea_offs) < 0xc4 ||\n\t\t\t   le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200)) {\n\t\t\t\thpfs_error(s,\n\t\t\t\t\t\"bad EA info in fnode %08lx: ea_offs == %04x ea_size_s == %04x\",\n\t\t\t\t\t(unsigned long)ino,\n\t\t\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tea = fnode_ea(fnode);\n\t\t\tea_end = fnode_end_ea(fnode);\n\t\t\twhile (ea != ea_end) {\n\t\t\t\tif (ea > ea_end) {\n\t\t\t\t\thpfs_error(s, \"bad EA in fnode %08lx\",\n\t\t\t\t\t\t(unsigned long)ino);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tea = next_ea(ea);\n\t\t\t}\n\t\t}\n\t}\n\treturn fnode;\n\tbail:\n\tbrelse(*bhp);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "i->i_sb"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/sched.h>\n\nstatic int hpfs_symlink_readpage(struct file *file, struct page *page)\n{\n\tchar *link = kmap(page);\n\tstruct inode *i = page->mapping->host;\n\tstruct fnode *fnode;\n\tstruct buffer_head *bh;\n\tint err;\n\n\terr = -EIO;\n\thpfs_lock(i->i_sb);\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh)))\n\t\tgoto fail;\n\terr = hpfs_read_ea(i->i_sb, fnode, \"SYMLINK\", link, PAGE_SIZE);\n\tbrelse(bh);\n\tif (err)\n\t\tgoto fail;\n\thpfs_unlock(i->i_sb);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\nfail:\n\thpfs_unlock(i->i_sb);\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "hpfs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/namei.c",
    "lines": "430-482",
    "snippet": "static int hpfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tstruct inode *inode = dentry->d_inode;\n\tdnode_secno dno;\n\tint n_items = 0;\n\tint err;\n\tint r;\n\n\thpfs_adjust_length(name, &len);\n\thpfs_lock(dir->i_sb);\n\terr = -ENOENT;\n\tde = map_dirent(dir, hpfs_i(dir)->i_dno, name, len, &dno, &qbh);\n\tif (!de)\n\t\tgoto out;\n\n\terr = -EPERM;\n\tif (de->first)\n\t\tgoto out1;\n\n\terr = -ENOTDIR;\n\tif (!de->directory)\n\t\tgoto out1;\n\n\thpfs_count_dnodes(dir->i_sb, hpfs_i(inode)->i_dno, NULL, NULL, &n_items);\n\terr = -ENOTEMPTY;\n\tif (n_items)\n\t\tgoto out1;\n\n\tr = hpfs_remove_dirent(dir, dno, de, &qbh, 1);\n\tswitch (r) {\n\tcase 1:\n\t\thpfs_error(dir->i_sb, \"there was error when removing dirent\");\n\t\terr = -EFSERROR;\n\t\tbreak;\n\tcase 2:\n\t\terr = -ENOSPC;\n\t\tbreak;\n\tdefault:\n\t\tdrop_nlink(dir);\n\t\tclear_nlink(inode);\n\t\terr = 0;\n\t}\n\tgoto out;\nout1:\n\thpfs_brelse4(&qbh);\nout:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "dir"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "dir->i_sb",
            "\"there was error when removing dirent\""
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_remove_dirent",
          "args": [
            "dir",
            "dno",
            "de",
            "&qbh",
            "1"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_remove_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "708-739",
          "snippet": "int hpfs_remove_dirent(struct inode *i, dnode_secno dno, struct hpfs_dirent *de,\n\t\t       struct quad_buffer_head *qbh, int depth)\n{\n\tstruct dnode *dnode = qbh->data;\n\tdnode_secno down = 0;\n\tloff_t t;\n\tif (de->first || de->last) {\n\t\thpfs_error(i->i_sb, \"hpfs_remove_dirent: attempt to delete first or last dirent in dnode %08x\", dno);\n\t\thpfs_brelse4(qbh);\n\t\treturn 1;\n\t}\n\tif (de->down) down = de_down_pointer(de);\n\tif (depth && (de->down || (de == dnode_first_de(dnode) && de_next_de(de)->last))) {\n\t\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_DEL)) {\n\t\t\thpfs_brelse4(qbh);\n\t\t\treturn 2;\n\t\t}\n\t}\n\ti->i_version++;\n\tfor_all_poss(i, hpfs_pos_del, (t = get_pos(dnode, de)) + 1, 1);\n\thpfs_delete_de(i->i_sb, dnode, de);\n\thpfs_mark_4buffers_dirty(qbh);\n\thpfs_brelse4(qbh);\n\tif (down) {\n\t\tdnode_secno a = move_to_top(i, down, dno);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t);\n\t\tif (a) delete_empty_dnode(i, a);\n\t\treturn !a;\n\t}\n\tdelete_empty_dnode(i, dno);\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_remove_dirent(struct inode *i, dnode_secno dno, struct hpfs_dirent *de,\n\t\t       struct quad_buffer_head *qbh, int depth)\n{\n\tstruct dnode *dnode = qbh->data;\n\tdnode_secno down = 0;\n\tloff_t t;\n\tif (de->first || de->last) {\n\t\thpfs_error(i->i_sb, \"hpfs_remove_dirent: attempt to delete first or last dirent in dnode %08x\", dno);\n\t\thpfs_brelse4(qbh);\n\t\treturn 1;\n\t}\n\tif (de->down) down = de_down_pointer(de);\n\tif (depth && (de->down || (de == dnode_first_de(dnode) && de_next_de(de)->last))) {\n\t\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_DEL)) {\n\t\t\thpfs_brelse4(qbh);\n\t\t\treturn 2;\n\t\t}\n\t}\n\ti->i_version++;\n\tfor_all_poss(i, hpfs_pos_del, (t = get_pos(dnode, de)) + 1, 1);\n\thpfs_delete_de(i->i_sb, dnode, de);\n\thpfs_mark_4buffers_dirty(qbh);\n\thpfs_brelse4(qbh);\n\tif (down) {\n\t\tdnode_secno a = move_to_top(i, down, dno);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t);\n\t\tif (a) delete_empty_dnode(i, a);\n\t\treturn !a;\n\t}\n\tdelete_empty_dnode(i, dno);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_count_dnodes",
          "args": [
            "dir->i_sb",
            "hpfs_i(inode)->i_dno",
            "NULL",
            "NULL",
            "&n_items"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_count_dnodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "741-792",
          "snippet": "void hpfs_count_dnodes(struct super_block *s, dnode_secno dno, int *n_dnodes,\n\t\t       int *n_subdirs, int *n_items)\n{\n\tstruct dnode *dnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tdnode_secno ptr, odno = 0;\n\tint c1, c2 = 0;\n\tint d1, d2 = 0;\n\tgo_down:\n\tif (n_dnodes) (*n_dnodes)++;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, dno, &c1, &c2, \"hpfs_count_dnodes #1\")) return;\n\tptr = 0;\n\tgo_up:\n\tif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\n\tif (hpfs_sb(s)->sb_chk) if (odno && odno != -1 && le32_to_cpu(dnode->up) != odno)\n\t\thpfs_error(s, \"hpfs_count_dnodes: bad up pointer; dnode %08x, down %08x points to %08x\", odno, dno, le32_to_cpu(dnode->up));\n\tde = dnode_first_de(dnode);\n\tif (ptr) while(1) {\n\t\tif (de->down) if (de_down_pointer(de) == ptr) goto process_de;\n\t\tif (de->last) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_error(s, \"hpfs_count_dnodes: pointer to dnode %08x not found in dnode %08x, got here from %08x\",\n\t\t\t\tptr, dno, odno);\n\t\t\treturn;\n\t\t}\n\t\tde = de_next_de(de);\n\t}\n\tnext_de:\n\tif (de->down) {\n\t\todno = dno;\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto go_down;\n\t}\n\tprocess_de:\n\tif (!de->first && !de->last && de->directory && n_subdirs) (*n_subdirs)++;\n\tif (!de->first && !de->last && n_items) (*n_items)++;\n\tif ((de = de_next_de(de)) < dnode_end_de(dnode)) goto next_de;\n\tptr = dno;\n\tdno = le32_to_cpu(dnode->up);\n\tif (dnode->root_dnode) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ptr, &d1, &d2, \"hpfs_count_dnodes #2\")) return;\n\todno = -1;\n\tgoto go_up;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_count_dnodes(struct super_block *s, dnode_secno dno, int *n_dnodes,\n\t\t       int *n_subdirs, int *n_items)\n{\n\tstruct dnode *dnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tdnode_secno ptr, odno = 0;\n\tint c1, c2 = 0;\n\tint d1, d2 = 0;\n\tgo_down:\n\tif (n_dnodes) (*n_dnodes)++;\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, dno, &c1, &c2, \"hpfs_count_dnodes #1\")) return;\n\tptr = 0;\n\tgo_up:\n\tif (!(dnode = hpfs_map_dnode(s, dno, &qbh))) return;\n\tif (hpfs_sb(s)->sb_chk) if (odno && odno != -1 && le32_to_cpu(dnode->up) != odno)\n\t\thpfs_error(s, \"hpfs_count_dnodes: bad up pointer; dnode %08x, down %08x points to %08x\", odno, dno, le32_to_cpu(dnode->up));\n\tde = dnode_first_de(dnode);\n\tif (ptr) while(1) {\n\t\tif (de->down) if (de_down_pointer(de) == ptr) goto process_de;\n\t\tif (de->last) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\thpfs_error(s, \"hpfs_count_dnodes: pointer to dnode %08x not found in dnode %08x, got here from %08x\",\n\t\t\t\tptr, dno, odno);\n\t\t\treturn;\n\t\t}\n\t\tde = de_next_de(de);\n\t}\n\tnext_de:\n\tif (de->down) {\n\t\todno = dno;\n\t\tdno = de_down_pointer(de);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto go_down;\n\t}\n\tprocess_de:\n\tif (!de->first && !de->last && de->directory && n_subdirs) (*n_subdirs)++;\n\tif (!de->first && !de->last && n_items) (*n_items)++;\n\tif ((de = de_next_de(de)) < dnode_end_de(dnode)) goto next_de;\n\tptr = dno;\n\tdno = le32_to_cpu(dnode->up);\n\tif (dnode->root_dnode) {\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_sb(s)->sb_chk)\n\t\tif (hpfs_stop_cycles(s, ptr, &d1, &d2, \"hpfs_count_dnodes #2\")) return;\n\todno = -1;\n\tgoto go_up;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "inode"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_dirent",
          "args": [
            "dir",
            "hpfs_i(dir)->i_dno",
            "name",
            "len",
            "&dno",
            "&qbh"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "map_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "907-940",
          "snippet": "struct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_adjust_length",
          "args": [
            "name",
            "&len"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_adjust_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "106-113",
          "snippet": "void hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/sched.h>\n\nstatic int hpfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tstruct inode *inode = dentry->d_inode;\n\tdnode_secno dno;\n\tint n_items = 0;\n\tint err;\n\tint r;\n\n\thpfs_adjust_length(name, &len);\n\thpfs_lock(dir->i_sb);\n\terr = -ENOENT;\n\tde = map_dirent(dir, hpfs_i(dir)->i_dno, name, len, &dno, &qbh);\n\tif (!de)\n\t\tgoto out;\n\n\terr = -EPERM;\n\tif (de->first)\n\t\tgoto out1;\n\n\terr = -ENOTDIR;\n\tif (!de->directory)\n\t\tgoto out1;\n\n\thpfs_count_dnodes(dir->i_sb, hpfs_i(inode)->i_dno, NULL, NULL, &n_items);\n\terr = -ENOTEMPTY;\n\tif (n_items)\n\t\tgoto out1;\n\n\tr = hpfs_remove_dirent(dir, dno, de, &qbh, 1);\n\tswitch (r) {\n\tcase 1:\n\t\thpfs_error(dir->i_sb, \"there was error when removing dirent\");\n\t\terr = -EFSERROR;\n\t\tbreak;\n\tcase 2:\n\t\terr = -ENOSPC;\n\t\tbreak;\n\tdefault:\n\t\tdrop_nlink(dir);\n\t\tclear_nlink(inode);\n\t\terr = 0;\n\t}\n\tgoto out;\nout1:\n\thpfs_brelse4(&qbh);\nout:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}"
  },
  {
    "function_name": "hpfs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/namei.c",
    "lines": "356-428",
    "snippet": "static int hpfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tstruct inode *inode = dentry->d_inode;\n\tdnode_secno dno;\n\tint r;\n\tint rep = 0;\n\tint err;\n\n\thpfs_lock(dir->i_sb);\n\thpfs_adjust_length(name, &len);\nagain:\n\terr = -ENOENT;\n\tde = map_dirent(dir, hpfs_i(dir)->i_dno, name, len, &dno, &qbh);\n\tif (!de)\n\t\tgoto out;\n\n\terr = -EPERM;\n\tif (de->first)\n\t\tgoto out1;\n\n\terr = -EISDIR;\n\tif (de->directory)\n\t\tgoto out1;\n\n\tr = hpfs_remove_dirent(dir, dno, de, &qbh, 1);\n\tswitch (r) {\n\tcase 1:\n\t\thpfs_error(dir->i_sb, \"there was error when removing dirent\");\n\t\terr = -EFSERROR;\n\t\tbreak;\n\tcase 2:\t\t/* no space for deleting, try to truncate file */\n\n\t\terr = -ENOSPC;\n\t\tif (rep++)\n\t\t\tbreak;\n\n\t\tdentry_unhash(dentry);\n\t\tif (!d_unhashed(dentry)) {\n\t\t\thpfs_unlock(dir->i_sb);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tif (generic_permission(inode, MAY_WRITE) ||\n\t\t    !S_ISREG(inode->i_mode) ||\n\t\t    get_write_access(inode)) {\n\t\t\td_rehash(dentry);\n\t\t} else {\n\t\t\tstruct iattr newattrs;\n\t\t\t/*pr_info(\"truncating file before delete.\\n\");*/\n\t\t\tnewattrs.ia_size = 0;\n\t\t\tnewattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;\n\t\t\terr = notify_change(dentry, &newattrs, NULL);\n\t\t\tput_write_access(inode);\n\t\t\tif (!err)\n\t\t\t\tgoto again;\n\t\t}\n\t\thpfs_unlock(dir->i_sb);\n\t\treturn -ENOSPC;\n\tdefault:\n\t\tdrop_nlink(inode);\n\t\terr = 0;\n\t}\n\tgoto out;\n\nout1:\n\thpfs_brelse4(&qbh);\nout:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_brelse4",
          "args": [
            "&qbh"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "inode"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_write_access",
          "args": [
            "inode"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notify_change",
          "args": [
            "dentry",
            "&newattrs",
            "NULL"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "notify_change",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "190-277",
          "snippet": "int notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint notify_change(struct dentry * dentry, struct iattr * attr, struct inode **delegated_inode)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tumode_t mode = inode->i_mode;\n\tint error;\n\tstruct timespec now;\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&inode->i_mutex));\n\n\tif (ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID | ATTR_TIMES_SET)) {\n\t\tif (IS_IMMUTABLE(inode) || IS_APPEND(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\tif ((ia_valid & ATTR_MODE)) {\n\t\tumode_t amode = attr->ia_mode;\n\t\t/* Flag setting protected by i_mutex */\n\t\tif (is_sxid(amode))\n\t\t\tinode->i_flags &= ~S_NOSEC;\n\t}\n\n\tnow = current_fs_time(inode->i_sb);\n\n\tattr->ia_ctime = now;\n\tif (!(ia_valid & ATTR_ATIME_SET))\n\t\tattr->ia_atime = now;\n\tif (!(ia_valid & ATTR_MTIME_SET))\n\t\tattr->ia_mtime = now;\n\tif (ia_valid & ATTR_KILL_PRIV) {\n\t\tattr->ia_valid &= ~ATTR_KILL_PRIV;\n\t\tia_valid &= ~ATTR_KILL_PRIV;\n\t\terror = security_inode_need_killpriv(dentry);\n\t\tif (error > 0)\n\t\t\terror = security_inode_killpriv(dentry);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/*\n\t * We now pass ATTR_KILL_S*ID to the lower level setattr function so\n\t * that the function has the ability to reinterpret a mode change\n\t * that's due to these bits. This adds an implicit restriction that\n\t * no function will ever call notify_change with both ATTR_MODE and\n\t * ATTR_KILL_S*ID set.\n\t */\n\tif ((ia_valid & (ATTR_KILL_SUID|ATTR_KILL_SGID)) &&\n\t    (ia_valid & ATTR_MODE))\n\t\tBUG();\n\n\tif (ia_valid & ATTR_KILL_SUID) {\n\t\tif (mode & S_ISUID) {\n\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\tattr->ia_mode = (inode->i_mode & ~S_ISUID);\n\t\t}\n\t}\n\tif (ia_valid & ATTR_KILL_SGID) {\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tif (!(ia_valid & ATTR_MODE)) {\n\t\t\t\tia_valid = attr->ia_valid |= ATTR_MODE;\n\t\t\t\tattr->ia_mode = inode->i_mode;\n\t\t\t}\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t\t}\n\t}\n\tif (!(attr->ia_valid & ~(ATTR_KILL_SUID | ATTR_KILL_SGID)))\n\t\treturn 0;\n\n\terror = security_inode_setattr(dentry, attr);\n\tif (error)\n\t\treturn error;\n\terror = try_break_deleg(inode, delegated_inode);\n\tif (error)\n\t\treturn error;\n\n\tif (inode->i_op->setattr)\n\t\terror = inode->i_op->setattr(dentry, attr);\n\telse\n\t\terror = simple_setattr(dentry, attr);\n\n\tif (!error) {\n\t\tfsnotify_change(dentry, ia_valid);\n\t\tima_inode_post_setattr(dentry);\n\t\tevm_inode_post_setattr(dentry, ia_valid);\n\t}\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_rehash",
          "args": [
            "dentry"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2403-2408",
          "snippet": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_write_access",
          "args": [
            "inode"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "MAY_WRITE"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_unhash",
          "args": [
            "dentry"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_unhash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3586-3593",
          "snippet": "void dentry_unhash(struct dentry *dentry)\n{\n\tshrink_dcache_parent(dentry);\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_lockref.count == 1)\n\t\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid dentry_unhash(struct dentry *dentry)\n{\n\tshrink_dcache_parent(dentry);\n\tspin_lock(&dentry->d_lock);\n\tif (dentry->d_lockref.count == 1)\n\t\t__d_drop(dentry);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_error",
          "args": [
            "dir->i_sb",
            "\"there was error when removing dirent\""
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/super.c",
          "lines": "57-86",
          "snippet": "void hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sched.h>",
            "#include <linux/magic.h>",
            "#include <linux/statfs.h>",
            "#include <linux/init.h>",
            "#include <linux/parser.h>",
            "#include <linux/module.h>",
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char err_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/sched.h>\n#include <linux/magic.h>\n#include <linux/statfs.h>\n#include <linux/init.h>\n#include <linux/parser.h>\n#include <linux/module.h>\n#include \"hpfs_fn.h\"\n\nstatic char err_buf[1024];\n\nvoid hpfs_error(struct super_block *s, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(err_buf, sizeof(err_buf), fmt, args);\n\tva_end(args);\n\n\tpr_err(\"filesystem error: %s\", err_buf);\n\tif (!hpfs_sb(s)->sb_was_error) {\n\t\tif (hpfs_sb(s)->sb_err == 2) {\n\t\t\tpr_cont(\"; crashing the system because you wanted it\\n\");\n\t\t\tmark_dirty(s, 0);\n\t\t\tpanic(\"HPFS panic\");\n\t\t} else if (hpfs_sb(s)->sb_err == 1) {\n\t\t\tif (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; already mounted read-only\\n\");\n\t\t\telse {\n\t\t\t\tpr_cont(\"; remounting read-only\\n\");\n\t\t\t\tmark_dirty(s, 0);\n\t\t\t\ts->s_flags |= MS_RDONLY;\n\t\t\t}\n\t\t} else if (s->s_flags & MS_RDONLY)\n\t\t\t\tpr_cont(\"; going on - but anything won't be destroyed because it's read-only\\n\");\n\t\telse\n\t\t\tpr_cont(\"; corrupted filesystem mounted read/write - your computer will explode within 20 seconds ... but you wanted it so!\\n\");\n\t} else\n\t\tpr_cont(\"\\n\");\n\thpfs_sb(s)->sb_was_error = 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_remove_dirent",
          "args": [
            "dir",
            "dno",
            "de",
            "&qbh",
            "1"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_remove_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "708-739",
          "snippet": "int hpfs_remove_dirent(struct inode *i, dnode_secno dno, struct hpfs_dirent *de,\n\t\t       struct quad_buffer_head *qbh, int depth)\n{\n\tstruct dnode *dnode = qbh->data;\n\tdnode_secno down = 0;\n\tloff_t t;\n\tif (de->first || de->last) {\n\t\thpfs_error(i->i_sb, \"hpfs_remove_dirent: attempt to delete first or last dirent in dnode %08x\", dno);\n\t\thpfs_brelse4(qbh);\n\t\treturn 1;\n\t}\n\tif (de->down) down = de_down_pointer(de);\n\tif (depth && (de->down || (de == dnode_first_de(dnode) && de_next_de(de)->last))) {\n\t\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_DEL)) {\n\t\t\thpfs_brelse4(qbh);\n\t\t\treturn 2;\n\t\t}\n\t}\n\ti->i_version++;\n\tfor_all_poss(i, hpfs_pos_del, (t = get_pos(dnode, de)) + 1, 1);\n\thpfs_delete_de(i->i_sb, dnode, de);\n\thpfs_mark_4buffers_dirty(qbh);\n\thpfs_brelse4(qbh);\n\tif (down) {\n\t\tdnode_secno a = move_to_top(i, down, dno);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t);\n\t\tif (a) delete_empty_dnode(i, a);\n\t\treturn !a;\n\t}\n\tdelete_empty_dnode(i, dno);\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_remove_dirent(struct inode *i, dnode_secno dno, struct hpfs_dirent *de,\n\t\t       struct quad_buffer_head *qbh, int depth)\n{\n\tstruct dnode *dnode = qbh->data;\n\tdnode_secno down = 0;\n\tloff_t t;\n\tif (de->first || de->last) {\n\t\thpfs_error(i->i_sb, \"hpfs_remove_dirent: attempt to delete first or last dirent in dnode %08x\", dno);\n\t\thpfs_brelse4(qbh);\n\t\treturn 1;\n\t}\n\tif (de->down) down = de_down_pointer(de);\n\tif (depth && (de->down || (de == dnode_first_de(dnode) && de_next_de(de)->last))) {\n\t\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_DEL)) {\n\t\t\thpfs_brelse4(qbh);\n\t\t\treturn 2;\n\t\t}\n\t}\n\ti->i_version++;\n\tfor_all_poss(i, hpfs_pos_del, (t = get_pos(dnode, de)) + 1, 1);\n\thpfs_delete_de(i->i_sb, dnode, de);\n\thpfs_mark_4buffers_dirty(qbh);\n\thpfs_brelse4(qbh);\n\tif (down) {\n\t\tdnode_secno a = move_to_top(i, down, dno);\n\t\tfor_all_poss(i, hpfs_pos_subst, 5, t);\n\t\tif (a) delete_empty_dnode(i, a);\n\t\treturn !a;\n\t}\n\tdelete_empty_dnode(i, dno);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_dirent",
          "args": [
            "dir",
            "hpfs_i(dir)->i_dno",
            "name",
            "len",
            "&dno",
            "&qbh"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "map_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "907-940",
          "snippet": "struct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *map_dirent(struct inode *inode, dnode_secno dno,\n\t\t\t       const unsigned char *name, unsigned len,\n\t\t\t       dnode_secno *dd, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *dnode;\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end;\n\tint c1, c2 = 0;\n\n\tif (!S_ISDIR(inode->i_mode)) hpfs_error(inode->i_sb, \"map_dirent: not a directory\\n\");\n\tagain:\n\tif (hpfs_sb(inode->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(inode->i_sb, dno, &c1, &c2, \"map_dirent\")) return NULL;\n\tif (!(dnode = hpfs_map_dnode(inode->i_sb, dno, qbh))) return NULL;\n\t\n\tde_end = dnode_end_de(dnode);\n\tfor (de = dnode_first_de(dnode); de < de_end; de = de_next_de(de)) {\n\t\tint t = hpfs_compare_names(inode->i_sb, name, len, de->name, de->namelen, de->last);\n\t\tif (!t) {\n\t\t\tif (dd) *dd = dno;\n\t\t\treturn de;\n\t\t}\n\t\tif (t < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(qbh);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(qbh);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "dir"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_adjust_length",
          "args": [
            "name",
            "&len"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_adjust_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "106-113",
          "snippet": "void hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_adjust_length(const unsigned char *name, unsigned *len)\n{\n\tif (!*len) return;\n\tif (*len == 1 && name[0] == '.') return;\n\tif (*len == 2 && name[0] == '.' && name[1] == '.') return;\n\twhile (*len && (name[*len - 1] == '.' || name[*len - 1] == ' '))\n\t\t(*len)--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/sched.h>\n\nstatic int hpfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tstruct inode *inode = dentry->d_inode;\n\tdnode_secno dno;\n\tint r;\n\tint rep = 0;\n\tint err;\n\n\thpfs_lock(dir->i_sb);\n\thpfs_adjust_length(name, &len);\nagain:\n\terr = -ENOENT;\n\tde = map_dirent(dir, hpfs_i(dir)->i_dno, name, len, &dno, &qbh);\n\tif (!de)\n\t\tgoto out;\n\n\terr = -EPERM;\n\tif (de->first)\n\t\tgoto out1;\n\n\terr = -EISDIR;\n\tif (de->directory)\n\t\tgoto out1;\n\n\tr = hpfs_remove_dirent(dir, dno, de, &qbh, 1);\n\tswitch (r) {\n\tcase 1:\n\t\thpfs_error(dir->i_sb, \"there was error when removing dirent\");\n\t\terr = -EFSERROR;\n\t\tbreak;\n\tcase 2:\t\t/* no space for deleting, try to truncate file */\n\n\t\terr = -ENOSPC;\n\t\tif (rep++)\n\t\t\tbreak;\n\n\t\tdentry_unhash(dentry);\n\t\tif (!d_unhashed(dentry)) {\n\t\t\thpfs_unlock(dir->i_sb);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tif (generic_permission(inode, MAY_WRITE) ||\n\t\t    !S_ISREG(inode->i_mode) ||\n\t\t    get_write_access(inode)) {\n\t\t\td_rehash(dentry);\n\t\t} else {\n\t\t\tstruct iattr newattrs;\n\t\t\t/*pr_info(\"truncating file before delete.\\n\");*/\n\t\t\tnewattrs.ia_size = 0;\n\t\t\tnewattrs.ia_valid = ATTR_SIZE | ATTR_CTIME;\n\t\t\terr = notify_change(dentry, &newattrs, NULL);\n\t\t\tput_write_access(inode);\n\t\t\tif (!err)\n\t\t\t\tgoto again;\n\t\t}\n\t\thpfs_unlock(dir->i_sb);\n\t\treturn -ENOSPC;\n\tdefault:\n\t\tdrop_nlink(inode);\n\t\terr = 0;\n\t}\n\tgoto out;\n\nout1:\n\thpfs_brelse4(&qbh);\nout:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}"
  },
  {
    "function_name": "hpfs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/namei.c",
    "lines": "279-354",
    "snippet": "static int hpfs_symlink(struct inode *dir, struct dentry *dentry, const char *symlink)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tfnode_secno fno;\n\tint r;\n\tstruct hpfs_dirent dee;\n\tstruct inode *result;\n\tint err;\n\tif ((err = hpfs_chk_name(name, &len))) return err==-ENOENT ? -EINVAL : err;\n\thpfs_lock(dir->i_sb);\n\tif (hpfs_sb(dir->i_sb)->sb_eas < 2) {\n\t\thpfs_unlock(dir->i_sb);\n\t\treturn -EPERM;\n\t}\n\terr = -ENOSPC;\n\tfnode = hpfs_alloc_fnode(dir->i_sb, hpfs_i(dir)->i_dno, &fno, &bh);\n\tif (!fnode)\n\t\tgoto bail;\n\tmemset(&dee, 0, sizeof dee);\n\tdee.archive = 1;\n\tdee.hidden = name[0] == '.';\n\tdee.fnode = cpu_to_le32(fno);\n\tdee.creation_date = dee.write_date = dee.read_date = cpu_to_le32(gmt_to_local(dir->i_sb, get_seconds()));\n\n\tresult = new_inode(dir->i_sb);\n\tif (!result)\n\t\tgoto bail1;\n\tresult->i_ino = fno;\n\thpfs_init_inode(result);\n\thpfs_i(result)->i_parent_dir = dir->i_ino;\n\tresult->i_ctime.tv_sec = result->i_mtime.tv_sec = result->i_atime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(dee.creation_date));\n\tresult->i_ctime.tv_nsec = 0;\n\tresult->i_mtime.tv_nsec = 0;\n\tresult->i_atime.tv_nsec = 0;\n\thpfs_i(result)->i_ea_size = 0;\n\tresult->i_mode = S_IFLNK | 0777;\n\tresult->i_uid = current_fsuid();\n\tresult->i_gid = current_fsgid();\n\tresult->i_blocks = 1;\n\tset_nlink(result, 1);\n\tresult->i_size = strlen(symlink);\n\tresult->i_op = &page_symlink_inode_operations;\n\tresult->i_data.a_ops = &hpfs_symlink_aops;\n\n\tr = hpfs_add_dirent(dir, name, len, &dee);\n\tif (r == 1)\n\t\tgoto bail2;\n\tif (r == -1) {\n\t\terr = -EEXIST;\n\t\tgoto bail2;\n\t}\n\tfnode->len = len;\n\tmemcpy(fnode->name, name, len > 15 ? 15 : len);\n\tfnode->up = cpu_to_le32(dir->i_ino);\n\thpfs_set_ea(result, fnode, \"SYMLINK\", symlink, strlen(symlink));\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tinsert_inode_hash(result);\n\n\thpfs_write_inode_nolock(result);\n\td_instantiate(dentry, result);\n\thpfs_unlock(dir->i_sb);\n\treturn 0;\nbail2:\n\tiput(result);\nbail1:\n\tbrelse(bh);\n\thpfs_free_sectors(dir->i_sb, fno, 1);\nbail:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct address_space_operations hpfs_symlink_aops = {\n\t.readpage\t= hpfs_symlink_readpage\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "dir->i_sb",
            "fno",
            "1"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "result"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "result"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_write_inode_nolock",
          "args": [
            "result"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_write_inode_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "207-256",
          "snippet": "void hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "result"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_set_ea",
          "args": [
            "result",
            "fnode",
            "\"SYMLINK\"",
            "symlink",
            "strlen(symlink)"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_set_ea",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/ea.c",
          "lines": "189-366",
          "snippet": "void hpfs_set_ea(struct inode *inode, struct fnode *fnode, const char *key,\n\t\t const char *data, int size)\n{\n\tfnode_secno fno = inode->i_ino;\n\tstruct super_block *s = inode->i_sb;\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tunsigned char h[4];\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t} else if (ea_valuelen(ea) == size) {\n\t\t\t\tmemcpy(ea_data(ea), data, size);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ea_valuelen(ea) == size)\n\t\t\t\t\thpfs_ea_write(s, a, ano, pos + 4 + ea->namelen + 1, size, data);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\tif (!le16_to_cpu(fnode->ea_offs)) {\n\t\t/*if (le16_to_cpu(fnode->ea_size_s)) {\n\t\t\thpfs_error(s, \"fnode %08x: ea_size_s == %03x, ea_offs == 0\",\n\t\t\t\tinode->i_ino, le16_to_cpu(fnode->ea_size_s));\n\t\t\treturn;\n\t\t}*/\n\t\tfnode->ea_offs = cpu_to_le16(0xc4);\n\t}\n\tif (le16_to_cpu(fnode->ea_offs) < 0xc4 || le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200) {\n\t\thpfs_error(s, \"fnode %08lx: ea_offs == %03x, ea_size_s == %03x\",\n\t\t\t(unsigned long)inode->i_ino,\n\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\treturn;\n\t}\n\tif ((le16_to_cpu(fnode->ea_size_s) || !le32_to_cpu(fnode->ea_size_l)) &&\n\t     le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5 <= 0x200) {\n\t\tea = fnode_end_ea(fnode);\n\t\t*(char *)ea = 0;\n\t\tea->namelen = strlen(key);\n\t\tea->valuelen_lo = size;\n\t\tea->valuelen_hi = size >> 8;\n\t\tstrcpy(ea->name, key);\n\t\tmemcpy(ea_data(ea), data, size);\n\t\tfnode->ea_size_s = cpu_to_le16(le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5);\n\t\tgoto ret;\n\t}\n\t/* Most the code here is 99.9993422% unused. I hope there are no bugs.\n\t   But what .. HPFS.IFS has also bugs in ea management. */\n\tif (le16_to_cpu(fnode->ea_size_s) && !le32_to_cpu(fnode->ea_size_l)) {\n\t\tsecno n;\n\t\tstruct buffer_head *bh;\n\t\tchar *data;\n\t\tif (!(n = hpfs_alloc_sector(s, fno, 1, 0))) return;\n\t\tif (!(data = hpfs_get_sector(s, n, &bh))) {\n\t\t\thpfs_free_sectors(s, n, 1);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(data, fnode_ea(fnode), le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_l = cpu_to_le32(le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_s = cpu_to_le16(0);\n\t\tfnode->ea_secno = cpu_to_le32(n);\n\t\tfnode->flags &= ~FNODE_anode;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tpos = le32_to_cpu(fnode->ea_size_l) + 5 + strlen(key) + size;\n\tlen = (le32_to_cpu(fnode->ea_size_l) + 511) >> 9;\n\tif (pos >= 30000) goto bail;\n\twhile (((pos + 511) >> 9) > len) {\n\t\tif (!len) {\n\t\t\tsecno q = hpfs_alloc_sector(s, fno, 1, 0);\n\t\t\tif (!q) goto bail;\n\t\t\tfnode->ea_secno = cpu_to_le32(q);\n\t\t\tfnode->flags &= ~FNODE_anode;\n\t\t\tlen++;\n\t\t} else if (!fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_alloc_if_possible(s, le32_to_cpu(fnode->ea_secno) + len)) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\t/* Aargh... don't know how to create ea anodes :-( */\n\t\t\t\t/*struct buffer_head *bh;\n\t\t\t\tstruct anode *anode;\n\t\t\t\tanode_secno a_s;\n\t\t\t\tif (!(anode = hpfs_alloc_anode(s, fno, &a_s, &bh)))\n\t\t\t\t\tgoto bail;\n\t\t\t\tanode->up = cpu_to_le32(fno);\n\t\t\t\tanode->btree.fnode_parent = 1;\n\t\t\t\tanode->btree.n_free_nodes--;\n\t\t\t\tanode->btree.n_used_nodes++;\n\t\t\t\tanode->btree.first_free = cpu_to_le16(le16_to_cpu(anode->btree.first_free) + 12);\n\t\t\t\tanode->u.external[0].disk_secno = cpu_to_le32(le32_to_cpu(fnode->ea_secno));\n\t\t\t\tanode->u.external[0].file_secno = cpu_to_le32(0);\n\t\t\t\tanode->u.external[0].length = cpu_to_le32(len);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tfnode->flags |= FNODE_anode;\n\t\t\t\tfnode->ea_secno = cpu_to_le32(a_s);*/\n\t\t\t\tsecno new_sec;\n\t\t\t\tint i;\n\t\t\t\tif (!(new_sec = hpfs_alloc_sector(s, fno, 1, 1 - ((pos + 511) >> 9))))\n\t\t\t\t\tgoto bail;\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tstruct buffer_head *bh1, *bh2;\n\t\t\t\t\tvoid *b1, *b2;\n\t\t\t\t\tif (!(b1 = hpfs_map_sector(s, le32_to_cpu(fnode->ea_secno) + i, &bh1, len - i - 1))) {\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(b2 = hpfs_get_sector(s, new_sec + i, &bh2))) {\n\t\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(b2, b1, 512);\n\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\tmark_buffer_dirty(bh2);\n\t\t\t\t\tbrelse(bh2);\n\t\t\t\t}\n\t\t\t\thpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno), len);\n\t\t\t\tfnode->ea_secno = cpu_to_le32(new_sec);\n\t\t\t\tlen = (pos + 511) >> 9;\n\t\t\t}\n\t\t}\n\t\tif (fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_add_sector_to_btree(s, le32_to_cpu(fnode->ea_secno),\n\t\t\t\t\t\t     0, len) != -1) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\th[0] = 0;\n\th[1] = strlen(key);\n\th[2] = size & 0xff;\n\th[3] = size >> 8;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l), 4, h)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 4, h[1] + 1, key)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 5 + h[1], size, data)) goto bail;\n\tfnode->ea_size_l = cpu_to_le32(pos);\n\tret:\n\thpfs_i(inode)->i_ea_size += 5 + strlen(key) + size;\n\treturn;\n\tbail:\n\tif (le32_to_cpu(fnode->ea_secno))\n\t\tif (fnode_in_anode(fnode)) hpfs_truncate_btree(s, le32_to_cpu(fnode->ea_secno), 1, (le32_to_cpu(fnode->ea_size_l) + 511) >> 9);\n\t\telse hpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno) + ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9), len - ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9));\n\telse fnode->ea_secno = fnode->ea_size_l = cpu_to_le32(0);\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_set_ea(struct inode *inode, struct fnode *fnode, const char *key,\n\t\t const char *data, int size)\n{\n\tfnode_secno fno = inode->i_ino;\n\tstruct super_block *s = inode->i_sb;\n\tunsigned pos;\n\tint ano, len;\n\tsecno a;\n\tunsigned char h[4];\n\tstruct extended_attribute *ea;\n\tstruct extended_attribute *ea_end = fnode_end_ea(fnode);\n\tfor (ea = fnode_ea(fnode); ea < ea_end; ea = next_ea(ea))\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t} else if (ea_valuelen(ea) == size) {\n\t\t\t\tmemcpy(ea_data(ea), data, size);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\ta = le32_to_cpu(fnode->ea_secno);\n\tlen = le32_to_cpu(fnode->ea_size_l);\n\tano = fnode_in_anode(fnode);\n\tpos = 0;\n\twhile (pos < len) {\n\t\tchar ex[4 + 255 + 1 + 8];\n\t\tea = (struct extended_attribute *)ex;\n\t\tif (pos + 4 > len) {\n\t\t\thpfs_error(s, \"EAs don't end correctly, %s %08x, len %08x\",\n\t\t\t\tano ? \"anode\" : \"sectors\", a, len);\n\t\t\treturn;\n\t\t}\n\t\tif (hpfs_ea_read(s, a, ano, pos, 4, ex)) return;\n\t\tif (hpfs_ea_read(s, a, ano, pos + 4, ea->namelen + 1 + (ea_indirect(ea) ? 8 : 0), ex + 4))\n\t\t\treturn;\n\t\tif (!strcmp(ea->name, key)) {\n\t\t\tif (ea_indirect(ea)) {\n\t\t\t\tif (ea_len(ea) == size)\n\t\t\t\t\tset_indirect_ea(s, ea_in_anode(ea), ea_sec(ea), data, size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ea_valuelen(ea) == size)\n\t\t\t\t\thpfs_ea_write(s, a, ano, pos + 4 + ea->namelen + 1, size, data);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpos += ea->namelen + ea_valuelen(ea) + 5;\n\t}\n\tif (!le16_to_cpu(fnode->ea_offs)) {\n\t\t/*if (le16_to_cpu(fnode->ea_size_s)) {\n\t\t\thpfs_error(s, \"fnode %08x: ea_size_s == %03x, ea_offs == 0\",\n\t\t\t\tinode->i_ino, le16_to_cpu(fnode->ea_size_s));\n\t\t\treturn;\n\t\t}*/\n\t\tfnode->ea_offs = cpu_to_le16(0xc4);\n\t}\n\tif (le16_to_cpu(fnode->ea_offs) < 0xc4 || le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) > 0x200) {\n\t\thpfs_error(s, \"fnode %08lx: ea_offs == %03x, ea_size_s == %03x\",\n\t\t\t(unsigned long)inode->i_ino,\n\t\t\tle16_to_cpu(fnode->ea_offs), le16_to_cpu(fnode->ea_size_s));\n\t\treturn;\n\t}\n\tif ((le16_to_cpu(fnode->ea_size_s) || !le32_to_cpu(fnode->ea_size_l)) &&\n\t     le16_to_cpu(fnode->ea_offs) + le16_to_cpu(fnode->acl_size_s) + le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5 <= 0x200) {\n\t\tea = fnode_end_ea(fnode);\n\t\t*(char *)ea = 0;\n\t\tea->namelen = strlen(key);\n\t\tea->valuelen_lo = size;\n\t\tea->valuelen_hi = size >> 8;\n\t\tstrcpy(ea->name, key);\n\t\tmemcpy(ea_data(ea), data, size);\n\t\tfnode->ea_size_s = cpu_to_le16(le16_to_cpu(fnode->ea_size_s) + strlen(key) + size + 5);\n\t\tgoto ret;\n\t}\n\t/* Most the code here is 99.9993422% unused. I hope there are no bugs.\n\t   But what .. HPFS.IFS has also bugs in ea management. */\n\tif (le16_to_cpu(fnode->ea_size_s) && !le32_to_cpu(fnode->ea_size_l)) {\n\t\tsecno n;\n\t\tstruct buffer_head *bh;\n\t\tchar *data;\n\t\tif (!(n = hpfs_alloc_sector(s, fno, 1, 0))) return;\n\t\tif (!(data = hpfs_get_sector(s, n, &bh))) {\n\t\t\thpfs_free_sectors(s, n, 1);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(data, fnode_ea(fnode), le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_l = cpu_to_le32(le16_to_cpu(fnode->ea_size_s));\n\t\tfnode->ea_size_s = cpu_to_le16(0);\n\t\tfnode->ea_secno = cpu_to_le32(n);\n\t\tfnode->flags &= ~FNODE_anode;\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\t}\n\tpos = le32_to_cpu(fnode->ea_size_l) + 5 + strlen(key) + size;\n\tlen = (le32_to_cpu(fnode->ea_size_l) + 511) >> 9;\n\tif (pos >= 30000) goto bail;\n\twhile (((pos + 511) >> 9) > len) {\n\t\tif (!len) {\n\t\t\tsecno q = hpfs_alloc_sector(s, fno, 1, 0);\n\t\t\tif (!q) goto bail;\n\t\t\tfnode->ea_secno = cpu_to_le32(q);\n\t\t\tfnode->flags &= ~FNODE_anode;\n\t\t\tlen++;\n\t\t} else if (!fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_alloc_if_possible(s, le32_to_cpu(fnode->ea_secno) + len)) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\t/* Aargh... don't know how to create ea anodes :-( */\n\t\t\t\t/*struct buffer_head *bh;\n\t\t\t\tstruct anode *anode;\n\t\t\t\tanode_secno a_s;\n\t\t\t\tif (!(anode = hpfs_alloc_anode(s, fno, &a_s, &bh)))\n\t\t\t\t\tgoto bail;\n\t\t\t\tanode->up = cpu_to_le32(fno);\n\t\t\t\tanode->btree.fnode_parent = 1;\n\t\t\t\tanode->btree.n_free_nodes--;\n\t\t\t\tanode->btree.n_used_nodes++;\n\t\t\t\tanode->btree.first_free = cpu_to_le16(le16_to_cpu(anode->btree.first_free) + 12);\n\t\t\t\tanode->u.external[0].disk_secno = cpu_to_le32(le32_to_cpu(fnode->ea_secno));\n\t\t\t\tanode->u.external[0].file_secno = cpu_to_le32(0);\n\t\t\t\tanode->u.external[0].length = cpu_to_le32(len);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tbrelse(bh);\n\t\t\t\tfnode->flags |= FNODE_anode;\n\t\t\t\tfnode->ea_secno = cpu_to_le32(a_s);*/\n\t\t\t\tsecno new_sec;\n\t\t\t\tint i;\n\t\t\t\tif (!(new_sec = hpfs_alloc_sector(s, fno, 1, 1 - ((pos + 511) >> 9))))\n\t\t\t\t\tgoto bail;\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tstruct buffer_head *bh1, *bh2;\n\t\t\t\t\tvoid *b1, *b2;\n\t\t\t\t\tif (!(b1 = hpfs_map_sector(s, le32_to_cpu(fnode->ea_secno) + i, &bh1, len - i - 1))) {\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tif (!(b2 = hpfs_get_sector(s, new_sec + i, &bh2))) {\n\t\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\t\thpfs_free_sectors(s, new_sec, (pos + 511) >> 9);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(b2, b1, 512);\n\t\t\t\t\tbrelse(bh1);\n\t\t\t\t\tmark_buffer_dirty(bh2);\n\t\t\t\t\tbrelse(bh2);\n\t\t\t\t}\n\t\t\t\thpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno), len);\n\t\t\t\tfnode->ea_secno = cpu_to_le32(new_sec);\n\t\t\t\tlen = (pos + 511) >> 9;\n\t\t\t}\n\t\t}\n\t\tif (fnode_in_anode(fnode)) {\n\t\t\tif (hpfs_add_sector_to_btree(s, le32_to_cpu(fnode->ea_secno),\n\t\t\t\t\t\t     0, len) != -1) {\n\t\t\t\tlen++;\n\t\t\t} else {\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\th[0] = 0;\n\th[1] = strlen(key);\n\th[2] = size & 0xff;\n\th[3] = size >> 8;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l), 4, h)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 4, h[1] + 1, key)) goto bail;\n\tif (hpfs_ea_write(s, le32_to_cpu(fnode->ea_secno), fnode_in_anode(fnode), le32_to_cpu(fnode->ea_size_l) + 5 + h[1], size, data)) goto bail;\n\tfnode->ea_size_l = cpu_to_le32(pos);\n\tret:\n\thpfs_i(inode)->i_ea_size += 5 + strlen(key) + size;\n\treturn;\n\tbail:\n\tif (le32_to_cpu(fnode->ea_secno))\n\t\tif (fnode_in_anode(fnode)) hpfs_truncate_btree(s, le32_to_cpu(fnode->ea_secno), 1, (le32_to_cpu(fnode->ea_size_l) + 511) >> 9);\n\t\telse hpfs_free_sectors(s, le32_to_cpu(fnode->ea_secno) + ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9), len - ((le32_to_cpu(fnode->ea_size_l) + 511) >> 9));\n\telse fnode->ea_secno = fnode->ea_size_l = cpu_to_le32(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symlink"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dir->i_ino"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fnode->name",
            "name",
            "len > 15 ? 15 : len"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_add_dirent",
          "args": [
            "dir",
            "name",
            "len",
            "&dee"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "383-423",
          "snippet": "int hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\ti->i_version++;\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\ti->i_version++;\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "result",
            "1"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "result"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_to_gmt",
          "args": [
            "dir->i_sb",
            "le32_to_cpu(dee.creation_date)"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "local_to_gmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "326-330",
          "snippet": "static inline time_t local_to_gmt(struct super_block *s, time32_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t + sys_tz.tz_minuteswest * 60 + hpfs_sb(s)->sb_timeshift;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline time_t local_to_gmt(struct super_block *s, time32_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t + sys_tz.tz_minuteswest * 60 + hpfs_sb(s)->sb_timeshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dee.creation_date"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_init_inode",
          "args": [
            "result"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "13-41",
          "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "dir->i_sb"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "drop_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "588-595",
          "snippet": "static int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "gmt_to_local(dir->i_sb, get_seconds())"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gmt_to_local",
          "args": [
            "dir->i_sb",
            "get_seconds()"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "gmt_to_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "332-336",
          "snippet": "static inline time32_t gmt_to_local(struct super_block *s, time_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t - sys_tz.tz_minuteswest * 60 - hpfs_sb(s)->sb_timeshift;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline time32_t gmt_to_local(struct super_block *s, time_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t - sys_tz.tz_minuteswest * 60 - hpfs_sb(s)->sb_timeshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "fno"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dee",
            "0",
            "sizeof dee"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_fnode",
          "args": [
            "dir->i_sb",
            "hpfs_i(dir)->i_dno",
            "&fno",
            "&bh"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "453-468",
          "snippet": "struct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "dir->i_sb"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_name",
          "args": [
            "name",
            "&len"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "41-51",
          "snippet": "int hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/sched.h>\n\nconst struct address_space_operations hpfs_symlink_aops = {\n\t.readpage\t= hpfs_symlink_readpage\n};\n\nstatic int hpfs_symlink(struct inode *dir, struct dentry *dentry, const char *symlink)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tfnode_secno fno;\n\tint r;\n\tstruct hpfs_dirent dee;\n\tstruct inode *result;\n\tint err;\n\tif ((err = hpfs_chk_name(name, &len))) return err==-ENOENT ? -EINVAL : err;\n\thpfs_lock(dir->i_sb);\n\tif (hpfs_sb(dir->i_sb)->sb_eas < 2) {\n\t\thpfs_unlock(dir->i_sb);\n\t\treturn -EPERM;\n\t}\n\terr = -ENOSPC;\n\tfnode = hpfs_alloc_fnode(dir->i_sb, hpfs_i(dir)->i_dno, &fno, &bh);\n\tif (!fnode)\n\t\tgoto bail;\n\tmemset(&dee, 0, sizeof dee);\n\tdee.archive = 1;\n\tdee.hidden = name[0] == '.';\n\tdee.fnode = cpu_to_le32(fno);\n\tdee.creation_date = dee.write_date = dee.read_date = cpu_to_le32(gmt_to_local(dir->i_sb, get_seconds()));\n\n\tresult = new_inode(dir->i_sb);\n\tif (!result)\n\t\tgoto bail1;\n\tresult->i_ino = fno;\n\thpfs_init_inode(result);\n\thpfs_i(result)->i_parent_dir = dir->i_ino;\n\tresult->i_ctime.tv_sec = result->i_mtime.tv_sec = result->i_atime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(dee.creation_date));\n\tresult->i_ctime.tv_nsec = 0;\n\tresult->i_mtime.tv_nsec = 0;\n\tresult->i_atime.tv_nsec = 0;\n\thpfs_i(result)->i_ea_size = 0;\n\tresult->i_mode = S_IFLNK | 0777;\n\tresult->i_uid = current_fsuid();\n\tresult->i_gid = current_fsgid();\n\tresult->i_blocks = 1;\n\tset_nlink(result, 1);\n\tresult->i_size = strlen(symlink);\n\tresult->i_op = &page_symlink_inode_operations;\n\tresult->i_data.a_ops = &hpfs_symlink_aops;\n\n\tr = hpfs_add_dirent(dir, name, len, &dee);\n\tif (r == 1)\n\t\tgoto bail2;\n\tif (r == -1) {\n\t\terr = -EEXIST;\n\t\tgoto bail2;\n\t}\n\tfnode->len = len;\n\tmemcpy(fnode->name, name, len > 15 ? 15 : len);\n\tfnode->up = cpu_to_le32(dir->i_ino);\n\thpfs_set_ea(result, fnode, \"SYMLINK\", symlink, strlen(symlink));\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tinsert_inode_hash(result);\n\n\thpfs_write_inode_nolock(result);\n\td_instantiate(dentry, result);\n\thpfs_unlock(dir->i_sb);\n\treturn 0;\nbail2:\n\tiput(result);\nbail1:\n\tbrelse(bh);\n\thpfs_free_sectors(dir->i_sb, fno, 1);\nbail:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}"
  },
  {
    "function_name": "hpfs_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/namei.c",
    "lines": "204-277",
    "snippet": "static int hpfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tfnode_secno fno;\n\tint r;\n\tstruct hpfs_dirent dee;\n\tstruct inode *result = NULL;\n\tint err;\n\tif ((err = hpfs_chk_name(name, &len))) return err==-ENOENT ? -EINVAL : err;\n\tif (hpfs_sb(dir->i_sb)->sb_eas < 2) return -EPERM;\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\thpfs_lock(dir->i_sb);\n\terr = -ENOSPC;\n\tfnode = hpfs_alloc_fnode(dir->i_sb, hpfs_i(dir)->i_dno, &fno, &bh);\n\tif (!fnode)\n\t\tgoto bail;\n\tmemset(&dee, 0, sizeof dee);\n\tif (!(mode & 0222)) dee.read_only = 1;\n\tdee.archive = 1;\n\tdee.hidden = name[0] == '.';\n\tdee.fnode = cpu_to_le32(fno);\n\tdee.creation_date = dee.write_date = dee.read_date = cpu_to_le32(gmt_to_local(dir->i_sb, get_seconds()));\n\n\tresult = new_inode(dir->i_sb);\n\tif (!result)\n\t\tgoto bail1;\n\n\thpfs_init_inode(result);\n\tresult->i_ino = fno;\n\thpfs_i(result)->i_parent_dir = dir->i_ino;\n\tresult->i_ctime.tv_sec = result->i_mtime.tv_sec = result->i_atime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(dee.creation_date));\n\tresult->i_ctime.tv_nsec = 0;\n\tresult->i_mtime.tv_nsec = 0;\n\tresult->i_atime.tv_nsec = 0;\n\thpfs_i(result)->i_ea_size = 0;\n\tresult->i_uid = current_fsuid();\n\tresult->i_gid = current_fsgid();\n\tset_nlink(result, 1);\n\tresult->i_size = 0;\n\tresult->i_blocks = 1;\n\tinit_special_inode(result, mode, rdev);\n\n\tr = hpfs_add_dirent(dir, name, len, &dee);\n\tif (r == 1)\n\t\tgoto bail2;\n\tif (r == -1) {\n\t\terr = -EEXIST;\n\t\tgoto bail2;\n\t}\n\tfnode->len = len;\n\tmemcpy(fnode->name, name, len > 15 ? 15 : len);\n\tfnode->up = cpu_to_le32(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\n\tinsert_inode_hash(result);\n\n\thpfs_write_inode_nolock(result);\n\td_instantiate(dentry, result);\n\tbrelse(bh);\n\thpfs_unlock(dir->i_sb);\n\treturn 0;\nbail2:\n\tiput(result);\nbail1:\n\tbrelse(bh);\n\thpfs_free_sectors(dir->i_sb, fno, 1);\nbail:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "dir->i_sb",
            "fno",
            "1"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "result"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "result"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_write_inode_nolock",
          "args": [
            "result"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_write_inode_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "207-256",
          "snippet": "void hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "result"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dir->i_ino"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fnode->name",
            "name",
            "len > 15 ? 15 : len"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_add_dirent",
          "args": [
            "dir",
            "name",
            "len",
            "&dee"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "383-423",
          "snippet": "int hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\ti->i_version++;\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\ti->i_version++;\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "result",
            "mode",
            "rdev"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "result",
            "1"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "result"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_to_gmt",
          "args": [
            "dir->i_sb",
            "le32_to_cpu(dee.creation_date)"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "local_to_gmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "326-330",
          "snippet": "static inline time_t local_to_gmt(struct super_block *s, time32_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t + sys_tz.tz_minuteswest * 60 + hpfs_sb(s)->sb_timeshift;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline time_t local_to_gmt(struct super_block *s, time32_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t + sys_tz.tz_minuteswest * 60 + hpfs_sb(s)->sb_timeshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dee.creation_date"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_init_inode",
          "args": [
            "result"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "13-41",
          "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "dir->i_sb"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "drop_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "588-595",
          "snippet": "static int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "gmt_to_local(dir->i_sb, get_seconds())"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gmt_to_local",
          "args": [
            "dir->i_sb",
            "get_seconds()"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "gmt_to_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "332-336",
          "snippet": "static inline time32_t gmt_to_local(struct super_block *s, time_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t - sys_tz.tz_minuteswest * 60 - hpfs_sb(s)->sb_timeshift;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline time32_t gmt_to_local(struct super_block *s, time_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t - sys_tz.tz_minuteswest * 60 - hpfs_sb(s)->sb_timeshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "fno"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dee",
            "0",
            "sizeof dee"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_fnode",
          "args": [
            "dir->i_sb",
            "hpfs_i(dir)->i_dno",
            "&fno",
            "&bh"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "453-468",
          "snippet": "struct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_sb",
          "args": [
            "dir->i_sb"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "310-313",
          "snippet": "static inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline struct hpfs_sb_info *hpfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_name",
          "args": [
            "name",
            "&len"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "41-51",
          "snippet": "int hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/sched.h>\n\nstatic int hpfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode, dev_t rdev)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tfnode_secno fno;\n\tint r;\n\tstruct hpfs_dirent dee;\n\tstruct inode *result = NULL;\n\tint err;\n\tif ((err = hpfs_chk_name(name, &len))) return err==-ENOENT ? -EINVAL : err;\n\tif (hpfs_sb(dir->i_sb)->sb_eas < 2) return -EPERM;\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\thpfs_lock(dir->i_sb);\n\terr = -ENOSPC;\n\tfnode = hpfs_alloc_fnode(dir->i_sb, hpfs_i(dir)->i_dno, &fno, &bh);\n\tif (!fnode)\n\t\tgoto bail;\n\tmemset(&dee, 0, sizeof dee);\n\tif (!(mode & 0222)) dee.read_only = 1;\n\tdee.archive = 1;\n\tdee.hidden = name[0] == '.';\n\tdee.fnode = cpu_to_le32(fno);\n\tdee.creation_date = dee.write_date = dee.read_date = cpu_to_le32(gmt_to_local(dir->i_sb, get_seconds()));\n\n\tresult = new_inode(dir->i_sb);\n\tif (!result)\n\t\tgoto bail1;\n\n\thpfs_init_inode(result);\n\tresult->i_ino = fno;\n\thpfs_i(result)->i_parent_dir = dir->i_ino;\n\tresult->i_ctime.tv_sec = result->i_mtime.tv_sec = result->i_atime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(dee.creation_date));\n\tresult->i_ctime.tv_nsec = 0;\n\tresult->i_mtime.tv_nsec = 0;\n\tresult->i_atime.tv_nsec = 0;\n\thpfs_i(result)->i_ea_size = 0;\n\tresult->i_uid = current_fsuid();\n\tresult->i_gid = current_fsgid();\n\tset_nlink(result, 1);\n\tresult->i_size = 0;\n\tresult->i_blocks = 1;\n\tinit_special_inode(result, mode, rdev);\n\n\tr = hpfs_add_dirent(dir, name, len, &dee);\n\tif (r == 1)\n\t\tgoto bail2;\n\tif (r == -1) {\n\t\terr = -EEXIST;\n\t\tgoto bail2;\n\t}\n\tfnode->len = len;\n\tmemcpy(fnode->name, name, len > 15 ? 15 : len);\n\tfnode->up = cpu_to_le32(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\n\tinsert_inode_hash(result);\n\n\thpfs_write_inode_nolock(result);\n\td_instantiate(dentry, result);\n\tbrelse(bh);\n\thpfs_unlock(dir->i_sb);\n\treturn 0;\nbail2:\n\tiput(result);\nbail1:\n\tbrelse(bh);\n\thpfs_free_sectors(dir->i_sb, fno, 1);\nbail:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}"
  },
  {
    "function_name": "hpfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/namei.c",
    "lines": "118-202",
    "snippet": "static int hpfs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct inode *result = NULL;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tfnode_secno fno;\n\tint r;\n\tstruct hpfs_dirent dee;\n\tint err;\n\tif ((err = hpfs_chk_name(name, &len)))\n\t\treturn err==-ENOENT ? -EINVAL : err;\n\thpfs_lock(dir->i_sb);\n\terr = -ENOSPC;\n\tfnode = hpfs_alloc_fnode(dir->i_sb, hpfs_i(dir)->i_dno, &fno, &bh);\n\tif (!fnode)\n\t\tgoto bail;\n\tmemset(&dee, 0, sizeof dee);\n\tif (!(mode & 0222)) dee.read_only = 1;\n\tdee.archive = 1;\n\tdee.hidden = name[0] == '.';\n\tdee.fnode = cpu_to_le32(fno);\n\tdee.creation_date = dee.write_date = dee.read_date = cpu_to_le32(gmt_to_local(dir->i_sb, get_seconds()));\n\n\tresult = new_inode(dir->i_sb);\n\tif (!result)\n\t\tgoto bail1;\n\t\n\thpfs_init_inode(result);\n\tresult->i_ino = fno;\n\tresult->i_mode |= S_IFREG;\n\tresult->i_mode &= ~0111;\n\tresult->i_op = &hpfs_file_iops;\n\tresult->i_fop = &hpfs_file_ops;\n\tset_nlink(result, 1);\n\thpfs_i(result)->i_parent_dir = dir->i_ino;\n\tresult->i_ctime.tv_sec = result->i_mtime.tv_sec = result->i_atime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(dee.creation_date));\n\tresult->i_ctime.tv_nsec = 0;\n\tresult->i_mtime.tv_nsec = 0;\n\tresult->i_atime.tv_nsec = 0;\n\thpfs_i(result)->i_ea_size = 0;\n\tif (dee.read_only)\n\t\tresult->i_mode &= ~0222;\n\tresult->i_blocks = 1;\n\tresult->i_size = 0;\n\tresult->i_data.a_ops = &hpfs_aops;\n\thpfs_i(result)->mmu_private = 0;\n\n\tr = hpfs_add_dirent(dir, name, len, &dee);\n\tif (r == 1)\n\t\tgoto bail2;\n\tif (r == -1) {\n\t\terr = -EEXIST;\n\t\tgoto bail2;\n\t}\n\tfnode->len = len;\n\tmemcpy(fnode->name, name, len > 15 ? 15 : len);\n\tfnode->up = cpu_to_le32(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tinsert_inode_hash(result);\n\n\tif (!uid_eq(result->i_uid, current_fsuid()) ||\n\t    !gid_eq(result->i_gid, current_fsgid()) ||\n\t    result->i_mode != (mode | S_IFREG)) {\n\t\tresult->i_uid = current_fsuid();\n\t\tresult->i_gid = current_fsgid();\n\t\tresult->i_mode = mode | S_IFREG;\n\t\thpfs_write_inode_nolock(result);\n\t}\n\td_instantiate(dentry, result);\n\thpfs_unlock(dir->i_sb);\n\treturn 0;\n\nbail2:\n\tiput(result);\nbail1:\n\tbrelse(bh);\n\thpfs_free_sectors(dir->i_sb, fno, 1);\nbail:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "dir->i_sb",
            "fno",
            "1"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "result"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "result"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_write_inode_nolock",
          "args": [
            "result"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_write_inode_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "207-256",
          "snippet": "void hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "result->i_gid",
            "current_fsgid()"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "result->i_uid",
            "current_fsuid()"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "result"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dir->i_ino"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fnode->name",
            "name",
            "len > 15 ? 15 : len"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_add_dirent",
          "args": [
            "dir",
            "name",
            "len",
            "&dee"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "383-423",
          "snippet": "int hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\ti->i_version++;\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\ti->i_version++;\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "result"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_to_gmt",
          "args": [
            "dir->i_sb",
            "le32_to_cpu(dee.creation_date)"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "local_to_gmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "326-330",
          "snippet": "static inline time_t local_to_gmt(struct super_block *s, time32_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t + sys_tz.tz_minuteswest * 60 + hpfs_sb(s)->sb_timeshift;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline time_t local_to_gmt(struct super_block *s, time32_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t + sys_tz.tz_minuteswest * 60 + hpfs_sb(s)->sb_timeshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dee.creation_date"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "result",
            "1"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_init_inode",
          "args": [
            "result"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "13-41",
          "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "dir->i_sb"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "drop_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "588-595",
          "snippet": "static int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "gmt_to_local(dir->i_sb, get_seconds())"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gmt_to_local",
          "args": [
            "dir->i_sb",
            "get_seconds()"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "gmt_to_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "332-336",
          "snippet": "static inline time32_t gmt_to_local(struct super_block *s, time_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t - sys_tz.tz_minuteswest * 60 - hpfs_sb(s)->sb_timeshift;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline time32_t gmt_to_local(struct super_block *s, time_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t - sys_tz.tz_minuteswest * 60 - hpfs_sb(s)->sb_timeshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "fno"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dee",
            "0",
            "sizeof dee"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_fnode",
          "args": [
            "dir->i_sb",
            "hpfs_i(dir)->i_dno",
            "&fno",
            "&bh"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "453-468",
          "snippet": "struct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_name",
          "args": [
            "name",
            "&len"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "41-51",
          "snippet": "int hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/sched.h>\n\nstatic int hpfs_create(struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct inode *result = NULL;\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tfnode_secno fno;\n\tint r;\n\tstruct hpfs_dirent dee;\n\tint err;\n\tif ((err = hpfs_chk_name(name, &len)))\n\t\treturn err==-ENOENT ? -EINVAL : err;\n\thpfs_lock(dir->i_sb);\n\terr = -ENOSPC;\n\tfnode = hpfs_alloc_fnode(dir->i_sb, hpfs_i(dir)->i_dno, &fno, &bh);\n\tif (!fnode)\n\t\tgoto bail;\n\tmemset(&dee, 0, sizeof dee);\n\tif (!(mode & 0222)) dee.read_only = 1;\n\tdee.archive = 1;\n\tdee.hidden = name[0] == '.';\n\tdee.fnode = cpu_to_le32(fno);\n\tdee.creation_date = dee.write_date = dee.read_date = cpu_to_le32(gmt_to_local(dir->i_sb, get_seconds()));\n\n\tresult = new_inode(dir->i_sb);\n\tif (!result)\n\t\tgoto bail1;\n\t\n\thpfs_init_inode(result);\n\tresult->i_ino = fno;\n\tresult->i_mode |= S_IFREG;\n\tresult->i_mode &= ~0111;\n\tresult->i_op = &hpfs_file_iops;\n\tresult->i_fop = &hpfs_file_ops;\n\tset_nlink(result, 1);\n\thpfs_i(result)->i_parent_dir = dir->i_ino;\n\tresult->i_ctime.tv_sec = result->i_mtime.tv_sec = result->i_atime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(dee.creation_date));\n\tresult->i_ctime.tv_nsec = 0;\n\tresult->i_mtime.tv_nsec = 0;\n\tresult->i_atime.tv_nsec = 0;\n\thpfs_i(result)->i_ea_size = 0;\n\tif (dee.read_only)\n\t\tresult->i_mode &= ~0222;\n\tresult->i_blocks = 1;\n\tresult->i_size = 0;\n\tresult->i_data.a_ops = &hpfs_aops;\n\thpfs_i(result)->mmu_private = 0;\n\n\tr = hpfs_add_dirent(dir, name, len, &dee);\n\tif (r == 1)\n\t\tgoto bail2;\n\tif (r == -1) {\n\t\terr = -EEXIST;\n\t\tgoto bail2;\n\t}\n\tfnode->len = len;\n\tmemcpy(fnode->name, name, len > 15 ? 15 : len);\n\tfnode->up = cpu_to_le32(dir->i_ino);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\n\tinsert_inode_hash(result);\n\n\tif (!uid_eq(result->i_uid, current_fsuid()) ||\n\t    !gid_eq(result->i_gid, current_fsgid()) ||\n\t    result->i_mode != (mode | S_IFREG)) {\n\t\tresult->i_uid = current_fsuid();\n\t\tresult->i_gid = current_fsgid();\n\t\tresult->i_mode = mode | S_IFREG;\n\t\thpfs_write_inode_nolock(result);\n\t}\n\td_instantiate(dentry, result);\n\thpfs_unlock(dir->i_sb);\n\treturn 0;\n\nbail2:\n\tiput(result);\nbail1:\n\tbrelse(bh);\n\thpfs_free_sectors(dir->i_sb, fno, 1);\nbail:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}"
  },
  {
    "function_name": "hpfs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/namei.c",
    "lines": "11-116",
    "snippet": "static int hpfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh0;\n\tstruct buffer_head *bh;\n\tstruct hpfs_dirent *de;\n\tstruct fnode *fnode;\n\tstruct dnode *dnode;\n\tstruct inode *result;\n\tfnode_secno fno;\n\tdnode_secno dno;\n\tint r;\n\tstruct hpfs_dirent dee;\n\tint err;\n\tif ((err = hpfs_chk_name(name, &len))) return err==-ENOENT ? -EINVAL : err;\n\thpfs_lock(dir->i_sb);\n\terr = -ENOSPC;\n\tfnode = hpfs_alloc_fnode(dir->i_sb, hpfs_i(dir)->i_dno, &fno, &bh);\n\tif (!fnode)\n\t\tgoto bail;\n\tdnode = hpfs_alloc_dnode(dir->i_sb, fno, &dno, &qbh0);\n\tif (!dnode)\n\t\tgoto bail1;\n\tmemset(&dee, 0, sizeof dee);\n\tdee.directory = 1;\n\tif (!(mode & 0222)) dee.read_only = 1;\n\t/*dee.archive = 0;*/\n\tdee.hidden = name[0] == '.';\n\tdee.fnode = cpu_to_le32(fno);\n\tdee.creation_date = dee.write_date = dee.read_date = cpu_to_le32(gmt_to_local(dir->i_sb, get_seconds()));\n\tresult = new_inode(dir->i_sb);\n\tif (!result)\n\t\tgoto bail2;\n\thpfs_init_inode(result);\n\tresult->i_ino = fno;\n\thpfs_i(result)->i_parent_dir = dir->i_ino;\n\thpfs_i(result)->i_dno = dno;\n\tresult->i_ctime.tv_sec = result->i_mtime.tv_sec = result->i_atime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(dee.creation_date));\n\tresult->i_ctime.tv_nsec = 0; \n\tresult->i_mtime.tv_nsec = 0; \n\tresult->i_atime.tv_nsec = 0; \n\thpfs_i(result)->i_ea_size = 0;\n\tresult->i_mode |= S_IFDIR;\n\tresult->i_op = &hpfs_dir_iops;\n\tresult->i_fop = &hpfs_dir_ops;\n\tresult->i_blocks = 4;\n\tresult->i_size = 2048;\n\tset_nlink(result, 2);\n\tif (dee.read_only)\n\t\tresult->i_mode &= ~0222;\n\n\tr = hpfs_add_dirent(dir, name, len, &dee);\n\tif (r == 1)\n\t\tgoto bail3;\n\tif (r == -1) {\n\t\terr = -EEXIST;\n\t\tgoto bail3;\n\t}\n\tfnode->len = len;\n\tmemcpy(fnode->name, name, len > 15 ? 15 : len);\n\tfnode->up = cpu_to_le32(dir->i_ino);\n\tfnode->flags |= FNODE_dir;\n\tfnode->btree.n_free_nodes = 7;\n\tfnode->btree.n_used_nodes = 1;\n\tfnode->btree.first_free = cpu_to_le16(0x14);\n\tfnode->u.external[0].disk_secno = cpu_to_le32(dno);\n\tfnode->u.external[0].file_secno = cpu_to_le32(-1);\n\tdnode->root_dnode = 1;\n\tdnode->up = cpu_to_le32(fno);\n\tde = hpfs_add_de(dir->i_sb, dnode, \"\\001\\001\", 2, 0);\n\tde->creation_date = de->write_date = de->read_date = cpu_to_le32(gmt_to_local(dir->i_sb, get_seconds()));\n\tif (!(mode & 0222)) de->read_only = 1;\n\tde->first = de->directory = 1;\n\t/*de->hidden = de->system = 0;*/\n\tde->fnode = cpu_to_le32(fno);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\thpfs_mark_4buffers_dirty(&qbh0);\n\thpfs_brelse4(&qbh0);\n\tinc_nlink(dir);\n\tinsert_inode_hash(result);\n\n\tif (!uid_eq(result->i_uid, current_fsuid()) ||\n\t    !gid_eq(result->i_gid, current_fsgid()) ||\n\t    result->i_mode != (mode | S_IFDIR)) {\n\t\tresult->i_uid = current_fsuid();\n\t\tresult->i_gid = current_fsgid();\n\t\tresult->i_mode = mode | S_IFDIR;\n\t\thpfs_write_inode_nolock(result);\n\t}\n\td_instantiate(dentry, result);\n\thpfs_unlock(dir->i_sb);\n\treturn 0;\nbail3:\n\tiput(result);\nbail2:\n\thpfs_brelse4(&qbh0);\n\thpfs_free_dnode(dir->i_sb, dno);\nbail1:\n\tbrelse(bh);\n\thpfs_free_sectors(dir->i_sb, fno, 1);\nbail:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}",
    "includes": [
      "#include \"hpfs_fn.h\"",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations hpfs_dir_iops =\n{\n\t.create\t\t= hpfs_create,\n\t.lookup\t\t= hpfs_lookup,\n\t.unlink\t\t= hpfs_unlink,\n\t.symlink\t= hpfs_symlink,\n\t.mkdir\t\t= hpfs_mkdir,\n\t.rmdir\t\t= hpfs_rmdir,\n\t.mknod\t\t= hpfs_mknod,\n\t.rename\t\t= hpfs_rename,\n\t.setattr\t= hpfs_setattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hpfs_unlock",
          "args": [
            "dir->i_sb"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "353-357",
          "snippet": "static inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_unlock(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tmutex_unlock(&sbi->hpfs_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_free_sectors",
          "args": [
            "dir->i_sb",
            "fno",
            "1"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_sectors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "314-350",
          "snippet": "void hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_sectors(struct super_block *s, secno sec, unsigned n)\n{\n\tstruct quad_buffer_head qbh;\n\t__le32 *bmp;\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\t/*pr_info(\"2 - \");*/\n\tif (!n) return;\n\tif (sec < 0x12) {\n\t\thpfs_error(s, \"Trying to free reserved sector %08x\", sec);\n\t\treturn;\n\t}\n\tsbi->sb_max_fwd_alloc += n > 0xffff ? 0xffff : n;\n\tif (sbi->sb_max_fwd_alloc > 0xffffff) sbi->sb_max_fwd_alloc = 0xffffff;\n\tnew_map:\n\tif (!(bmp = hpfs_map_bitmap(s, sec >> 14, &qbh, \"free\"))) {\n\t\treturn;\n\t}\t\n\tnew_tst:\n\tif ((le32_to_cpu(bmp[(sec & 0x3fff) >> 5]) >> (sec & 0x1f) & 1)) {\n\t\thpfs_error(s, \"sector %08x not allocated\", sec);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\n\tbmp[(sec & 0x3fff) >> 5] |= cpu_to_le32(1 << (sec & 0x1f));\n\thpfs_claim_free(s, sec);\n\tif (!--n) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\treturn;\n\t}\t\n\tif (!(++sec & 0x3fff)) {\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\tgoto new_map;\n\t}\n\tgoto new_tst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_brelse4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "182-190",
          "snippet": "void hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_brelse4(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data))\n\t\tkfree(qbh->data);\n\tbrelse(qbh->bh[0]);\n\tbrelse(qbh->bh[1]);\n\tbrelse(qbh->bh[2]);\n\tbrelse(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_free_dnode",
          "args": [
            "dir->i_sb",
            "dno"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_free_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "404-425",
          "snippet": "void hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nvoid hpfs_free_dnode(struct super_block *s, dnode_secno dno)\n{\n\tif (hpfs_sb(s)->sb_chk) if (dno & 3) {\n\t\thpfs_error(s, \"hpfs_free_dnode: dnode %08x not aligned\", dno);\n\t\treturn;\n\t}\n\tif (dno < hpfs_sb(s)->sb_dirband_start ||\n\t    dno >= hpfs_sb(s)->sb_dirband_start + hpfs_sb(s)->sb_dirband_size) {\n\t\thpfs_free_sectors(s, dno, 4);\n\t} else {\n\t\tstruct quad_buffer_head qbh;\n\t\t__le32 *bmp;\n\t\tunsigned ssec = (dno - hpfs_sb(s)->sb_dirband_start) / 4;\n\t\tif (!(bmp = hpfs_map_dnode_bitmap(s, &qbh))) {\n\t\t\treturn;\n\t\t}\n\t\tbmp[ssec >> 5] |= cpu_to_le32(1 << (ssec & 0x1f));\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t\thpfs_claim_dirband_free(s, dno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "result"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "result"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_write_inode_nolock",
          "args": [
            "result"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_write_inode_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "207-256",
          "snippet": "void hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_write_inode_nolock(struct inode *i)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct buffer_head *bh;\n\tstruct fnode *fnode;\n\tstruct quad_buffer_head qbh;\n\tstruct hpfs_dirent *de;\n\tif (i->i_ino == hpfs_sb(i->i_sb)->sb_root) return;\n\tif (!(fnode = hpfs_map_fnode(i->i_sb, i->i_ino, &bh))) return;\n\tif (i->i_ino != hpfs_sb(i->i_sb)->sb_root && i->i_nlink) {\n\t\tif (!(de = map_fnode_dirent(i->i_sb, i->i_ino, fnode, &qbh))) {\n\t\t\tbrelse(bh);\n\t\t\treturn;\n\t\t}\n\t} else de = NULL;\n\tif (S_ISREG(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(i->i_size);\n\t\tif (de) de->file_size = cpu_to_le32(i->i_size);\n\t} else if (S_ISDIR(i->i_mode)) {\n\t\tfnode->file_size = cpu_to_le32(0);\n\t\tif (de) de->file_size = cpu_to_le32(0);\n\t}\n\thpfs_write_inode_ea(i, fnode);\n\tif (de) {\n\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\tde->read_only = !(i->i_mode & 0222);\n\t\tde->ea_size = cpu_to_le32(hpfs_inode->i_ea_size);\n\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\thpfs_brelse4(&qbh);\n\t}\n\tif (S_ISDIR(i->i_mode)) {\n\t\tif ((de = map_dirent(i, hpfs_inode->i_dno, \"\\001\\001\", 2, NULL, &qbh))) {\n\t\t\tde->write_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_mtime.tv_sec));\n\t\t\tde->read_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_atime.tv_sec));\n\t\t\tde->creation_date = cpu_to_le32(gmt_to_local(i->i_sb, i->i_ctime.tv_sec));\n\t\t\tde->read_only = !(i->i_mode & 0222);\n\t\t\tde->ea_size = cpu_to_le32(/*hpfs_inode->i_ea_size*/0);\n\t\t\tde->file_size = cpu_to_le32(0);\n\t\t\thpfs_mark_4buffers_dirty(&qbh);\n\t\t\thpfs_brelse4(&qbh);\n\t\t} else\n\t\t\thpfs_error(i->i_sb,\n\t\t\t\t\"directory %08lx doesn't have '.' entry\",\n\t\t\t\t(unsigned long)i->i_ino);\n\t}\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "result->i_gid",
            "current_fsgid()"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "result->i_uid",
            "current_fsuid()"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "result"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_mark_4buffers_dirty",
          "args": [
            "&qbh0"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_mark_4buffers_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/buffer.c",
          "lines": "192-204",
          "snippet": "void hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid hpfs_mark_4buffers_dirty(struct quad_buffer_head *qbh)\n{\n\tif (unlikely(qbh->data != qbh->bh[0]->b_data)) {\n\t\tmemcpy(qbh->bh[0]->b_data, qbh->data + 0 * 512, 512);\n\t\tmemcpy(qbh->bh[1]->b_data, qbh->data + 1 * 512, 512);\n\t\tmemcpy(qbh->bh[2]->b_data, qbh->data + 2 * 512, 512);\n\t\tmemcpy(qbh->bh[3]->b_data, qbh->data + 3 * 512, 512);\n\t}\n\tmark_buffer_dirty(qbh->bh[0]);\n\tmark_buffer_dirty(qbh->bh[1]);\n\tmark_buffer_dirty(qbh->bh[2]);\n\tmark_buffer_dirty(qbh->bh[3]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "fno"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "gmt_to_local(dir->i_sb, get_seconds())"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gmt_to_local",
          "args": [
            "dir->i_sb",
            "get_seconds()"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "gmt_to_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "332-336",
          "snippet": "static inline time32_t gmt_to_local(struct super_block *s, time_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t - sys_tz.tz_minuteswest * 60 - hpfs_sb(s)->sb_timeshift;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline time32_t gmt_to_local(struct super_block *s, time_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t - sys_tz.tz_minuteswest * 60 - hpfs_sb(s)->sb_timeshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_add_de",
          "args": [
            "dir->i_sb",
            "dnode",
            "\"\\001\\001\"",
            "2",
            "0"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_de",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "169-196",
          "snippet": "struct hpfs_dirent *hpfs_add_de(struct super_block *s, struct dnode *d,\n\t\t\t\tconst unsigned char *name,\n\t\t\t\tunsigned namelen, secno down_ptr)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tunsigned d_size = de_size(namelen, down_ptr);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tint c = hpfs_compare_names(s, name, namelen, de->name, de->namelen, de->last);\n\t\tif (!c) {\n\t\t\thpfs_error(s, \"name (%c,%d) already exists in dnode %08x\", *name, namelen, le32_to_cpu(d->self));\n\t\t\treturn NULL;\n\t\t}\n\t\tif (c < 0) break;\n\t}\n\tmemmove((char *)de + d_size, de, (char *)de_end - (char *)de);\n\tmemset(de, 0, d_size);\n\tif (down_ptr) {\n\t\t*(__le32 *)((char *)de + d_size - 4) = cpu_to_le32(down_ptr);\n\t\tde->down = 1;\n\t}\n\tde->length = cpu_to_le16(d_size);\n\tde->not_8x3 = hpfs_is_name_long(name, namelen);\n\tde->namelen = namelen;\n\tmemcpy(de->name, name, namelen);\n\tle32_add_cpu(&d->first_free, d_size);\n\treturn de;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct hpfs_dirent *hpfs_add_de(struct super_block *s, struct dnode *d,\n\t\t\t\tconst unsigned char *name,\n\t\t\t\tunsigned namelen, secno down_ptr)\n{\n\tstruct hpfs_dirent *de;\n\tstruct hpfs_dirent *de_end = dnode_end_de(d);\n\tunsigned d_size = de_size(namelen, down_ptr);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tint c = hpfs_compare_names(s, name, namelen, de->name, de->namelen, de->last);\n\t\tif (!c) {\n\t\t\thpfs_error(s, \"name (%c,%d) already exists in dnode %08x\", *name, namelen, le32_to_cpu(d->self));\n\t\t\treturn NULL;\n\t\t}\n\t\tif (c < 0) break;\n\t}\n\tmemmove((char *)de + d_size, de, (char *)de_end - (char *)de);\n\tmemset(de, 0, d_size);\n\tif (down_ptr) {\n\t\t*(__le32 *)((char *)de + d_size - 4) = cpu_to_le32(down_ptr);\n\t\tde->down = 1;\n\t}\n\tde->length = cpu_to_le16(d_size);\n\tde->not_8x3 = hpfs_is_name_long(name, namelen);\n\tde->namelen = namelen;\n\tmemcpy(de->name, name, namelen);\n\tle32_add_cpu(&d->first_free, d_size);\n\treturn de;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "fno"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "-1"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dno"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "0x14"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "dir->i_ino"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fnode->name",
            "name",
            "len > 15 ? 15 : len"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_add_dirent",
          "args": [
            "dir",
            "name",
            "len",
            "&dee"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_add_dirent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/dnode.c",
          "lines": "383-423",
          "snippet": "int hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\ti->i_version++;\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_add_dirent(struct inode *i,\n\t\t    const unsigned char *name, unsigned namelen,\n\t\t    struct hpfs_dirent *new_de)\n{\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\tstruct dnode *d;\n\tstruct hpfs_dirent *de, *de_end;\n\tstruct quad_buffer_head qbh;\n\tdnode_secno dno;\n\tint c;\n\tint c1, c2 = 0;\n\tdno = hpfs_inode->i_dno;\n\tdown:\n\tif (hpfs_sb(i->i_sb)->sb_chk)\n\t\tif (hpfs_stop_cycles(i->i_sb, dno, &c1, &c2, \"hpfs_add_dirent\")) return 1;\n\tif (!(d = hpfs_map_dnode(i->i_sb, dno, &qbh))) return 1;\n\tde_end = dnode_end_de(d);\n\tfor (de = dnode_first_de(d); de < de_end; de = de_next_de(de)) {\n\t\tif (!(c = hpfs_compare_names(i->i_sb, name, namelen, de->name, de->namelen, de->last))) {\n\t\t\thpfs_brelse4(&qbh);\n\t\t\treturn -1;\n\t\t}\t\n\t\tif (c < 0) {\n\t\t\tif (de->down) {\n\t\t\t\tdno = de_down_pointer(de);\n\t\t\t\thpfs_brelse4(&qbh);\n\t\t\t\tgoto down;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\thpfs_brelse4(&qbh);\n\tif (hpfs_check_free_dnodes(i->i_sb, FREE_DNODES_ADD)) {\n\t\tc = 1;\n\t\tgoto ret;\n\t}\t\n\ti->i_version++;\n\tc = hpfs_add_to_dnode(i, dno, name, namelen, new_de, 0);\n\tret:\n\treturn c;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "result",
            "2"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_i",
          "args": [
            "result"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "305-308",
          "snippet": "static inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void hpfs_truncate(struct inode *);",
            "void hpfs_init_inode(struct inode *);",
            "void hpfs_read_inode(struct inode *);",
            "void hpfs_write_inode(struct inode *);",
            "void hpfs_write_inode_nolock(struct inode *);",
            "void hpfs_write_if_changed(struct inode *);",
            "void hpfs_evict_inode(struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nvoid hpfs_truncate(struct inode *);\nvoid hpfs_init_inode(struct inode *);\nvoid hpfs_read_inode(struct inode *);\nvoid hpfs_write_inode(struct inode *);\nvoid hpfs_write_inode_nolock(struct inode *);\nvoid hpfs_write_if_changed(struct inode *);\nvoid hpfs_evict_inode(struct inode *);\n\nstatic inline struct hpfs_inode_info *hpfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct hpfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_to_gmt",
          "args": [
            "dir->i_sb",
            "le32_to_cpu(dee.creation_date)"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "local_to_gmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "326-330",
          "snippet": "static inline time_t local_to_gmt(struct super_block *s, time32_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t + sys_tz.tz_minuteswest * 60 + hpfs_sb(s)->sb_timeshift;\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline time_t local_to_gmt(struct super_block *s, time32_t t)\n{\n\textern struct timezone sys_tz;\n\treturn t + sys_tz.tz_minuteswest * 60 + hpfs_sb(s)->sb_timeshift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dee.creation_date"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_init_inode",
          "args": [
            "result"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/inode.c",
          "lines": "13-41",
          "snippet": "void hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/user_namespace.h>\n#include <linux/slab.h>\n\nvoid hpfs_init_inode(struct inode *i)\n{\n\tstruct super_block *sb = i->i_sb;\n\tstruct hpfs_inode_info *hpfs_inode = hpfs_i(i);\n\n\ti->i_uid = hpfs_sb(sb)->sb_uid;\n\ti->i_gid = hpfs_sb(sb)->sb_gid;\n\ti->i_mode = hpfs_sb(sb)->sb_mode;\n\ti->i_size = -1;\n\ti->i_blocks = -1;\n\t\n\thpfs_inode->i_dno = 0;\n\thpfs_inode->i_n_secs = 0;\n\thpfs_inode->i_file_sec = 0;\n\thpfs_inode->i_disk_sec = 0;\n\thpfs_inode->i_dpos = 0;\n\thpfs_inode->i_dsubdno = 0;\n\thpfs_inode->i_ea_mode = 0;\n\thpfs_inode->i_ea_uid = 0;\n\thpfs_inode->i_ea_gid = 0;\n\thpfs_inode->i_ea_size = 0;\n\n\thpfs_inode->i_rddir_off = NULL;\n\thpfs_inode->i_dirty = 0;\n\n\ti->i_ctime.tv_sec = i->i_ctime.tv_nsec = 0;\n\ti->i_mtime.tv_sec = i->i_mtime.tv_nsec = 0;\n\ti->i_atime.tv_sec = i->i_atime.tv_nsec = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "dir->i_sb"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "drop_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/namei.c",
          "lines": "588-595",
          "snippet": "static int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/quotaops.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/quotaops.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/slab.h>\n#include <linux/bitops.h>\n#include <linux/time.h>\n\nstatic int drop_new_inode(struct inode *inode)\n{\n\tdquot_drop(inode);\n\tmake_bad_inode(inode);\n\tinode->i_flags |= S_NOQUOTA;\n\tiput(inode);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "gmt_to_local(dir->i_sb, get_seconds())"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "fno"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dee",
            "0",
            "sizeof dee"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_dnode",
          "args": [
            "dir->i_sb",
            "fno",
            "&dno",
            "&qbh0"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_dnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "427-451",
          "snippet": "struct dnode *hpfs_alloc_dnode(struct super_block *s, secno near,\n\t\t\t dnode_secno *dno, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *d;\n\tif (hpfs_get_free_dnodes(s) > FREE_DNODES_ADD) {\n\t\tif (!(*dno = alloc_in_dirband(s, near)))\n\t\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0))) return NULL;\n\t} else {\n\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0)))\n\t\t\tif (!(*dno = alloc_in_dirband(s, near))) return NULL;\n\t}\n\tif (!(d = hpfs_get_4sectors(s, *dno, qbh))) {\n\t\thpfs_free_dnode(s, *dno);\n\t\treturn NULL;\n\t}\n\tmemset(d, 0, 2048);\n\td->magic = cpu_to_le32(DNODE_MAGIC);\n\td->first_free = cpu_to_le32(52);\n\td->dirent[0] = 32;\n\td->dirent[2] = 8;\n\td->dirent[30] = 1;\n\td->dirent[31] = 255;\n\td->self = cpu_to_le32(*dno);\n\treturn d;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct dnode *hpfs_alloc_dnode(struct super_block *s, secno near,\n\t\t\t dnode_secno *dno, struct quad_buffer_head *qbh)\n{\n\tstruct dnode *d;\n\tif (hpfs_get_free_dnodes(s) > FREE_DNODES_ADD) {\n\t\tif (!(*dno = alloc_in_dirband(s, near)))\n\t\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0))) return NULL;\n\t} else {\n\t\tif (!(*dno = hpfs_alloc_sector(s, near, 4, 0)))\n\t\t\tif (!(*dno = alloc_in_dirband(s, near))) return NULL;\n\t}\n\tif (!(d = hpfs_get_4sectors(s, *dno, qbh))) {\n\t\thpfs_free_dnode(s, *dno);\n\t\treturn NULL;\n\t}\n\tmemset(d, 0, 2048);\n\td->magic = cpu_to_le32(DNODE_MAGIC);\n\td->first_free = cpu_to_le32(52);\n\td->dirent[0] = 32;\n\td->dirent[2] = 8;\n\td->dirent[30] = 1;\n\td->dirent[31] = 255;\n\td->self = cpu_to_le32(*dno);\n\treturn d;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_alloc_fnode",
          "args": [
            "dir->i_sb",
            "hpfs_i(dir)->i_dno",
            "&fno",
            "&bh"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_alloc_fnode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/alloc.c",
          "lines": "453-468",
          "snippet": "struct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nstruct fnode *hpfs_alloc_fnode(struct super_block *s, secno near, fnode_secno *fno,\n\t\t\t  struct buffer_head **bh)\n{\n\tstruct fnode *f;\n\tif (!(*fno = hpfs_alloc_sector(s, near, 1, FNODE_ALLOC_FWD))) return NULL;\n\tif (!(f = hpfs_get_sector(s, *fno, bh))) {\n\t\thpfs_free_sectors(s, *fno, 1);\n\t\treturn NULL;\n\t}\t\n\tmemset(f, 0, 512);\n\tf->magic = cpu_to_le32(FNODE_MAGIC);\n\tf->ea_offs = cpu_to_le16(0xc4);\n\tf->btree.n_free_nodes = 8;\n\tf->btree.first_free = cpu_to_le16(8);\n\treturn f;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_lock",
          "args": [
            "dir->i_sb"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_lock_assert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/hpfs_fn.h",
          "lines": "359-363",
          "snippet": "static inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}",
          "includes": [
            "#include \"hpfs.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int hpfs_check_free_dnodes(struct super_block *, int);",
            "void hpfs_prefetch_sectors(struct super_block *, unsigned, int);",
            "void hpfs_prefetch_bitmap(struct super_block *, unsigned);",
            "unsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);",
            "int hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);",
            "void hpfs_error(struct super_block *, const char *, ...);",
            "int hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);",
            "unsigned hpfs_get_free_dnodes(struct super_block *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs.h\"\n#include <asm/unaligned.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n\nint hpfs_check_free_dnodes(struct super_block *, int);\nvoid hpfs_prefetch_sectors(struct super_block *, unsigned, int);\nvoid hpfs_prefetch_bitmap(struct super_block *, unsigned);\nunsigned char *hpfs_translate_name(struct super_block *, unsigned char *, unsigned, int, int);\nint hpfs_compare_names(struct super_block *, const unsigned char *, unsigned,\n\t\t       const unsigned char *, unsigned, int);\nvoid hpfs_error(struct super_block *, const char *, ...);\nint hpfs_stop_cycles(struct super_block *, int, int *, int *, char *);\nunsigned hpfs_get_free_dnodes(struct super_block *);\n\nstatic inline void hpfs_lock_assert(struct super_block *s)\n{\n\tstruct hpfs_sb_info *sbi = hpfs_sb(s);\n\tWARN_ON(!mutex_is_locked(&sbi->hpfs_mutex));\n}"
        }
      },
      {
        "call_info": {
          "callee": "hpfs_chk_name",
          "args": [
            "name",
            "&len"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "hpfs_chk_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hpfs/name.c",
          "lines": "41-51",
          "snippet": "int hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"hpfs_fn.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hpfs_fn.h\"\n\nint hpfs_chk_name(const unsigned char *name, unsigned *len)\n{\n\tint i;\n\tif (*len > 254) return -ENAMETOOLONG;\n\thpfs_adjust_length(name, len);\n\tif (!*len) return -EINVAL;\n\tfor (i = 0; i < *len; i++) if (not_allowed_char(name[i])) return -EINVAL;\n\tif (*len == 1) if (name[0] == '.') return -EINVAL;\n\tif (*len == 2) if (name[0] == '.' && name[1] == '.') return -EINVAL;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hpfs_fn.h\"\n#include <linux/sched.h>\n\nconst struct inode_operations hpfs_dir_iops =\n{\n\t.create\t\t= hpfs_create,\n\t.lookup\t\t= hpfs_lookup,\n\t.unlink\t\t= hpfs_unlink,\n\t.symlink\t= hpfs_symlink,\n\t.mkdir\t\t= hpfs_mkdir,\n\t.rmdir\t\t= hpfs_rmdir,\n\t.mknod\t\t= hpfs_mknod,\n\t.rename\t\t= hpfs_rename,\n\t.setattr\t= hpfs_setattr,\n};\n\nstatic int hpfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tunsigned len = dentry->d_name.len;\n\tstruct quad_buffer_head qbh0;\n\tstruct buffer_head *bh;\n\tstruct hpfs_dirent *de;\n\tstruct fnode *fnode;\n\tstruct dnode *dnode;\n\tstruct inode *result;\n\tfnode_secno fno;\n\tdnode_secno dno;\n\tint r;\n\tstruct hpfs_dirent dee;\n\tint err;\n\tif ((err = hpfs_chk_name(name, &len))) return err==-ENOENT ? -EINVAL : err;\n\thpfs_lock(dir->i_sb);\n\terr = -ENOSPC;\n\tfnode = hpfs_alloc_fnode(dir->i_sb, hpfs_i(dir)->i_dno, &fno, &bh);\n\tif (!fnode)\n\t\tgoto bail;\n\tdnode = hpfs_alloc_dnode(dir->i_sb, fno, &dno, &qbh0);\n\tif (!dnode)\n\t\tgoto bail1;\n\tmemset(&dee, 0, sizeof dee);\n\tdee.directory = 1;\n\tif (!(mode & 0222)) dee.read_only = 1;\n\t/*dee.archive = 0;*/\n\tdee.hidden = name[0] == '.';\n\tdee.fnode = cpu_to_le32(fno);\n\tdee.creation_date = dee.write_date = dee.read_date = cpu_to_le32(gmt_to_local(dir->i_sb, get_seconds()));\n\tresult = new_inode(dir->i_sb);\n\tif (!result)\n\t\tgoto bail2;\n\thpfs_init_inode(result);\n\tresult->i_ino = fno;\n\thpfs_i(result)->i_parent_dir = dir->i_ino;\n\thpfs_i(result)->i_dno = dno;\n\tresult->i_ctime.tv_sec = result->i_mtime.tv_sec = result->i_atime.tv_sec = local_to_gmt(dir->i_sb, le32_to_cpu(dee.creation_date));\n\tresult->i_ctime.tv_nsec = 0; \n\tresult->i_mtime.tv_nsec = 0; \n\tresult->i_atime.tv_nsec = 0; \n\thpfs_i(result)->i_ea_size = 0;\n\tresult->i_mode |= S_IFDIR;\n\tresult->i_op = &hpfs_dir_iops;\n\tresult->i_fop = &hpfs_dir_ops;\n\tresult->i_blocks = 4;\n\tresult->i_size = 2048;\n\tset_nlink(result, 2);\n\tif (dee.read_only)\n\t\tresult->i_mode &= ~0222;\n\n\tr = hpfs_add_dirent(dir, name, len, &dee);\n\tif (r == 1)\n\t\tgoto bail3;\n\tif (r == -1) {\n\t\terr = -EEXIST;\n\t\tgoto bail3;\n\t}\n\tfnode->len = len;\n\tmemcpy(fnode->name, name, len > 15 ? 15 : len);\n\tfnode->up = cpu_to_le32(dir->i_ino);\n\tfnode->flags |= FNODE_dir;\n\tfnode->btree.n_free_nodes = 7;\n\tfnode->btree.n_used_nodes = 1;\n\tfnode->btree.first_free = cpu_to_le16(0x14);\n\tfnode->u.external[0].disk_secno = cpu_to_le32(dno);\n\tfnode->u.external[0].file_secno = cpu_to_le32(-1);\n\tdnode->root_dnode = 1;\n\tdnode->up = cpu_to_le32(fno);\n\tde = hpfs_add_de(dir->i_sb, dnode, \"\\001\\001\", 2, 0);\n\tde->creation_date = de->write_date = de->read_date = cpu_to_le32(gmt_to_local(dir->i_sb, get_seconds()));\n\tif (!(mode & 0222)) de->read_only = 1;\n\tde->first = de->directory = 1;\n\t/*de->hidden = de->system = 0;*/\n\tde->fnode = cpu_to_le32(fno);\n\tmark_buffer_dirty(bh);\n\tbrelse(bh);\n\thpfs_mark_4buffers_dirty(&qbh0);\n\thpfs_brelse4(&qbh0);\n\tinc_nlink(dir);\n\tinsert_inode_hash(result);\n\n\tif (!uid_eq(result->i_uid, current_fsuid()) ||\n\t    !gid_eq(result->i_gid, current_fsgid()) ||\n\t    result->i_mode != (mode | S_IFDIR)) {\n\t\tresult->i_uid = current_fsuid();\n\t\tresult->i_gid = current_fsgid();\n\t\tresult->i_mode = mode | S_IFDIR;\n\t\thpfs_write_inode_nolock(result);\n\t}\n\td_instantiate(dentry, result);\n\thpfs_unlock(dir->i_sb);\n\treturn 0;\nbail3:\n\tiput(result);\nbail2:\n\thpfs_brelse4(&qbh0);\n\thpfs_free_dnode(dir->i_sb, dno);\nbail1:\n\tbrelse(bh);\n\thpfs_free_sectors(dir->i_sb, fno, 1);\nbail:\n\thpfs_unlock(dir->i_sb);\n\treturn err;\n}"
  }
]