[
  {
    "function_name": "btrfs_previous_extent_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "5873-5908",
    "snippet": "int btrfs_previous_extent_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t\t    found_key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < BTRFS_EXTENT_ITEM_KEY)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 5897
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 5891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_prev_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 5884
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_prev_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5049-5089",
          "snippet": "int btrfs_prev_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key found_key;\n\tint ret;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, 0);\n\n\tif (key.offset > 0) {\n\t\tkey.offset--;\n\t} else if (key.type > 0) {\n\t\tkey.type--;\n\t\tkey.offset = (u64)-1;\n\t} else if (key.objectid > 0) {\n\t\tkey.objectid--;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\treturn 1;\n\t}\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tbtrfs_item_key(path->nodes[0], &found_key, 0);\n\tret = comp_keys(&found_key, &key);\n\t/*\n\t * We might have had an item with the previous key in the tree right\n\t * before we released our path. And after we released our path, that\n\t * item might have been pushed to the first slot (0) of the leaf we\n\t * were holding due to a tree balance. Alternatively, an item with the\n\t * previous key can exist as the only element of a leaf (big fat item).\n\t * Therefore account for these 2 cases, so that our callers (like\n\t * btrfs_previous_item) don't miss an existing item with a key matching\n\t * the previous key we computed above.\n\t */\n\tif (ret <= 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_prev_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key found_key;\n\tint ret;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, 0);\n\n\tif (key.offset > 0) {\n\t\tkey.offset--;\n\t} else if (key.type > 0) {\n\t\tkey.type--;\n\t\tkey.offset = (u64)-1;\n\t} else if (key.objectid > 0) {\n\t\tkey.objectid--;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\treturn 1;\n\t}\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tbtrfs_item_key(path->nodes[0], &found_key, 0);\n\tret = comp_keys(&found_key, &key);\n\t/*\n\t * We might have had an item with the previous key in the tree right\n\t * before we released our path. And after we released our path, that\n\t * item might have been pushed to the first slot (0) of the leaf we\n\t * were holding due to a tree balance. Alternatively, an item with the\n\t * previous key can exist as the only element of a leaf (big fat item).\n\t * Therefore account for these 2 cases, so that our callers (like\n\t * btrfs_previous_item) don't miss an existing item with a key matching\n\t * the previous key we computed above.\n\t */\n\tif (ret <= 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "path"
          ],
          "line": 5883
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_extent_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t\t    found_key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < BTRFS_EXTENT_ITEM_KEY)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_previous_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "5830-5865",
    "snippet": "int btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "path->slots[0]"
          ],
          "line": 5855
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 5849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_prev_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 5842
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_prev_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5049-5089",
          "snippet": "int btrfs_prev_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key found_key;\n\tint ret;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, 0);\n\n\tif (key.offset > 0) {\n\t\tkey.offset--;\n\t} else if (key.type > 0) {\n\t\tkey.type--;\n\t\tkey.offset = (u64)-1;\n\t} else if (key.objectid > 0) {\n\t\tkey.objectid--;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\treturn 1;\n\t}\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tbtrfs_item_key(path->nodes[0], &found_key, 0);\n\tret = comp_keys(&found_key, &key);\n\t/*\n\t * We might have had an item with the previous key in the tree right\n\t * before we released our path. And after we released our path, that\n\t * item might have been pushed to the first slot (0) of the leaf we\n\t * were holding due to a tree balance. Alternatively, an item with the\n\t * previous key can exist as the only element of a leaf (big fat item).\n\t * Therefore account for these 2 cases, so that our callers (like\n\t * btrfs_previous_item) don't miss an existing item with a key matching\n\t * the previous key we computed above.\n\t */\n\tif (ret <= 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_prev_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key found_key;\n\tint ret;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, 0);\n\n\tif (key.offset > 0) {\n\t\tkey.offset--;\n\t} else if (key.type > 0) {\n\t\tkey.type--;\n\t\tkey.offset = (u64)-1;\n\t} else if (key.objectid > 0) {\n\t\tkey.objectid--;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\treturn 1;\n\t}\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tbtrfs_item_key(path->nodes[0], &found_key, 0);\n\tret = comp_keys(&found_key, &key);\n\t/*\n\t * We might have had an item with the previous key in the tree right\n\t * before we released our path. And after we released our path, that\n\t * item might have been pushed to the first slot (0) of the leaf we\n\t * were holding due to a tree balance. Alternatively, an item with the\n\t * previous key can exist as the only element of a leaf (big fat item).\n\t * Therefore account for these 2 cases, so that our callers (like\n\t * btrfs_previous_item) don't miss an existing item with a key matching\n\t * the previous key we computed above.\n\t */\n\tif (ret <= 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "path"
          ],
          "line": 5841
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid,\n\t\t\tint type)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == type)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < type)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_next_old_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "5651-5822",
    "snippet": "int btrfs_next_old_leaf(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tu64 time_seq)\n{\n\tint slot;\n\tint level;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *next;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint ret;\n\tint old_spinning = path->leave_spinning;\n\tint next_rw_lock = 0;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tif (nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, nritems - 1);\nagain:\n\tlevel = 1;\n\tnext = NULL;\n\tnext_rw_lock = 0;\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->leave_spinning = 1;\n\n\tif (time_seq)\n\t\tret = btrfs_search_old_slot(root, &key, path, time_seq);\n\telse\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tpath->keep_locks = 0;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t/*\n\t * by releasing the path above we dropped all our locks.  A balance\n\t * could have added more items next to the key that used to be\n\t * at the very end of the block.  So, check again here and\n\t * advance the path if there are now more items available.\n\t */\n\tif (nritems > 0 && path->slots[0] < nritems - 1) {\n\t\tif (ret == 0)\n\t\t\tpath->slots[0]++;\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\t/*\n\t * So the above check misses one case:\n\t * - after releasing the path above, someone has removed the item that\n\t *   used to be at the very end of the block, and balance between leafs\n\t *   gets another one with bigger key.offset to replace it.\n\t *\n\t * This one should be returned as well, or we can get leaf corruption\n\t * later(esp. in __btrfs_drop_extents()).\n\t *\n\t * And a bit more explanation about this check,\n\t * with ret > 0, the key isn't found, the path points to the slot\n\t * where it should be inserted, so the path->slots[0] item must be the\n\t * bigger one.\n\t */\n\tif (nritems > 0 && ret > 0 && path->slots[0] == nritems - 1) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level]) {\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tlevel++;\n\t\t\tif (level == BTRFS_MAX_LEVEL) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (next) {\n\t\t\tbtrfs_tree_unlock_rw(next, next_rw_lock);\n\t\t\tfree_extent_buffer(next);\n\t\t}\n\n\t\tnext = c;\n\t\tnext_rw_lock = path->locks[level];\n\t\tret = read_block_for_search(NULL, root, path, &next, level,\n\t\t\t\t\t    slot, &key, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret && time_seq) {\n\t\t\t\t/*\n\t\t\t\t * If we don't get the lock, we may be racing\n\t\t\t\t * with push_leaf_left, holding that lock while\n\t\t\t\t * itself waiting for the leaf we've currently\n\t\t\t\t * locked. To solve this situation, we give up\n\t\t\t\t * on our lock and cycle.\n\t\t\t\t */\n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (!ret) {\n\t\t\t\tbtrfs_set_path_blocking(path);\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t\tbtrfs_clear_path_blocking(path, next,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tnext_rw_lock = BTRFS_READ_LOCK;\n\t\t}\n\t\tbreak;\n\t}\n\tpath->slots[level] = slot;\n\twhile (1) {\n\t\tlevel--;\n\t\tc = path->nodes[level];\n\t\tif (path->locks[level])\n\t\t\tbtrfs_tree_unlock_rw(c, path->locks[level]);\n\n\t\tfree_extent_buffer(c);\n\t\tpath->nodes[level] = next;\n\t\tpath->slots[level] = 0;\n\t\tif (!path->skip_locking)\n\t\t\tpath->locks[level] = next_rw_lock;\n\t\tif (!level)\n\t\t\tbreak;\n\n\t\tret = read_block_for_search(NULL, root, path, &next, level,\n\t\t\t\t\t    0, &key, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret) {\n\t\t\t\tbtrfs_set_path_blocking(path);\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t\tbtrfs_clear_path_blocking(path, next,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tnext_rw_lock = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\tret = 0;\ndone:\n\tunlock_up(path, 0, 1, 0, NULL);\n\tpath->leave_spinning = old_spinning;\n\tif (!old_spinning)\n\t\tbtrfs_set_path_blocking(path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "path"
          ],
          "line": 5819
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_up",
          "args": [
            "path",
            "0",
            "1",
            "0",
            "NULL"
          ],
          "line": 5816
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2361-2402",
          "snippet": "static noinline void unlock_up(struct btrfs_path *path, int level,\n\t\t\t       int lowest_unlock, int min_write_lock_level,\n\t\t\t       int *write_lock_level)\n{\n\tint i;\n\tint skip_level = level;\n\tint no_skips = 0;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tif (!path->locks[i])\n\t\t\tbreak;\n\t\tif (!no_skips && path->slots[i] == 0) {\n\t\t\tskip_level = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!no_skips && path->keep_locks) {\n\t\t\tu32 nritems;\n\t\t\tt = path->nodes[i];\n\t\t\tnritems = btrfs_header_nritems(t);\n\t\t\tif (nritems < 1 || path->slots[i] >= nritems - 1) {\n\t\t\t\tskip_level = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (skip_level < i && i >= lowest_unlock)\n\t\t\tno_skips = 1;\n\n\t\tt = path->nodes[i];\n\t\tif (i >= lowest_unlock && i > skip_level && path->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(t, path->locks[i]);\n\t\t\tpath->locks[i] = 0;\n\t\t\tif (write_lock_level &&\n\t\t\t    i > min_write_lock_level &&\n\t\t\t    i <= *write_lock_level) {\n\t\t\t\t*write_lock_level = i - 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline void unlock_up(struct btrfs_path *path, int level,\n\t\t\t       int lowest_unlock, int min_write_lock_level,\n\t\t\t       int *write_lock_level)\n{\n\tint i;\n\tint skip_level = level;\n\tint no_skips = 0;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tif (!path->locks[i])\n\t\t\tbreak;\n\t\tif (!no_skips && path->slots[i] == 0) {\n\t\t\tskip_level = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!no_skips && path->keep_locks) {\n\t\t\tu32 nritems;\n\t\t\tt = path->nodes[i];\n\t\t\tnritems = btrfs_header_nritems(t);\n\t\t\tif (nritems < 1 || path->slots[i] >= nritems - 1) {\n\t\t\t\tskip_level = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (skip_level < i && i >= lowest_unlock)\n\t\t\tno_skips = 1;\n\n\t\tt = path->nodes[i];\n\t\tif (i >= lowest_unlock && i > skip_level && path->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(t, path->locks[i]);\n\t\t\tpath->locks[i] = 0;\n\t\t\tif (write_lock_level &&\n\t\t\t    i > min_write_lock_level &&\n\t\t\t    i <= *write_lock_level) {\n\t\t\t\t*write_lock_level = i - 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clear_path_blocking",
          "args": [
            "path",
            "next",
            "BTRFS_READ_LOCK"
          ],
          "line": 5808
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "78-104",
          "snippet": "noinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_lock",
          "args": [
            "next"
          ],
          "line": 5807
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_lock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "135-148",
          "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_try_tree_read_lock",
          "args": [
            "next"
          ],
          "line": 5804
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_try_tree_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "154-169",
          "snippet": "int btrfs_try_tree_read_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tif (!read_trylock(&eb->lock))\n\t\treturn 0;\n\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_try_tree_read_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tif (!read_trylock(&eb->lock))\n\t\treturn 0;\n\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 5799
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_block_for_search",
          "args": [
            "NULL",
            "root",
            "path",
            "&next",
            "level",
            "0",
            "&key",
            "0"
          ],
          "line": 5793
        },
        "resolved": true,
        "details": {
          "function_name": "read_block_for_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2438-2510",
          "snippet": "static int\nread_block_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer **eb_ret, int level, int slot,\n\t\t       struct btrfs_key *key, u64 time_seq)\n{\n\tu64 blocknr;\n\tu64 gen;\n\tstruct extent_buffer *b = *eb_ret;\n\tstruct extent_buffer *tmp;\n\tint ret;\n\n\tblocknr = btrfs_node_blockptr(b, slot);\n\tgen = btrfs_node_ptr_generation(b, slot);\n\n\ttmp = btrfs_find_tree_block(root, blocknr);\n\tif (tmp) {\n\t\t/* first we do an atomic uptodate check */\n\t\tif (btrfs_buffer_uptodate(tmp, gen, 1) > 0) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* the pages were up to date, but we failed\n\t\t * the generation number check.  Do a full\n\t\t * read for the generation number that is correct.\n\t\t * We must do this without dropping locks so\n\t\t * we can trust our generation number\n\t\t */\n\t\tbtrfs_set_path_blocking(p);\n\n\t\t/* now we're allowed to do a blocking uptodate check */\n\t\tret = btrfs_read_buffer(tmp, gen);\n\t\tif (!ret) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(tmp);\n\t\tbtrfs_release_path(p);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * reduce lock contention at high levels\n\t * of the btree by dropping locks before\n\t * we read.  Don't release the lock on the current\n\t * level because we need to walk this node to figure\n\t * out which blocks to read.\n\t */\n\tbtrfs_unlock_up_safe(p, level + 1);\n\tbtrfs_set_path_blocking(p);\n\n\tfree_extent_buffer(tmp);\n\tif (p->reada)\n\t\treada_for_search(root, p, level, slot, key->objectid);\n\n\tbtrfs_release_path(p);\n\n\tret = -EAGAIN;\n\ttmp = read_tree_block(root, blocknr, 0);\n\tif (tmp) {\n\t\t/*\n\t\t * If the read above didn't mark this buffer up to date,\n\t\t * it will never end up being up to date.  Set ret to EIO now\n\t\t * and give up so that our caller doesn't loop forever\n\t\t * on our EAGAINs.\n\t\t */\n\t\tif (!btrfs_buffer_uptodate(tmp, 0, 0))\n\t\t\tret = -EIO;\n\t\tfree_extent_buffer(tmp);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int\nread_block_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer **eb_ret, int level, int slot,\n\t\t       struct btrfs_key *key, u64 time_seq)\n{\n\tu64 blocknr;\n\tu64 gen;\n\tstruct extent_buffer *b = *eb_ret;\n\tstruct extent_buffer *tmp;\n\tint ret;\n\n\tblocknr = btrfs_node_blockptr(b, slot);\n\tgen = btrfs_node_ptr_generation(b, slot);\n\n\ttmp = btrfs_find_tree_block(root, blocknr);\n\tif (tmp) {\n\t\t/* first we do an atomic uptodate check */\n\t\tif (btrfs_buffer_uptodate(tmp, gen, 1) > 0) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* the pages were up to date, but we failed\n\t\t * the generation number check.  Do a full\n\t\t * read for the generation number that is correct.\n\t\t * We must do this without dropping locks so\n\t\t * we can trust our generation number\n\t\t */\n\t\tbtrfs_set_path_blocking(p);\n\n\t\t/* now we're allowed to do a blocking uptodate check */\n\t\tret = btrfs_read_buffer(tmp, gen);\n\t\tif (!ret) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(tmp);\n\t\tbtrfs_release_path(p);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * reduce lock contention at high levels\n\t * of the btree by dropping locks before\n\t * we read.  Don't release the lock on the current\n\t * level because we need to walk this node to figure\n\t * out which blocks to read.\n\t */\n\tbtrfs_unlock_up_safe(p, level + 1);\n\tbtrfs_set_path_blocking(p);\n\n\tfree_extent_buffer(tmp);\n\tif (p->reada)\n\t\treada_for_search(root, p, level, slot, key->objectid);\n\n\tbtrfs_release_path(p);\n\n\tret = -EAGAIN;\n\ttmp = read_tree_block(root, blocknr, 0);\n\tif (tmp) {\n\t\t/*\n\t\t * If the read above didn't mark this buffer up to date,\n\t\t * it will never end up being up to date.  Set ret to EIO now\n\t\t * and give up so that our caller doesn't loop forever\n\t\t * on our EAGAINs.\n\t\t */\n\t\tif (!btrfs_buffer_uptodate(tmp, 0, 0))\n\t\t\tret = -EIO;\n\t\tfree_extent_buffer(tmp);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "c"
          ],
          "line": 5785
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock_rw",
          "args": [
            "c",
            "path->locks[level]"
          ],
          "line": 5783
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "41-51",
          "snippet": "static inline void btrfs_tree_unlock_rw(struct extent_buffer *eb, int rw)\n{\n\tif (rw == BTRFS_WRITE_LOCK || rw == BTRFS_WRITE_LOCK_BLOCKING)\n\t\tbtrfs_tree_unlock(eb);\n\telse if (rw == BTRFS_READ_LOCK_BLOCKING)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\telse if (rw == BTRFS_READ_LOCK)\n\t\tbtrfs_tree_read_unlock(eb);\n\telse\n\t\tBUG();\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_READ_LOCK_BLOCKING 4",
            "#define BTRFS_WRITE_LOCK_BLOCKING 3",
            "#define BTRFS_READ_LOCK 2",
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_READ_LOCK_BLOCKING 4\n#define BTRFS_WRITE_LOCK_BLOCKING 3\n#define BTRFS_READ_LOCK 2\n#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_tree_unlock_rw(struct extent_buffer *eb, int rw)\n{\n\tif (rw == BTRFS_WRITE_LOCK || rw == BTRFS_WRITE_LOCK_BLOCKING)\n\t\tbtrfs_tree_unlock(eb);\n\telse if (rw == BTRFS_READ_LOCK_BLOCKING)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\telse if (rw == BTRFS_READ_LOCK)\n\t\tbtrfs_tree_read_unlock(eb);\n\telse\n\t\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 5765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "c"
          ],
          "line": 5727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 5687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 5681
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_old_slot",
          "args": [
            "root",
            "&key",
            "path",
            "time_seq"
          ],
          "line": 5679
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_old_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2945-3043",
          "snippet": "int btrfs_search_old_slot(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct btrfs_path *p, u64 time_seq)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tu8 lowest_level = 0;\n\tint prev_cmp = -1;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(p->nodes[0] != NULL);\n\n\tif (p->search_commit_root) {\n\t\tBUG_ON(time_seq);\n\t\treturn btrfs_search_slot(NULL, root, key, p, 0, 0);\n\t}\n\nagain:\n\tb = get_old_root(root, time_seq);\n\tlevel = btrfs_header_level(b);\n\tp->locks[level] = BTRFS_READ_LOCK;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t */\n\t\tbtrfs_unlock_up_safe(p, level + 1);\n\n\t\t/*\n\t\t * Since we can unwind eb's we want to do a real search every\n\t\t * time.\n\t\t */\n\t\tprev_cmp = -1;\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(NULL, root, p, &b, level,\n\t\t\t\t\t\t    slot, key, time_seq);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\tif (!err) {\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tb = tree_mod_log_rewind(root->fs_info, p, b, time_seq);\n\t\t\tif (!b) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\tp->nodes[level] = b;\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0)\n\t\tbtrfs_release_path(p);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nint btrfs_search_old_slot(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct btrfs_path *p, u64 time_seq)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tu8 lowest_level = 0;\n\tint prev_cmp = -1;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(p->nodes[0] != NULL);\n\n\tif (p->search_commit_root) {\n\t\tBUG_ON(time_seq);\n\t\treturn btrfs_search_slot(NULL, root, key, p, 0, 0);\n\t}\n\nagain:\n\tb = get_old_root(root, time_seq);\n\tlevel = btrfs_header_level(b);\n\tp->locks[level] = BTRFS_READ_LOCK;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t */\n\t\tbtrfs_unlock_up_safe(p, level + 1);\n\n\t\t/*\n\t\t * Since we can unwind eb's we want to do a real search every\n\t\t * time.\n\t\t */\n\t\tprev_cmp = -1;\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(NULL, root, p, &b, level,\n\t\t\t\t\t\t    slot, key, time_seq);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\tif (!err) {\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tb = tree_mod_log_rewind(root->fs_info, p, b, time_seq);\n\t\t\tif (!b) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\tp->nodes[level] = b;\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0)\n\t\tbtrfs_release_path(p);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "&key",
            "nritems - 1"
          ],
          "line": 5668
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 5664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_next_old_leaf(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tu64 time_seq)\n{\n\tint slot;\n\tint level;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *next;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint ret;\n\tint old_spinning = path->leave_spinning;\n\tint next_rw_lock = 0;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tif (nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, nritems - 1);\nagain:\n\tlevel = 1;\n\tnext = NULL;\n\tnext_rw_lock = 0;\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->leave_spinning = 1;\n\n\tif (time_seq)\n\t\tret = btrfs_search_old_slot(root, &key, path, time_seq);\n\telse\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tpath->keep_locks = 0;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t/*\n\t * by releasing the path above we dropped all our locks.  A balance\n\t * could have added more items next to the key that used to be\n\t * at the very end of the block.  So, check again here and\n\t * advance the path if there are now more items available.\n\t */\n\tif (nritems > 0 && path->slots[0] < nritems - 1) {\n\t\tif (ret == 0)\n\t\t\tpath->slots[0]++;\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\t/*\n\t * So the above check misses one case:\n\t * - after releasing the path above, someone has removed the item that\n\t *   used to be at the very end of the block, and balance between leafs\n\t *   gets another one with bigger key.offset to replace it.\n\t *\n\t * This one should be returned as well, or we can get leaf corruption\n\t * later(esp. in __btrfs_drop_extents()).\n\t *\n\t * And a bit more explanation about this check,\n\t * with ret > 0, the key isn't found, the path points to the slot\n\t * where it should be inserted, so the path->slots[0] item must be the\n\t * bigger one.\n\t */\n\tif (nritems > 0 && ret > 0 && path->slots[0] == nritems - 1) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level]) {\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tlevel++;\n\t\t\tif (level == BTRFS_MAX_LEVEL) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (next) {\n\t\t\tbtrfs_tree_unlock_rw(next, next_rw_lock);\n\t\t\tfree_extent_buffer(next);\n\t\t}\n\n\t\tnext = c;\n\t\tnext_rw_lock = path->locks[level];\n\t\tret = read_block_for_search(NULL, root, path, &next, level,\n\t\t\t\t\t    slot, &key, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret && time_seq) {\n\t\t\t\t/*\n\t\t\t\t * If we don't get the lock, we may be racing\n\t\t\t\t * with push_leaf_left, holding that lock while\n\t\t\t\t * itself waiting for the leaf we've currently\n\t\t\t\t * locked. To solve this situation, we give up\n\t\t\t\t * on our lock and cycle.\n\t\t\t\t */\n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (!ret) {\n\t\t\t\tbtrfs_set_path_blocking(path);\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t\tbtrfs_clear_path_blocking(path, next,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tnext_rw_lock = BTRFS_READ_LOCK;\n\t\t}\n\t\tbreak;\n\t}\n\tpath->slots[level] = slot;\n\twhile (1) {\n\t\tlevel--;\n\t\tc = path->nodes[level];\n\t\tif (path->locks[level])\n\t\t\tbtrfs_tree_unlock_rw(c, path->locks[level]);\n\n\t\tfree_extent_buffer(c);\n\t\tpath->nodes[level] = next;\n\t\tpath->slots[level] = 0;\n\t\tif (!path->skip_locking)\n\t\t\tpath->locks[level] = next_rw_lock;\n\t\tif (!level)\n\t\t\tbreak;\n\n\t\tret = read_block_for_search(NULL, root, path, &next, level,\n\t\t\t\t\t    0, &key, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret) {\n\t\t\t\tbtrfs_set_path_blocking(path);\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t\tbtrfs_clear_path_blocking(path, next,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tnext_rw_lock = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\tret = 0;\ndone:\n\tunlock_up(path, 0, 1, 0, NULL);\n\tpath->leave_spinning = old_spinning;\n\tif (!old_spinning)\n\t\tbtrfs_set_path_blocking(path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_next_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "5646-5649",
    "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_next_old_leaf",
          "args": [
            "root",
            "path",
            "0"
          ],
          "line": 5648
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_old_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5651-5822",
          "snippet": "int btrfs_next_old_leaf(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tu64 time_seq)\n{\n\tint slot;\n\tint level;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *next;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint ret;\n\tint old_spinning = path->leave_spinning;\n\tint next_rw_lock = 0;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tif (nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, nritems - 1);\nagain:\n\tlevel = 1;\n\tnext = NULL;\n\tnext_rw_lock = 0;\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->leave_spinning = 1;\n\n\tif (time_seq)\n\t\tret = btrfs_search_old_slot(root, &key, path, time_seq);\n\telse\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tpath->keep_locks = 0;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t/*\n\t * by releasing the path above we dropped all our locks.  A balance\n\t * could have added more items next to the key that used to be\n\t * at the very end of the block.  So, check again here and\n\t * advance the path if there are now more items available.\n\t */\n\tif (nritems > 0 && path->slots[0] < nritems - 1) {\n\t\tif (ret == 0)\n\t\t\tpath->slots[0]++;\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\t/*\n\t * So the above check misses one case:\n\t * - after releasing the path above, someone has removed the item that\n\t *   used to be at the very end of the block, and balance between leafs\n\t *   gets another one with bigger key.offset to replace it.\n\t *\n\t * This one should be returned as well, or we can get leaf corruption\n\t * later(esp. in __btrfs_drop_extents()).\n\t *\n\t * And a bit more explanation about this check,\n\t * with ret > 0, the key isn't found, the path points to the slot\n\t * where it should be inserted, so the path->slots[0] item must be the\n\t * bigger one.\n\t */\n\tif (nritems > 0 && ret > 0 && path->slots[0] == nritems - 1) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level]) {\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tlevel++;\n\t\t\tif (level == BTRFS_MAX_LEVEL) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (next) {\n\t\t\tbtrfs_tree_unlock_rw(next, next_rw_lock);\n\t\t\tfree_extent_buffer(next);\n\t\t}\n\n\t\tnext = c;\n\t\tnext_rw_lock = path->locks[level];\n\t\tret = read_block_for_search(NULL, root, path, &next, level,\n\t\t\t\t\t    slot, &key, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret && time_seq) {\n\t\t\t\t/*\n\t\t\t\t * If we don't get the lock, we may be racing\n\t\t\t\t * with push_leaf_left, holding that lock while\n\t\t\t\t * itself waiting for the leaf we've currently\n\t\t\t\t * locked. To solve this situation, we give up\n\t\t\t\t * on our lock and cycle.\n\t\t\t\t */\n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (!ret) {\n\t\t\t\tbtrfs_set_path_blocking(path);\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t\tbtrfs_clear_path_blocking(path, next,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tnext_rw_lock = BTRFS_READ_LOCK;\n\t\t}\n\t\tbreak;\n\t}\n\tpath->slots[level] = slot;\n\twhile (1) {\n\t\tlevel--;\n\t\tc = path->nodes[level];\n\t\tif (path->locks[level])\n\t\t\tbtrfs_tree_unlock_rw(c, path->locks[level]);\n\n\t\tfree_extent_buffer(c);\n\t\tpath->nodes[level] = next;\n\t\tpath->slots[level] = 0;\n\t\tif (!path->skip_locking)\n\t\t\tpath->locks[level] = next_rw_lock;\n\t\tif (!level)\n\t\t\tbreak;\n\n\t\tret = read_block_for_search(NULL, root, path, &next, level,\n\t\t\t\t\t    0, &key, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret) {\n\t\t\t\tbtrfs_set_path_blocking(path);\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t\tbtrfs_clear_path_blocking(path, next,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tnext_rw_lock = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\tret = 0;\ndone:\n\tunlock_up(path, 0, 1, 0, NULL);\n\tpath->leave_spinning = old_spinning;\n\tif (!old_spinning)\n\t\tbtrfs_set_path_blocking(path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_next_old_leaf(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tu64 time_seq)\n{\n\tint slot;\n\tint level;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *next;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint ret;\n\tint old_spinning = path->leave_spinning;\n\tint next_rw_lock = 0;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tif (nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, nritems - 1);\nagain:\n\tlevel = 1;\n\tnext = NULL;\n\tnext_rw_lock = 0;\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->leave_spinning = 1;\n\n\tif (time_seq)\n\t\tret = btrfs_search_old_slot(root, &key, path, time_seq);\n\telse\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tpath->keep_locks = 0;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t/*\n\t * by releasing the path above we dropped all our locks.  A balance\n\t * could have added more items next to the key that used to be\n\t * at the very end of the block.  So, check again here and\n\t * advance the path if there are now more items available.\n\t */\n\tif (nritems > 0 && path->slots[0] < nritems - 1) {\n\t\tif (ret == 0)\n\t\t\tpath->slots[0]++;\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\t/*\n\t * So the above check misses one case:\n\t * - after releasing the path above, someone has removed the item that\n\t *   used to be at the very end of the block, and balance between leafs\n\t *   gets another one with bigger key.offset to replace it.\n\t *\n\t * This one should be returned as well, or we can get leaf corruption\n\t * later(esp. in __btrfs_drop_extents()).\n\t *\n\t * And a bit more explanation about this check,\n\t * with ret > 0, the key isn't found, the path points to the slot\n\t * where it should be inserted, so the path->slots[0] item must be the\n\t * bigger one.\n\t */\n\tif (nritems > 0 && ret > 0 && path->slots[0] == nritems - 1) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level]) {\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tlevel++;\n\t\t\tif (level == BTRFS_MAX_LEVEL) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (next) {\n\t\t\tbtrfs_tree_unlock_rw(next, next_rw_lock);\n\t\t\tfree_extent_buffer(next);\n\t\t}\n\n\t\tnext = c;\n\t\tnext_rw_lock = path->locks[level];\n\t\tret = read_block_for_search(NULL, root, path, &next, level,\n\t\t\t\t\t    slot, &key, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret && time_seq) {\n\t\t\t\t/*\n\t\t\t\t * If we don't get the lock, we may be racing\n\t\t\t\t * with push_leaf_left, holding that lock while\n\t\t\t\t * itself waiting for the leaf we've currently\n\t\t\t\t * locked. To solve this situation, we give up\n\t\t\t\t * on our lock and cycle.\n\t\t\t\t */\n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (!ret) {\n\t\t\t\tbtrfs_set_path_blocking(path);\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t\tbtrfs_clear_path_blocking(path, next,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tnext_rw_lock = BTRFS_READ_LOCK;\n\t\t}\n\t\tbreak;\n\t}\n\tpath->slots[level] = slot;\n\twhile (1) {\n\t\tlevel--;\n\t\tc = path->nodes[level];\n\t\tif (path->locks[level])\n\t\t\tbtrfs_tree_unlock_rw(c, path->locks[level]);\n\n\t\tfree_extent_buffer(c);\n\t\tpath->nodes[level] = next;\n\t\tpath->slots[level] = 0;\n\t\tif (!path->skip_locking)\n\t\t\tpath->locks[level] = next_rw_lock;\n\t\tif (!level)\n\t\t\tbreak;\n\n\t\tret = read_block_for_search(NULL, root, path, &next, level,\n\t\t\t\t\t    0, &key, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret) {\n\t\t\t\tbtrfs_set_path_blocking(path);\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t\tbtrfs_clear_path_blocking(path, next,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tnext_rw_lock = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\tret = 0;\ndone:\n\tunlock_up(path, 0, 1, 0, NULL);\n\tpath->leave_spinning = old_spinning;\n\tif (!old_spinning)\n\t\tbtrfs_set_path_blocking(path);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
  },
  {
    "function_name": "btrfs_find_next_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "5576-5639",
    "snippet": "int btrfs_find_next_key(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key, int level, u64 min_trans)\n{\n\tint slot;\n\tstruct extent_buffer *c;\n\n\tWARN_ON(!path->keep_locks);\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\treturn 1;\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\nnext:\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tint ret;\n\t\t\tint orig_lowest;\n\t\t\tstruct btrfs_key cur_key;\n\t\t\tif (level + 1 >= BTRFS_MAX_LEVEL ||\n\t\t\t    !path->nodes[level + 1])\n\t\t\t\treturn 1;\n\n\t\t\tif (path->locks[level + 1]) {\n\t\t\t\tlevel++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslot = btrfs_header_nritems(c) - 1;\n\t\t\tif (level == 0)\n\t\t\t\tbtrfs_item_key_to_cpu(c, &cur_key, slot);\n\t\t\telse\n\t\t\t\tbtrfs_node_key_to_cpu(c, &cur_key, slot);\n\n\t\t\torig_lowest = path->lowest_level;\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->lowest_level = level;\n\t\t\tret = btrfs_search_slot(NULL, root, &cur_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tpath->lowest_level = orig_lowest;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tc = path->nodes[level];\n\t\t\tslot = path->slots[level];\n\t\t\tif (ret == 0)\n\t\t\t\tslot++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (level == 0)\n\t\t\tbtrfs_item_key_to_cpu(c, key, slot);\n\t\telse {\n\t\t\tu64 gen = btrfs_node_ptr_generation(c, slot);\n\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbtrfs_node_key_to_cpu(c, key, slot);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_node_key_to_cpu",
          "args": [
            "c",
            "key",
            "slot"
          ],
          "line": 5634
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "c",
            "slot"
          ],
          "line": 5628
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "c",
            "key",
            "slot"
          ],
          "line": 5626
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&cur_key",
            "path",
            "0",
            "0"
          ],
          "line": 5612
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 5610
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "c"
          ],
          "line": 5603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "c"
          ],
          "line": 5590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!path->keep_locks"
          ],
          "line": 5582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_find_next_key(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key, int level, u64 min_trans)\n{\n\tint slot;\n\tstruct extent_buffer *c;\n\n\tWARN_ON(!path->keep_locks);\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\treturn 1;\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\nnext:\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tint ret;\n\t\t\tint orig_lowest;\n\t\t\tstruct btrfs_key cur_key;\n\t\t\tif (level + 1 >= BTRFS_MAX_LEVEL ||\n\t\t\t    !path->nodes[level + 1])\n\t\t\t\treturn 1;\n\n\t\t\tif (path->locks[level + 1]) {\n\t\t\t\tlevel++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslot = btrfs_header_nritems(c) - 1;\n\t\t\tif (level == 0)\n\t\t\t\tbtrfs_item_key_to_cpu(c, &cur_key, slot);\n\t\t\telse\n\t\t\t\tbtrfs_node_key_to_cpu(c, &cur_key, slot);\n\n\t\t\torig_lowest = path->lowest_level;\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->lowest_level = level;\n\t\t\tret = btrfs_search_slot(NULL, root, &cur_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tpath->lowest_level = orig_lowest;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tc = path->nodes[level];\n\t\t\tslot = path->slots[level];\n\t\t\tif (ret == 0)\n\t\t\t\tslot++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (level == 0)\n\t\t\tbtrfs_item_key_to_cpu(c, key, slot);\n\t\telse {\n\t\t\tu64 gen = btrfs_node_ptr_generation(c, slot);\n\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbtrfs_node_key_to_cpu(c, key, slot);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_compare_trees",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "5322-5563",
    "snippet": "int btrfs_compare_trees(struct btrfs_root *left_root,\n\t\t\tstruct btrfs_root *right_root,\n\t\t\tbtrfs_changed_cb_t changed_cb, void *ctx)\n{\n\tint ret;\n\tint cmp;\n\tstruct btrfs_path *left_path = NULL;\n\tstruct btrfs_path *right_path = NULL;\n\tstruct btrfs_key left_key;\n\tstruct btrfs_key right_key;\n\tchar *tmp_buf = NULL;\n\tint left_root_level;\n\tint right_root_level;\n\tint left_level;\n\tint right_level;\n\tint left_end_reached;\n\tint right_end_reached;\n\tint advance_left;\n\tint advance_right;\n\tu64 left_blockptr;\n\tu64 right_blockptr;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tleft_path = btrfs_alloc_path();\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tright_path = btrfs_alloc_path();\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttmp_buf = kmalloc(left_root->nodesize, GFP_NOFS);\n\tif (!tmp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tleft_path->search_commit_root = 1;\n\tleft_path->skip_locking = 1;\n\tright_path->search_commit_root = 1;\n\tright_path->skip_locking = 1;\n\n\t/*\n\t * Strategy: Go to the first items of both trees. Then do\n\t *\n\t * If both trees are at level 0\n\t *   Compare keys of current items\n\t *     If left < right treat left item as new, advance left tree\n\t *       and repeat\n\t *     If left > right treat right item as deleted, advance right tree\n\t *       and repeat\n\t *     If left == right do deep compare of items, treat as changed if\n\t *       needed, advance both trees and repeat\n\t * If both trees are at the same level but not at level 0\n\t *   Compare keys of current nodes/leafs\n\t *     If left < right advance left tree and repeat\n\t *     If left > right advance right tree and repeat\n\t *     If left == right compare blockptrs of the next nodes/leafs\n\t *       If they match advance both trees but stay at the same level\n\t *         and repeat\n\t *       If they don't match advance both trees while allowing to go\n\t *         deeper and repeat\n\t * If tree levels are different\n\t *   Advance the tree that needs it and repeat\n\t *\n\t * Advancing a tree means:\n\t *   If we are at level 0, try to go to the next slot. If that's not\n\t *   possible, go one level up and repeat. Stop when we found a level\n\t *   where we could go to the next slot. We may at this point be on a\n\t *   node or a leaf.\n\t *\n\t *   If we are not at level 0 and not on shared tree blocks, go one\n\t *   level deeper.\n\t *\n\t *   If we are not at level 0 and on shared tree blocks, go one slot to\n\t *   the right if possible or go up and right.\n\t */\n\n\tdown_read(&left_root->fs_info->commit_root_sem);\n\tleft_level = btrfs_header_level(left_root->commit_root);\n\tleft_root_level = left_level;\n\tleft_path->nodes[left_level] = left_root->commit_root;\n\textent_buffer_get(left_path->nodes[left_level]);\n\n\tright_level = btrfs_header_level(right_root->commit_root);\n\tright_root_level = right_level;\n\tright_path->nodes[right_level] = right_root->commit_root;\n\textent_buffer_get(right_path->nodes[right_level]);\n\tup_read(&left_root->fs_info->commit_root_sem);\n\n\tif (left_level == 0)\n\t\tbtrfs_item_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\tif (right_level == 0)\n\t\tbtrfs_item_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\n\tleft_end_reached = right_end_reached = 0;\n\tadvance_left = advance_right = 0;\n\n\twhile (1) {\n\t\tif (advance_left && !left_end_reached) {\n\t\t\tret = tree_advance(left_root, left_path, &left_level,\n\t\t\t\t\tleft_root_level,\n\t\t\t\t\tadvance_left != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&left_key);\n\t\t\tif (ret < 0)\n\t\t\t\tleft_end_reached = ADVANCE;\n\t\t\tadvance_left = 0;\n\t\t}\n\t\tif (advance_right && !right_end_reached) {\n\t\t\tret = tree_advance(right_root, right_path, &right_level,\n\t\t\t\t\tright_root_level,\n\t\t\t\t\tadvance_right != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&right_key);\n\t\t\tif (ret < 0)\n\t\t\t\tright_end_reached = ADVANCE;\n\t\t\tadvance_right = 0;\n\t\t}\n\n\t\tif (left_end_reached && right_end_reached) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else if (left_end_reached) {\n\t\t\tif (right_level == 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadvance_right = ADVANCE;\n\t\t\tcontinue;\n\t\t} else if (right_end_reached) {\n\t\t\tif (left_level == 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&left_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_NEW,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadvance_left = ADVANCE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (left_level == 0 && right_level == 0) {\n\t\t\tcmp = btrfs_comp_cpu_keys(&left_key, &right_key);\n\t\t\tif (cmp < 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&left_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_NEW,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t} else {\n\t\t\t\tenum btrfs_compare_tree_result result;\n\n\t\t\t\tWARN_ON(!extent_buffer_uptodate(left_path->nodes[0]));\n\t\t\t\tret = tree_compare_item(left_root, left_path,\n\t\t\t\t\t\tright_path, tmp_buf);\n\t\t\t\tif (ret)\n\t\t\t\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\t\t\telse\n\t\t\t\t\tresult = BTRFS_COMPARE_TREE_SAME;\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\t left_path, right_path,\n\t\t\t\t\t\t &left_key, result, ctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t}\n\t\t} else if (left_level == right_level) {\n\t\t\tcmp = btrfs_comp_cpu_keys(&left_key, &right_key);\n\t\t\tif (cmp < 0) {\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t} else {\n\t\t\t\tleft_blockptr = btrfs_node_blockptr(\n\t\t\t\t\t\tleft_path->nodes[left_level],\n\t\t\t\t\t\tleft_path->slots[left_level]);\n\t\t\t\tright_blockptr = btrfs_node_blockptr(\n\t\t\t\t\t\tright_path->nodes[right_level],\n\t\t\t\t\t\tright_path->slots[right_level]);\n\t\t\t\tleft_gen = btrfs_node_ptr_generation(\n\t\t\t\t\t\tleft_path->nodes[left_level],\n\t\t\t\t\t\tleft_path->slots[left_level]);\n\t\t\t\tright_gen = btrfs_node_ptr_generation(\n\t\t\t\t\t\tright_path->nodes[right_level],\n\t\t\t\t\t\tright_path->slots[right_level]);\n\t\t\t\tif (left_blockptr == right_blockptr &&\n\t\t\t\t    left_gen == right_gen) {\n\t\t\t\t\t/*\n\t\t\t\t\t * As we're on a shared block, don't\n\t\t\t\t\t * allow to go deeper.\n\t\t\t\t\t */\n\t\t\t\t\tadvance_left = ADVANCE_ONLY_NEXT;\n\t\t\t\t\tadvance_right = ADVANCE_ONLY_NEXT;\n\t\t\t\t} else {\n\t\t\t\t\tadvance_left = ADVANCE;\n\t\t\t\t\tadvance_right = ADVANCE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (left_level < right_level) {\n\t\t\tadvance_right = ADVANCE;\n\t\t} else {\n\t\t\tadvance_left = ADVANCE;\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(left_path);\n\tbtrfs_free_path(right_path);\n\tkfree(tmp_buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define ADVANCE_ONLY_NEXT -1",
      "#define ADVANCE 1"
    ],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp_buf"
          ],
          "line": 5561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "right_path"
          ],
          "line": 5560
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "right_path->nodes[right_level]",
            "right_path->slots[right_level]"
          ],
          "line": 5535
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "right_path->nodes[right_level]",
            "right_path->slots[right_level]"
          ],
          "line": 5529
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_comp_cpu_keys",
          "args": [
            "&left_key",
            "&right_key"
          ],
          "line": 5520
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_comp_cpu_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1598-1613",
          "snippet": "int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "changed_cb",
          "args": [
            "left_root",
            "right_root",
            "left_path",
            "right_path",
            "&left_key",
            "result",
            "ctx"
          ],
          "line": 5511
        },
        "resolved": true,
        "details": {
          "function_name": "changed_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "5505-5558",
          "snippet": "static int changed_cb(struct btrfs_root *left_root,\n\t\t      struct btrfs_root *right_root,\n\t\t      struct btrfs_path *left_path,\n\t\t      struct btrfs_path *right_path,\n\t\t      struct btrfs_key *key,\n\t\t      enum btrfs_compare_tree_result result,\n\t\t      void *ctx)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\n\tif (result == BTRFS_COMPARE_TREE_SAME) {\n\t\tif (key->type == BTRFS_INODE_REF_KEY ||\n\t\t    key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = compare_refs(sctx, left_path, key);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else if (key->type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\treturn maybe_send_hole(sctx, left_path, key);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\tret = 0;\n\t}\n\n\tsctx->left_path = left_path;\n\tsctx->right_path = right_path;\n\tsctx->cmp_key = key;\n\n\tret = finish_inode_if_needed(sctx, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Ignore non-FS objects */\n\tif (key->objectid == BTRFS_FREE_INO_OBJECTID ||\n\t    key->objectid == BTRFS_FREE_SPACE_OBJECTID)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_INODE_ITEM_KEY)\n\t\tret = changed_inode(sctx, result);\n\telse if (key->type == BTRFS_INODE_REF_KEY ||\n\t\t key->type == BTRFS_INODE_EXTREF_KEY)\n\t\tret = changed_ref(sctx, result);\n\telse if (key->type == BTRFS_XATTR_ITEM_KEY)\n\t\tret = changed_xattr(sctx, result);\n\telse if (key->type == BTRFS_EXTENT_DATA_KEY)\n\t\tret = changed_extent(sctx, result);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int changed_cb(struct btrfs_root *left_root,\n\t\t      struct btrfs_root *right_root,\n\t\t      struct btrfs_path *left_path,\n\t\t      struct btrfs_path *right_path,\n\t\t      struct btrfs_key *key,\n\t\t      enum btrfs_compare_tree_result result,\n\t\t      void *ctx)\n{\n\tint ret = 0;\n\tstruct send_ctx *sctx = ctx;\n\n\tif (result == BTRFS_COMPARE_TREE_SAME) {\n\t\tif (key->type == BTRFS_INODE_REF_KEY ||\n\t\t    key->type == BTRFS_INODE_EXTREF_KEY) {\n\t\t\tret = compare_refs(sctx, left_path, key);\n\t\t\tif (!ret)\n\t\t\t\treturn 0;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t} else if (key->type == BTRFS_EXTENT_DATA_KEY) {\n\t\t\treturn maybe_send_hole(sctx, left_path, key);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\tret = 0;\n\t}\n\n\tsctx->left_path = left_path;\n\tsctx->right_path = right_path;\n\tsctx->cmp_key = key;\n\n\tret = finish_inode_if_needed(sctx, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* Ignore non-FS objects */\n\tif (key->objectid == BTRFS_FREE_INO_OBJECTID ||\n\t    key->objectid == BTRFS_FREE_SPACE_OBJECTID)\n\t\tgoto out;\n\n\tif (key->type == BTRFS_INODE_ITEM_KEY)\n\t\tret = changed_inode(sctx, result);\n\telse if (key->type == BTRFS_INODE_REF_KEY ||\n\t\t key->type == BTRFS_INODE_EXTREF_KEY)\n\t\tret = changed_ref(sctx, result);\n\telse if (key->type == BTRFS_XATTR_ITEM_KEY)\n\t\tret = changed_xattr(sctx, result);\n\telse if (key->type == BTRFS_EXTENT_DATA_KEY)\n\t\tret = changed_extent(sctx, result);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_compare_item",
          "args": [
            "left_root",
            "left_path",
            "right_path",
            "tmp_buf"
          ],
          "line": 5505
        },
        "resolved": true,
        "details": {
          "function_name": "tree_compare_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5280-5304",
          "snippet": "static int tree_compare_item(struct btrfs_root *left_root,\n\t\t\t     struct btrfs_path *left_path,\n\t\t\t     struct btrfs_path *right_path,\n\t\t\t     char *tmp_buf)\n{\n\tint cmp;\n\tint len1, len2;\n\tunsigned long off1, off2;\n\n\tlen1 = btrfs_item_size_nr(left_path->nodes[0], left_path->slots[0]);\n\tlen2 = btrfs_item_size_nr(right_path->nodes[0], right_path->slots[0]);\n\tif (len1 != len2)\n\t\treturn 1;\n\n\toff1 = btrfs_item_ptr_offset(left_path->nodes[0], left_path->slots[0]);\n\toff2 = btrfs_item_ptr_offset(right_path->nodes[0],\n\t\t\t\tright_path->slots[0]);\n\n\tread_extent_buffer(left_path->nodes[0], tmp_buf, off1, len1);\n\n\tcmp = memcmp_extent_buffer(right_path->nodes[0], tmp_buf, off2, len1);\n\tif (cmp)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int tree_compare_item(struct btrfs_root *left_root,\n\t\t\t     struct btrfs_path *left_path,\n\t\t\t     struct btrfs_path *right_path,\n\t\t\t     char *tmp_buf)\n{\n\tint cmp;\n\tint len1, len2;\n\tunsigned long off1, off2;\n\n\tlen1 = btrfs_item_size_nr(left_path->nodes[0], left_path->slots[0]);\n\tlen2 = btrfs_item_size_nr(right_path->nodes[0], right_path->slots[0]);\n\tif (len1 != len2)\n\t\treturn 1;\n\n\toff1 = btrfs_item_ptr_offset(left_path->nodes[0], left_path->slots[0]);\n\toff2 = btrfs_item_ptr_offset(right_path->nodes[0],\n\t\t\t\tright_path->slots[0]);\n\n\tread_extent_buffer(left_path->nodes[0], tmp_buf, off1, len1);\n\n\tcmp = memcmp_extent_buffer(right_path->nodes[0], tmp_buf, off2, len1);\n\tif (cmp)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!extent_buffer_uptodate(left_path->nodes[0])"
          ],
          "line": 5504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "left_path->nodes[0]"
          ],
          "line": 5504
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_advance",
          "args": [
            "right_root",
            "right_path",
            "&right_level",
            "right_root_level",
            "advance_right != ADVANCE_ONLY_NEXT",
            "&right_key"
          ],
          "line": 5443
        },
        "resolved": true,
        "details": {
          "function_name": "tree_advance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5255-5278",
          "snippet": "static int tree_advance(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path,\n\t\t\tint *level, int root_level,\n\t\t\tint allow_down,\n\t\t\tstruct btrfs_key *key)\n{\n\tint ret;\n\n\tif (*level == 0 || !allow_down) {\n\t\tret = tree_move_next_or_upnext(root, path, level, root_level);\n\t} else {\n\t\ttree_move_down(root, path, level, root_level);\n\t\tret = 0;\n\t}\n\tif (ret >= 0) {\n\t\tif (*level == 0)\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[*level], key,\n\t\t\t\t\tpath->slots[*level]);\n\t\telse\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[*level], key,\n\t\t\t\t\tpath->slots[*level]);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic int tree_advance(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path,\n\t\t\tint *level, int root_level,\n\t\t\tint allow_down,\n\t\t\tstruct btrfs_key *key)\n{\n\tint ret;\n\n\tif (*level == 0 || !allow_down) {\n\t\tret = tree_move_next_or_upnext(root, path, level, root_level);\n\t} else {\n\t\ttree_move_down(root, path, level, root_level);\n\t\tret = 0;\n\t}\n\tif (ret >= 0) {\n\t\tif (*level == 0)\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[*level], key,\n\t\t\t\t\tpath->slots[*level]);\n\t\telse\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[*level], key,\n\t\t\t\t\tpath->slots[*level]);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_to_cpu",
          "args": [
            "right_path->nodes[right_level]",
            "&right_key",
            "right_path->slots[right_level]"
          ],
          "line": 5426
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "right_path->nodes[right_level]",
            "&right_key",
            "right_path->slots[right_level]"
          ],
          "line": 5423
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&left_root->fs_info->commit_root_sem"
          ],
          "line": 5414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "right_path->nodes[right_level]"
          ],
          "line": 5413
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "right_root->commit_root"
          ],
          "line": 5410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "left_root->commit_root"
          ],
          "line": 5405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&left_root->fs_info->commit_root_sem"
          ],
          "line": 5404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "left_root->nodesize",
            "GFP_NOFS"
          ],
          "line": 5357
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 5351
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#define ADVANCE_ONLY_NEXT -1\n#define ADVANCE 1\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_compare_trees(struct btrfs_root *left_root,\n\t\t\tstruct btrfs_root *right_root,\n\t\t\tbtrfs_changed_cb_t changed_cb, void *ctx)\n{\n\tint ret;\n\tint cmp;\n\tstruct btrfs_path *left_path = NULL;\n\tstruct btrfs_path *right_path = NULL;\n\tstruct btrfs_key left_key;\n\tstruct btrfs_key right_key;\n\tchar *tmp_buf = NULL;\n\tint left_root_level;\n\tint right_root_level;\n\tint left_level;\n\tint right_level;\n\tint left_end_reached;\n\tint right_end_reached;\n\tint advance_left;\n\tint advance_right;\n\tu64 left_blockptr;\n\tu64 right_blockptr;\n\tu64 left_gen;\n\tu64 right_gen;\n\n\tleft_path = btrfs_alloc_path();\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tright_path = btrfs_alloc_path();\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttmp_buf = kmalloc(left_root->nodesize, GFP_NOFS);\n\tif (!tmp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tleft_path->search_commit_root = 1;\n\tleft_path->skip_locking = 1;\n\tright_path->search_commit_root = 1;\n\tright_path->skip_locking = 1;\n\n\t/*\n\t * Strategy: Go to the first items of both trees. Then do\n\t *\n\t * If both trees are at level 0\n\t *   Compare keys of current items\n\t *     If left < right treat left item as new, advance left tree\n\t *       and repeat\n\t *     If left > right treat right item as deleted, advance right tree\n\t *       and repeat\n\t *     If left == right do deep compare of items, treat as changed if\n\t *       needed, advance both trees and repeat\n\t * If both trees are at the same level but not at level 0\n\t *   Compare keys of current nodes/leafs\n\t *     If left < right advance left tree and repeat\n\t *     If left > right advance right tree and repeat\n\t *     If left == right compare blockptrs of the next nodes/leafs\n\t *       If they match advance both trees but stay at the same level\n\t *         and repeat\n\t *       If they don't match advance both trees while allowing to go\n\t *         deeper and repeat\n\t * If tree levels are different\n\t *   Advance the tree that needs it and repeat\n\t *\n\t * Advancing a tree means:\n\t *   If we are at level 0, try to go to the next slot. If that's not\n\t *   possible, go one level up and repeat. Stop when we found a level\n\t *   where we could go to the next slot. We may at this point be on a\n\t *   node or a leaf.\n\t *\n\t *   If we are not at level 0 and not on shared tree blocks, go one\n\t *   level deeper.\n\t *\n\t *   If we are not at level 0 and on shared tree blocks, go one slot to\n\t *   the right if possible or go up and right.\n\t */\n\n\tdown_read(&left_root->fs_info->commit_root_sem);\n\tleft_level = btrfs_header_level(left_root->commit_root);\n\tleft_root_level = left_level;\n\tleft_path->nodes[left_level] = left_root->commit_root;\n\textent_buffer_get(left_path->nodes[left_level]);\n\n\tright_level = btrfs_header_level(right_root->commit_root);\n\tright_root_level = right_level;\n\tright_path->nodes[right_level] = right_root->commit_root;\n\textent_buffer_get(right_path->nodes[right_level]);\n\tup_read(&left_root->fs_info->commit_root_sem);\n\n\tif (left_level == 0)\n\t\tbtrfs_item_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(left_path->nodes[left_level],\n\t\t\t\t&left_key, left_path->slots[left_level]);\n\tif (right_level == 0)\n\t\tbtrfs_item_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\telse\n\t\tbtrfs_node_key_to_cpu(right_path->nodes[right_level],\n\t\t\t\t&right_key, right_path->slots[right_level]);\n\n\tleft_end_reached = right_end_reached = 0;\n\tadvance_left = advance_right = 0;\n\n\twhile (1) {\n\t\tif (advance_left && !left_end_reached) {\n\t\t\tret = tree_advance(left_root, left_path, &left_level,\n\t\t\t\t\tleft_root_level,\n\t\t\t\t\tadvance_left != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&left_key);\n\t\t\tif (ret < 0)\n\t\t\t\tleft_end_reached = ADVANCE;\n\t\t\tadvance_left = 0;\n\t\t}\n\t\tif (advance_right && !right_end_reached) {\n\t\t\tret = tree_advance(right_root, right_path, &right_level,\n\t\t\t\t\tright_root_level,\n\t\t\t\t\tadvance_right != ADVANCE_ONLY_NEXT,\n\t\t\t\t\t&right_key);\n\t\t\tif (ret < 0)\n\t\t\t\tright_end_reached = ADVANCE;\n\t\t\tadvance_right = 0;\n\t\t}\n\n\t\tif (left_end_reached && right_end_reached) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else if (left_end_reached) {\n\t\t\tif (right_level == 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadvance_right = ADVANCE;\n\t\t\tcontinue;\n\t\t} else if (right_end_reached) {\n\t\t\tif (left_level == 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&left_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_NEW,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tadvance_left = ADVANCE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (left_level == 0 && right_level == 0) {\n\t\t\tcmp = btrfs_comp_cpu_keys(&left_key, &right_key);\n\t\t\tif (cmp < 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&left_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_NEW,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\tleft_path, right_path,\n\t\t\t\t\t\t&right_key,\n\t\t\t\t\t\tBTRFS_COMPARE_TREE_DELETED,\n\t\t\t\t\t\tctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t} else {\n\t\t\t\tenum btrfs_compare_tree_result result;\n\n\t\t\t\tWARN_ON(!extent_buffer_uptodate(left_path->nodes[0]));\n\t\t\t\tret = tree_compare_item(left_root, left_path,\n\t\t\t\t\t\tright_path, tmp_buf);\n\t\t\t\tif (ret)\n\t\t\t\t\tresult = BTRFS_COMPARE_TREE_CHANGED;\n\t\t\t\telse\n\t\t\t\t\tresult = BTRFS_COMPARE_TREE_SAME;\n\t\t\t\tret = changed_cb(left_root, right_root,\n\t\t\t\t\t\t left_path, right_path,\n\t\t\t\t\t\t &left_key, result, ctx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out;\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t}\n\t\t} else if (left_level == right_level) {\n\t\t\tcmp = btrfs_comp_cpu_keys(&left_key, &right_key);\n\t\t\tif (cmp < 0) {\n\t\t\t\tadvance_left = ADVANCE;\n\t\t\t} else if (cmp > 0) {\n\t\t\t\tadvance_right = ADVANCE;\n\t\t\t} else {\n\t\t\t\tleft_blockptr = btrfs_node_blockptr(\n\t\t\t\t\t\tleft_path->nodes[left_level],\n\t\t\t\t\t\tleft_path->slots[left_level]);\n\t\t\t\tright_blockptr = btrfs_node_blockptr(\n\t\t\t\t\t\tright_path->nodes[right_level],\n\t\t\t\t\t\tright_path->slots[right_level]);\n\t\t\t\tleft_gen = btrfs_node_ptr_generation(\n\t\t\t\t\t\tleft_path->nodes[left_level],\n\t\t\t\t\t\tleft_path->slots[left_level]);\n\t\t\t\tright_gen = btrfs_node_ptr_generation(\n\t\t\t\t\t\tright_path->nodes[right_level],\n\t\t\t\t\t\tright_path->slots[right_level]);\n\t\t\t\tif (left_blockptr == right_blockptr &&\n\t\t\t\t    left_gen == right_gen) {\n\t\t\t\t\t/*\n\t\t\t\t\t * As we're on a shared block, don't\n\t\t\t\t\t * allow to go deeper.\n\t\t\t\t\t */\n\t\t\t\t\tadvance_left = ADVANCE_ONLY_NEXT;\n\t\t\t\t\tadvance_right = ADVANCE_ONLY_NEXT;\n\t\t\t\t} else {\n\t\t\t\t\tadvance_left = ADVANCE;\n\t\t\t\t\tadvance_right = ADVANCE;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (left_level < right_level) {\n\t\t\tadvance_right = ADVANCE;\n\t\t} else {\n\t\t\tadvance_left = ADVANCE;\n\t\t}\n\t}\n\nout:\n\tbtrfs_free_path(left_path);\n\tbtrfs_free_path(right_path);\n\tkfree(tmp_buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "tree_compare_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "5280-5304",
    "snippet": "static int tree_compare_item(struct btrfs_root *left_root,\n\t\t\t     struct btrfs_path *left_path,\n\t\t\t     struct btrfs_path *right_path,\n\t\t\t     char *tmp_buf)\n{\n\tint cmp;\n\tint len1, len2;\n\tunsigned long off1, off2;\n\n\tlen1 = btrfs_item_size_nr(left_path->nodes[0], left_path->slots[0]);\n\tlen2 = btrfs_item_size_nr(right_path->nodes[0], right_path->slots[0]);\n\tif (len1 != len2)\n\t\treturn 1;\n\n\toff1 = btrfs_item_ptr_offset(left_path->nodes[0], left_path->slots[0]);\n\toff2 = btrfs_item_ptr_offset(right_path->nodes[0],\n\t\t\t\tright_path->slots[0]);\n\n\tread_extent_buffer(left_path->nodes[0], tmp_buf, off1, len1);\n\n\tcmp = memcmp_extent_buffer(right_path->nodes[0], tmp_buf, off2, len1);\n\tif (cmp)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp_extent_buffer",
          "args": [
            "right_path->nodes[0]",
            "tmp_buf",
            "off2",
            "len1"
          ],
          "line": 5300
        },
        "resolved": true,
        "details": {
          "function_name": "memcmp_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5320-5354",
          "snippet": "int memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,\n\t\t\t  unsigned long start,\n\t\t\t  unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *ptr = (char *)ptrv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tret = memcmp(ptr, kaddr + offset, cur);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tptr += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint memcmp_extent_buffer(struct extent_buffer *eb, const void *ptrv,\n\t\t\t  unsigned long start,\n\t\t\t  unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *ptr = (char *)ptrv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tint ret = 0;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\n\t\tcur = min(len, (PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tret = memcmp(ptr, kaddr + offset, cur);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tptr += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "left_path->nodes[0]",
            "tmp_buf",
            "off1",
            "len1"
          ],
          "line": 5298
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "right_path->nodes[0]",
            "right_path->slots[0]"
          ],
          "line": 5295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "left_path->nodes[0]",
            "left_path->slots[0]"
          ],
          "line": 5294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "right_path->nodes[0]",
            "right_path->slots[0]"
          ],
          "line": 5290
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int tree_compare_item(struct btrfs_root *left_root,\n\t\t\t     struct btrfs_path *left_path,\n\t\t\t     struct btrfs_path *right_path,\n\t\t\t     char *tmp_buf)\n{\n\tint cmp;\n\tint len1, len2;\n\tunsigned long off1, off2;\n\n\tlen1 = btrfs_item_size_nr(left_path->nodes[0], left_path->slots[0]);\n\tlen2 = btrfs_item_size_nr(right_path->nodes[0], right_path->slots[0]);\n\tif (len1 != len2)\n\t\treturn 1;\n\n\toff1 = btrfs_item_ptr_offset(left_path->nodes[0], left_path->slots[0]);\n\toff2 = btrfs_item_ptr_offset(right_path->nodes[0],\n\t\t\t\tright_path->slots[0]);\n\n\tread_extent_buffer(left_path->nodes[0], tmp_buf, off1, len1);\n\n\tcmp = memcmp_extent_buffer(right_path->nodes[0], tmp_buf, off2, len1);\n\tif (cmp)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "tree_advance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "5255-5278",
    "snippet": "static int tree_advance(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path,\n\t\t\tint *level, int root_level,\n\t\t\tint allow_down,\n\t\t\tstruct btrfs_key *key)\n{\n\tint ret;\n\n\tif (*level == 0 || !allow_down) {\n\t\tret = tree_move_next_or_upnext(root, path, level, root_level);\n\t} else {\n\t\ttree_move_down(root, path, level, root_level);\n\t\tret = 0;\n\t}\n\tif (ret >= 0) {\n\t\tif (*level == 0)\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[*level], key,\n\t\t\t\t\tpath->slots[*level]);\n\t\telse\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[*level], key,\n\t\t\t\t\tpath->slots[*level]);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_node_key_to_cpu",
          "args": [
            "path->nodes[*level]",
            "key",
            "path->slots[*level]"
          ],
          "line": 5274
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[*level]",
            "key",
            "path->slots[*level]"
          ],
          "line": 5271
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_move_down",
          "args": [
            "root",
            "path",
            "level",
            "root_level"
          ],
          "line": 5266
        },
        "resolved": true,
        "details": {
          "function_name": "tree_move_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5213-5222",
          "snippet": "static void tree_move_down(struct btrfs_root *root,\n\t\t\t   struct btrfs_path *path,\n\t\t\t   int *level, int root_level)\n{\n\tBUG_ON(*level == 0);\n\tpath->nodes[*level - 1] = read_node_slot(root, path->nodes[*level],\n\t\t\t\t\tpath->slots[*level]);\n\tpath->slots[*level - 1] = 0;\n\t(*level)--;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic void tree_move_down(struct btrfs_root *root,\n\t\t\t   struct btrfs_path *path,\n\t\t\t   int *level, int root_level)\n{\n\tBUG_ON(*level == 0);\n\tpath->nodes[*level - 1] = read_node_slot(root, path->nodes[*level],\n\t\t\t\t\tpath->slots[*level]);\n\tpath->slots[*level - 1] = 0;\n\t(*level)--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_move_next_or_upnext",
          "args": [
            "root",
            "path",
            "level",
            "root_level"
          ],
          "line": 5264
        },
        "resolved": true,
        "details": {
          "function_name": "tree_move_next_or_upnext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5224-5249",
          "snippet": "static int tree_move_next_or_upnext(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    int *level, int root_level)\n{\n\tint ret = 0;\n\tint nritems;\n\tnritems = btrfs_header_nritems(path->nodes[*level]);\n\n\tpath->slots[*level]++;\n\n\twhile (path->slots[*level] >= nritems) {\n\t\tif (*level == root_level)\n\t\t\treturn -1;\n\n\t\t/* move upnext */\n\t\tpath->slots[*level] = 0;\n\t\tfree_extent_buffer(path->nodes[*level]);\n\t\tpath->nodes[*level] = NULL;\n\t\t(*level)++;\n\t\tpath->slots[*level]++;\n\n\t\tnritems = btrfs_header_nritems(path->nodes[*level]);\n\t\tret = 1;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic int tree_move_next_or_upnext(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    int *level, int root_level)\n{\n\tint ret = 0;\n\tint nritems;\n\tnritems = btrfs_header_nritems(path->nodes[*level]);\n\n\tpath->slots[*level]++;\n\n\twhile (path->slots[*level] >= nritems) {\n\t\tif (*level == root_level)\n\t\t\treturn -1;\n\n\t\t/* move upnext */\n\t\tpath->slots[*level] = 0;\n\t\tfree_extent_buffer(path->nodes[*level]);\n\t\tpath->nodes[*level] = NULL;\n\t\t(*level)++;\n\t\tpath->slots[*level]++;\n\n\t\tnritems = btrfs_header_nritems(path->nodes[*level]);\n\t\tret = 1;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic int tree_advance(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path,\n\t\t\tint *level, int root_level,\n\t\t\tint allow_down,\n\t\t\tstruct btrfs_key *key)\n{\n\tint ret;\n\n\tif (*level == 0 || !allow_down) {\n\t\tret = tree_move_next_or_upnext(root, path, level, root_level);\n\t} else {\n\t\ttree_move_down(root, path, level, root_level);\n\t\tret = 0;\n\t}\n\tif (ret >= 0) {\n\t\tif (*level == 0)\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[*level], key,\n\t\t\t\t\tpath->slots[*level]);\n\t\telse\n\t\t\tbtrfs_node_key_to_cpu(path->nodes[*level], key,\n\t\t\t\t\tpath->slots[*level]);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "tree_move_next_or_upnext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "5224-5249",
    "snippet": "static int tree_move_next_or_upnext(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    int *level, int root_level)\n{\n\tint ret = 0;\n\tint nritems;\n\tnritems = btrfs_header_nritems(path->nodes[*level]);\n\n\tpath->slots[*level]++;\n\n\twhile (path->slots[*level] >= nritems) {\n\t\tif (*level == root_level)\n\t\t\treturn -1;\n\n\t\t/* move upnext */\n\t\tpath->slots[*level] = 0;\n\t\tfree_extent_buffer(path->nodes[*level]);\n\t\tpath->nodes[*level] = NULL;\n\t\t(*level)++;\n\t\tpath->slots[*level]++;\n\n\t\tnritems = btrfs_header_nritems(path->nodes[*level]);\n\t\tret = 1;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[*level]"
          ],
          "line": 5245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "path->nodes[*level]"
          ],
          "line": 5240
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[*level]"
          ],
          "line": 5230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic int tree_move_next_or_upnext(struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    int *level, int root_level)\n{\n\tint ret = 0;\n\tint nritems;\n\tnritems = btrfs_header_nritems(path->nodes[*level]);\n\n\tpath->slots[*level]++;\n\n\twhile (path->slots[*level] >= nritems) {\n\t\tif (*level == root_level)\n\t\t\treturn -1;\n\n\t\t/* move upnext */\n\t\tpath->slots[*level] = 0;\n\t\tfree_extent_buffer(path->nodes[*level]);\n\t\tpath->nodes[*level] = NULL;\n\t\t(*level)++;\n\t\tpath->slots[*level]++;\n\n\t\tnritems = btrfs_header_nritems(path->nodes[*level]);\n\t\tret = 1;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "tree_move_down",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "5213-5222",
    "snippet": "static void tree_move_down(struct btrfs_root *root,\n\t\t\t   struct btrfs_path *path,\n\t\t\t   int *level, int root_level)\n{\n\tBUG_ON(*level == 0);\n\tpath->nodes[*level - 1] = read_node_slot(root, path->nodes[*level],\n\t\t\t\t\tpath->slots[*level]);\n\tpath->slots[*level - 1] = 0;\n\t(*level)--;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_node_slot",
          "args": [
            "root",
            "path->nodes[*level]",
            "path->slots[*level]"
          ],
          "line": 5218
        },
        "resolved": true,
        "details": {
          "function_name": "read_node_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1853-1874",
          "snippet": "extent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nextent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*level == 0"
          ],
          "line": 5217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic void tree_move_down(struct btrfs_root *root,\n\t\t\t   struct btrfs_path *path,\n\t\t\t   int *level, int root_level)\n{\n\tBUG_ON(*level == 0);\n\tpath->nodes[*level - 1] = read_node_slot(root, path->nodes[*level],\n\t\t\t\t\tpath->slots[*level]);\n\tpath->slots[*level - 1] = 0;\n\t(*level)--;\n}"
  },
  {
    "function_name": "btrfs_search_forward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "5113-5211",
    "snippet": "int btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "min_key",
            "&found_key",
            "sizeof(found_key)"
          ],
          "line": 5208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "path"
          ],
          "line": 5207
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_unlock_up_safe",
          "args": [
            "path",
            "path->lowest_level + 1"
          ],
          "line": 5206
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unlock_up_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2413-2428",
          "snippet": "noinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nnoinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clear_path_blocking",
          "args": [
            "path",
            "NULL",
            "0"
          ],
          "line": 5201
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "78-104",
          "snippet": "noinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_up",
          "args": [
            "path",
            "level",
            "1",
            "0",
            "NULL"
          ],
          "line": 5200
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2361-2402",
          "snippet": "static noinline void unlock_up(struct btrfs_path *path, int level,\n\t\t\t       int lowest_unlock, int min_write_lock_level,\n\t\t\t       int *write_lock_level)\n{\n\tint i;\n\tint skip_level = level;\n\tint no_skips = 0;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tif (!path->locks[i])\n\t\t\tbreak;\n\t\tif (!no_skips && path->slots[i] == 0) {\n\t\t\tskip_level = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!no_skips && path->keep_locks) {\n\t\t\tu32 nritems;\n\t\t\tt = path->nodes[i];\n\t\t\tnritems = btrfs_header_nritems(t);\n\t\t\tif (nritems < 1 || path->slots[i] >= nritems - 1) {\n\t\t\t\tskip_level = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (skip_level < i && i >= lowest_unlock)\n\t\t\tno_skips = 1;\n\n\t\tt = path->nodes[i];\n\t\tif (i >= lowest_unlock && i > skip_level && path->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(t, path->locks[i]);\n\t\t\tpath->locks[i] = 0;\n\t\t\tif (write_lock_level &&\n\t\t\t    i > min_write_lock_level &&\n\t\t\t    i <= *write_lock_level) {\n\t\t\t\t*write_lock_level = i - 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline void unlock_up(struct btrfs_path *path, int level,\n\t\t\t       int lowest_unlock, int min_write_lock_level,\n\t\t\t       int *write_lock_level)\n{\n\tint i;\n\tint skip_level = level;\n\tint no_skips = 0;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tif (!path->locks[i])\n\t\t\tbreak;\n\t\tif (!no_skips && path->slots[i] == 0) {\n\t\t\tskip_level = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!no_skips && path->keep_locks) {\n\t\t\tu32 nritems;\n\t\t\tt = path->nodes[i];\n\t\t\tnritems = btrfs_header_nritems(t);\n\t\t\tif (nritems < 1 || path->slots[i] >= nritems - 1) {\n\t\t\t\tskip_level = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (skip_level < i && i >= lowest_unlock)\n\t\t\tno_skips = 1;\n\n\t\tt = path->nodes[i];\n\t\tif (i >= lowest_unlock && i > skip_level && path->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(t, path->locks[i]);\n\t\t\tpath->locks[i] = 0;\n\t\t\tif (write_lock_level &&\n\t\t\t    i > min_write_lock_level &&\n\t\t\t    i <= *write_lock_level) {\n\t\t\t\t*write_lock_level = i - 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_lock",
          "args": [
            "cur"
          ],
          "line": 5196
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_lock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "135-148",
          "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cur"
          ],
          "line": 5194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_node_slot",
          "args": [
            "root",
            "cur",
            "slot"
          ],
          "line": 5193
        },
        "resolved": true,
        "details": {
          "function_name": "read_node_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1853-1874",
          "snippet": "extent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nextent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_to_cpu",
          "args": [
            "cur",
            "&found_key",
            "slot"
          ],
          "line": 5186
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 5179
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_next_key",
          "args": [
            "root",
            "path",
            "min_key",
            "level",
            "min_trans"
          ],
          "line": 5176
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_next_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5576-5639",
          "snippet": "int btrfs_find_next_key(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key, int level, u64 min_trans)\n{\n\tint slot;\n\tstruct extent_buffer *c;\n\n\tWARN_ON(!path->keep_locks);\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\treturn 1;\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\nnext:\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tint ret;\n\t\t\tint orig_lowest;\n\t\t\tstruct btrfs_key cur_key;\n\t\t\tif (level + 1 >= BTRFS_MAX_LEVEL ||\n\t\t\t    !path->nodes[level + 1])\n\t\t\t\treturn 1;\n\n\t\t\tif (path->locks[level + 1]) {\n\t\t\t\tlevel++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslot = btrfs_header_nritems(c) - 1;\n\t\t\tif (level == 0)\n\t\t\t\tbtrfs_item_key_to_cpu(c, &cur_key, slot);\n\t\t\telse\n\t\t\t\tbtrfs_node_key_to_cpu(c, &cur_key, slot);\n\n\t\t\torig_lowest = path->lowest_level;\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->lowest_level = level;\n\t\t\tret = btrfs_search_slot(NULL, root, &cur_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tpath->lowest_level = orig_lowest;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tc = path->nodes[level];\n\t\t\tslot = path->slots[level];\n\t\t\tif (ret == 0)\n\t\t\t\tslot++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (level == 0)\n\t\t\tbtrfs_item_key_to_cpu(c, key, slot);\n\t\telse {\n\t\t\tu64 gen = btrfs_node_ptr_generation(c, slot);\n\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbtrfs_node_key_to_cpu(c, key, slot);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_find_next_key(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tstruct btrfs_key *key, int level, u64 min_trans)\n{\n\tint slot;\n\tstruct extent_buffer *c;\n\n\tWARN_ON(!path->keep_locks);\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level])\n\t\t\treturn 1;\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\nnext:\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tint ret;\n\t\t\tint orig_lowest;\n\t\t\tstruct btrfs_key cur_key;\n\t\t\tif (level + 1 >= BTRFS_MAX_LEVEL ||\n\t\t\t    !path->nodes[level + 1])\n\t\t\t\treturn 1;\n\n\t\t\tif (path->locks[level + 1]) {\n\t\t\t\tlevel++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslot = btrfs_header_nritems(c) - 1;\n\t\t\tif (level == 0)\n\t\t\t\tbtrfs_item_key_to_cpu(c, &cur_key, slot);\n\t\t\telse\n\t\t\t\tbtrfs_node_key_to_cpu(c, &cur_key, slot);\n\n\t\t\torig_lowest = path->lowest_level;\n\t\t\tbtrfs_release_path(path);\n\t\t\tpath->lowest_level = level;\n\t\t\tret = btrfs_search_slot(NULL, root, &cur_key, path,\n\t\t\t\t\t\t0, 0);\n\t\t\tpath->lowest_level = orig_lowest;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tc = path->nodes[level];\n\t\t\tslot = path->slots[level];\n\t\t\tif (ret == 0)\n\t\t\t\tslot++;\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (level == 0)\n\t\t\tbtrfs_item_key_to_cpu(c, key, slot);\n\t\telse {\n\t\t\tu64 gen = btrfs_node_ptr_generation(c, slot);\n\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tbtrfs_node_key_to_cpu(c, key, slot);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "cur",
            "slot"
          ],
          "line": 5161
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "cur",
            "&found_key",
            "slot"
          ],
          "line": 5149
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bin_search",
          "args": [
            "cur",
            "min_key",
            "level",
            "&slot"
          ],
          "line": 5141
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bin_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1827-1831",
          "snippet": "int btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nint btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "cur"
          ],
          "line": 5140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "cur"
          ],
          "line": 5139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "cur"
          ],
          "line": 5134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "path->nodes[level]"
          ],
          "line": 5130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "cur"
          ],
          "line": 5129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_lock_root_node",
          "args": [
            "root"
          ],
          "line": 5128
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_lock_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "195-208",
          "snippet": "static struct extent_buffer *btrfs_read_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_read_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_read_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic struct extent_buffer *btrfs_read_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_read_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_read_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_forward(struct btrfs_root *root, struct btrfs_key *min_key,\n\t\t\t struct btrfs_path *path,\n\t\t\t u64 min_trans)\n{\n\tstruct extent_buffer *cur;\n\tstruct btrfs_key found_key;\n\tint slot;\n\tint sret;\n\tu32 nritems;\n\tint level;\n\tint ret = 1;\n\tint keep_locks = path->keep_locks;\n\n\tpath->keep_locks = 1;\nagain:\n\tcur = btrfs_read_lock_root_node(root);\n\tlevel = btrfs_header_level(cur);\n\tWARN_ON(path->nodes[level]);\n\tpath->nodes[level] = cur;\n\tpath->locks[level] = BTRFS_READ_LOCK;\n\n\tif (btrfs_header_generation(cur) < min_trans) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tnritems = btrfs_header_nritems(cur);\n\t\tlevel = btrfs_header_level(cur);\n\t\tsret = bin_search(cur, min_key, level, &slot);\n\n\t\t/* at the lowest level, we're done, setup the path and exit */\n\t\tif (level == path->lowest_level) {\n\t\t\tif (slot >= nritems)\n\t\t\t\tgoto find_next_key;\n\t\t\tret = 0;\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_item_key_to_cpu(cur, &found_key, slot);\n\t\t\tgoto out;\n\t\t}\n\t\tif (sret && slot > 0)\n\t\t\tslot--;\n\t\t/*\n\t\t * check this node pointer against the min_trans parameters.\n\t\t * If it is too old, old, skip to the next one.\n\t\t */\n\t\twhile (slot < nritems) {\n\t\t\tu64 gen;\n\n\t\t\tgen = btrfs_node_ptr_generation(cur, slot);\n\t\t\tif (gen < min_trans) {\n\t\t\t\tslot++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\nfind_next_key:\n\t\t/*\n\t\t * we didn't find a candidate key in this node, walk forward\n\t\t * and find another one\n\t\t */\n\t\tif (slot >= nritems) {\n\t\t\tpath->slots[level] = slot;\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tsret = btrfs_find_next_key(root, path, min_key, level,\n\t\t\t\t\t\t  min_trans);\n\t\t\tif (sret == 0) {\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tgoto again;\n\t\t\t} else {\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t/* save our key for returning back */\n\t\tbtrfs_node_key_to_cpu(cur, &found_key, slot);\n\t\tpath->slots[level] = slot;\n\t\tif (level == path->lowest_level) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tbtrfs_set_path_blocking(path);\n\t\tcur = read_node_slot(root, cur, slot);\n\t\tBUG_ON(!cur); /* -ENOMEM */\n\n\t\tbtrfs_tree_read_lock(cur);\n\n\t\tpath->locks[level - 1] = BTRFS_READ_LOCK;\n\t\tpath->nodes[level - 1] = cur;\n\t\tunlock_up(path, level, 1, 0, NULL);\n\t\tbtrfs_clear_path_blocking(path, NULL, 0);\n\t}\nout:\n\tpath->keep_locks = keep_locks;\n\tif (ret == 0) {\n\t\tbtrfs_unlock_up_safe(path, path->lowest_level + 1);\n\t\tbtrfs_set_path_blocking(path);\n\t\tmemcpy(min_key, &found_key, sizeof(found_key));\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_prev_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "5049-5089",
    "snippet": "int btrfs_prev_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key found_key;\n\tint ret;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, 0);\n\n\tif (key.offset > 0) {\n\t\tkey.offset--;\n\t} else if (key.type > 0) {\n\t\tkey.type--;\n\t\tkey.offset = (u64)-1;\n\t} else if (key.objectid > 0) {\n\t\tkey.objectid--;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\treturn 1;\n\t}\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tbtrfs_item_key(path->nodes[0], &found_key, 0);\n\tret = comp_keys(&found_key, &key);\n\t/*\n\t * We might have had an item with the previous key in the tree right\n\t * before we released our path. And after we released our path, that\n\t * item might have been pushed to the first slot (0) of the leaf we\n\t * were holding due to a tree balance. Alternatively, an item with the\n\t * previous key can exist as the only element of a leaf (big fat item).\n\t * Therefore account for these 2 cases, so that our callers (like\n\t * btrfs_previous_item) don't miss an existing item with a key matching\n\t * the previous key we computed above.\n\t */\n\tif (ret <= 0)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "comp_keys",
          "args": [
            "&found_key",
            "&key"
          ],
          "line": 5075
        },
        "resolved": true,
        "details": {
          "function_name": "comp_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1586-1593",
          "snippet": "static int comp_keys(struct btrfs_disk_key *disk, struct btrfs_key *k2)\n{\n\tstruct btrfs_key k1;\n\n\tbtrfs_disk_key_to_cpu(&k1, disk);\n\n\treturn btrfs_comp_cpu_keys(&k1, k2);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int comp_keys(struct btrfs_disk_key *disk, struct btrfs_key *k2)\n{\n\tstruct btrfs_key k1;\n\n\tbtrfs_disk_key_to_cpu(&k1, disk);\n\n\treturn btrfs_comp_cpu_keys(&k1, k2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key",
          "args": [
            "path->nodes[0]",
            "&found_key",
            "0"
          ],
          "line": 5074
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 5071
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 5070
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_prev_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key found_key;\n\tint ret;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, 0);\n\n\tif (key.offset > 0) {\n\t\tkey.offset--;\n\t} else if (key.type > 0) {\n\t\tkey.type--;\n\t\tkey.offset = (u64)-1;\n\t} else if (key.objectid > 0) {\n\t\tkey.objectid--;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\treturn 1;\n\t}\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tbtrfs_item_key(path->nodes[0], &found_key, 0);\n\tret = comp_keys(&found_key, &key);\n\t/*\n\t * We might have had an item with the previous key in the tree right\n\t * before we released our path. And after we released our path, that\n\t * item might have been pushed to the first slot (0) of the leaf we\n\t * were holding due to a tree balance. Alternatively, an item with the\n\t * previous key can exist as the only element of a leaf (big fat item).\n\t * Therefore account for these 2 cases, so that our callers (like\n\t * btrfs_previous_item) don't miss an existing item with a key matching\n\t * the previous key we computed above.\n\t */\n\tif (ret <= 0)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_del_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4930-5039",
    "snippet": "int btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tint last_off;\n\tint dsize = 0;\n\tint ret = 0;\n\tint wret;\n\tint i;\n\tu32 nritems;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tlast_off = btrfs_item_offset_nr(leaf, slot + nr - 1);\n\n\tfor (i = 0; i < nr; i++)\n\t\tdsize += btrfs_item_size_nr(leaf, slot + i);\n\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tint data_end = leaf_data_end(root, leaf);\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + dsize,\n\t\t\t      btrfs_leaf_data(leaf) + data_end,\n\t\t\t      last_off - data_end);\n\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr(i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff + dsize, &token);\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),\n\t\t\t      btrfs_item_nr_offset(slot + nr),\n\t\t\t      sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr));\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t/* delete the leaf if we've emptied it */\n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tclean_tree_block(trans, root, leaf);\n\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\n\t\t/* delete the leaf if it is mostly empty */\n\t\tif (used < BTRFS_LEAF_DATA_SIZE(root) / 3) {\n\t\t\t/* push_leaf_left fixes the path.\n\t\t\t * make sure the path still points to our leaf\n\t\t\t * for possible call to del_ptr below\n\t\t\t */\n\t\t\tslot = path->slots[1];\n\t\t\textent_buffer_get(leaf);\n\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\twret = push_leaf_left(trans, root, path, 1, 1,\n\t\t\t\t\t      1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\twret = push_leaf_right(trans, root, path, 1,\n\t\t\t\t\t\t       1, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t/* if we're still in the path, make sure\n\t\t\t\t * we're dirty.  Otherwise, one of the\n\t\t\t\t * push_leaf functions must have already\n\t\t\t\t * dirtied this buffer\n\t\t\t\t */\n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 5035
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "leaf"
          ],
          "line": 5032
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_del_leaf",
          "args": [
            "trans",
            "root",
            "path",
            "leaf"
          ],
          "line": 5021
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_del_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4906-4925",
          "snippet": "static noinline void btrfs_del_leaf(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *leaf)\n{\n\tWARN_ON(btrfs_header_generation(leaf) != trans->transid);\n\tdel_ptr(root, path, 1, path->slots[1]);\n\n\t/*\n\t * btrfs_free_extent is expensive, we want to make sure we\n\t * aren't holding any locks when we call it\n\t */\n\tbtrfs_unlock_up_safe(path, 0);\n\n\troot_sub_used(root, leaf->len);\n\n\textent_buffer_get(leaf);\n\tbtrfs_free_tree_block(trans, root, leaf, 0, 1);\n\tfree_extent_buffer_stale(leaf);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline void btrfs_del_leaf(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *leaf)\n{\n\tWARN_ON(btrfs_header_generation(leaf) != trans->transid);\n\tdel_ptr(root, path, 1, path->slots[1]);\n\n\t/*\n\t * btrfs_free_extent is expensive, we want to make sure we\n\t * aren't holding any locks when we call it\n\t */\n\tbtrfs_unlock_up_safe(path, 0);\n\n\troot_sub_used(root, leaf->len);\n\n\textent_buffer_get(leaf);\n\tbtrfs_free_tree_block(trans, root, leaf, 0, 1);\n\tfree_extent_buffer_stale(leaf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 5019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "push_leaf_right",
          "args": [
            "trans",
            "root",
            "path",
            "1",
            "1",
            "1",
            "0"
          ],
          "line": 5013
        },
        "resolved": true,
        "details": {
          "function_name": "push_leaf_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3734-3801",
          "snippet": "static int push_leaf_right(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t   *root, struct btrfs_path *path,\n\t\t\t   int min_data_size, int data_size,\n\t\t\t   int empty, u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *right;\n\tstruct extent_buffer *upper;\n\tint slot;\n\tint free_space;\n\tu32 left_nritems;\n\tint ret;\n\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tslot = path->slots[1];\n\tupper = path->nodes[1];\n\tif (slot >= btrfs_header_nritems(upper) - 1)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tright = read_node_slot(root, upper, slot + 1);\n\tif (right == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(right);\n\tbtrfs_set_lock_blocking(right);\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, right, upper,\n\t\t\t      slot + 1, &right);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\tleft_nritems = btrfs_header_nritems(left);\n\tif (left_nritems == 0)\n\t\tgoto out_unlock;\n\n\tif (path->slots[0] == left_nritems && !empty) {\n\t\t/* Key greater than all keys in the leaf, right neighbor has\n\t\t * enough room for it and we're not emptying our leaf to delete\n\t\t * it, therefore use right neighbor to insert the new item and\n\t\t * no need to touch/dirty our left leaft. */\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] = 0;\n\t\tpath->slots[1]++;\n\t\treturn 0;\n\t}\n\n\treturn __push_leaf_right(trans, root, path, min_data_size, empty,\n\t\t\t\tright, free_space, left_nritems, min_slot);\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int push_leaf_right(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t   *root, struct btrfs_path *path,\n\t\t\t   int min_data_size, int data_size,\n\t\t\t   int empty, u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *right;\n\tstruct extent_buffer *upper;\n\tint slot;\n\tint free_space;\n\tu32 left_nritems;\n\tint ret;\n\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tslot = path->slots[1];\n\tupper = path->nodes[1];\n\tif (slot >= btrfs_header_nritems(upper) - 1)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tright = read_node_slot(root, upper, slot + 1);\n\tif (right == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(right);\n\tbtrfs_set_lock_blocking(right);\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, right, upper,\n\t\t\t      slot + 1, &right);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\tleft_nritems = btrfs_header_nritems(left);\n\tif (left_nritems == 0)\n\t\tgoto out_unlock;\n\n\tif (path->slots[0] == left_nritems && !empty) {\n\t\t/* Key greater than all keys in the leaf, right neighbor has\n\t\t * enough room for it and we're not emptying our leaf to delete\n\t\t * it, therefore use right neighbor to insert the new item and\n\t\t * no need to touch/dirty our left leaft. */\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] = 0;\n\t\tpath->slots[1]++;\n\t\treturn 0;\n\t}\n\n\treturn __push_leaf_right(trans, root, path, min_data_size, empty,\n\t\t\t\tright, free_space, left_nritems, min_slot);\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 5012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "push_leaf_left",
          "args": [
            "trans",
            "root",
            "path",
            "1",
            "1",
            "1",
            "(u32)-1"
          ],
          "line": 5006
        },
        "resolved": true,
        "details": {
          "function_name": "push_leaf_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3964-4023",
          "snippet": "static int push_leaf_left(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, struct btrfs_path *path, int min_data_size,\n\t\t\t  int data_size, int empty, u32 max_slot)\n{\n\tstruct extent_buffer *right = path->nodes[0];\n\tstruct extent_buffer *left;\n\tint slot;\n\tint free_space;\n\tu32 right_nritems;\n\tint ret = 0;\n\n\tslot = path->slots[1];\n\tif (slot == 0)\n\t\treturn 1;\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tright_nritems = btrfs_header_nritems(right);\n\tif (right_nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tleft = read_node_slot(root, path->nodes[1], slot - 1);\n\tif (left == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(left);\n\tbtrfs_set_lock_blocking(left);\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, left,\n\t\t\t      path->nodes[1], slot - 1, &left);\n\tif (ret) {\n\t\t/* we hit -ENOSPC, but it isn't fatal here */\n\t\tif (ret == -ENOSPC)\n\t\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\treturn __push_leaf_left(trans, root, path, min_data_size,\n\t\t\t       empty, left, free_space, right_nritems,\n\t\t\t       max_slot);\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int push_leaf_left(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, struct btrfs_path *path, int min_data_size,\n\t\t\t  int data_size, int empty, u32 max_slot)\n{\n\tstruct extent_buffer *right = path->nodes[0];\n\tstruct extent_buffer *left;\n\tint slot;\n\tint free_space;\n\tu32 right_nritems;\n\tint ret = 0;\n\n\tslot = path->slots[1];\n\tif (slot == 0)\n\t\treturn 1;\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tright_nritems = btrfs_header_nritems(right);\n\tif (right_nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tleft = read_node_slot(root, path->nodes[1], slot - 1);\n\tif (left == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(left);\n\tbtrfs_set_lock_blocking(left);\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, left,\n\t\t\t      path->nodes[1], slot - 1, &left);\n\tif (ret) {\n\t\t/* we hit -ENOSPC, but it isn't fatal here */\n\t\tif (ret == -ENOSPC)\n\t\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\treturn __push_leaf_left(trans, root, path, min_data_size,\n\t\t\t       empty, left, free_space, right_nritems,\n\t\t\t       max_slot);\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "path"
          ],
          "line": 5005
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "leaf"
          ],
          "line": 5003
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 4997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixup_low_keys",
          "args": [
            "root",
            "path",
            "&disk_key",
            "1"
          ],
          "line": 4993
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_low_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3129-3146",
          "snippet": "static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key",
          "args": [
            "leaf",
            "&disk_key",
            "0"
          ],
          "line": 4992
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_space_used",
          "args": [
            "leaf",
            "0",
            "nritems"
          ],
          "line": 4988
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_space_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3539-3559",
          "snippet": "static int leaf_space_used(struct extent_buffer *l, int start, int nr)\n{\n\tstruct btrfs_item *start_item;\n\tstruct btrfs_item *end_item;\n\tstruct btrfs_map_token token;\n\tint data_len;\n\tint nritems = btrfs_header_nritems(l);\n\tint end = min(nritems, start + nr) - 1;\n\n\tif (!nr)\n\t\treturn 0;\n\tbtrfs_init_map_token(&token);\n\tstart_item = btrfs_item_nr(start);\n\tend_item = btrfs_item_nr(end);\n\tdata_len = btrfs_token_item_offset(l, start_item, &token) +\n\t\tbtrfs_token_item_size(l, start_item, &token);\n\tdata_len = data_len - btrfs_token_item_offset(l, end_item, &token);\n\tdata_len += sizeof(struct btrfs_item) * nr;\n\tWARN_ON(data_len < 0);\n\treturn data_len;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int leaf_space_used(struct extent_buffer *l, int start, int nr)\n{\n\tstruct btrfs_item *start_item;\n\tstruct btrfs_item *end_item;\n\tstruct btrfs_map_token token;\n\tint data_len;\n\tint nritems = btrfs_header_nritems(l);\n\tint end = min(nritems, start + nr) - 1;\n\n\tif (!nr)\n\t\treturn 0;\n\tbtrfs_init_map_token(&token);\n\tstart_item = btrfs_item_nr(start);\n\tend_item = btrfs_item_nr(end);\n\tdata_len = btrfs_token_item_offset(l, start_item, &token) +\n\t\tbtrfs_token_item_size(l, start_item, &token);\n\tdata_len = data_len - btrfs_token_item_offset(l, end_item, &token);\n\tdata_len += sizeof(struct btrfs_item) * nr;\n\tWARN_ON(data_len < 0);\n\treturn data_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_tree_block",
          "args": [
            "trans",
            "root",
            "leaf"
          ],
          "line": 4984
        },
        "resolved": true,
        "details": {
          "function_name": "clean_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1168-1186",
          "snippet": "void clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_level",
          "args": [
            "leaf",
            "0"
          ],
          "line": 4981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "leaf",
            "nritems - nr"
          ],
          "line": 4975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "leaf",
            "btrfs_item_nr_offset(slot)",
            "btrfs_item_nr_offset(slot + nr)",
            "sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr)"
          ],
          "line": 4970
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr_offset",
          "args": [
            "slot + nr"
          ],
          "line": 4971
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2622-2626",
          "snippet": "static inline unsigned long btrfs_item_nr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_leaf, items) +\n\t\tsizeof(struct btrfs_item) * nr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_item_nr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_leaf, items) +\n\t\tsizeof(struct btrfs_item) * nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_item_offset",
          "args": [
            "leaf",
            "item",
            "ioff + dsize",
            "&token"
          ],
          "line": 4966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_token_item_offset",
          "args": [
            "leaf",
            "item",
            "&token"
          ],
          "line": 4965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "i"
          ],
          "line": 4964
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_data",
          "args": [
            "leaf"
          ],
          "line": 4958
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3075-3078",
          "snippet": "static inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_data_end",
          "args": [
            "root",
            "leaf"
          ],
          "line": 4954
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1729-1736",
          "snippet": "static inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 4951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "slot + i"
          ],
          "line": 4949
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_offset_nr",
          "args": [
            "leaf",
            "slot + nr - 1"
          ],
          "line": 4946
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_offset_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2644-2647",
          "snippet": "static inline u32 btrfs_item_offset_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_offset(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_offset_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_offset(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_map_token",
          "args": [
            "&token"
          ],
          "line": 4943
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_map_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2214-2217",
          "snippet": "static inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_del_items(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t    struct btrfs_path *path, int slot, int nr)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tint last_off;\n\tint dsize = 0;\n\tint ret = 0;\n\tint wret;\n\tint i;\n\tu32 nritems;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tlast_off = btrfs_item_offset_nr(leaf, slot + nr - 1);\n\n\tfor (i = 0; i < nr; i++)\n\t\tdsize += btrfs_item_size_nr(leaf, slot + i);\n\n\tnritems = btrfs_header_nritems(leaf);\n\n\tif (slot + nr != nritems) {\n\t\tint data_end = leaf_data_end(root, leaf);\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + dsize,\n\t\t\t      btrfs_leaf_data(leaf) + data_end,\n\t\t\t      last_off - data_end);\n\n\t\tfor (i = slot + nr; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr(i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff + dsize, &token);\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot),\n\t\t\t      btrfs_item_nr_offset(slot + nr),\n\t\t\t      sizeof(struct btrfs_item) *\n\t\t\t      (nritems - slot - nr));\n\t}\n\tbtrfs_set_header_nritems(leaf, nritems - nr);\n\tnritems -= nr;\n\n\t/* delete the leaf if we've emptied it */\n\tif (nritems == 0) {\n\t\tif (leaf == root->node) {\n\t\t\tbtrfs_set_header_level(leaf, 0);\n\t\t} else {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tclean_tree_block(trans, root, leaf);\n\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t}\n\t} else {\n\t\tint used = leaf_space_used(leaf, 0, nritems);\n\t\tif (slot == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_item_key(leaf, &disk_key, 0);\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\n\t\t/* delete the leaf if it is mostly empty */\n\t\tif (used < BTRFS_LEAF_DATA_SIZE(root) / 3) {\n\t\t\t/* push_leaf_left fixes the path.\n\t\t\t * make sure the path still points to our leaf\n\t\t\t * for possible call to del_ptr below\n\t\t\t */\n\t\t\tslot = path->slots[1];\n\t\t\textent_buffer_get(leaf);\n\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\twret = push_leaf_left(trans, root, path, 1, 1,\n\t\t\t\t\t      1, (u32)-1);\n\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\tret = wret;\n\n\t\t\tif (path->nodes[0] == leaf &&\n\t\t\t    btrfs_header_nritems(leaf)) {\n\t\t\t\twret = push_leaf_right(trans, root, path, 1,\n\t\t\t\t\t\t       1, 1, 0);\n\t\t\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\t\t\tret = wret;\n\t\t\t}\n\n\t\t\tif (btrfs_header_nritems(leaf) == 0) {\n\t\t\t\tpath->slots[1] = slot;\n\t\t\t\tbtrfs_del_leaf(trans, root, path, leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t\tret = 0;\n\t\t\t} else {\n\t\t\t\t/* if we're still in the path, make sure\n\t\t\t\t * we're dirty.  Otherwise, one of the\n\t\t\t\t * push_leaf functions must have already\n\t\t\t\t * dirtied this buffer\n\t\t\t\t */\n\t\t\t\tif (path->nodes[0] == leaf)\n\t\t\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t\t\tfree_extent_buffer(leaf);\n\t\t\t}\n\t\t} else {\n\t\t\tbtrfs_mark_buffer_dirty(leaf);\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_del_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4906-4925",
    "snippet": "static noinline void btrfs_del_leaf(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *leaf)\n{\n\tWARN_ON(btrfs_header_generation(leaf) != trans->transid);\n\tdel_ptr(root, path, 1, path->slots[1]);\n\n\t/*\n\t * btrfs_free_extent is expensive, we want to make sure we\n\t * aren't holding any locks when we call it\n\t */\n\tbtrfs_unlock_up_safe(path, 0);\n\n\troot_sub_used(root, leaf->len);\n\n\textent_buffer_get(leaf);\n\tbtrfs_free_tree_block(trans, root, leaf, 0, 1);\n\tfree_extent_buffer_stale(leaf);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer_stale",
          "args": [
            "leaf"
          ],
          "line": 4924
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_tree_block",
          "args": [
            "trans",
            "root",
            "leaf",
            "0",
            "1"
          ],
          "line": 4923
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "6190-6246",
          "snippet": "void btrfs_free_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct extent_buffer *buf,\n\t\t\t   u64 parent, int last_ref)\n{\n\tint pin = 1;\n\tint ret;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tbuf->start, buf->len,\n\t\t\t\t\tparent, root->root_key.objectid,\n\t\t\t\t\tbtrfs_header_level(buf),\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tif (!last_ref)\n\t\treturn;\n\n\tif (btrfs_header_generation(buf) == trans->transid) {\n\t\tstruct btrfs_block_group_cache *cache;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\t\tret = check_ref_cleanup(trans, root, buf->start);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcache = btrfs_lookup_block_group(root->fs_info, buf->start);\n\n\t\tif (btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN)) {\n\t\t\tpin_down_extent(root, cache, buf->start, buf->len, 1);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto out;\n\t\t}\n\n\t\tWARN_ON(test_bit(EXTENT_BUFFER_DIRTY, &buf->bflags));\n\n\t\tbtrfs_add_free_space(cache, buf->start, buf->len);\n\t\tbtrfs_update_reserved_bytes(cache, buf->len, RESERVE_FREE, 0);\n\t\tbtrfs_put_block_group(cache);\n\t\ttrace_btrfs_reserved_extent_free(root, buf->start, buf->len);\n\t\tpin = 0;\n\t}\nout:\n\tif (pin)\n\t\tadd_pinned_bytes(root->fs_info, buf->len,\n\t\t\t\t btrfs_header_level(buf),\n\t\t\t\t root->root_key.objectid);\n\n\t/*\n\t * Deleting the buffer, clear the corrupt flag since it doesn't matter\n\t * anymore.\n\t */\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &buf->bflags);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct extent_buffer *buf,\n\t\t\t   u64 parent, int last_ref)\n{\n\tint pin = 1;\n\tint ret;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tbuf->start, buf->len,\n\t\t\t\t\tparent, root->root_key.objectid,\n\t\t\t\t\tbtrfs_header_level(buf),\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tif (!last_ref)\n\t\treturn;\n\n\tif (btrfs_header_generation(buf) == trans->transid) {\n\t\tstruct btrfs_block_group_cache *cache;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\t\tret = check_ref_cleanup(trans, root, buf->start);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcache = btrfs_lookup_block_group(root->fs_info, buf->start);\n\n\t\tif (btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN)) {\n\t\t\tpin_down_extent(root, cache, buf->start, buf->len, 1);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto out;\n\t\t}\n\n\t\tWARN_ON(test_bit(EXTENT_BUFFER_DIRTY, &buf->bflags));\n\n\t\tbtrfs_add_free_space(cache, buf->start, buf->len);\n\t\tbtrfs_update_reserved_bytes(cache, buf->len, RESERVE_FREE, 0);\n\t\tbtrfs_put_block_group(cache);\n\t\ttrace_btrfs_reserved_extent_free(root, buf->start, buf->len);\n\t\tpin = 0;\n\t}\nout:\n\tif (pin)\n\t\tadd_pinned_bytes(root->fs_info, buf->len,\n\t\t\t\t btrfs_header_level(buf),\n\t\t\t\t root->root_key.objectid);\n\n\t/*\n\t * Deleting the buffer, clear the corrupt flag since it doesn't matter\n\t * anymore.\n\t */\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &buf->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "leaf"
          ],
          "line": 4922
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "root_sub_used",
          "args": [
            "root",
            "leaf->len"
          ],
          "line": 4920
        },
        "resolved": true,
        "details": {
          "function_name": "root_sub_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1841-1847",
          "snippet": "static void root_sub_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) - size);\n\tspin_unlock(&root->accounting_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void root_sub_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) - size);\n\tspin_unlock(&root->accounting_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_unlock_up_safe",
          "args": [
            "path",
            "0"
          ],
          "line": 4918
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unlock_up_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2413-2428",
          "snippet": "noinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nnoinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_ptr",
          "args": [
            "root",
            "path",
            "1",
            "path->slots[1]"
          ],
          "line": 4912
        },
        "resolved": true,
        "details": {
          "function_name": "del_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4858-4894",
          "snippet": "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot)\n{\n\tstruct extent_buffer *parent = path->nodes[level];\n\tu32 nritems;\n\tint ret;\n\n\tnritems = btrfs_header_nritems(parent);\n\tif (slot != nritems - 1) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, parent, slot,\n\t\t\t\t\t     slot + 1, nritems - slot - 1);\n\t\tmemmove_extent_buffer(parent,\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      sizeof(struct btrfs_key_ptr) *\n\t\t\t      (nritems - slot - 1));\n\t} else if (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, parent, slot,\n\t\t\t\t\t      MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\n\tnritems--;\n\tbtrfs_set_header_nritems(parent, nritems);\n\tif (nritems == 0 && parent == root->node) {\n\t\tBUG_ON(btrfs_header_level(root->node) != 1);\n\t\t/* just turn the root into a leaf and break */\n\t\tbtrfs_set_header_level(root->node, 0);\n\t} else if (slot == 0) {\n\t\tstruct btrfs_disk_key disk_key;\n\n\t\tbtrfs_node_key(parent, &disk_key, 0);\n\t\tfixup_low_keys(root, path, &disk_key, level + 1);\n\t}\n\tbtrfs_mark_buffer_dirty(parent);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot)\n{\n\tstruct extent_buffer *parent = path->nodes[level];\n\tu32 nritems;\n\tint ret;\n\n\tnritems = btrfs_header_nritems(parent);\n\tif (slot != nritems - 1) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, parent, slot,\n\t\t\t\t\t     slot + 1, nritems - slot - 1);\n\t\tmemmove_extent_buffer(parent,\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      sizeof(struct btrfs_key_ptr) *\n\t\t\t      (nritems - slot - 1));\n\t} else if (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, parent, slot,\n\t\t\t\t\t      MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\n\tnritems--;\n\tbtrfs_set_header_nritems(parent, nritems);\n\tif (nritems == 0 && parent == root->node) {\n\t\tBUG_ON(btrfs_header_level(root->node) != 1);\n\t\t/* just turn the root into a leaf and break */\n\t\tbtrfs_set_header_level(root->node, 0);\n\t} else if (slot == 0) {\n\t\tstruct btrfs_disk_key disk_key;\n\n\t\tbtrfs_node_key(parent, &disk_key, 0);\n\t\tfixup_low_keys(root, path, &disk_key, level + 1);\n\t}\n\tbtrfs_mark_buffer_dirty(parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_generation(leaf) != trans->transid"
          ],
          "line": 4911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "leaf"
          ],
          "line": 4911
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline void btrfs_del_leaf(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *leaf)\n{\n\tWARN_ON(btrfs_header_generation(leaf) != trans->transid);\n\tdel_ptr(root, path, 1, path->slots[1]);\n\n\t/*\n\t * btrfs_free_extent is expensive, we want to make sure we\n\t * aren't holding any locks when we call it\n\t */\n\tbtrfs_unlock_up_safe(path, 0);\n\n\troot_sub_used(root, leaf->len);\n\n\textent_buffer_get(leaf);\n\tbtrfs_free_tree_block(trans, root, leaf, 0, 1);\n\tfree_extent_buffer_stale(leaf);\n}"
  },
  {
    "function_name": "del_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4858-4894",
    "snippet": "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot)\n{\n\tstruct extent_buffer *parent = path->nodes[level];\n\tu32 nritems;\n\tint ret;\n\n\tnritems = btrfs_header_nritems(parent);\n\tif (slot != nritems - 1) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, parent, slot,\n\t\t\t\t\t     slot + 1, nritems - slot - 1);\n\t\tmemmove_extent_buffer(parent,\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      sizeof(struct btrfs_key_ptr) *\n\t\t\t      (nritems - slot - 1));\n\t} else if (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, parent, slot,\n\t\t\t\t\t      MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\n\tnritems--;\n\tbtrfs_set_header_nritems(parent, nritems);\n\tif (nritems == 0 && parent == root->node) {\n\t\tBUG_ON(btrfs_header_level(root->node) != 1);\n\t\t/* just turn the root into a leaf and break */\n\t\tbtrfs_set_header_level(root->node, 0);\n\t} else if (slot == 0) {\n\t\tstruct btrfs_disk_key disk_key;\n\n\t\tbtrfs_node_key(parent, &disk_key, 0);\n\t\tfixup_low_keys(root, path, &disk_key, level + 1);\n\t}\n\tbtrfs_mark_buffer_dirty(parent);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "parent"
          ],
          "line": 4893
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_low_keys",
          "args": [
            "root",
            "path",
            "&disk_key",
            "level + 1"
          ],
          "line": 4891
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_low_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3129-3146",
          "snippet": "static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key",
          "args": [
            "parent",
            "&disk_key",
            "0"
          ],
          "line": 4890
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_level",
          "args": [
            "root->node",
            "0"
          ],
          "line": 4886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "btrfs_header_level(root->node) != 1"
          ],
          "line": 4884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "root->node"
          ],
          "line": 4884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "parent",
            "nritems"
          ],
          "line": 4882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0"
          ],
          "line": 4878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_insert_key",
          "args": [
            "root->fs_info",
            "parent",
            "slot",
            "MOD_LOG_KEY_REMOVE",
            "GFP_NOFS"
          ],
          "line": 4876
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_insert_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "539-565",
          "snippet": "static noinline int\ntree_mod_log_insert_key(struct btrfs_fs_info *fs_info,\n\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\tenum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\tint ret;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm = alloc_tree_mod_elem(eb, slot, op, flags);\n\tif (!tm)\n\t\treturn -ENOMEM;\n\n\tif (tree_mod_dont_log(fs_info, eb)) {\n\t\tkfree(tm);\n\t\treturn 0;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tkfree(tm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_insert_key(struct btrfs_fs_info *fs_info,\n\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\tenum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\tint ret;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm = alloc_tree_mod_elem(eb, slot, op, flags);\n\tif (!tm)\n\t\treturn -ENOMEM;\n\n\tif (tree_mod_dont_log(fs_info, eb)) {\n\t\tkfree(tm);\n\t\treturn 0;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tkfree(tm);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "parent",
            "btrfs_node_key_ptr_offset(slot)",
            "btrfs_node_key_ptr_offset(slot + 1)",
            "sizeof(struct btrfs_key_ptr) *\n\t\t\t      (nritems - slot - 1)"
          ],
          "line": 4870
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_ptr_offset",
          "args": [
            "slot + 1"
          ],
          "line": 4872
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_ptr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2598-2602",
          "snippet": "static inline unsigned long btrfs_node_key_ptr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_node_key_ptr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_log_eb_move",
          "args": [
            "root->fs_info",
            "parent",
            "slot",
            "slot + 1",
            "nritems - slot - 1"
          ],
          "line": 4868
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_eb_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "871-879",
          "snippet": "static inline void\ntree_mod_log_eb_move(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     int dst_offset, int src_offset, int nr_items)\n{\n\tint ret;\n\tret = tree_mod_log_insert_move(fs_info, dst, dst_offset, src_offset,\n\t\t\t\t       nr_items, GFP_NOFS);\n\tBUG_ON(ret < 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void\ntree_mod_log_eb_move(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     int dst_offset, int src_offset, int nr_items)\n{\n\tint ret;\n\tret = tree_mod_log_insert_move(fs_info, dst, dst_offset, src_offset,\n\t\t\t\t       nr_items, GFP_NOFS);\n\tBUG_ON(ret < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "parent"
          ],
          "line": 4865
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot)\n{\n\tstruct extent_buffer *parent = path->nodes[level];\n\tu32 nritems;\n\tint ret;\n\n\tnritems = btrfs_header_nritems(parent);\n\tif (slot != nritems - 1) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, parent, slot,\n\t\t\t\t\t     slot + 1, nritems - slot - 1);\n\t\tmemmove_extent_buffer(parent,\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      sizeof(struct btrfs_key_ptr) *\n\t\t\t      (nritems - slot - 1));\n\t} else if (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, parent, slot,\n\t\t\t\t\t      MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\n\tnritems--;\n\tbtrfs_set_header_nritems(parent, nritems);\n\tif (nritems == 0 && parent == root->node) {\n\t\tBUG_ON(btrfs_header_level(root->node) != 1);\n\t\t/* just turn the root into a leaf and break */\n\t\tbtrfs_set_header_level(root->node, 0);\n\t} else if (slot == 0) {\n\t\tstruct btrfs_disk_key disk_key;\n\n\t\tbtrfs_node_key(parent, &disk_key, 0);\n\t\tfixup_low_keys(root, path, &disk_key, level + 1);\n\t}\n\tbtrfs_mark_buffer_dirty(parent);\n}"
  },
  {
    "function_name": "btrfs_insert_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4829-4850",
    "snippet": "int btrfs_insert_item(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *cpu_key, void *data, u32\n\t\t      data_size)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = btrfs_insert_empty_item(trans, root, path, cpu_key, data_size);\n\tif (!ret) {\n\t\tleaf = path->nodes[0];\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\twrite_extent_buffer(leaf, data, ptr, data_size);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t}\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 4848
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 4846
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "leaf",
            "data",
            "ptr",
            "data_size"
          ],
          "line": 4845
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 4844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_insert_empty_item",
          "args": [
            "trans",
            "root",
            "path",
            "cpu_key",
            "data_size"
          ],
          "line": 4841
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_empty_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3579-3586",
          "snippet": "static inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_insert_empty_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  struct btrfs_key *key,\n\t\t\t\t\t  u32 data_size)\n{\n\treturn btrfs_insert_empty_items(trans, root, path, key, &data_size, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 4838
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_insert_item(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *cpu_key, void *data, u32\n\t\t      data_size)\n{\n\tint ret = 0;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = btrfs_insert_empty_item(trans, root, path, cpu_key, data_size);\n\tif (!ret) {\n\t\tleaf = path->nodes[0];\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\twrite_extent_buffer(leaf, data, ptr, data_size);\n\t\tbtrfs_mark_buffer_dirty(leaf);\n\t}\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_insert_empty_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4795-4823",
    "snippet": "int btrfs_insert_empty_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    int nr)\n{\n\tint ret = 0;\n\tint slot;\n\tint i;\n\tu32 total_size = 0;\n\tu32 total_data = 0;\n\n\tfor (i = 0; i < nr; i++)\n\t\ttotal_data += data_size[i];\n\n\ttotal_size = total_data + (nr * sizeof(struct btrfs_item));\n\tret = btrfs_search_slot(trans, root, cpu_key, path, total_size, 1);\n\tif (ret == 0)\n\t\treturn -EEXIST;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tslot = path->slots[0];\n\tBUG_ON(slot < 0);\n\n\tsetup_items_for_insert(root, path, cpu_key, data_size,\n\t\t\t       total_data, total_size, nr);\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_items_for_insert",
          "args": [
            "root",
            "path",
            "cpu_key",
            "data_size",
            "total_data",
            "total_size",
            "nr"
          ],
          "line": 4820
        },
        "resolved": true,
        "details": {
          "function_name": "setup_items_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4704-4789",
          "snippet": "void setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "slot < 0"
          ],
          "line": 4818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "cpu_key",
            "path",
            "total_size",
            "1"
          ],
          "line": 4811
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_insert_empty_items(struct btrfs_trans_handle *trans,\n\t\t\t    struct btrfs_root *root,\n\t\t\t    struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    int nr)\n{\n\tint ret = 0;\n\tint slot;\n\tint i;\n\tu32 total_size = 0;\n\tu32 total_data = 0;\n\n\tfor (i = 0; i < nr; i++)\n\t\ttotal_data += data_size[i];\n\n\ttotal_size = total_data + (nr * sizeof(struct btrfs_item));\n\tret = btrfs_search_slot(trans, root, cpu_key, path, total_size, 1);\n\tif (ret == 0)\n\t\treturn -EEXIST;\n\tif (ret < 0)\n\t\treturn ret;\n\n\tslot = path->slots[0];\n\tBUG_ON(slot < 0);\n\n\tsetup_items_for_insert(root, path, cpu_key, data_size,\n\t\t\t       total_data, total_size, nr);\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_items_for_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4704-4789",
    "snippet": "void setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 4787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_print_leaf",
          "args": [
            "root",
            "leaf"
          ],
          "line": 4786
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_print_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/print-tree.c",
          "lines": "172-311",
          "snippet": "void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)\n{\n\tint i;\n\tu32 type, nr;\n\tstruct btrfs_item *item;\n\tstruct btrfs_root_item *ri;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_block_group_item *bi;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_extent_data_ref *dref;\n\tstruct btrfs_shared_data_ref *sref;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\n\tif (!l)\n\t\treturn;\n\n\tnr = btrfs_header_nritems(l);\n\n\tbtrfs_info(root->fs_info, \"leaf %llu total ptrs %d free space %d\",\n\t\t   btrfs_header_bytenr(l), nr, btrfs_leaf_free_space(root, l));\n\tfor (i = 0 ; i < nr ; i++) {\n\t\titem = btrfs_item_nr(i);\n\t\tbtrfs_item_key_to_cpu(l, &key, i);\n\t\ttype = key.type;\n\t\tprintk(KERN_INFO \"\\titem %d key (%llu %u %llu) itemoff %d \"\n\t\t       \"itemsize %d\\n\",\n\t\t\ti, key.objectid, type, key.offset,\n\t\t\tbtrfs_item_offset(l, item), btrfs_item_size(l, item));\n\t\tswitch (type) {\n\t\tcase BTRFS_INODE_ITEM_KEY:\n\t\t\tii = btrfs_item_ptr(l, i, struct btrfs_inode_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tinode generation %llu size %llu \"\n\t\t\t       \"mode %o\\n\",\n\t\t\t       btrfs_inode_generation(l, ii),\n\t\t\t       btrfs_inode_size(l, ii),\n\t\t\t       btrfs_inode_mode(l, ii));\n\t\t\tbreak;\n\t\tcase BTRFS_DIR_ITEM_KEY:\n\t\t\tdi = btrfs_item_ptr(l, i, struct btrfs_dir_item);\n\t\t\tbtrfs_dir_item_key_to_cpu(l, di, &found_key);\n\t\t\tprintk(KERN_INFO \"\\t\\tdir oid %llu type %u\\n\",\n\t\t\t\tfound_key.objectid,\n\t\t\t\tbtrfs_dir_type(l, di));\n\t\t\tbreak;\n\t\tcase BTRFS_ROOT_ITEM_KEY:\n\t\t\tri = btrfs_item_ptr(l, i, struct btrfs_root_item);\n\t\t\tprintk(KERN_INFO \"\\t\\troot data bytenr %llu refs %u\\n\",\n\t\t\t\tbtrfs_disk_root_bytenr(l, ri),\n\t\t\t\tbtrfs_disk_root_refs(l, ri));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_ITEM_KEY:\n\t\tcase BTRFS_METADATA_ITEM_KEY:\n\t\t\tprint_extent_item(l, i, type);\n\t\t\tbreak;\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\ttree block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tshared block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_extent_data_ref);\n\t\t\tprint_extent_data_ref(l, dref);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_shared_data_ref);\n\t\t\tprintk(KERN_INFO \"\\t\\tshared data backref count %u\\n\",\n\t\t\t       btrfs_shared_data_ref_count(l, sref));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_KEY:\n\t\t\tfi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tif (btrfs_file_extent_type(l, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tprintk(KERN_INFO \"\\t\\tinline extent data \"\n\t\t\t\t       \"size %u\\n\",\n\t\t\t\t       btrfs_file_extent_inline_len(l, i, fi));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_INFO \"\\t\\textent data disk bytenr %llu \"\n\t\t\t       \"nr %llu\\n\",\n\t\t\t       btrfs_file_extent_disk_bytenr(l, fi),\n\t\t\t       btrfs_file_extent_disk_num_bytes(l, fi));\n\t\t\tprintk(KERN_INFO \"\\t\\textent data offset %llu \"\n\t\t\t       \"nr %llu ram %llu\\n\",\n\t\t\t       btrfs_file_extent_offset(l, fi),\n\t\t\t       btrfs_file_extent_num_bytes(l, fi),\n\t\t\t       btrfs_file_extent_ram_bytes(l, fi));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_REF_V0_KEY:\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tprint_extent_ref_v0(l, i);\n#else\n\t\t\tBUG();\n#endif\n\t\t\tbreak;\n\t\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:\n\t\t\tbi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_block_group_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tblock group used %llu\\n\",\n\t\t\t       btrfs_disk_block_group_used(l, bi));\n\t\t\tbreak;\n\t\tcase BTRFS_CHUNK_ITEM_KEY:\n\t\t\tprint_chunk(l, btrfs_item_ptr(l, i,\n\t\t\t\t\t\t      struct btrfs_chunk));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_ITEM_KEY:\n\t\t\tprint_dev_item(l, btrfs_item_ptr(l, i,\n\t\t\t\t\tstruct btrfs_dev_item));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_EXTENT_KEY:\n\t\t\tdev_extent = btrfs_item_ptr(l, i,\n\t\t\t\t\t\t    struct btrfs_dev_extent);\n\t\t\tprintk(KERN_INFO \"\\t\\tdev extent chunk_tree %llu\\n\"\n\t\t\t       \"\\t\\tchunk objectid %llu chunk offset %llu \"\n\t\t\t       \"length %llu\\n\",\n\t\t\t       btrfs_dev_extent_chunk_tree(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_objectid(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_offset(l, dev_extent),\n\t\t\t       btrfs_dev_extent_length(l, dev_extent));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_STATS_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdevice stats\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_REPLACE_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdev replace\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_UUID_KEY_SUBVOL:\n\t\tcase BTRFS_UUID_KEY_RECEIVED_SUBVOL:\n\t\t\tprint_uuid_item(l, btrfs_item_ptr_offset(l, i),\n\t\t\t\t\tbtrfs_item_size_nr(l, i));\n\t\t\tbreak;\n\t\t};\n\t}\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nvoid btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)\n{\n\tint i;\n\tu32 type, nr;\n\tstruct btrfs_item *item;\n\tstruct btrfs_root_item *ri;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_block_group_item *bi;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_extent_data_ref *dref;\n\tstruct btrfs_shared_data_ref *sref;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\n\tif (!l)\n\t\treturn;\n\n\tnr = btrfs_header_nritems(l);\n\n\tbtrfs_info(root->fs_info, \"leaf %llu total ptrs %d free space %d\",\n\t\t   btrfs_header_bytenr(l), nr, btrfs_leaf_free_space(root, l));\n\tfor (i = 0 ; i < nr ; i++) {\n\t\titem = btrfs_item_nr(i);\n\t\tbtrfs_item_key_to_cpu(l, &key, i);\n\t\ttype = key.type;\n\t\tprintk(KERN_INFO \"\\titem %d key (%llu %u %llu) itemoff %d \"\n\t\t       \"itemsize %d\\n\",\n\t\t\ti, key.objectid, type, key.offset,\n\t\t\tbtrfs_item_offset(l, item), btrfs_item_size(l, item));\n\t\tswitch (type) {\n\t\tcase BTRFS_INODE_ITEM_KEY:\n\t\t\tii = btrfs_item_ptr(l, i, struct btrfs_inode_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tinode generation %llu size %llu \"\n\t\t\t       \"mode %o\\n\",\n\t\t\t       btrfs_inode_generation(l, ii),\n\t\t\t       btrfs_inode_size(l, ii),\n\t\t\t       btrfs_inode_mode(l, ii));\n\t\t\tbreak;\n\t\tcase BTRFS_DIR_ITEM_KEY:\n\t\t\tdi = btrfs_item_ptr(l, i, struct btrfs_dir_item);\n\t\t\tbtrfs_dir_item_key_to_cpu(l, di, &found_key);\n\t\t\tprintk(KERN_INFO \"\\t\\tdir oid %llu type %u\\n\",\n\t\t\t\tfound_key.objectid,\n\t\t\t\tbtrfs_dir_type(l, di));\n\t\t\tbreak;\n\t\tcase BTRFS_ROOT_ITEM_KEY:\n\t\t\tri = btrfs_item_ptr(l, i, struct btrfs_root_item);\n\t\t\tprintk(KERN_INFO \"\\t\\troot data bytenr %llu refs %u\\n\",\n\t\t\t\tbtrfs_disk_root_bytenr(l, ri),\n\t\t\t\tbtrfs_disk_root_refs(l, ri));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_ITEM_KEY:\n\t\tcase BTRFS_METADATA_ITEM_KEY:\n\t\t\tprint_extent_item(l, i, type);\n\t\t\tbreak;\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\ttree block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tshared block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_extent_data_ref);\n\t\t\tprint_extent_data_ref(l, dref);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_shared_data_ref);\n\t\t\tprintk(KERN_INFO \"\\t\\tshared data backref count %u\\n\",\n\t\t\t       btrfs_shared_data_ref_count(l, sref));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_KEY:\n\t\t\tfi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tif (btrfs_file_extent_type(l, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tprintk(KERN_INFO \"\\t\\tinline extent data \"\n\t\t\t\t       \"size %u\\n\",\n\t\t\t\t       btrfs_file_extent_inline_len(l, i, fi));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_INFO \"\\t\\textent data disk bytenr %llu \"\n\t\t\t       \"nr %llu\\n\",\n\t\t\t       btrfs_file_extent_disk_bytenr(l, fi),\n\t\t\t       btrfs_file_extent_disk_num_bytes(l, fi));\n\t\t\tprintk(KERN_INFO \"\\t\\textent data offset %llu \"\n\t\t\t       \"nr %llu ram %llu\\n\",\n\t\t\t       btrfs_file_extent_offset(l, fi),\n\t\t\t       btrfs_file_extent_num_bytes(l, fi),\n\t\t\t       btrfs_file_extent_ram_bytes(l, fi));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_REF_V0_KEY:\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tprint_extent_ref_v0(l, i);\n#else\n\t\t\tBUG();\n#endif\n\t\t\tbreak;\n\t\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:\n\t\t\tbi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_block_group_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tblock group used %llu\\n\",\n\t\t\t       btrfs_disk_block_group_used(l, bi));\n\t\t\tbreak;\n\t\tcase BTRFS_CHUNK_ITEM_KEY:\n\t\t\tprint_chunk(l, btrfs_item_ptr(l, i,\n\t\t\t\t\t\t      struct btrfs_chunk));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_ITEM_KEY:\n\t\t\tprint_dev_item(l, btrfs_item_ptr(l, i,\n\t\t\t\t\tstruct btrfs_dev_item));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_EXTENT_KEY:\n\t\t\tdev_extent = btrfs_item_ptr(l, i,\n\t\t\t\t\t\t    struct btrfs_dev_extent);\n\t\t\tprintk(KERN_INFO \"\\t\\tdev extent chunk_tree %llu\\n\"\n\t\t\t       \"\\t\\tchunk objectid %llu chunk offset %llu \"\n\t\t\t       \"length %llu\\n\",\n\t\t\t       btrfs_dev_extent_chunk_tree(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_objectid(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_offset(l, dev_extent),\n\t\t\t       btrfs_dev_extent_length(l, dev_extent));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_STATS_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdevice stats\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_REPLACE_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdev replace\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_UUID_KEY_SUBVOL:\n\t\tcase BTRFS_UUID_KEY_RECEIVED_SUBVOL:\n\t\t\tprint_uuid_item(l, btrfs_item_ptr_offset(l, i),\n\t\t\t\t\tbtrfs_item_size_nr(l, i));\n\t\t\tbreak;\n\t\t};\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "leaf"
          ],
          "line": 4785
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 4783
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "leaf",
            "nritems + nr"
          ],
          "line": 4782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_item_size",
          "args": [
            "leaf",
            "item",
            "data_size[i]",
            "&token"
          ],
          "line": 4779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_item_offset",
          "args": [
            "leaf",
            "item",
            "data_end - data_size[i]",
            "&token"
          ],
          "line": 4776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "slot + i"
          ],
          "line": 4775
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_key",
          "args": [
            "leaf",
            "&disk_key",
            "slot + i"
          ],
          "line": 4774
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_item_key_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3154-3177",
          "snippet": "void btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nvoid btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cpu_key_to_disk",
          "args": [
            "&disk_key",
            "cpu_key + i"
          ],
          "line": 4773
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cpu_key_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2739-2745",
          "snippet": "static inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "leaf",
            "btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data",
            "btrfs_leaf_data(leaf) +\n\t\t\t      data_end",
            "old_data - data_end"
          ],
          "line": 4765
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_data",
          "args": [
            "leaf"
          ],
          "line": 4766
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3075-3078",
          "snippet": "static inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr_offset",
          "args": [
            "slot"
          ],
          "line": 4761
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2622-2626",
          "snippet": "static inline unsigned long btrfs_item_nr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_leaf, items) +\n\t\tsizeof(struct btrfs_item) * nr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_item_nr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_leaf, items) +\n\t\tsizeof(struct btrfs_item) * nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_item_offset",
          "args": [
            "leaf",
            "item",
            "ioff - total_data",
            "&token"
          ],
          "line": 4756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_token_item_offset",
          "args": [
            "leaf",
            "item",
            "&token"
          ],
          "line": 4755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 4745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "root->fs_info",
            "\"slot %d old_data %d data_end %d\"",
            "slot",
            "old_data",
            "data_end"
          ],
          "line": 4743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_end_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 4739
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_end_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2639-2642",
          "snippet": "static inline u32 btrfs_item_end_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_end(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_end_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_end(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 4735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "root->fs_info",
            "\"not enough freespace need %u have %d\"",
            "total_size",
            "btrfs_leaf_free_space(root, leaf)"
          ],
          "line": 4733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_data_end",
          "args": [
            "root",
            "leaf"
          ],
          "line": 4729
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1729-1736",
          "snippet": "static inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 4728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_map_token",
          "args": [
            "&token"
          ],
          "line": 4723
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_map_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2214-2217",
          "snippet": "static inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_unlock_up_safe",
          "args": [
            "path",
            "1"
          ],
          "line": 4721
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unlock_up_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2413-2428",
          "snippet": "noinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nnoinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_low_keys",
          "args": [
            "root",
            "path",
            "&disk_key",
            "1"
          ],
          "line": 4719
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_low_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3129-3146",
          "snippet": "static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "btrfs_extend_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4634-4697",
    "snippet": "void btrfs_extend_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       u32 data_size)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data;\n\tunsigned int old_size;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < data_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n\tslot = path->slots[0];\n\told_data = btrfs_item_end_nr(leaf, slot);\n\n\tBUG_ON(slot < 0);\n\tif (slot >= nritems) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"slot %d too large, nritems %d\",\n\t\t       slot, nritems);\n\t\tBUG_ON(1);\n\t}\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff - data_size, &token);\n\t}\n\n\t/* shift the data */\n\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t      data_end - data_size, btrfs_leaf_data(leaf) +\n\t\t      data_end, old_data - data_end);\n\n\tdata_end = old_data;\n\told_size = btrfs_item_size_nr(leaf, slot);\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, old_size + data_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_print_leaf",
          "args": [
            "root",
            "leaf"
          ],
          "line": 4694
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_print_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/print-tree.c",
          "lines": "172-311",
          "snippet": "void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)\n{\n\tint i;\n\tu32 type, nr;\n\tstruct btrfs_item *item;\n\tstruct btrfs_root_item *ri;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_block_group_item *bi;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_extent_data_ref *dref;\n\tstruct btrfs_shared_data_ref *sref;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\n\tif (!l)\n\t\treturn;\n\n\tnr = btrfs_header_nritems(l);\n\n\tbtrfs_info(root->fs_info, \"leaf %llu total ptrs %d free space %d\",\n\t\t   btrfs_header_bytenr(l), nr, btrfs_leaf_free_space(root, l));\n\tfor (i = 0 ; i < nr ; i++) {\n\t\titem = btrfs_item_nr(i);\n\t\tbtrfs_item_key_to_cpu(l, &key, i);\n\t\ttype = key.type;\n\t\tprintk(KERN_INFO \"\\titem %d key (%llu %u %llu) itemoff %d \"\n\t\t       \"itemsize %d\\n\",\n\t\t\ti, key.objectid, type, key.offset,\n\t\t\tbtrfs_item_offset(l, item), btrfs_item_size(l, item));\n\t\tswitch (type) {\n\t\tcase BTRFS_INODE_ITEM_KEY:\n\t\t\tii = btrfs_item_ptr(l, i, struct btrfs_inode_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tinode generation %llu size %llu \"\n\t\t\t       \"mode %o\\n\",\n\t\t\t       btrfs_inode_generation(l, ii),\n\t\t\t       btrfs_inode_size(l, ii),\n\t\t\t       btrfs_inode_mode(l, ii));\n\t\t\tbreak;\n\t\tcase BTRFS_DIR_ITEM_KEY:\n\t\t\tdi = btrfs_item_ptr(l, i, struct btrfs_dir_item);\n\t\t\tbtrfs_dir_item_key_to_cpu(l, di, &found_key);\n\t\t\tprintk(KERN_INFO \"\\t\\tdir oid %llu type %u\\n\",\n\t\t\t\tfound_key.objectid,\n\t\t\t\tbtrfs_dir_type(l, di));\n\t\t\tbreak;\n\t\tcase BTRFS_ROOT_ITEM_KEY:\n\t\t\tri = btrfs_item_ptr(l, i, struct btrfs_root_item);\n\t\t\tprintk(KERN_INFO \"\\t\\troot data bytenr %llu refs %u\\n\",\n\t\t\t\tbtrfs_disk_root_bytenr(l, ri),\n\t\t\t\tbtrfs_disk_root_refs(l, ri));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_ITEM_KEY:\n\t\tcase BTRFS_METADATA_ITEM_KEY:\n\t\t\tprint_extent_item(l, i, type);\n\t\t\tbreak;\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\ttree block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tshared block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_extent_data_ref);\n\t\t\tprint_extent_data_ref(l, dref);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_shared_data_ref);\n\t\t\tprintk(KERN_INFO \"\\t\\tshared data backref count %u\\n\",\n\t\t\t       btrfs_shared_data_ref_count(l, sref));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_KEY:\n\t\t\tfi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tif (btrfs_file_extent_type(l, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tprintk(KERN_INFO \"\\t\\tinline extent data \"\n\t\t\t\t       \"size %u\\n\",\n\t\t\t\t       btrfs_file_extent_inline_len(l, i, fi));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_INFO \"\\t\\textent data disk bytenr %llu \"\n\t\t\t       \"nr %llu\\n\",\n\t\t\t       btrfs_file_extent_disk_bytenr(l, fi),\n\t\t\t       btrfs_file_extent_disk_num_bytes(l, fi));\n\t\t\tprintk(KERN_INFO \"\\t\\textent data offset %llu \"\n\t\t\t       \"nr %llu ram %llu\\n\",\n\t\t\t       btrfs_file_extent_offset(l, fi),\n\t\t\t       btrfs_file_extent_num_bytes(l, fi),\n\t\t\t       btrfs_file_extent_ram_bytes(l, fi));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_REF_V0_KEY:\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tprint_extent_ref_v0(l, i);\n#else\n\t\t\tBUG();\n#endif\n\t\t\tbreak;\n\t\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:\n\t\t\tbi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_block_group_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tblock group used %llu\\n\",\n\t\t\t       btrfs_disk_block_group_used(l, bi));\n\t\t\tbreak;\n\t\tcase BTRFS_CHUNK_ITEM_KEY:\n\t\t\tprint_chunk(l, btrfs_item_ptr(l, i,\n\t\t\t\t\t\t      struct btrfs_chunk));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_ITEM_KEY:\n\t\t\tprint_dev_item(l, btrfs_item_ptr(l, i,\n\t\t\t\t\tstruct btrfs_dev_item));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_EXTENT_KEY:\n\t\t\tdev_extent = btrfs_item_ptr(l, i,\n\t\t\t\t\t\t    struct btrfs_dev_extent);\n\t\t\tprintk(KERN_INFO \"\\t\\tdev extent chunk_tree %llu\\n\"\n\t\t\t       \"\\t\\tchunk objectid %llu chunk offset %llu \"\n\t\t\t       \"length %llu\\n\",\n\t\t\t       btrfs_dev_extent_chunk_tree(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_objectid(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_offset(l, dev_extent),\n\t\t\t       btrfs_dev_extent_length(l, dev_extent));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_STATS_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdevice stats\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_REPLACE_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdev replace\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_UUID_KEY_SUBVOL:\n\t\tcase BTRFS_UUID_KEY_RECEIVED_SUBVOL:\n\t\t\tprint_uuid_item(l, btrfs_item_ptr_offset(l, i),\n\t\t\t\t\tbtrfs_item_size_nr(l, i));\n\t\t\tbreak;\n\t\t};\n\t}\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nvoid btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)\n{\n\tint i;\n\tu32 type, nr;\n\tstruct btrfs_item *item;\n\tstruct btrfs_root_item *ri;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_block_group_item *bi;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_extent_data_ref *dref;\n\tstruct btrfs_shared_data_ref *sref;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\n\tif (!l)\n\t\treturn;\n\n\tnr = btrfs_header_nritems(l);\n\n\tbtrfs_info(root->fs_info, \"leaf %llu total ptrs %d free space %d\",\n\t\t   btrfs_header_bytenr(l), nr, btrfs_leaf_free_space(root, l));\n\tfor (i = 0 ; i < nr ; i++) {\n\t\titem = btrfs_item_nr(i);\n\t\tbtrfs_item_key_to_cpu(l, &key, i);\n\t\ttype = key.type;\n\t\tprintk(KERN_INFO \"\\titem %d key (%llu %u %llu) itemoff %d \"\n\t\t       \"itemsize %d\\n\",\n\t\t\ti, key.objectid, type, key.offset,\n\t\t\tbtrfs_item_offset(l, item), btrfs_item_size(l, item));\n\t\tswitch (type) {\n\t\tcase BTRFS_INODE_ITEM_KEY:\n\t\t\tii = btrfs_item_ptr(l, i, struct btrfs_inode_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tinode generation %llu size %llu \"\n\t\t\t       \"mode %o\\n\",\n\t\t\t       btrfs_inode_generation(l, ii),\n\t\t\t       btrfs_inode_size(l, ii),\n\t\t\t       btrfs_inode_mode(l, ii));\n\t\t\tbreak;\n\t\tcase BTRFS_DIR_ITEM_KEY:\n\t\t\tdi = btrfs_item_ptr(l, i, struct btrfs_dir_item);\n\t\t\tbtrfs_dir_item_key_to_cpu(l, di, &found_key);\n\t\t\tprintk(KERN_INFO \"\\t\\tdir oid %llu type %u\\n\",\n\t\t\t\tfound_key.objectid,\n\t\t\t\tbtrfs_dir_type(l, di));\n\t\t\tbreak;\n\t\tcase BTRFS_ROOT_ITEM_KEY:\n\t\t\tri = btrfs_item_ptr(l, i, struct btrfs_root_item);\n\t\t\tprintk(KERN_INFO \"\\t\\troot data bytenr %llu refs %u\\n\",\n\t\t\t\tbtrfs_disk_root_bytenr(l, ri),\n\t\t\t\tbtrfs_disk_root_refs(l, ri));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_ITEM_KEY:\n\t\tcase BTRFS_METADATA_ITEM_KEY:\n\t\t\tprint_extent_item(l, i, type);\n\t\t\tbreak;\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\ttree block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tshared block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_extent_data_ref);\n\t\t\tprint_extent_data_ref(l, dref);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_shared_data_ref);\n\t\t\tprintk(KERN_INFO \"\\t\\tshared data backref count %u\\n\",\n\t\t\t       btrfs_shared_data_ref_count(l, sref));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_KEY:\n\t\t\tfi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tif (btrfs_file_extent_type(l, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tprintk(KERN_INFO \"\\t\\tinline extent data \"\n\t\t\t\t       \"size %u\\n\",\n\t\t\t\t       btrfs_file_extent_inline_len(l, i, fi));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_INFO \"\\t\\textent data disk bytenr %llu \"\n\t\t\t       \"nr %llu\\n\",\n\t\t\t       btrfs_file_extent_disk_bytenr(l, fi),\n\t\t\t       btrfs_file_extent_disk_num_bytes(l, fi));\n\t\t\tprintk(KERN_INFO \"\\t\\textent data offset %llu \"\n\t\t\t       \"nr %llu ram %llu\\n\",\n\t\t\t       btrfs_file_extent_offset(l, fi),\n\t\t\t       btrfs_file_extent_num_bytes(l, fi),\n\t\t\t       btrfs_file_extent_ram_bytes(l, fi));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_REF_V0_KEY:\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tprint_extent_ref_v0(l, i);\n#else\n\t\t\tBUG();\n#endif\n\t\t\tbreak;\n\t\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:\n\t\t\tbi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_block_group_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tblock group used %llu\\n\",\n\t\t\t       btrfs_disk_block_group_used(l, bi));\n\t\t\tbreak;\n\t\tcase BTRFS_CHUNK_ITEM_KEY:\n\t\t\tprint_chunk(l, btrfs_item_ptr(l, i,\n\t\t\t\t\t\t      struct btrfs_chunk));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_ITEM_KEY:\n\t\t\tprint_dev_item(l, btrfs_item_ptr(l, i,\n\t\t\t\t\tstruct btrfs_dev_item));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_EXTENT_KEY:\n\t\t\tdev_extent = btrfs_item_ptr(l, i,\n\t\t\t\t\t\t    struct btrfs_dev_extent);\n\t\t\tprintk(KERN_INFO \"\\t\\tdev extent chunk_tree %llu\\n\"\n\t\t\t       \"\\t\\tchunk objectid %llu chunk offset %llu \"\n\t\t\t       \"length %llu\\n\",\n\t\t\t       btrfs_dev_extent_chunk_tree(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_objectid(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_offset(l, dev_extent),\n\t\t\t       btrfs_dev_extent_length(l, dev_extent));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_STATS_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdevice stats\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_REPLACE_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdev replace\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_UUID_KEY_SUBVOL:\n\t\tcase BTRFS_UUID_KEY_RECEIVED_SUBVOL:\n\t\t\tprint_uuid_item(l, btrfs_item_ptr_offset(l, i),\n\t\t\t\t\tbtrfs_item_size_nr(l, i));\n\t\t\tbreak;\n\t\t};\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "leaf"
          ],
          "line": 4693
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 4691
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_size",
          "args": [
            "leaf",
            "item",
            "old_size + data_size"
          ],
          "line": 4690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "slot"
          ],
          "line": 4689
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 4688
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "leaf",
            "btrfs_leaf_data(leaf) +\n\t\t      data_end - data_size",
            "btrfs_leaf_data(leaf) +\n\t\t      data_end",
            "old_data - data_end"
          ],
          "line": 4683
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_data",
          "args": [
            "leaf"
          ],
          "line": 4684
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3075-3078",
          "snippet": "static inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_item_offset",
          "args": [
            "leaf",
            "item",
            "ioff - data_size",
            "&token"
          ],
          "line": 4678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_token_item_offset",
          "args": [
            "leaf",
            "item",
            "&token"
          ],
          "line": 4677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 4666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "root->fs_info",
            "\"slot %d too large, nritems %d\"",
            "slot",
            "nritems"
          ],
          "line": 4664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "slot < 0"
          ],
          "line": 4661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_end_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 4659
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_end_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2639-2642",
          "snippet": "static inline u32 btrfs_item_end_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_end(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_end_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_end(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 4656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_data_end",
          "args": [
            "root",
            "leaf"
          ],
          "line": 4652
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1729-1736",
          "snippet": "static inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 4651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_map_token",
          "args": [
            "&token"
          ],
          "line": 4647
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_map_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2214-2217",
          "snippet": "static inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid btrfs_extend_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t       u32 data_size)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data;\n\tunsigned int old_size;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < data_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n\tslot = path->slots[0];\n\told_data = btrfs_item_end_nr(leaf, slot);\n\n\tBUG_ON(slot < 0);\n\tif (slot >= nritems) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"slot %d too large, nritems %d\",\n\t\t       slot, nritems);\n\t\tBUG_ON(1);\n\t}\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff - data_size, &token);\n\t}\n\n\t/* shift the data */\n\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t      data_end - data_size, btrfs_leaf_data(leaf) +\n\t\t      data_end, old_data - data_end);\n\n\tdata_end = old_data;\n\told_size = btrfs_item_size_nr(leaf, slot);\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, old_size + data_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "btrfs_truncate_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4535-4629",
    "snippet": "void btrfs_truncate_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t u32 new_size, int from_end)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data_start;\n\tunsigned int old_size;\n\tunsigned int size_diff;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\told_size = btrfs_item_size_nr(leaf, slot);\n\tif (old_size == new_size)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\told_data_start = btrfs_item_offset_nr(leaf, slot);\n\n\tsize_diff = old_size - new_size;\n\n\tBUG_ON(slot < 0);\n\tBUG_ON(slot >= nritems);\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff + size_diff, &token);\n\t}\n\n\t/* shift the data */\n\tif (from_end) {\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start + new_size - data_end);\n\t} else {\n\t\tstruct btrfs_disk_key disk_key;\n\t\tu64 offset;\n\n\t\tbtrfs_item_key(leaf, &disk_key, slot);\n\n\t\tif (btrfs_disk_key_type(&disk_key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tunsigned long ptr;\n\t\t\tstruct btrfs_file_extent_item *fi;\n\n\t\t\tfi = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tfi = (struct btrfs_file_extent_item *)(\n\t\t\t     (unsigned long)fi - size_diff);\n\n\t\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\tmemmove_extent_buffer(leaf, ptr,\n\t\t\t\t      (unsigned long)fi,\n\t\t\t\t      BTRFS_FILE_EXTENT_INLINE_DATA_START);\n\t\t\t}\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start - data_end);\n\n\t\toffset = btrfs_disk_key_offset(&disk_key);\n\t\tbtrfs_set_disk_key_offset(&disk_key, offset + size_diff);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\t\tif (slot == 0)\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, new_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 4627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_print_leaf",
          "args": [
            "root",
            "leaf"
          ],
          "line": 4626
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_print_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/print-tree.c",
          "lines": "172-311",
          "snippet": "void btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)\n{\n\tint i;\n\tu32 type, nr;\n\tstruct btrfs_item *item;\n\tstruct btrfs_root_item *ri;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_block_group_item *bi;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_extent_data_ref *dref;\n\tstruct btrfs_shared_data_ref *sref;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\n\tif (!l)\n\t\treturn;\n\n\tnr = btrfs_header_nritems(l);\n\n\tbtrfs_info(root->fs_info, \"leaf %llu total ptrs %d free space %d\",\n\t\t   btrfs_header_bytenr(l), nr, btrfs_leaf_free_space(root, l));\n\tfor (i = 0 ; i < nr ; i++) {\n\t\titem = btrfs_item_nr(i);\n\t\tbtrfs_item_key_to_cpu(l, &key, i);\n\t\ttype = key.type;\n\t\tprintk(KERN_INFO \"\\titem %d key (%llu %u %llu) itemoff %d \"\n\t\t       \"itemsize %d\\n\",\n\t\t\ti, key.objectid, type, key.offset,\n\t\t\tbtrfs_item_offset(l, item), btrfs_item_size(l, item));\n\t\tswitch (type) {\n\t\tcase BTRFS_INODE_ITEM_KEY:\n\t\t\tii = btrfs_item_ptr(l, i, struct btrfs_inode_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tinode generation %llu size %llu \"\n\t\t\t       \"mode %o\\n\",\n\t\t\t       btrfs_inode_generation(l, ii),\n\t\t\t       btrfs_inode_size(l, ii),\n\t\t\t       btrfs_inode_mode(l, ii));\n\t\t\tbreak;\n\t\tcase BTRFS_DIR_ITEM_KEY:\n\t\t\tdi = btrfs_item_ptr(l, i, struct btrfs_dir_item);\n\t\t\tbtrfs_dir_item_key_to_cpu(l, di, &found_key);\n\t\t\tprintk(KERN_INFO \"\\t\\tdir oid %llu type %u\\n\",\n\t\t\t\tfound_key.objectid,\n\t\t\t\tbtrfs_dir_type(l, di));\n\t\t\tbreak;\n\t\tcase BTRFS_ROOT_ITEM_KEY:\n\t\t\tri = btrfs_item_ptr(l, i, struct btrfs_root_item);\n\t\t\tprintk(KERN_INFO \"\\t\\troot data bytenr %llu refs %u\\n\",\n\t\t\t\tbtrfs_disk_root_bytenr(l, ri),\n\t\t\t\tbtrfs_disk_root_refs(l, ri));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_ITEM_KEY:\n\t\tcase BTRFS_METADATA_ITEM_KEY:\n\t\t\tprint_extent_item(l, i, type);\n\t\t\tbreak;\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\ttree block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tshared block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_extent_data_ref);\n\t\t\tprint_extent_data_ref(l, dref);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_shared_data_ref);\n\t\t\tprintk(KERN_INFO \"\\t\\tshared data backref count %u\\n\",\n\t\t\t       btrfs_shared_data_ref_count(l, sref));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_KEY:\n\t\t\tfi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tif (btrfs_file_extent_type(l, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tprintk(KERN_INFO \"\\t\\tinline extent data \"\n\t\t\t\t       \"size %u\\n\",\n\t\t\t\t       btrfs_file_extent_inline_len(l, i, fi));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_INFO \"\\t\\textent data disk bytenr %llu \"\n\t\t\t       \"nr %llu\\n\",\n\t\t\t       btrfs_file_extent_disk_bytenr(l, fi),\n\t\t\t       btrfs_file_extent_disk_num_bytes(l, fi));\n\t\t\tprintk(KERN_INFO \"\\t\\textent data offset %llu \"\n\t\t\t       \"nr %llu ram %llu\\n\",\n\t\t\t       btrfs_file_extent_offset(l, fi),\n\t\t\t       btrfs_file_extent_num_bytes(l, fi),\n\t\t\t       btrfs_file_extent_ram_bytes(l, fi));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_REF_V0_KEY:\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tprint_extent_ref_v0(l, i);\n#else\n\t\t\tBUG();\n#endif\n\t\t\tbreak;\n\t\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:\n\t\t\tbi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_block_group_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tblock group used %llu\\n\",\n\t\t\t       btrfs_disk_block_group_used(l, bi));\n\t\t\tbreak;\n\t\tcase BTRFS_CHUNK_ITEM_KEY:\n\t\t\tprint_chunk(l, btrfs_item_ptr(l, i,\n\t\t\t\t\t\t      struct btrfs_chunk));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_ITEM_KEY:\n\t\t\tprint_dev_item(l, btrfs_item_ptr(l, i,\n\t\t\t\t\tstruct btrfs_dev_item));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_EXTENT_KEY:\n\t\t\tdev_extent = btrfs_item_ptr(l, i,\n\t\t\t\t\t\t    struct btrfs_dev_extent);\n\t\t\tprintk(KERN_INFO \"\\t\\tdev extent chunk_tree %llu\\n\"\n\t\t\t       \"\\t\\tchunk objectid %llu chunk offset %llu \"\n\t\t\t       \"length %llu\\n\",\n\t\t\t       btrfs_dev_extent_chunk_tree(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_objectid(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_offset(l, dev_extent),\n\t\t\t       btrfs_dev_extent_length(l, dev_extent));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_STATS_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdevice stats\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_REPLACE_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdev replace\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_UUID_KEY_SUBVOL:\n\t\tcase BTRFS_UUID_KEY_RECEIVED_SUBVOL:\n\t\t\tprint_uuid_item(l, btrfs_item_ptr_offset(l, i),\n\t\t\t\t\tbtrfs_item_size_nr(l, i));\n\t\t\tbreak;\n\t\t};\n\t}\n}",
          "includes": [
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nvoid btrfs_print_leaf(struct btrfs_root *root, struct extent_buffer *l)\n{\n\tint i;\n\tu32 type, nr;\n\tstruct btrfs_item *item;\n\tstruct btrfs_root_item *ri;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_inode_item *ii;\n\tstruct btrfs_block_group_item *bi;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct btrfs_extent_data_ref *dref;\n\tstruct btrfs_shared_data_ref *sref;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\n\tif (!l)\n\t\treturn;\n\n\tnr = btrfs_header_nritems(l);\n\n\tbtrfs_info(root->fs_info, \"leaf %llu total ptrs %d free space %d\",\n\t\t   btrfs_header_bytenr(l), nr, btrfs_leaf_free_space(root, l));\n\tfor (i = 0 ; i < nr ; i++) {\n\t\titem = btrfs_item_nr(i);\n\t\tbtrfs_item_key_to_cpu(l, &key, i);\n\t\ttype = key.type;\n\t\tprintk(KERN_INFO \"\\titem %d key (%llu %u %llu) itemoff %d \"\n\t\t       \"itemsize %d\\n\",\n\t\t\ti, key.objectid, type, key.offset,\n\t\t\tbtrfs_item_offset(l, item), btrfs_item_size(l, item));\n\t\tswitch (type) {\n\t\tcase BTRFS_INODE_ITEM_KEY:\n\t\t\tii = btrfs_item_ptr(l, i, struct btrfs_inode_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tinode generation %llu size %llu \"\n\t\t\t       \"mode %o\\n\",\n\t\t\t       btrfs_inode_generation(l, ii),\n\t\t\t       btrfs_inode_size(l, ii),\n\t\t\t       btrfs_inode_mode(l, ii));\n\t\t\tbreak;\n\t\tcase BTRFS_DIR_ITEM_KEY:\n\t\t\tdi = btrfs_item_ptr(l, i, struct btrfs_dir_item);\n\t\t\tbtrfs_dir_item_key_to_cpu(l, di, &found_key);\n\t\t\tprintk(KERN_INFO \"\\t\\tdir oid %llu type %u\\n\",\n\t\t\t\tfound_key.objectid,\n\t\t\t\tbtrfs_dir_type(l, di));\n\t\t\tbreak;\n\t\tcase BTRFS_ROOT_ITEM_KEY:\n\t\t\tri = btrfs_item_ptr(l, i, struct btrfs_root_item);\n\t\t\tprintk(KERN_INFO \"\\t\\troot data bytenr %llu refs %u\\n\",\n\t\t\t\tbtrfs_disk_root_bytenr(l, ri),\n\t\t\t\tbtrfs_disk_root_refs(l, ri));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_ITEM_KEY:\n\t\tcase BTRFS_METADATA_ITEM_KEY:\n\t\t\tprint_extent_item(l, i, type);\n\t\t\tbreak;\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\ttree block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tshared block backref\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY:\n\t\t\tdref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_extent_data_ref);\n\t\t\tprint_extent_data_ref(l, dref);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY:\n\t\t\tsref = btrfs_item_ptr(l, i,\n\t\t\t\t\t      struct btrfs_shared_data_ref);\n\t\t\tprintk(KERN_INFO \"\\t\\tshared data backref count %u\\n\",\n\t\t\t       btrfs_shared_data_ref_count(l, sref));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_KEY:\n\t\t\tfi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tif (btrfs_file_extent_type(l, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tprintk(KERN_INFO \"\\t\\tinline extent data \"\n\t\t\t\t       \"size %u\\n\",\n\t\t\t\t       btrfs_file_extent_inline_len(l, i, fi));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_INFO \"\\t\\textent data disk bytenr %llu \"\n\t\t\t       \"nr %llu\\n\",\n\t\t\t       btrfs_file_extent_disk_bytenr(l, fi),\n\t\t\t       btrfs_file_extent_disk_num_bytes(l, fi));\n\t\t\tprintk(KERN_INFO \"\\t\\textent data offset %llu \"\n\t\t\t       \"nr %llu ram %llu\\n\",\n\t\t\t       btrfs_file_extent_offset(l, fi),\n\t\t\t       btrfs_file_extent_num_bytes(l, fi),\n\t\t\t       btrfs_file_extent_ram_bytes(l, fi));\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_REF_V0_KEY:\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tprint_extent_ref_v0(l, i);\n#else\n\t\t\tBUG();\n#endif\n\t\t\tbreak;\n\t\tcase BTRFS_BLOCK_GROUP_ITEM_KEY:\n\t\t\tbi = btrfs_item_ptr(l, i,\n\t\t\t\t\t    struct btrfs_block_group_item);\n\t\t\tprintk(KERN_INFO \"\\t\\tblock group used %llu\\n\",\n\t\t\t       btrfs_disk_block_group_used(l, bi));\n\t\t\tbreak;\n\t\tcase BTRFS_CHUNK_ITEM_KEY:\n\t\t\tprint_chunk(l, btrfs_item_ptr(l, i,\n\t\t\t\t\t\t      struct btrfs_chunk));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_ITEM_KEY:\n\t\t\tprint_dev_item(l, btrfs_item_ptr(l, i,\n\t\t\t\t\tstruct btrfs_dev_item));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_EXTENT_KEY:\n\t\t\tdev_extent = btrfs_item_ptr(l, i,\n\t\t\t\t\t\t    struct btrfs_dev_extent);\n\t\t\tprintk(KERN_INFO \"\\t\\tdev extent chunk_tree %llu\\n\"\n\t\t\t       \"\\t\\tchunk objectid %llu chunk offset %llu \"\n\t\t\t       \"length %llu\\n\",\n\t\t\t       btrfs_dev_extent_chunk_tree(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_objectid(l, dev_extent),\n\t\t\t       btrfs_dev_extent_chunk_offset(l, dev_extent),\n\t\t\t       btrfs_dev_extent_length(l, dev_extent));\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_STATS_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdevice stats\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_DEV_REPLACE_KEY:\n\t\t\tprintk(KERN_INFO \"\\t\\tdev replace\\n\");\n\t\t\tbreak;\n\t\tcase BTRFS_UUID_KEY_SUBVOL:\n\t\tcase BTRFS_UUID_KEY_RECEIVED_SUBVOL:\n\t\t\tprint_uuid_item(l, btrfs_item_ptr_offset(l, i),\n\t\t\t\t\tbtrfs_item_size_nr(l, i));\n\t\t\tbreak;\n\t\t};\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "leaf"
          ],
          "line": 4625
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 4623
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_size",
          "args": [
            "leaf",
            "item",
            "new_size"
          ],
          "line": 4622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "slot"
          ],
          "line": 4621
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_low_keys",
          "args": [
            "root",
            "path",
            "&disk_key",
            "1"
          ],
          "line": 4618
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_low_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3129-3146",
          "snippet": "static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_key",
          "args": [
            "leaf",
            "&disk_key",
            "slot"
          ],
          "line": 4616
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_item_key_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3154-3177",
          "snippet": "void btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nvoid btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_disk_key_offset",
          "args": [
            "&disk_key",
            "offset + size_diff"
          ],
          "line": 4615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_offset",
          "args": [
            "&disk_key"
          ],
          "line": 4614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "leaf",
            "btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff",
            "btrfs_leaf_data(leaf) +\n\t\t\t      data_end",
            "old_data_start - data_end"
          ],
          "line": 4610
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_data",
          "args": [
            "leaf"
          ],
          "line": 4611
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3075-3078",
          "snippet": "static inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 4603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 4601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_file_extent_item"
          ],
          "line": 4596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_type",
          "args": [
            "&disk_key"
          ],
          "line": 4592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key",
          "args": [
            "leaf",
            "&disk_key",
            "slot"
          ],
          "line": 4590
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_item_offset",
          "args": [
            "leaf",
            "item",
            "ioff + size_diff",
            "&token"
          ],
          "line": 4577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_token_item_offset",
          "args": [
            "leaf",
            "item",
            "&token"
          ],
          "line": 4576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "slot >= nritems"
          ],
          "line": 4566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "slot < 0"
          ],
          "line": 4565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_offset_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 4561
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_offset_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2644-2647",
          "snippet": "static inline u32 btrfs_item_offset_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_offset(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_offset_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_offset(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_data_end",
          "args": [
            "root",
            "leaf"
          ],
          "line": 4559
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1729-1736",
          "snippet": "static inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 4558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 4554
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_map_token",
          "args": [
            "&token"
          ],
          "line": 4549
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_map_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2214-2217",
          "snippet": "static inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid btrfs_truncate_item(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t u32 new_size, int from_end)\n{\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tu32 nritems;\n\tunsigned int data_end;\n\tunsigned int old_data_start;\n\tunsigned int old_size;\n\tunsigned int size_diff;\n\tint i;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\told_size = btrfs_item_size_nr(leaf, slot);\n\tif (old_size == new_size)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\told_data_start = btrfs_item_offset_nr(leaf, slot);\n\n\tsize_diff = old_size - new_size;\n\n\tBUG_ON(slot < 0);\n\tBUG_ON(slot >= nritems);\n\n\t/*\n\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t */\n\t/* first correct the data pointers */\n\tfor (i = slot; i < nritems; i++) {\n\t\tu32 ioff;\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    ioff + size_diff, &token);\n\t}\n\n\t/* shift the data */\n\tif (from_end) {\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start + new_size - data_end);\n\t} else {\n\t\tstruct btrfs_disk_key disk_key;\n\t\tu64 offset;\n\n\t\tbtrfs_item_key(leaf, &disk_key, slot);\n\n\t\tif (btrfs_disk_key_type(&disk_key) == BTRFS_EXTENT_DATA_KEY) {\n\t\t\tunsigned long ptr;\n\t\t\tstruct btrfs_file_extent_item *fi;\n\n\t\t\tfi = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t    struct btrfs_file_extent_item);\n\t\t\tfi = (struct btrfs_file_extent_item *)(\n\t\t\t     (unsigned long)fi - size_diff);\n\n\t\t\tif (btrfs_file_extent_type(leaf, fi) ==\n\t\t\t    BTRFS_FILE_EXTENT_INLINE) {\n\t\t\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\t\t\tmemmove_extent_buffer(leaf, ptr,\n\t\t\t\t      (unsigned long)fi,\n\t\t\t\t      BTRFS_FILE_EXTENT_INLINE_DATA_START);\n\t\t\t}\n\t\t}\n\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end + size_diff, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data_start - data_end);\n\n\t\toffset = btrfs_disk_key_offset(&disk_key);\n\t\tbtrfs_set_disk_key_offset(&disk_key, offset + size_diff);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\t\tif (slot == 0)\n\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\n\titem = btrfs_item_nr(slot);\n\tbtrfs_set_item_size(leaf, item, new_size);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "btrfs_duplicate_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4501-4527",
    "snippet": "int btrfs_duplicate_item(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path,\n\t\t\t struct btrfs_key *new_key)\n{\n\tstruct extent_buffer *leaf;\n\tint ret;\n\tu32 item_size;\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   item_size + sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tpath->slots[0]++;\n\tsetup_items_for_insert(root, path, new_key, &item_size,\n\t\t\t       item_size, item_size +\n\t\t\t       sizeof(struct btrfs_item), 1);\n\tleaf = path->nodes[0];\n\tmemcpy_extent_buffer(leaf,\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0] - 1),\n\t\t\t     item_size);\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy_extent_buffer",
          "args": [
            "leaf",
            "btrfs_item_ptr_offset(leaf, path->slots[0])",
            "btrfs_item_ptr_offset(leaf, path->slots[0] - 1)",
            "item_size"
          ],
          "line": 4522
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5477-5519",
          "snippet": "void memcpy_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\n\twhile (len > 0) {\n\t\tdst_off_in_page = (start_offset + dst_offset) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_offset) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tdst_i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_offset) >> PAGE_CACHE_SHIFT;\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE -\n\t\t\t\t\t       src_off_in_page));\n\t\tcur = min_t(unsigned long, cur,\n\t\t\t(unsigned long)(PAGE_CACHE_SIZE - dst_off_in_page));\n\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page, src_off_in_page, cur);\n\n\t\tsrc_offset += cur;\n\t\tdst_offset += cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memcpy_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu dst len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\n\twhile (len > 0) {\n\t\tdst_off_in_page = (start_offset + dst_offset) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_offset) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tdst_i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_offset) >> PAGE_CACHE_SHIFT;\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE -\n\t\t\t\t\t       src_off_in_page));\n\t\tcur = min_t(unsigned long, cur,\n\t\t\t(unsigned long)(PAGE_CACHE_SIZE - dst_off_in_page));\n\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page, src_off_in_page, cur);\n\n\t\tsrc_offset += cur;\n\t\tdst_offset += cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "path->slots[0] - 1"
          ],
          "line": 4524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 4523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_items_for_insert",
          "args": [
            "root",
            "path",
            "new_key",
            "&item_size",
            "item_size",
            "item_size +\n\t\t\t       sizeof(struct btrfs_item)",
            "1"
          ],
          "line": 4518
        },
        "resolved": true,
        "details": {
          "function_name": "setup_items_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4704-4789",
          "snippet": "void setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nvoid setup_items_for_insert(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t    struct btrfs_key *cpu_key, u32 *data_size,\n\t\t\t    u32 total_data, u32 total_size, int nr)\n{\n\tstruct btrfs_item *item;\n\tint i;\n\tu32 nritems;\n\tunsigned int data_end;\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_map_token token;\n\n\tif (path->slots[0] == 0) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key);\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t}\n\tbtrfs_unlock_up_safe(path, 1);\n\n\tbtrfs_init_map_token(&token);\n\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\tnritems = btrfs_header_nritems(leaf);\n\tdata_end = leaf_data_end(root, leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < total_size) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tbtrfs_crit(root->fs_info, \"not enough freespace need %u have %d\",\n\t\t       total_size, btrfs_leaf_free_space(root, leaf));\n\t\tBUG();\n\t}\n\n\tif (slot != nritems) {\n\t\tunsigned int old_data = btrfs_item_end_nr(leaf, slot);\n\n\t\tif (old_data < data_end) {\n\t\t\tbtrfs_print_leaf(root, leaf);\n\t\t\tbtrfs_crit(root->fs_info, \"slot %d old_data %d data_end %d\",\n\t\t\t       slot, old_data, data_end);\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t/*\n\t\t * item0..itemN ... dataN.offset..dataN.size .. data0.size\n\t\t */\n\t\t/* first correct the data pointers */\n\t\tfor (i = slot; i < nritems; i++) {\n\t\t\tu32 ioff;\n\n\t\t\titem = btrfs_item_nr( i);\n\t\t\tioff = btrfs_token_item_offset(leaf, item, &token);\n\t\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t\t    ioff - total_data, &token);\n\t\t}\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + nr),\n\t\t\t      btrfs_item_nr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_item));\n\n\t\t/* shift the data */\n\t\tmemmove_extent_buffer(leaf, btrfs_leaf_data(leaf) +\n\t\t\t      data_end - total_data, btrfs_leaf_data(leaf) +\n\t\t\t      data_end, old_data - data_end);\n\t\tdata_end = old_data;\n\t}\n\n\t/* setup the item for the new data */\n\tfor (i = 0; i < nr; i++) {\n\t\tbtrfs_cpu_key_to_disk(&disk_key, cpu_key + i);\n\t\tbtrfs_set_item_key(leaf, &disk_key, slot + i);\n\t\titem = btrfs_item_nr(slot + i);\n\t\tbtrfs_set_token_item_offset(leaf, item,\n\t\t\t\t\t    data_end - data_size[i], &token);\n\t\tdata_end -= data_size[i];\n\t\tbtrfs_set_token_item_size(leaf, item, data_size[i], &token);\n\t}\n\n\tbtrfs_set_header_nritems(leaf, nritems + nr);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tif (btrfs_leaf_free_space(root, leaf) < 0) {\n\t\tbtrfs_print_leaf(root, leaf);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_leaf_for_split",
          "args": [
            "trans",
            "root",
            "path",
            "item_size + sizeof(struct btrfs_item)"
          ],
          "line": 4512
        },
        "resolved": true,
        "details": {
          "function_name": "setup_leaf_for_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4324-4389",
          "snippet": "static noinline int setup_leaf_for_split(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_path *path, int ins_len)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_len = 0;\n\tu32 item_size;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\tBUG_ON(key.type != BTRFS_EXTENT_DATA_KEY &&\n\t       key.type != BTRFS_EXTENT_CSUM_KEY);\n\n\tif (btrfs_leaf_free_space(root, leaf) >= ins_len)\n\t\treturn 0;\n\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_len = btrfs_file_extent_num_bytes(leaf, fi);\n\t}\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->search_for_split = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tpath->search_for_split = 0;\n\tif (ret > 0)\n\t\tret = -EAGAIN;\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = -EAGAIN;\n\tleaf = path->nodes[0];\n\t/* if our item isn't there, return now */\n\tif (item_size != btrfs_item_size_nr(leaf, path->slots[0]))\n\t\tgoto err;\n\n\t/* the leaf has  changed, it now has room.  return now */\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= ins_len)\n\t\tgoto err;\n\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tif (extent_len != btrfs_file_extent_num_bytes(leaf, fi))\n\t\t\tgoto err;\n\t}\n\n\tbtrfs_set_path_blocking(path);\n\tret = split_leaf(trans, root, &key, path, ins_len, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tpath->keep_locks = 0;\n\tbtrfs_unlock_up_safe(path, 1);\n\treturn 0;\nerr:\n\tpath->keep_locks = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int setup_leaf_for_split(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_path *path, int ins_len)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_len = 0;\n\tu32 item_size;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\tBUG_ON(key.type != BTRFS_EXTENT_DATA_KEY &&\n\t       key.type != BTRFS_EXTENT_CSUM_KEY);\n\n\tif (btrfs_leaf_free_space(root, leaf) >= ins_len)\n\t\treturn 0;\n\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_len = btrfs_file_extent_num_bytes(leaf, fi);\n\t}\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->search_for_split = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tpath->search_for_split = 0;\n\tif (ret > 0)\n\t\tret = -EAGAIN;\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = -EAGAIN;\n\tleaf = path->nodes[0];\n\t/* if our item isn't there, return now */\n\tif (item_size != btrfs_item_size_nr(leaf, path->slots[0]))\n\t\tgoto err;\n\n\t/* the leaf has  changed, it now has room.  return now */\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= ins_len)\n\t\tgoto err;\n\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tif (extent_len != btrfs_file_extent_num_bytes(leaf, fi))\n\t\t\tgoto err;\n\t}\n\n\tbtrfs_set_path_blocking(path);\n\tret = split_leaf(trans, root, &key, path, ins_len, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tpath->keep_locks = 0;\n\tbtrfs_unlock_up_safe(path, 1);\n\treturn 0;\nerr:\n\tpath->keep_locks = 0;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 4511
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_duplicate_item(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path,\n\t\t\t struct btrfs_key *new_key)\n{\n\tstruct extent_buffer *leaf;\n\tint ret;\n\tu32 item_size;\n\n\tleaf = path->nodes[0];\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   item_size + sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tpath->slots[0]++;\n\tsetup_items_for_insert(root, path, new_key, &item_size,\n\t\t\t       item_size, item_size +\n\t\t\t       sizeof(struct btrfs_item), 1);\n\tleaf = path->nodes[0];\n\tmemcpy_extent_buffer(leaf,\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t     btrfs_item_ptr_offset(leaf, path->slots[0] - 1),\n\t\t\t     item_size);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_split_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4477-4491",
    "snippet": "int btrfs_split_item(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *new_key,\n\t\t     unsigned long split_offset)\n{\n\tint ret;\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tret = split_item(trans, root, path, new_key, split_offset);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "split_item",
          "args": [
            "trans",
            "root",
            "path",
            "new_key",
            "split_offset"
          ],
          "line": 4489
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_split_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4477-4491",
          "snippet": "int btrfs_split_item(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *new_key,\n\t\t     unsigned long split_offset)\n{\n\tint ret;\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tret = split_item(trans, root, path, new_key, split_offset);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "setup_leaf_for_split",
          "args": [
            "trans",
            "root",
            "path",
            "sizeof(struct btrfs_item)"
          ],
          "line": 4484
        },
        "resolved": true,
        "details": {
          "function_name": "setup_leaf_for_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4324-4389",
          "snippet": "static noinline int setup_leaf_for_split(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_path *path, int ins_len)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_len = 0;\n\tu32 item_size;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\tBUG_ON(key.type != BTRFS_EXTENT_DATA_KEY &&\n\t       key.type != BTRFS_EXTENT_CSUM_KEY);\n\n\tif (btrfs_leaf_free_space(root, leaf) >= ins_len)\n\t\treturn 0;\n\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_len = btrfs_file_extent_num_bytes(leaf, fi);\n\t}\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->search_for_split = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tpath->search_for_split = 0;\n\tif (ret > 0)\n\t\tret = -EAGAIN;\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = -EAGAIN;\n\tleaf = path->nodes[0];\n\t/* if our item isn't there, return now */\n\tif (item_size != btrfs_item_size_nr(leaf, path->slots[0]))\n\t\tgoto err;\n\n\t/* the leaf has  changed, it now has room.  return now */\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= ins_len)\n\t\tgoto err;\n\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tif (extent_len != btrfs_file_extent_num_bytes(leaf, fi))\n\t\t\tgoto err;\n\t}\n\n\tbtrfs_set_path_blocking(path);\n\tret = split_leaf(trans, root, &key, path, ins_len, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tpath->keep_locks = 0;\n\tbtrfs_unlock_up_safe(path, 1);\n\treturn 0;\nerr:\n\tpath->keep_locks = 0;\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int setup_leaf_for_split(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_path *path, int ins_len)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_len = 0;\n\tu32 item_size;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\tBUG_ON(key.type != BTRFS_EXTENT_DATA_KEY &&\n\t       key.type != BTRFS_EXTENT_CSUM_KEY);\n\n\tif (btrfs_leaf_free_space(root, leaf) >= ins_len)\n\t\treturn 0;\n\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_len = btrfs_file_extent_num_bytes(leaf, fi);\n\t}\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->search_for_split = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tpath->search_for_split = 0;\n\tif (ret > 0)\n\t\tret = -EAGAIN;\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = -EAGAIN;\n\tleaf = path->nodes[0];\n\t/* if our item isn't there, return now */\n\tif (item_size != btrfs_item_size_nr(leaf, path->slots[0]))\n\t\tgoto err;\n\n\t/* the leaf has  changed, it now has room.  return now */\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= ins_len)\n\t\tgoto err;\n\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tif (extent_len != btrfs_file_extent_num_bytes(leaf, fi))\n\t\t\tgoto err;\n\t}\n\n\tbtrfs_set_path_blocking(path);\n\tret = split_leaf(trans, root, &key, path, ins_len, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tpath->keep_locks = 0;\n\tbtrfs_unlock_up_safe(path, 1);\n\treturn 0;\nerr:\n\tpath->keep_locks = 0;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_split_item(struct btrfs_trans_handle *trans,\n\t\t     struct btrfs_root *root,\n\t\t     struct btrfs_path *path,\n\t\t     struct btrfs_key *new_key,\n\t\t     unsigned long split_offset)\n{\n\tint ret;\n\tret = setup_leaf_for_split(trans, root, path,\n\t\t\t\t   sizeof(struct btrfs_item));\n\tif (ret)\n\t\treturn ret;\n\n\tret = split_item(trans, root, path, new_key, split_offset);\n\treturn ret;\n}"
  },
  {
    "function_name": "split_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4391-4460",
    "snippet": "static noinline int split_item(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *new_key,\n\t\t\t       unsigned long split_offset)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tstruct btrfs_item *new_item;\n\tint slot;\n\tchar *buf;\n\tu32 nritems;\n\tu32 item_size;\n\tu32 orig_offset;\n\tstruct btrfs_disk_key disk_key;\n\n\tleaf = path->nodes[0];\n\tBUG_ON(btrfs_leaf_free_space(root, leaf) < sizeof(struct btrfs_item));\n\n\tbtrfs_set_path_blocking(path);\n\n\titem = btrfs_item_nr(path->slots[0]);\n\torig_offset = btrfs_item_offset(leaf, item);\n\titem_size = btrfs_item_size(leaf, item);\n\n\tbuf = kmalloc(item_size, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(leaf, buf, btrfs_item_ptr_offset(leaf,\n\t\t\t    path->slots[0]), item_size);\n\n\tslot = path->slots[0] + 1;\n\tnritems = btrfs_header_nritems(leaf);\n\tif (slot != nritems) {\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + 1),\n\t\t\t\tbtrfs_item_nr_offset(slot),\n\t\t\t\t(nritems - slot) * sizeof(struct btrfs_item));\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\n\tnew_item = btrfs_item_nr(slot);\n\n\tbtrfs_set_item_offset(leaf, new_item, orig_offset);\n\tbtrfs_set_item_size(leaf, new_item, item_size - split_offset);\n\n\tbtrfs_set_item_offset(leaf, item,\n\t\t\t      orig_offset + item_size - split_offset);\n\tbtrfs_set_item_size(leaf, item, split_offset);\n\n\tbtrfs_set_header_nritems(leaf, nritems + 1);\n\n\t/* write the data for the start of the original item */\n\twrite_extent_buffer(leaf, buf,\n\t\t\t    btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t    split_offset);\n\n\t/* write the data for the new item */\n\twrite_extent_buffer(leaf, buf + split_offset,\n\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t    item_size - split_offset);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tBUG_ON(btrfs_leaf_free_space(root, leaf) < 0);\n\tkfree(buf);\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 4458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "btrfs_leaf_free_space(root, leaf) < 0"
          ],
          "line": 4457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "leaf"
          ],
          "line": 4457
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "leaf"
          ],
          "line": 4455
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "leaf",
            "buf + split_offset",
            "btrfs_item_ptr_offset(leaf, slot)",
            "item_size - split_offset"
          ],
          "line": 4452
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 4448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "leaf",
            "nritems + 1"
          ],
          "line": 4444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_size",
          "args": [
            "leaf",
            "item",
            "split_offset"
          ],
          "line": 4442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_offset",
          "args": [
            "leaf",
            "item",
            "orig_offset + item_size - split_offset"
          ],
          "line": 4440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_size",
          "args": [
            "leaf",
            "new_item",
            "item_size - split_offset"
          ],
          "line": 4438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_offset",
          "args": [
            "leaf",
            "new_item",
            "orig_offset"
          ],
          "line": 4437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "slot"
          ],
          "line": 4435
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_key",
          "args": [
            "leaf",
            "&disk_key",
            "slot"
          ],
          "line": 4433
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_item_key_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3154-3177",
          "snippet": "void btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nvoid btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cpu_key_to_disk",
          "args": [
            "&disk_key",
            "new_key"
          ],
          "line": 4432
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cpu_key_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2739-2745",
          "snippet": "static inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "leaf",
            "btrfs_item_nr_offset(slot + 1)",
            "btrfs_item_nr_offset(slot)",
            "(nritems - slot) * sizeof(struct btrfs_item)"
          ],
          "line": 4427
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr_offset",
          "args": [
            "slot"
          ],
          "line": 4428
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2622-2626",
          "snippet": "static inline unsigned long btrfs_item_nr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_leaf, items) +\n\t\tsizeof(struct btrfs_item) * nr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_item_nr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_leaf, items) +\n\t\tsizeof(struct btrfs_item) * nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 4424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "leaf",
            "buf",
            "btrfs_item_ptr_offset(leaf,\n\t\t\t    path->slots[0])",
            "item_size"
          ],
          "line": 4420
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "item_size",
            "GFP_NOFS"
          ],
          "line": 4416
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size",
          "args": [
            "leaf",
            "item"
          ],
          "line": 4414
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_offset",
          "args": [
            "leaf",
            "item"
          ],
          "line": 4413
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_offset_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2644-2647",
          "snippet": "static inline u32 btrfs_item_offset_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_offset(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_offset_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_offset(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "path"
          ],
          "line": 4410
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "btrfs_leaf_free_space(root, leaf) < sizeof(struct btrfs_item)"
          ],
          "line": 4408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic noinline int split_item(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_path *path,\n\t\t\t       struct btrfs_key *new_key,\n\t\t\t       unsigned long split_offset)\n{\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_item *item;\n\tstruct btrfs_item *new_item;\n\tint slot;\n\tchar *buf;\n\tu32 nritems;\n\tu32 item_size;\n\tu32 orig_offset;\n\tstruct btrfs_disk_key disk_key;\n\n\tleaf = path->nodes[0];\n\tBUG_ON(btrfs_leaf_free_space(root, leaf) < sizeof(struct btrfs_item));\n\n\tbtrfs_set_path_blocking(path);\n\n\titem = btrfs_item_nr(path->slots[0]);\n\torig_offset = btrfs_item_offset(leaf, item);\n\titem_size = btrfs_item_size(leaf, item);\n\n\tbuf = kmalloc(item_size, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tread_extent_buffer(leaf, buf, btrfs_item_ptr_offset(leaf,\n\t\t\t    path->slots[0]), item_size);\n\n\tslot = path->slots[0] + 1;\n\tnritems = btrfs_header_nritems(leaf);\n\tif (slot != nritems) {\n\t\t/* shift the items */\n\t\tmemmove_extent_buffer(leaf, btrfs_item_nr_offset(slot + 1),\n\t\t\t\tbtrfs_item_nr_offset(slot),\n\t\t\t\t(nritems - slot) * sizeof(struct btrfs_item));\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(leaf, &disk_key, slot);\n\n\tnew_item = btrfs_item_nr(slot);\n\n\tbtrfs_set_item_offset(leaf, new_item, orig_offset);\n\tbtrfs_set_item_size(leaf, new_item, item_size - split_offset);\n\n\tbtrfs_set_item_offset(leaf, item,\n\t\t\t      orig_offset + item_size - split_offset);\n\tbtrfs_set_item_size(leaf, item, split_offset);\n\n\tbtrfs_set_header_nritems(leaf, nritems + 1);\n\n\t/* write the data for the start of the original item */\n\twrite_extent_buffer(leaf, buf,\n\t\t\t    btrfs_item_ptr_offset(leaf, path->slots[0]),\n\t\t\t    split_offset);\n\n\t/* write the data for the new item */\n\twrite_extent_buffer(leaf, buf + split_offset,\n\t\t\t    btrfs_item_ptr_offset(leaf, slot),\n\t\t\t    item_size - split_offset);\n\tbtrfs_mark_buffer_dirty(leaf);\n\n\tBUG_ON(btrfs_leaf_free_space(root, leaf) < 0);\n\tkfree(buf);\n\treturn 0;\n}"
  },
  {
    "function_name": "setup_leaf_for_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4324-4389",
    "snippet": "static noinline int setup_leaf_for_split(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_path *path, int ins_len)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_len = 0;\n\tu32 item_size;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\tBUG_ON(key.type != BTRFS_EXTENT_DATA_KEY &&\n\t       key.type != BTRFS_EXTENT_CSUM_KEY);\n\n\tif (btrfs_leaf_free_space(root, leaf) >= ins_len)\n\t\treturn 0;\n\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_len = btrfs_file_extent_num_bytes(leaf, fi);\n\t}\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->search_for_split = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tpath->search_for_split = 0;\n\tif (ret > 0)\n\t\tret = -EAGAIN;\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = -EAGAIN;\n\tleaf = path->nodes[0];\n\t/* if our item isn't there, return now */\n\tif (item_size != btrfs_item_size_nr(leaf, path->slots[0]))\n\t\tgoto err;\n\n\t/* the leaf has  changed, it now has room.  return now */\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= ins_len)\n\t\tgoto err;\n\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tif (extent_len != btrfs_file_extent_num_bytes(leaf, fi))\n\t\t\tgoto err;\n\t}\n\n\tbtrfs_set_path_blocking(path);\n\tret = split_leaf(trans, root, &key, path, ins_len, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tpath->keep_locks = 0;\n\tbtrfs_unlock_up_safe(path, 1);\n\treturn 0;\nerr:\n\tpath->keep_locks = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_unlock_up_safe",
          "args": [
            "path",
            "1"
          ],
          "line": 4384
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unlock_up_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2413-2428",
          "snippet": "noinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nnoinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_leaf",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "ins_len",
            "1"
          ],
          "line": 4379
        },
        "resolved": true,
        "details": {
          "function_name": "split_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4159-4322",
          "snippet": "static noinline int split_leaf(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_key *ins_key,\n\t\t\t       struct btrfs_path *path, int data_size,\n\t\t\t       int extend)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *l;\n\tu32 nritems;\n\tint mid;\n\tint slot;\n\tstruct extent_buffer *right;\n\tint ret = 0;\n\tint wret;\n\tint split;\n\tint num_doubles = 0;\n\tint tried_avoid_double = 0;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tif (extend && data_size + btrfs_item_size_nr(l, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root))\n\t\treturn -EOVERFLOW;\n\n\t/* first try to make some room by pushing left and right */\n\tif (data_size && path->nodes[1]) {\n\t\tint space_needed = data_size;\n\n\t\tif (slot < btrfs_header_nritems(l))\n\t\t\tspace_needed -= btrfs_leaf_free_space(root, l);\n\n\t\twret = push_leaf_right(trans, root, path, space_needed,\n\t\t\t\t       space_needed, 0, 0);\n\t\tif (wret < 0)\n\t\t\treturn wret;\n\t\tif (wret) {\n\t\t\twret = push_leaf_left(trans, root, path, space_needed,\n\t\t\t\t\t      space_needed, 0, (u32)-1);\n\t\t\tif (wret < 0)\n\t\t\t\treturn wret;\n\t\t}\n\t\tl = path->nodes[0];\n\n\t\t/* did the pushes work? */\n\t\tif (btrfs_leaf_free_space(root, l) >= data_size)\n\t\t\treturn 0;\n\t}\n\n\tif (!path->nodes[1]) {\n\t\tret = insert_new_root(trans, root, path, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\nagain:\n\tsplit = 1;\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(l);\n\tmid = (nritems + 1) / 2;\n\n\tif (mid <= slot) {\n\t\tif (nritems == 1 ||\n\t\t    leaf_space_used(l, mid, nritems - mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (slot >= nritems) {\n\t\t\t\tsplit = 0;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (leaf_space_used(l, 0, mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (!extend && data_size && slot == 0) {\n\t\t\t\tsplit = 0;\n\t\t\t} else if ((extend || !data_size) && slot == 0) {\n\t\t\t\tmid = 1;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (split == 0)\n\t\tbtrfs_cpu_key_to_disk(&disk_key, ins_key);\n\telse\n\t\tbtrfs_item_key(l, &disk_key, mid);\n\n\tright = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t&disk_key, 0, l->start, 0);\n\tif (IS_ERR(right))\n\t\treturn PTR_ERR(right);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(right, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(right, right->start);\n\tbtrfs_set_header_generation(right, trans->transid);\n\tbtrfs_set_header_backref_rev(right, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(right, root->root_key.objectid);\n\tbtrfs_set_header_level(right, 0);\n\twrite_extent_buffer(right, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(right, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(right),\n\t\t\t    BTRFS_UUID_SIZE);\n\n\tif (split == 0) {\n\t\tif (mid <= slot) {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t   path->slots[1] + 1, 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tpath->slots[1] += 1;\n\t\t} else {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t\t  path->slots[1], 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tif (path->slots[1] == 0)\n\t\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\t\tbtrfs_mark_buffer_dirty(right);\n\t\treturn ret;\n\t}\n\n\tcopy_for_split(trans, root, path, l, right, slot, mid, nritems);\n\n\tif (split == 2) {\n\t\tBUG_ON(num_doubles != 0);\n\t\tnum_doubles++;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n\npush_for_double:\n\tpush_for_double_split(trans, root, path, data_size);\n\ttried_avoid_double = 1;\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= data_size)\n\t\treturn 0;\n\tgoto again;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_leaf(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *ins_key,\n\t\t      struct btrfs_path *path, int data_size, int extend);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_leaf(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *ins_key,\n\t\t      struct btrfs_path *path, int data_size, int extend);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic noinline int split_leaf(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_key *ins_key,\n\t\t\t       struct btrfs_path *path, int data_size,\n\t\t\t       int extend)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *l;\n\tu32 nritems;\n\tint mid;\n\tint slot;\n\tstruct extent_buffer *right;\n\tint ret = 0;\n\tint wret;\n\tint split;\n\tint num_doubles = 0;\n\tint tried_avoid_double = 0;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tif (extend && data_size + btrfs_item_size_nr(l, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root))\n\t\treturn -EOVERFLOW;\n\n\t/* first try to make some room by pushing left and right */\n\tif (data_size && path->nodes[1]) {\n\t\tint space_needed = data_size;\n\n\t\tif (slot < btrfs_header_nritems(l))\n\t\t\tspace_needed -= btrfs_leaf_free_space(root, l);\n\n\t\twret = push_leaf_right(trans, root, path, space_needed,\n\t\t\t\t       space_needed, 0, 0);\n\t\tif (wret < 0)\n\t\t\treturn wret;\n\t\tif (wret) {\n\t\t\twret = push_leaf_left(trans, root, path, space_needed,\n\t\t\t\t\t      space_needed, 0, (u32)-1);\n\t\t\tif (wret < 0)\n\t\t\t\treturn wret;\n\t\t}\n\t\tl = path->nodes[0];\n\n\t\t/* did the pushes work? */\n\t\tif (btrfs_leaf_free_space(root, l) >= data_size)\n\t\t\treturn 0;\n\t}\n\n\tif (!path->nodes[1]) {\n\t\tret = insert_new_root(trans, root, path, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\nagain:\n\tsplit = 1;\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(l);\n\tmid = (nritems + 1) / 2;\n\n\tif (mid <= slot) {\n\t\tif (nritems == 1 ||\n\t\t    leaf_space_used(l, mid, nritems - mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (slot >= nritems) {\n\t\t\t\tsplit = 0;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (leaf_space_used(l, 0, mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (!extend && data_size && slot == 0) {\n\t\t\t\tsplit = 0;\n\t\t\t} else if ((extend || !data_size) && slot == 0) {\n\t\t\t\tmid = 1;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (split == 0)\n\t\tbtrfs_cpu_key_to_disk(&disk_key, ins_key);\n\telse\n\t\tbtrfs_item_key(l, &disk_key, mid);\n\n\tright = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t&disk_key, 0, l->start, 0);\n\tif (IS_ERR(right))\n\t\treturn PTR_ERR(right);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(right, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(right, right->start);\n\tbtrfs_set_header_generation(right, trans->transid);\n\tbtrfs_set_header_backref_rev(right, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(right, root->root_key.objectid);\n\tbtrfs_set_header_level(right, 0);\n\twrite_extent_buffer(right, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(right, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(right),\n\t\t\t    BTRFS_UUID_SIZE);\n\n\tif (split == 0) {\n\t\tif (mid <= slot) {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t   path->slots[1] + 1, 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tpath->slots[1] += 1;\n\t\t} else {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t\t  path->slots[1], 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tif (path->slots[1] == 0)\n\t\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\t\tbtrfs_mark_buffer_dirty(right);\n\t\treturn ret;\n\t}\n\n\tcopy_for_split(trans, root, path, l, right, slot, mid, nritems);\n\n\tif (split == 2) {\n\t\tBUG_ON(num_doubles != 0);\n\t\tnum_doubles++;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n\npush_for_double:\n\tpush_for_double_split(trans, root, path, data_size);\n\ttried_avoid_double = 1;\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= data_size)\n\t\treturn 0;\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "path"
          ],
          "line": 4378
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 4374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 4372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "path->nodes[0]"
          ],
          "line": 4368
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 4364
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "trans",
            "root",
            "&key",
            "path",
            "0",
            "1"
          ],
          "line": 4354
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 4350
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "leaf",
            "fi"
          ],
          "line": 4348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "path->slots[0]",
            "structbtrfs_file_extent_item"
          ],
          "line": 4346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "key.type != BTRFS_EXTENT_DATA_KEY &&\n\t       key.type != BTRFS_EXTENT_CSUM_KEY"
          ],
          "line": 4338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "path->slots[0]"
          ],
          "line": 4336
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int setup_leaf_for_split(struct btrfs_trans_handle *trans,\n\t\t\t\t\t struct btrfs_root *root,\n\t\t\t\t\t struct btrfs_path *path, int ins_len)\n{\n\tstruct btrfs_key key;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_file_extent_item *fi;\n\tu64 extent_len = 0;\n\tu32 item_size;\n\tint ret;\n\n\tleaf = path->nodes[0];\n\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\n\tBUG_ON(key.type != BTRFS_EXTENT_DATA_KEY &&\n\t       key.type != BTRFS_EXTENT_CSUM_KEY);\n\n\tif (btrfs_leaf_free_space(root, leaf) >= ins_len)\n\t\treturn 0;\n\n\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\textent_len = btrfs_file_extent_num_bytes(leaf, fi);\n\t}\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->search_for_split = 1;\n\tret = btrfs_search_slot(trans, root, &key, path, 0, 1);\n\tpath->search_for_split = 0;\n\tif (ret > 0)\n\t\tret = -EAGAIN;\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = -EAGAIN;\n\tleaf = path->nodes[0];\n\t/* if our item isn't there, return now */\n\tif (item_size != btrfs_item_size_nr(leaf, path->slots[0]))\n\t\tgoto err;\n\n\t/* the leaf has  changed, it now has room.  return now */\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= ins_len)\n\t\tgoto err;\n\n\tif (key.type == BTRFS_EXTENT_DATA_KEY) {\n\t\tfi = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t    struct btrfs_file_extent_item);\n\t\tif (extent_len != btrfs_file_extent_num_bytes(leaf, fi))\n\t\t\tgoto err;\n\t}\n\n\tbtrfs_set_path_blocking(path);\n\tret = split_leaf(trans, root, &key, path, ins_len, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tpath->keep_locks = 0;\n\tbtrfs_unlock_up_safe(path, 1);\n\treturn 0;\nerr:\n\tpath->keep_locks = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "split_leaf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4159-4322",
    "snippet": "static noinline int split_leaf(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_key *ins_key,\n\t\t\t       struct btrfs_path *path, int data_size,\n\t\t\t       int extend)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *l;\n\tu32 nritems;\n\tint mid;\n\tint slot;\n\tstruct extent_buffer *right;\n\tint ret = 0;\n\tint wret;\n\tint split;\n\tint num_doubles = 0;\n\tint tried_avoid_double = 0;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tif (extend && data_size + btrfs_item_size_nr(l, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root))\n\t\treturn -EOVERFLOW;\n\n\t/* first try to make some room by pushing left and right */\n\tif (data_size && path->nodes[1]) {\n\t\tint space_needed = data_size;\n\n\t\tif (slot < btrfs_header_nritems(l))\n\t\t\tspace_needed -= btrfs_leaf_free_space(root, l);\n\n\t\twret = push_leaf_right(trans, root, path, space_needed,\n\t\t\t\t       space_needed, 0, 0);\n\t\tif (wret < 0)\n\t\t\treturn wret;\n\t\tif (wret) {\n\t\t\twret = push_leaf_left(trans, root, path, space_needed,\n\t\t\t\t\t      space_needed, 0, (u32)-1);\n\t\t\tif (wret < 0)\n\t\t\t\treturn wret;\n\t\t}\n\t\tl = path->nodes[0];\n\n\t\t/* did the pushes work? */\n\t\tif (btrfs_leaf_free_space(root, l) >= data_size)\n\t\t\treturn 0;\n\t}\n\n\tif (!path->nodes[1]) {\n\t\tret = insert_new_root(trans, root, path, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\nagain:\n\tsplit = 1;\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(l);\n\tmid = (nritems + 1) / 2;\n\n\tif (mid <= slot) {\n\t\tif (nritems == 1 ||\n\t\t    leaf_space_used(l, mid, nritems - mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (slot >= nritems) {\n\t\t\t\tsplit = 0;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (leaf_space_used(l, 0, mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (!extend && data_size && slot == 0) {\n\t\t\t\tsplit = 0;\n\t\t\t} else if ((extend || !data_size) && slot == 0) {\n\t\t\t\tmid = 1;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (split == 0)\n\t\tbtrfs_cpu_key_to_disk(&disk_key, ins_key);\n\telse\n\t\tbtrfs_item_key(l, &disk_key, mid);\n\n\tright = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t&disk_key, 0, l->start, 0);\n\tif (IS_ERR(right))\n\t\treturn PTR_ERR(right);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(right, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(right, right->start);\n\tbtrfs_set_header_generation(right, trans->transid);\n\tbtrfs_set_header_backref_rev(right, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(right, root->root_key.objectid);\n\tbtrfs_set_header_level(right, 0);\n\twrite_extent_buffer(right, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(right, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(right),\n\t\t\t    BTRFS_UUID_SIZE);\n\n\tif (split == 0) {\n\t\tif (mid <= slot) {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t   path->slots[1] + 1, 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tpath->slots[1] += 1;\n\t\t} else {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t\t  path->slots[1], 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tif (path->slots[1] == 0)\n\t\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\t\tbtrfs_mark_buffer_dirty(right);\n\t\treturn ret;\n\t}\n\n\tcopy_for_split(trans, root, path, l, right, slot, mid, nritems);\n\n\tif (split == 2) {\n\t\tBUG_ON(num_doubles != 0);\n\t\tnum_doubles++;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n\npush_for_double:\n\tpush_for_double_split(trans, root, path, data_size);\n\ttried_avoid_double = 1;\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= data_size)\n\t\treturn 0;\n\tgoto again;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_leaf(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *ins_key,\n\t\t      struct btrfs_path *path, int data_size, int extend);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "path->nodes[0]"
          ],
          "line": 4319
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_for_double_split",
          "args": [
            "trans",
            "root",
            "path",
            "data_size"
          ],
          "line": 4317
        },
        "resolved": true,
        "details": {
          "function_name": "push_for_double_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4102-4151",
          "snippet": "static noinline int push_for_double_split(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  int data_size)\n{\n\tint ret;\n\tint progress = 0;\n\tint slot;\n\tu32 nritems;\n\tint space_needed = data_size;\n\n\tslot = path->slots[0];\n\tif (slot < btrfs_header_nritems(path->nodes[0]))\n\t\tspace_needed -= btrfs_leaf_free_space(root, path->nodes[0]);\n\n\t/*\n\t * try to push all the items after our slot into the\n\t * right leaf\n\t */\n\tret = push_leaf_right(trans, root, path, 1, space_needed, 0, slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\tprogress++;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t/*\n\t * our goal is to get our slot at the start or end of a leaf.  If\n\t * we've done so we're done\n\t */\n\tif (path->slots[0] == 0 || path->slots[0] == nritems)\n\t\treturn 0;\n\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= data_size)\n\t\treturn 0;\n\n\t/* try to push all the items before our slot into the next leaf */\n\tslot = path->slots[0];\n\tret = push_leaf_left(trans, root, path, 1, space_needed, 0, slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\tprogress++;\n\n\tif (progress)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic noinline int push_for_double_split(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  int data_size)\n{\n\tint ret;\n\tint progress = 0;\n\tint slot;\n\tu32 nritems;\n\tint space_needed = data_size;\n\n\tslot = path->slots[0];\n\tif (slot < btrfs_header_nritems(path->nodes[0]))\n\t\tspace_needed -= btrfs_leaf_free_space(root, path->nodes[0]);\n\n\t/*\n\t * try to push all the items after our slot into the\n\t * right leaf\n\t */\n\tret = push_leaf_right(trans, root, path, 1, space_needed, 0, slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\tprogress++;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t/*\n\t * our goal is to get our slot at the start or end of a leaf.  If\n\t * we've done so we're done\n\t */\n\tif (path->slots[0] == 0 || path->slots[0] == nritems)\n\t\treturn 0;\n\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= data_size)\n\t\treturn 0;\n\n\t/* try to push all the items before our slot into the next leaf */\n\tslot = path->slots[0];\n\tret = push_leaf_left(trans, root, path, 1, space_needed, 0, slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\tprogress++;\n\n\tif (progress)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "num_doubles != 0"
          ],
          "line": 4309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_for_split",
          "args": [
            "trans",
            "root",
            "path",
            "l",
            "right",
            "slot",
            "mid",
            "nritems"
          ],
          "line": 4306
        },
        "resolved": true,
        "details": {
          "function_name": "copy_for_split",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4029-4090",
          "snippet": "static noinline void copy_for_split(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *l,\n\t\t\t\t    struct extent_buffer *right,\n\t\t\t\t    int slot, int mid, int nritems)\n{\n\tint data_copy_size;\n\tint rt_data_off;\n\tint i;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tnritems = nritems - mid;\n\tbtrfs_set_header_nritems(right, nritems);\n\tdata_copy_size = btrfs_item_end_nr(l, mid) - leaf_data_end(root, l);\n\n\tcopy_extent_buffer(right, l, btrfs_item_nr_offset(0),\n\t\t\t   btrfs_item_nr_offset(mid),\n\t\t\t   nritems * sizeof(struct btrfs_item));\n\n\tcopy_extent_buffer(right, l,\n\t\t     btrfs_leaf_data(right) + BTRFS_LEAF_DATA_SIZE(root) -\n\t\t     data_copy_size, btrfs_leaf_data(l) +\n\t\t     leaf_data_end(root, l), data_copy_size);\n\n\trt_data_off = BTRFS_LEAF_DATA_SIZE(root) -\n\t\t      btrfs_item_end_nr(l, mid);\n\n\tfor (i = 0; i < nritems; i++) {\n\t\tstruct btrfs_item *item = btrfs_item_nr(i);\n\t\tu32 ioff;\n\n\t\tioff = btrfs_token_item_offset(right, item, &token);\n\t\tbtrfs_set_token_item_offset(right, item,\n\t\t\t\t\t    ioff + rt_data_off, &token);\n\t}\n\n\tbtrfs_set_header_nritems(l, mid);\n\tbtrfs_item_key(right, &disk_key, 0);\n\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t   path->slots[1] + 1, 1);\n\n\tbtrfs_mark_buffer_dirty(right);\n\tbtrfs_mark_buffer_dirty(l);\n\tBUG_ON(path->slots[0] != slot);\n\n\tif (mid <= slot) {\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] -= mid;\n\t\tpath->slots[1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\n\tBUG_ON(path->slots[0] < 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic noinline void copy_for_split(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *l,\n\t\t\t\t    struct extent_buffer *right,\n\t\t\t\t    int slot, int mid, int nritems)\n{\n\tint data_copy_size;\n\tint rt_data_off;\n\tint i;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tnritems = nritems - mid;\n\tbtrfs_set_header_nritems(right, nritems);\n\tdata_copy_size = btrfs_item_end_nr(l, mid) - leaf_data_end(root, l);\n\n\tcopy_extent_buffer(right, l, btrfs_item_nr_offset(0),\n\t\t\t   btrfs_item_nr_offset(mid),\n\t\t\t   nritems * sizeof(struct btrfs_item));\n\n\tcopy_extent_buffer(right, l,\n\t\t     btrfs_leaf_data(right) + BTRFS_LEAF_DATA_SIZE(root) -\n\t\t     data_copy_size, btrfs_leaf_data(l) +\n\t\t     leaf_data_end(root, l), data_copy_size);\n\n\trt_data_off = BTRFS_LEAF_DATA_SIZE(root) -\n\t\t      btrfs_item_end_nr(l, mid);\n\n\tfor (i = 0; i < nritems; i++) {\n\t\tstruct btrfs_item *item = btrfs_item_nr(i);\n\t\tu32 ioff;\n\n\t\tioff = btrfs_token_item_offset(right, item, &token);\n\t\tbtrfs_set_token_item_offset(right, item,\n\t\t\t\t\t    ioff + rt_data_off, &token);\n\t}\n\n\tbtrfs_set_header_nritems(l, mid);\n\tbtrfs_item_key(right, &disk_key, 0);\n\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t   path->slots[1] + 1, 1);\n\n\tbtrfs_mark_buffer_dirty(right);\n\tbtrfs_mark_buffer_dirty(l);\n\tBUG_ON(path->slots[0] != slot);\n\n\tif (mid <= slot) {\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] -= mid;\n\t\tpath->slots[1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\n\tBUG_ON(path->slots[0] < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "right"
          ],
          "line": 4302
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixup_low_keys",
          "args": [
            "root",
            "path",
            "&disk_key",
            "1"
          ],
          "line": 4300
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_low_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3129-3146",
          "snippet": "static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "path->nodes[0]"
          ],
          "line": 4296
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "path->nodes[0]"
          ],
          "line": 4295
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_ptr",
          "args": [
            "trans",
            "root",
            "path",
            "&disk_key",
            "right->start",
            "path->slots[1]",
            "1"
          ],
          "line": 4293
        },
        "resolved": true,
        "details": {
          "function_name": "insert_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3395-3430",
          "snippet": "static void insert_ptr(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *path,\n\t\t       struct btrfs_disk_key *key, u64 bytenr,\n\t\t       int slot, int level)\n{\n\tstruct extent_buffer *lower;\n\tint nritems;\n\tint ret;\n\n\tBUG_ON(!path->nodes[level]);\n\tbtrfs_assert_tree_locked(path->nodes[level]);\n\tlower = path->nodes[level];\n\tnritems = btrfs_header_nritems(lower);\n\tBUG_ON(slot > nritems);\n\tBUG_ON(nritems == BTRFS_NODEPTRS_PER_BLOCK(root));\n\tif (slot != nritems) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, lower, slot + 1,\n\t\t\t\t\t     slot, nritems - slot);\n\t\tmemmove_extent_buffer(lower,\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_key_ptr));\n\t}\n\tif (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, lower, slot,\n\t\t\t\t\t      MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\tbtrfs_set_node_key(lower, key, slot);\n\tbtrfs_set_node_blockptr(lower, slot, bytenr);\n\tWARN_ON(trans->transid == 0);\n\tbtrfs_set_node_ptr_generation(lower, slot, trans->transid);\n\tbtrfs_set_header_nritems(lower, nritems + 1);\n\tbtrfs_mark_buffer_dirty(lower);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic void insert_ptr(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *path,\n\t\t       struct btrfs_disk_key *key, u64 bytenr,\n\t\t       int slot, int level)\n{\n\tstruct extent_buffer *lower;\n\tint nritems;\n\tint ret;\n\n\tBUG_ON(!path->nodes[level]);\n\tbtrfs_assert_tree_locked(path->nodes[level]);\n\tlower = path->nodes[level];\n\tnritems = btrfs_header_nritems(lower);\n\tBUG_ON(slot > nritems);\n\tBUG_ON(nritems == BTRFS_NODEPTRS_PER_BLOCK(root));\n\tif (slot != nritems) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, lower, slot + 1,\n\t\t\t\t\t     slot, nritems - slot);\n\t\tmemmove_extent_buffer(lower,\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_key_ptr));\n\t}\n\tif (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, lower, slot,\n\t\t\t\t\t      MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\tbtrfs_set_node_key(lower, key, slot);\n\tbtrfs_set_node_blockptr(lower, slot, bytenr);\n\tWARN_ON(trans->transid == 0);\n\tbtrfs_set_node_ptr_generation(lower, slot, trans->transid);\n\tbtrfs_set_header_nritems(lower, nritems + 1);\n\tbtrfs_mark_buffer_dirty(lower);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "right",
            "0"
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "right",
            "0"
          ],
          "line": 4283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "right",
            "root->fs_info->chunk_tree_uuid",
            "btrfs_header_chunk_tree_uuid(right)",
            "BTRFS_UUID_SIZE"
          ],
          "line": 4277
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_chunk_tree_uuid",
          "args": [
            "right"
          ],
          "line": 4278
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_chunk_tree_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2837-2840",
          "snippet": "static inline unsigned long btrfs_header_chunk_tree_uuid(struct extent_buffer *eb)\n{\n\treturn offsetof(struct btrfs_header, chunk_tree_uuid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_chunk_tree_uuid(struct extent_buffer *eb)\n{\n\treturn offsetof(struct btrfs_header, chunk_tree_uuid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_fsid",
          "args": [],
          "line": 4275
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2832-2835",
          "snippet": "static inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_level",
          "args": [
            "right",
            "0"
          ],
          "line": 4273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_owner",
          "args": [
            "right",
            "root->root_key.objectid"
          ],
          "line": 4272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_backref_rev",
          "args": [
            "right",
            "BTRFS_MIXED_BACKREF_REV"
          ],
          "line": 4271
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2823-2830",
          "snippet": "static inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)",
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_generation",
          "args": [
            "right",
            "trans->transid"
          ],
          "line": 4270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_bytenr",
          "args": [
            "right",
            "right->start"
          ],
          "line": 4269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset_extent_buffer",
          "args": [
            "right",
            "0",
            "0",
            "sizeof(struct btrfs_header)"
          ],
          "line": 4268
        },
        "resolved": true,
        "details": {
          "function_name": "memset_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5387-5414",
          "snippet": "void memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "root_add_used",
          "args": [
            "root",
            "root->nodesize"
          ],
          "line": 4266
        },
        "resolved": true,
        "details": {
          "function_name": "root_add_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1833-1839",
          "snippet": "static void root_add_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) + size);\n\tspin_unlock(&root->accounting_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void root_add_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) + size);\n\tspin_unlock(&root->accounting_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "right"
          ],
          "line": 4264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "right"
          ],
          "line": 4263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_tree_block",
          "args": [
            "trans",
            "root",
            "0",
            "root->root_key.objectid",
            "&disk_key",
            "0",
            "l->start",
            "0"
          ],
          "line": 4261
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "7316-7385",
          "snippet": "struct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key",
          "args": [
            "l",
            "&disk_key",
            "mid"
          ],
          "line": 4259
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cpu_key_to_disk",
          "args": [
            "&disk_key",
            "ins_key"
          ],
          "line": 4257
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cpu_key_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2739-2745",
          "snippet": "static inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 4247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_space_used",
          "args": [
            "l",
            "mid",
            "nritems - mid"
          ],
          "line": 4246
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_space_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3539-3559",
          "snippet": "static int leaf_space_used(struct extent_buffer *l, int start, int nr)\n{\n\tstruct btrfs_item *start_item;\n\tstruct btrfs_item *end_item;\n\tstruct btrfs_map_token token;\n\tint data_len;\n\tint nritems = btrfs_header_nritems(l);\n\tint end = min(nritems, start + nr) - 1;\n\n\tif (!nr)\n\t\treturn 0;\n\tbtrfs_init_map_token(&token);\n\tstart_item = btrfs_item_nr(start);\n\tend_item = btrfs_item_nr(end);\n\tdata_len = btrfs_token_item_offset(l, start_item, &token) +\n\t\tbtrfs_token_item_size(l, start_item, &token);\n\tdata_len = data_len - btrfs_token_item_offset(l, end_item, &token);\n\tdata_len += sizeof(struct btrfs_item) * nr;\n\tWARN_ON(data_len < 0);\n\treturn data_len;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int leaf_space_used(struct extent_buffer *l, int start, int nr)\n{\n\tstruct btrfs_item *start_item;\n\tstruct btrfs_item *end_item;\n\tstruct btrfs_map_token token;\n\tint data_len;\n\tint nritems = btrfs_header_nritems(l);\n\tint end = min(nritems, start + nr) - 1;\n\n\tif (!nr)\n\t\treturn 0;\n\tbtrfs_init_map_token(&token);\n\tstart_item = btrfs_item_nr(start);\n\tend_item = btrfs_item_nr(end);\n\tdata_len = btrfs_token_item_offset(l, start_item, &token) +\n\t\tbtrfs_token_item_size(l, start_item, &token);\n\tdata_len = data_len - btrfs_token_item_offset(l, end_item, &token);\n\tdata_len += sizeof(struct btrfs_item) * nr;\n\tWARN_ON(data_len < 0);\n\treturn data_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 4238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "l"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_new_root",
          "args": [
            "trans",
            "root",
            "path",
            "1"
          ],
          "line": 4208
        },
        "resolved": true,
        "details": {
          "function_name": "insert_new_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3324-3386",
          "snippet": "static noinline int insert_new_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_path *path, int level)\n{\n\tu64 lower_gen;\n\tstruct extent_buffer *lower;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *old;\n\tstruct btrfs_disk_key lower_key;\n\n\tBUG_ON(path->nodes[level]);\n\tBUG_ON(path->nodes[level-1] != root->node);\n\n\tlower = path->nodes[level-1];\n\tif (level == 1)\n\t\tbtrfs_item_key(lower, &lower_key, 0);\n\telse\n\t\tbtrfs_node_key(lower, &lower_key, 0);\n\n\tc = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t\t   &lower_key, level, root->node->start, 0);\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(c, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_nritems(c, 1);\n\tbtrfs_set_header_level(c, level);\n\tbtrfs_set_header_bytenr(c, c->start);\n\tbtrfs_set_header_generation(c, trans->transid);\n\tbtrfs_set_header_backref_rev(c, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(c, root->root_key.objectid);\n\n\twrite_extent_buffer(c, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(c, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(c), BTRFS_UUID_SIZE);\n\n\tbtrfs_set_node_key(c, &lower_key, 0);\n\tbtrfs_set_node_blockptr(c, 0, lower->start);\n\tlower_gen = btrfs_header_generation(lower);\n\tWARN_ON(lower_gen != trans->transid);\n\n\tbtrfs_set_node_ptr_generation(c, 0, lower_gen);\n\n\tbtrfs_mark_buffer_dirty(c);\n\n\told = root->node;\n\ttree_mod_log_set_root_pointer(root, c, 0);\n\trcu_assign_pointer(root->node, c);\n\n\t/* the super has an extra ref to root->node */\n\tfree_extent_buffer(old);\n\n\tadd_root_to_dirty_list(root);\n\textent_buffer_get(c);\n\tpath->nodes[level] = c;\n\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\tpath->slots[level] = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline int insert_new_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_path *path, int level)\n{\n\tu64 lower_gen;\n\tstruct extent_buffer *lower;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *old;\n\tstruct btrfs_disk_key lower_key;\n\n\tBUG_ON(path->nodes[level]);\n\tBUG_ON(path->nodes[level-1] != root->node);\n\n\tlower = path->nodes[level-1];\n\tif (level == 1)\n\t\tbtrfs_item_key(lower, &lower_key, 0);\n\telse\n\t\tbtrfs_node_key(lower, &lower_key, 0);\n\n\tc = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t\t   &lower_key, level, root->node->start, 0);\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(c, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_nritems(c, 1);\n\tbtrfs_set_header_level(c, level);\n\tbtrfs_set_header_bytenr(c, c->start);\n\tbtrfs_set_header_generation(c, trans->transid);\n\tbtrfs_set_header_backref_rev(c, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(c, root->root_key.objectid);\n\n\twrite_extent_buffer(c, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(c, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(c), BTRFS_UUID_SIZE);\n\n\tbtrfs_set_node_key(c, &lower_key, 0);\n\tbtrfs_set_node_blockptr(c, 0, lower->start);\n\tlower_gen = btrfs_header_generation(lower);\n\tWARN_ON(lower_gen != trans->transid);\n\n\tbtrfs_set_node_ptr_generation(c, 0, lower_gen);\n\n\tbtrfs_mark_buffer_dirty(c);\n\n\told = root->node;\n\ttree_mod_log_set_root_pointer(root, c, 0);\n\trcu_assign_pointer(root->node, c);\n\n\t/* the super has an extra ref to root->node */\n\tfree_extent_buffer(old);\n\n\tadd_root_to_dirty_list(root);\n\textent_buffer_get(c);\n\tpath->nodes[level] = c;\n\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\tpath->slots[level] = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_leaf_left",
          "args": [
            "trans",
            "root",
            "path",
            "space_needed",
            "space_needed",
            "0",
            "(u32)-1"
          ],
          "line": 4195
        },
        "resolved": true,
        "details": {
          "function_name": "push_leaf_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3964-4023",
          "snippet": "static int push_leaf_left(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, struct btrfs_path *path, int min_data_size,\n\t\t\t  int data_size, int empty, u32 max_slot)\n{\n\tstruct extent_buffer *right = path->nodes[0];\n\tstruct extent_buffer *left;\n\tint slot;\n\tint free_space;\n\tu32 right_nritems;\n\tint ret = 0;\n\n\tslot = path->slots[1];\n\tif (slot == 0)\n\t\treturn 1;\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tright_nritems = btrfs_header_nritems(right);\n\tif (right_nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tleft = read_node_slot(root, path->nodes[1], slot - 1);\n\tif (left == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(left);\n\tbtrfs_set_lock_blocking(left);\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, left,\n\t\t\t      path->nodes[1], slot - 1, &left);\n\tif (ret) {\n\t\t/* we hit -ENOSPC, but it isn't fatal here */\n\t\tif (ret == -ENOSPC)\n\t\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\treturn __push_leaf_left(trans, root, path, min_data_size,\n\t\t\t       empty, left, free_space, right_nritems,\n\t\t\t       max_slot);\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int push_leaf_left(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, struct btrfs_path *path, int min_data_size,\n\t\t\t  int data_size, int empty, u32 max_slot)\n{\n\tstruct extent_buffer *right = path->nodes[0];\n\tstruct extent_buffer *left;\n\tint slot;\n\tint free_space;\n\tu32 right_nritems;\n\tint ret = 0;\n\n\tslot = path->slots[1];\n\tif (slot == 0)\n\t\treturn 1;\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tright_nritems = btrfs_header_nritems(right);\n\tif (right_nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tleft = read_node_slot(root, path->nodes[1], slot - 1);\n\tif (left == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(left);\n\tbtrfs_set_lock_blocking(left);\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, left,\n\t\t\t      path->nodes[1], slot - 1, &left);\n\tif (ret) {\n\t\t/* we hit -ENOSPC, but it isn't fatal here */\n\t\tif (ret == -ENOSPC)\n\t\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\treturn __push_leaf_left(trans, root, path, min_data_size,\n\t\t\t       empty, left, free_space, right_nritems,\n\t\t\t       max_slot);\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_leaf_right",
          "args": [
            "trans",
            "root",
            "path",
            "space_needed",
            "space_needed",
            "0",
            "0"
          ],
          "line": 4190
        },
        "resolved": true,
        "details": {
          "function_name": "push_leaf_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3734-3801",
          "snippet": "static int push_leaf_right(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t   *root, struct btrfs_path *path,\n\t\t\t   int min_data_size, int data_size,\n\t\t\t   int empty, u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *right;\n\tstruct extent_buffer *upper;\n\tint slot;\n\tint free_space;\n\tu32 left_nritems;\n\tint ret;\n\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tslot = path->slots[1];\n\tupper = path->nodes[1];\n\tif (slot >= btrfs_header_nritems(upper) - 1)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tright = read_node_slot(root, upper, slot + 1);\n\tif (right == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(right);\n\tbtrfs_set_lock_blocking(right);\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, right, upper,\n\t\t\t      slot + 1, &right);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\tleft_nritems = btrfs_header_nritems(left);\n\tif (left_nritems == 0)\n\t\tgoto out_unlock;\n\n\tif (path->slots[0] == left_nritems && !empty) {\n\t\t/* Key greater than all keys in the leaf, right neighbor has\n\t\t * enough room for it and we're not emptying our leaf to delete\n\t\t * it, therefore use right neighbor to insert the new item and\n\t\t * no need to touch/dirty our left leaft. */\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] = 0;\n\t\tpath->slots[1]++;\n\t\treturn 0;\n\t}\n\n\treturn __push_leaf_right(trans, root, path, min_data_size, empty,\n\t\t\t\tright, free_space, left_nritems, min_slot);\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int push_leaf_right(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t   *root, struct btrfs_path *path,\n\t\t\t   int min_data_size, int data_size,\n\t\t\t   int empty, u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *right;\n\tstruct extent_buffer *upper;\n\tint slot;\n\tint free_space;\n\tu32 left_nritems;\n\tint ret;\n\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tslot = path->slots[1];\n\tupper = path->nodes[1];\n\tif (slot >= btrfs_header_nritems(upper) - 1)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tright = read_node_slot(root, upper, slot + 1);\n\tif (right == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(right);\n\tbtrfs_set_lock_blocking(right);\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, right, upper,\n\t\t\t      slot + 1, &right);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\tleft_nritems = btrfs_header_nritems(left);\n\tif (left_nritems == 0)\n\t\tgoto out_unlock;\n\n\tif (path->slots[0] == left_nritems && !empty) {\n\t\t/* Key greater than all keys in the leaf, right neighbor has\n\t\t * enough room for it and we're not emptying our leaf to delete\n\t\t * it, therefore use right neighbor to insert the new item and\n\t\t * no need to touch/dirty our left leaft. */\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] = 0;\n\t\tpath->slots[1]++;\n\t\treturn 0;\n\t}\n\n\treturn __push_leaf_right(trans, root, path, min_data_size, empty,\n\t\t\t\tright, free_space, left_nritems, min_slot);\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "l"
          ],
          "line": 4187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 4180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "l",
            "slot"
          ],
          "line": 4179
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_leaf(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *ins_key,\n\t\t      struct btrfs_path *path, int data_size, int extend);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic noinline int split_leaf(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_key *ins_key,\n\t\t\t       struct btrfs_path *path, int data_size,\n\t\t\t       int extend)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *l;\n\tu32 nritems;\n\tint mid;\n\tint slot;\n\tstruct extent_buffer *right;\n\tint ret = 0;\n\tint wret;\n\tint split;\n\tint num_doubles = 0;\n\tint tried_avoid_double = 0;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tif (extend && data_size + btrfs_item_size_nr(l, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root))\n\t\treturn -EOVERFLOW;\n\n\t/* first try to make some room by pushing left and right */\n\tif (data_size && path->nodes[1]) {\n\t\tint space_needed = data_size;\n\n\t\tif (slot < btrfs_header_nritems(l))\n\t\t\tspace_needed -= btrfs_leaf_free_space(root, l);\n\n\t\twret = push_leaf_right(trans, root, path, space_needed,\n\t\t\t\t       space_needed, 0, 0);\n\t\tif (wret < 0)\n\t\t\treturn wret;\n\t\tif (wret) {\n\t\t\twret = push_leaf_left(trans, root, path, space_needed,\n\t\t\t\t\t      space_needed, 0, (u32)-1);\n\t\t\tif (wret < 0)\n\t\t\t\treturn wret;\n\t\t}\n\t\tl = path->nodes[0];\n\n\t\t/* did the pushes work? */\n\t\tif (btrfs_leaf_free_space(root, l) >= data_size)\n\t\t\treturn 0;\n\t}\n\n\tif (!path->nodes[1]) {\n\t\tret = insert_new_root(trans, root, path, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\nagain:\n\tsplit = 1;\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(l);\n\tmid = (nritems + 1) / 2;\n\n\tif (mid <= slot) {\n\t\tif (nritems == 1 ||\n\t\t    leaf_space_used(l, mid, nritems - mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (slot >= nritems) {\n\t\t\t\tsplit = 0;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (leaf_space_used(l, 0, mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (!extend && data_size && slot == 0) {\n\t\t\t\tsplit = 0;\n\t\t\t} else if ((extend || !data_size) && slot == 0) {\n\t\t\t\tmid = 1;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (split == 0)\n\t\tbtrfs_cpu_key_to_disk(&disk_key, ins_key);\n\telse\n\t\tbtrfs_item_key(l, &disk_key, mid);\n\n\tright = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t&disk_key, 0, l->start, 0);\n\tif (IS_ERR(right))\n\t\treturn PTR_ERR(right);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(right, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(right, right->start);\n\tbtrfs_set_header_generation(right, trans->transid);\n\tbtrfs_set_header_backref_rev(right, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(right, root->root_key.objectid);\n\tbtrfs_set_header_level(right, 0);\n\twrite_extent_buffer(right, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(right, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(right),\n\t\t\t    BTRFS_UUID_SIZE);\n\n\tif (split == 0) {\n\t\tif (mid <= slot) {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t   path->slots[1] + 1, 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tpath->slots[1] += 1;\n\t\t} else {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t\t  path->slots[1], 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tif (path->slots[1] == 0)\n\t\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\t\tbtrfs_mark_buffer_dirty(right);\n\t\treturn ret;\n\t}\n\n\tcopy_for_split(trans, root, path, l, right, slot, mid, nritems);\n\n\tif (split == 2) {\n\t\tBUG_ON(num_doubles != 0);\n\t\tnum_doubles++;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n\npush_for_double:\n\tpush_for_double_split(trans, root, path, data_size);\n\ttried_avoid_double = 1;\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= data_size)\n\t\treturn 0;\n\tgoto again;\n}"
  },
  {
    "function_name": "push_for_double_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4102-4151",
    "snippet": "static noinline int push_for_double_split(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  int data_size)\n{\n\tint ret;\n\tint progress = 0;\n\tint slot;\n\tu32 nritems;\n\tint space_needed = data_size;\n\n\tslot = path->slots[0];\n\tif (slot < btrfs_header_nritems(path->nodes[0]))\n\t\tspace_needed -= btrfs_leaf_free_space(root, path->nodes[0]);\n\n\t/*\n\t * try to push all the items after our slot into the\n\t * right leaf\n\t */\n\tret = push_leaf_right(trans, root, path, 1, space_needed, 0, slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\tprogress++;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t/*\n\t * our goal is to get our slot at the start or end of a leaf.  If\n\t * we've done so we're done\n\t */\n\tif (path->slots[0] == 0 || path->slots[0] == nritems)\n\t\treturn 0;\n\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= data_size)\n\t\treturn 0;\n\n\t/* try to push all the items before our slot into the next leaf */\n\tslot = path->slots[0];\n\tret = push_leaf_left(trans, root, path, 1, space_needed, 0, slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\tprogress++;\n\n\tif (progress)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "push_leaf_left",
          "args": [
            "trans",
            "root",
            "path",
            "1",
            "space_needed",
            "0",
            "slot"
          ],
          "line": 4141
        },
        "resolved": true,
        "details": {
          "function_name": "push_leaf_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3964-4023",
          "snippet": "static int push_leaf_left(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, struct btrfs_path *path, int min_data_size,\n\t\t\t  int data_size, int empty, u32 max_slot)\n{\n\tstruct extent_buffer *right = path->nodes[0];\n\tstruct extent_buffer *left;\n\tint slot;\n\tint free_space;\n\tu32 right_nritems;\n\tint ret = 0;\n\n\tslot = path->slots[1];\n\tif (slot == 0)\n\t\treturn 1;\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tright_nritems = btrfs_header_nritems(right);\n\tif (right_nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tleft = read_node_slot(root, path->nodes[1], slot - 1);\n\tif (left == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(left);\n\tbtrfs_set_lock_blocking(left);\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, left,\n\t\t\t      path->nodes[1], slot - 1, &left);\n\tif (ret) {\n\t\t/* we hit -ENOSPC, but it isn't fatal here */\n\t\tif (ret == -ENOSPC)\n\t\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\treturn __push_leaf_left(trans, root, path, min_data_size,\n\t\t\t       empty, left, free_space, right_nritems,\n\t\t\t       max_slot);\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int push_leaf_left(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, struct btrfs_path *path, int min_data_size,\n\t\t\t  int data_size, int empty, u32 max_slot)\n{\n\tstruct extent_buffer *right = path->nodes[0];\n\tstruct extent_buffer *left;\n\tint slot;\n\tint free_space;\n\tu32 right_nritems;\n\tint ret = 0;\n\n\tslot = path->slots[1];\n\tif (slot == 0)\n\t\treturn 1;\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tright_nritems = btrfs_header_nritems(right);\n\tif (right_nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tleft = read_node_slot(root, path->nodes[1], slot - 1);\n\tif (left == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(left);\n\tbtrfs_set_lock_blocking(left);\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, left,\n\t\t\t      path->nodes[1], slot - 1, &left);\n\tif (ret) {\n\t\t/* we hit -ENOSPC, but it isn't fatal here */\n\t\tif (ret == -ENOSPC)\n\t\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\treturn __push_leaf_left(trans, root, path, min_data_size,\n\t\t\t       empty, left, free_space, right_nritems,\n\t\t\t       max_slot);\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "path->nodes[0]"
          ],
          "line": 4136
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 4128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "push_leaf_right",
          "args": [
            "trans",
            "root",
            "path",
            "1",
            "space_needed",
            "0",
            "slot"
          ],
          "line": 4121
        },
        "resolved": true,
        "details": {
          "function_name": "push_leaf_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3734-3801",
          "snippet": "static int push_leaf_right(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t   *root, struct btrfs_path *path,\n\t\t\t   int min_data_size, int data_size,\n\t\t\t   int empty, u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *right;\n\tstruct extent_buffer *upper;\n\tint slot;\n\tint free_space;\n\tu32 left_nritems;\n\tint ret;\n\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tslot = path->slots[1];\n\tupper = path->nodes[1];\n\tif (slot >= btrfs_header_nritems(upper) - 1)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tright = read_node_slot(root, upper, slot + 1);\n\tif (right == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(right);\n\tbtrfs_set_lock_blocking(right);\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, right, upper,\n\t\t\t      slot + 1, &right);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\tleft_nritems = btrfs_header_nritems(left);\n\tif (left_nritems == 0)\n\t\tgoto out_unlock;\n\n\tif (path->slots[0] == left_nritems && !empty) {\n\t\t/* Key greater than all keys in the leaf, right neighbor has\n\t\t * enough room for it and we're not emptying our leaf to delete\n\t\t * it, therefore use right neighbor to insert the new item and\n\t\t * no need to touch/dirty our left leaft. */\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] = 0;\n\t\tpath->slots[1]++;\n\t\treturn 0;\n\t}\n\n\treturn __push_leaf_right(trans, root, path, min_data_size, empty,\n\t\t\t\tright, free_space, left_nritems, min_slot);\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int push_leaf_right(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t   *root, struct btrfs_path *path,\n\t\t\t   int min_data_size, int data_size,\n\t\t\t   int empty, u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *right;\n\tstruct extent_buffer *upper;\n\tint slot;\n\tint free_space;\n\tu32 left_nritems;\n\tint ret;\n\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tslot = path->slots[1];\n\tupper = path->nodes[1];\n\tif (slot >= btrfs_header_nritems(upper) - 1)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tright = read_node_slot(root, upper, slot + 1);\n\tif (right == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(right);\n\tbtrfs_set_lock_blocking(right);\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, right, upper,\n\t\t\t      slot + 1, &right);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\tleft_nritems = btrfs_header_nritems(left);\n\tif (left_nritems == 0)\n\t\tgoto out_unlock;\n\n\tif (path->slots[0] == left_nritems && !empty) {\n\t\t/* Key greater than all keys in the leaf, right neighbor has\n\t\t * enough room for it and we're not emptying our leaf to delete\n\t\t * it, therefore use right neighbor to insert the new item and\n\t\t * no need to touch/dirty our left leaft. */\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] = 0;\n\t\tpath->slots[1]++;\n\t\treturn 0;\n\t}\n\n\treturn __push_leaf_right(trans, root, path, min_data_size, empty,\n\t\t\t\tright, free_space, left_nritems, min_slot);\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 4114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic noinline int push_for_double_split(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t\t  int data_size)\n{\n\tint ret;\n\tint progress = 0;\n\tint slot;\n\tu32 nritems;\n\tint space_needed = data_size;\n\n\tslot = path->slots[0];\n\tif (slot < btrfs_header_nritems(path->nodes[0]))\n\t\tspace_needed -= btrfs_leaf_free_space(root, path->nodes[0]);\n\n\t/*\n\t * try to push all the items after our slot into the\n\t * right leaf\n\t */\n\tret = push_leaf_right(trans, root, path, 1, space_needed, 0, slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\tprogress++;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t/*\n\t * our goal is to get our slot at the start or end of a leaf.  If\n\t * we've done so we're done\n\t */\n\tif (path->slots[0] == 0 || path->slots[0] == nritems)\n\t\treturn 0;\n\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= data_size)\n\t\treturn 0;\n\n\t/* try to push all the items before our slot into the next leaf */\n\tslot = path->slots[0];\n\tret = push_leaf_left(trans, root, path, 1, space_needed, 0, slot);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\tprogress++;\n\n\tif (progress)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "copy_for_split",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "4029-4090",
    "snippet": "static noinline void copy_for_split(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *l,\n\t\t\t\t    struct extent_buffer *right,\n\t\t\t\t    int slot, int mid, int nritems)\n{\n\tint data_copy_size;\n\tint rt_data_off;\n\tint i;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tnritems = nritems - mid;\n\tbtrfs_set_header_nritems(right, nritems);\n\tdata_copy_size = btrfs_item_end_nr(l, mid) - leaf_data_end(root, l);\n\n\tcopy_extent_buffer(right, l, btrfs_item_nr_offset(0),\n\t\t\t   btrfs_item_nr_offset(mid),\n\t\t\t   nritems * sizeof(struct btrfs_item));\n\n\tcopy_extent_buffer(right, l,\n\t\t     btrfs_leaf_data(right) + BTRFS_LEAF_DATA_SIZE(root) -\n\t\t     data_copy_size, btrfs_leaf_data(l) +\n\t\t     leaf_data_end(root, l), data_copy_size);\n\n\trt_data_off = BTRFS_LEAF_DATA_SIZE(root) -\n\t\t      btrfs_item_end_nr(l, mid);\n\n\tfor (i = 0; i < nritems; i++) {\n\t\tstruct btrfs_item *item = btrfs_item_nr(i);\n\t\tu32 ioff;\n\n\t\tioff = btrfs_token_item_offset(right, item, &token);\n\t\tbtrfs_set_token_item_offset(right, item,\n\t\t\t\t\t    ioff + rt_data_off, &token);\n\t}\n\n\tbtrfs_set_header_nritems(l, mid);\n\tbtrfs_item_key(right, &disk_key, 0);\n\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t   path->slots[1] + 1, 1);\n\n\tbtrfs_mark_buffer_dirty(right);\n\tbtrfs_mark_buffer_dirty(l);\n\tBUG_ON(path->slots[0] != slot);\n\n\tif (mid <= slot) {\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] -= mid;\n\t\tpath->slots[1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\n\tBUG_ON(path->slots[0] < 0);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path->slots[0] < 0"
          ],
          "line": 4089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "right"
          ],
          "line": 4086
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "right"
          ],
          "line": 4085
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path->slots[0] != slot"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "l"
          ],
          "line": 4075
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_ptr",
          "args": [
            "trans",
            "root",
            "path",
            "&disk_key",
            "right->start",
            "path->slots[1] + 1",
            "1"
          ],
          "line": 4071
        },
        "resolved": true,
        "details": {
          "function_name": "insert_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3395-3430",
          "snippet": "static void insert_ptr(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *path,\n\t\t       struct btrfs_disk_key *key, u64 bytenr,\n\t\t       int slot, int level)\n{\n\tstruct extent_buffer *lower;\n\tint nritems;\n\tint ret;\n\n\tBUG_ON(!path->nodes[level]);\n\tbtrfs_assert_tree_locked(path->nodes[level]);\n\tlower = path->nodes[level];\n\tnritems = btrfs_header_nritems(lower);\n\tBUG_ON(slot > nritems);\n\tBUG_ON(nritems == BTRFS_NODEPTRS_PER_BLOCK(root));\n\tif (slot != nritems) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, lower, slot + 1,\n\t\t\t\t\t     slot, nritems - slot);\n\t\tmemmove_extent_buffer(lower,\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_key_ptr));\n\t}\n\tif (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, lower, slot,\n\t\t\t\t\t      MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\tbtrfs_set_node_key(lower, key, slot);\n\tbtrfs_set_node_blockptr(lower, slot, bytenr);\n\tWARN_ON(trans->transid == 0);\n\tbtrfs_set_node_ptr_generation(lower, slot, trans->transid);\n\tbtrfs_set_header_nritems(lower, nritems + 1);\n\tbtrfs_mark_buffer_dirty(lower);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic void insert_ptr(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *path,\n\t\t       struct btrfs_disk_key *key, u64 bytenr,\n\t\t       int slot, int level)\n{\n\tstruct extent_buffer *lower;\n\tint nritems;\n\tint ret;\n\n\tBUG_ON(!path->nodes[level]);\n\tbtrfs_assert_tree_locked(path->nodes[level]);\n\tlower = path->nodes[level];\n\tnritems = btrfs_header_nritems(lower);\n\tBUG_ON(slot > nritems);\n\tBUG_ON(nritems == BTRFS_NODEPTRS_PER_BLOCK(root));\n\tif (slot != nritems) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, lower, slot + 1,\n\t\t\t\t\t     slot, nritems - slot);\n\t\tmemmove_extent_buffer(lower,\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_key_ptr));\n\t}\n\tif (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, lower, slot,\n\t\t\t\t\t      MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\tbtrfs_set_node_key(lower, key, slot);\n\tbtrfs_set_node_blockptr(lower, slot, bytenr);\n\tWARN_ON(trans->transid == 0);\n\tbtrfs_set_node_ptr_generation(lower, slot, trans->transid);\n\tbtrfs_set_header_nritems(lower, nritems + 1);\n\tbtrfs_mark_buffer_dirty(lower);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key",
          "args": [
            "right",
            "&disk_key",
            "0"
          ],
          "line": 4070
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "l",
            "mid"
          ],
          "line": 4069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_item_offset",
          "args": [
            "right",
            "item",
            "ioff + rt_data_off",
            "&token"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_token_item_offset",
          "args": [
            "right",
            "item",
            "&token"
          ],
          "line": 4064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "i"
          ],
          "line": 4061
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_end_nr",
          "args": [
            "l",
            "mid"
          ],
          "line": 4058
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_end_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2639-2642",
          "snippet": "static inline u32 btrfs_item_end_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_end(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_end_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_end(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 4057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_extent_buffer",
          "args": [
            "right",
            "l",
            "btrfs_leaf_data(right) + BTRFS_LEAF_DATA_SIZE(root) -\n\t\t     data_copy_size",
            "btrfs_leaf_data(l) +\n\t\t     leaf_data_end(root, l)",
            "data_copy_size"
          ],
          "line": 4052
        },
        "resolved": true,
        "details": {
          "function_name": "copy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5416-5447",
          "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_data_end",
          "args": [
            "root",
            "l"
          ],
          "line": 4055
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1729-1736",
          "snippet": "static inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_data",
          "args": [
            "l"
          ],
          "line": 4054
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3075-3078",
          "snippet": "static inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 4053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr_offset",
          "args": [
            "mid"
          ],
          "line": 4049
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2622-2626",
          "snippet": "static inline unsigned long btrfs_item_nr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_leaf, items) +\n\t\tsizeof(struct btrfs_item) * nr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_item_nr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_leaf, items) +\n\t\tsizeof(struct btrfs_item) * nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "right",
            "nritems"
          ],
          "line": 4045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_map_token",
          "args": [
            "&token"
          ],
          "line": 4042
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_map_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2214-2217",
          "snippet": "static inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic noinline void copy_for_split(struct btrfs_trans_handle *trans,\n\t\t\t\t    struct btrfs_root *root,\n\t\t\t\t    struct btrfs_path *path,\n\t\t\t\t    struct extent_buffer *l,\n\t\t\t\t    struct extent_buffer *right,\n\t\t\t\t    int slot, int mid, int nritems)\n{\n\tint data_copy_size;\n\tint rt_data_off;\n\tint i;\n\tstruct btrfs_disk_key disk_key;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tnritems = nritems - mid;\n\tbtrfs_set_header_nritems(right, nritems);\n\tdata_copy_size = btrfs_item_end_nr(l, mid) - leaf_data_end(root, l);\n\n\tcopy_extent_buffer(right, l, btrfs_item_nr_offset(0),\n\t\t\t   btrfs_item_nr_offset(mid),\n\t\t\t   nritems * sizeof(struct btrfs_item));\n\n\tcopy_extent_buffer(right, l,\n\t\t     btrfs_leaf_data(right) + BTRFS_LEAF_DATA_SIZE(root) -\n\t\t     data_copy_size, btrfs_leaf_data(l) +\n\t\t     leaf_data_end(root, l), data_copy_size);\n\n\trt_data_off = BTRFS_LEAF_DATA_SIZE(root) -\n\t\t      btrfs_item_end_nr(l, mid);\n\n\tfor (i = 0; i < nritems; i++) {\n\t\tstruct btrfs_item *item = btrfs_item_nr(i);\n\t\tu32 ioff;\n\n\t\tioff = btrfs_token_item_offset(right, item, &token);\n\t\tbtrfs_set_token_item_offset(right, item,\n\t\t\t\t\t    ioff + rt_data_off, &token);\n\t}\n\n\tbtrfs_set_header_nritems(l, mid);\n\tbtrfs_item_key(right, &disk_key, 0);\n\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t   path->slots[1] + 1, 1);\n\n\tbtrfs_mark_buffer_dirty(right);\n\tbtrfs_mark_buffer_dirty(l);\n\tBUG_ON(path->slots[0] != slot);\n\n\tif (mid <= slot) {\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] -= mid;\n\t\tpath->slots[1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\n\tBUG_ON(path->slots[0] < 0);\n}"
  },
  {
    "function_name": "push_leaf_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3964-4023",
    "snippet": "static int push_leaf_left(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, struct btrfs_path *path, int min_data_size,\n\t\t\t  int data_size, int empty, u32 max_slot)\n{\n\tstruct extent_buffer *right = path->nodes[0];\n\tstruct extent_buffer *left;\n\tint slot;\n\tint free_space;\n\tu32 right_nritems;\n\tint ret = 0;\n\n\tslot = path->slots[1];\n\tif (slot == 0)\n\t\treturn 1;\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tright_nritems = btrfs_header_nritems(right);\n\tif (right_nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tleft = read_node_slot(root, path->nodes[1], slot - 1);\n\tif (left == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(left);\n\tbtrfs_set_lock_blocking(left);\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, left,\n\t\t\t      path->nodes[1], slot - 1, &left);\n\tif (ret) {\n\t\t/* we hit -ENOSPC, but it isn't fatal here */\n\t\tif (ret == -ENOSPC)\n\t\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\treturn __push_leaf_left(trans, root, path, min_data_size,\n\t\t\t       empty, left, free_space, right_nritems,\n\t\t\t       max_slot);\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "left"
          ],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "left"
          ],
          "line": 4020
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__push_leaf_left",
          "args": [
            "trans",
            "root",
            "path",
            "min_data_size",
            "empty",
            "left",
            "free_space",
            "right_nritems",
            "max_slot"
          ],
          "line": 4016
        },
        "resolved": true,
        "details": {
          "function_name": "__push_leaf_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3811-3954",
          "snippet": "static noinline int __push_leaf_left(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     struct btrfs_path *path, int data_size,\n\t\t\t\t     int empty, struct extent_buffer *left,\n\t\t\t\t     int free_space, u32 right_nritems,\n\t\t\t\t     u32 max_slot)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *right = path->nodes[0];\n\tint i;\n\tint push_space = 0;\n\tint push_items = 0;\n\tstruct btrfs_item *item;\n\tu32 old_left_nritems;\n\tu32 nr;\n\tint ret = 0;\n\tu32 this_item_size;\n\tu32 old_left_item_size;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (empty)\n\t\tnr = min(right_nritems, max_slot);\n\telse\n\t\tnr = min(right_nritems - 1, max_slot);\n\n\tfor (i = 0; i < nr; i++) {\n\t\titem = btrfs_item_nr(i);\n\n\t\tif (!empty && push_items > 0) {\n\t\t\tif (path->slots[0] < i)\n\t\t\t\tbreak;\n\t\t\tif (path->slots[0] == i) {\n\t\t\t\tint space = btrfs_leaf_free_space(root, right);\n\t\t\t\tif (space + push_space * 2 > free_space)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (path->slots[0] == i)\n\t\t\tpush_space += data_size;\n\n\t\tthis_item_size = btrfs_item_size(right, item);\n\t\tif (this_item_size + sizeof(*item) + push_space > free_space)\n\t\t\tbreak;\n\n\t\tpush_items++;\n\t\tpush_space += this_item_size + sizeof(*item);\n\t}\n\n\tif (push_items == 0) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tWARN_ON(!empty && push_items == btrfs_header_nritems(right));\n\n\t/* push data from right to left */\n\tcopy_extent_buffer(left, right,\n\t\t\t   btrfs_item_nr_offset(btrfs_header_nritems(left)),\n\t\t\t   btrfs_item_nr_offset(0),\n\t\t\t   push_items * sizeof(struct btrfs_item));\n\n\tpush_space = BTRFS_LEAF_DATA_SIZE(root) -\n\t\t     btrfs_item_offset_nr(right, push_items - 1);\n\n\tcopy_extent_buffer(left, right, btrfs_leaf_data(left) +\n\t\t     leaf_data_end(root, left) - push_space,\n\t\t     btrfs_leaf_data(right) +\n\t\t     btrfs_item_offset_nr(right, push_items - 1),\n\t\t     push_space);\n\told_left_nritems = btrfs_header_nritems(left);\n\tBUG_ON(old_left_nritems <= 0);\n\n\told_left_item_size = btrfs_item_offset_nr(left, old_left_nritems - 1);\n\tfor (i = old_left_nritems; i < old_left_nritems + push_items; i++) {\n\t\tu32 ioff;\n\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(left, item, &token);\n\t\tbtrfs_set_token_item_offset(left, item,\n\t\t      ioff - (BTRFS_LEAF_DATA_SIZE(root) - old_left_item_size),\n\t\t      &token);\n\t}\n\tbtrfs_set_header_nritems(left, old_left_nritems + push_items);\n\n\t/* fixup right node */\n\tif (push_items > right_nritems)\n\t\tWARN(1, KERN_CRIT \"push items %d nr %u\\n\", push_items,\n\t\t       right_nritems);\n\n\tif (push_items < right_nritems) {\n\t\tpush_space = btrfs_item_offset_nr(right, push_items - 1) -\n\t\t\t\t\t\t  leaf_data_end(root, right);\n\t\tmemmove_extent_buffer(right, btrfs_leaf_data(right) +\n\t\t\t\t      BTRFS_LEAF_DATA_SIZE(root) - push_space,\n\t\t\t\t      btrfs_leaf_data(right) +\n\t\t\t\t      leaf_data_end(root, right), push_space);\n\n\t\tmemmove_extent_buffer(right, btrfs_item_nr_offset(0),\n\t\t\t      btrfs_item_nr_offset(push_items),\n\t\t\t     (btrfs_header_nritems(right) - push_items) *\n\t\t\t     sizeof(struct btrfs_item));\n\t}\n\tright_nritems -= push_items;\n\tbtrfs_set_header_nritems(right, right_nritems);\n\tpush_space = BTRFS_LEAF_DATA_SIZE(root);\n\tfor (i = 0; i < right_nritems; i++) {\n\t\titem = btrfs_item_nr(i);\n\n\t\tpush_space = push_space - btrfs_token_item_size(right,\n\t\t\t\t\t\t\t\titem, &token);\n\t\tbtrfs_set_token_item_offset(right, item, push_space, &token);\n\t}\n\n\tbtrfs_mark_buffer_dirty(left);\n\tif (right_nritems)\n\t\tbtrfs_mark_buffer_dirty(right);\n\telse\n\t\tclean_tree_block(trans, root, right);\n\n\tbtrfs_item_key(right, &disk_key, 0);\n\tfixup_low_keys(root, path, &disk_key, 1);\n\n\t/* then fixup the leaf pointer in the path */\n\tif (path->slots[0] < push_items) {\n\t\tpath->slots[0] += old_left_nritems;\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = left;\n\t\tpath->slots[1] -= 1;\n\t} else {\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->slots[0] -= push_items;\n\t}\n\tBUG_ON(path->slots[0] < 0);\n\treturn ret;\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic noinline struct;\n\nstatic noinline int __push_leaf_left(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     struct btrfs_path *path, int data_size,\n\t\t\t\t     int empty, struct extent_buffer *left,\n\t\t\t\t     int free_space, u32 right_nritems,\n\t\t\t\t     u32 max_slot)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *right = path->nodes[0];\n\tint i;\n\tint push_space = 0;\n\tint push_items = 0;\n\tstruct btrfs_item *item;\n\tu32 old_left_nritems;\n\tu32 nr;\n\tint ret = 0;\n\tu32 this_item_size;\n\tu32 old_left_item_size;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (empty)\n\t\tnr = min(right_nritems, max_slot);\n\telse\n\t\tnr = min(right_nritems - 1, max_slot);\n\n\tfor (i = 0; i < nr; i++) {\n\t\titem = btrfs_item_nr(i);\n\n\t\tif (!empty && push_items > 0) {\n\t\t\tif (path->slots[0] < i)\n\t\t\t\tbreak;\n\t\t\tif (path->slots[0] == i) {\n\t\t\t\tint space = btrfs_leaf_free_space(root, right);\n\t\t\t\tif (space + push_space * 2 > free_space)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (path->slots[0] == i)\n\t\t\tpush_space += data_size;\n\n\t\tthis_item_size = btrfs_item_size(right, item);\n\t\tif (this_item_size + sizeof(*item) + push_space > free_space)\n\t\t\tbreak;\n\n\t\tpush_items++;\n\t\tpush_space += this_item_size + sizeof(*item);\n\t}\n\n\tif (push_items == 0) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tWARN_ON(!empty && push_items == btrfs_header_nritems(right));\n\n\t/* push data from right to left */\n\tcopy_extent_buffer(left, right,\n\t\t\t   btrfs_item_nr_offset(btrfs_header_nritems(left)),\n\t\t\t   btrfs_item_nr_offset(0),\n\t\t\t   push_items * sizeof(struct btrfs_item));\n\n\tpush_space = BTRFS_LEAF_DATA_SIZE(root) -\n\t\t     btrfs_item_offset_nr(right, push_items - 1);\n\n\tcopy_extent_buffer(left, right, btrfs_leaf_data(left) +\n\t\t     leaf_data_end(root, left) - push_space,\n\t\t     btrfs_leaf_data(right) +\n\t\t     btrfs_item_offset_nr(right, push_items - 1),\n\t\t     push_space);\n\told_left_nritems = btrfs_header_nritems(left);\n\tBUG_ON(old_left_nritems <= 0);\n\n\told_left_item_size = btrfs_item_offset_nr(left, old_left_nritems - 1);\n\tfor (i = old_left_nritems; i < old_left_nritems + push_items; i++) {\n\t\tu32 ioff;\n\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(left, item, &token);\n\t\tbtrfs_set_token_item_offset(left, item,\n\t\t      ioff - (BTRFS_LEAF_DATA_SIZE(root) - old_left_item_size),\n\t\t      &token);\n\t}\n\tbtrfs_set_header_nritems(left, old_left_nritems + push_items);\n\n\t/* fixup right node */\n\tif (push_items > right_nritems)\n\t\tWARN(1, KERN_CRIT \"push items %d nr %u\\n\", push_items,\n\t\t       right_nritems);\n\n\tif (push_items < right_nritems) {\n\t\tpush_space = btrfs_item_offset_nr(right, push_items - 1) -\n\t\t\t\t\t\t  leaf_data_end(root, right);\n\t\tmemmove_extent_buffer(right, btrfs_leaf_data(right) +\n\t\t\t\t      BTRFS_LEAF_DATA_SIZE(root) - push_space,\n\t\t\t\t      btrfs_leaf_data(right) +\n\t\t\t\t      leaf_data_end(root, right), push_space);\n\n\t\tmemmove_extent_buffer(right, btrfs_item_nr_offset(0),\n\t\t\t      btrfs_item_nr_offset(push_items),\n\t\t\t     (btrfs_header_nritems(right) - push_items) *\n\t\t\t     sizeof(struct btrfs_item));\n\t}\n\tright_nritems -= push_items;\n\tbtrfs_set_header_nritems(right, right_nritems);\n\tpush_space = BTRFS_LEAF_DATA_SIZE(root);\n\tfor (i = 0; i < right_nritems; i++) {\n\t\titem = btrfs_item_nr(i);\n\n\t\tpush_space = push_space - btrfs_token_item_size(right,\n\t\t\t\t\t\t\t\titem, &token);\n\t\tbtrfs_set_token_item_offset(right, item, push_space, &token);\n\t}\n\n\tbtrfs_mark_buffer_dirty(left);\n\tif (right_nritems)\n\t\tbtrfs_mark_buffer_dirty(right);\n\telse\n\t\tclean_tree_block(trans, root, right);\n\n\tbtrfs_item_key(right, &disk_key, 0);\n\tfixup_low_keys(root, path, &disk_key, 1);\n\n\t/* then fixup the leaf pointer in the path */\n\tif (path->slots[0] < push_items) {\n\t\tpath->slots[0] += old_left_nritems;\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = left;\n\t\tpath->slots[1] -= 1;\n\t} else {\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->slots[0] -= push_items;\n\t}\n\tBUG_ON(path->slots[0] < 0);\n\treturn ret;\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "left"
          ],
          "line": 4010
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cow_block",
          "args": [
            "trans",
            "root",
            "left",
            "path->nodes[1]",
            "slot - 1",
            "&left"
          ],
          "line": 4001
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1534-1568",
          "snippet": "noinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "left"
          ],
          "line": 3992
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "left"
          ],
          "line": 3991
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_node_slot",
          "args": [
            "root",
            "path->nodes[1]",
            "slot - 1"
          ],
          "line": 3987
        },
        "resolved": true,
        "details": {
          "function_name": "read_node_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1853-1874",
          "snippet": "extent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nextent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_locked",
          "args": [
            "path->nodes[1]"
          ],
          "line": 3985
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "292-295",
          "snippet": "void btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "right"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int push_leaf_left(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t  *root, struct btrfs_path *path, int min_data_size,\n\t\t\t  int data_size, int empty, u32 max_slot)\n{\n\tstruct extent_buffer *right = path->nodes[0];\n\tstruct extent_buffer *left;\n\tint slot;\n\tint free_space;\n\tu32 right_nritems;\n\tint ret = 0;\n\n\tslot = path->slots[1];\n\tif (slot == 0)\n\t\treturn 1;\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tright_nritems = btrfs_header_nritems(right);\n\tif (right_nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tleft = read_node_slot(root, path->nodes[1], slot - 1);\n\tif (left == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(left);\n\tbtrfs_set_lock_blocking(left);\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, left,\n\t\t\t      path->nodes[1], slot - 1, &left);\n\tif (ret) {\n\t\t/* we hit -ENOSPC, but it isn't fatal here */\n\t\tif (ret == -ENOSPC)\n\t\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\tfree_space = btrfs_leaf_free_space(root, left);\n\tif (free_space < data_size) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\treturn __push_leaf_left(trans, root, path, min_data_size,\n\t\t\t       empty, left, free_space, right_nritems,\n\t\t\t       max_slot);\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}"
  },
  {
    "function_name": "__push_leaf_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3811-3954",
    "snippet": "static noinline int __push_leaf_left(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     struct btrfs_path *path, int data_size,\n\t\t\t\t     int empty, struct extent_buffer *left,\n\t\t\t\t     int free_space, u32 right_nritems,\n\t\t\t\t     u32 max_slot)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *right = path->nodes[0];\n\tint i;\n\tint push_space = 0;\n\tint push_items = 0;\n\tstruct btrfs_item *item;\n\tu32 old_left_nritems;\n\tu32 nr;\n\tint ret = 0;\n\tu32 this_item_size;\n\tu32 old_left_item_size;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (empty)\n\t\tnr = min(right_nritems, max_slot);\n\telse\n\t\tnr = min(right_nritems - 1, max_slot);\n\n\tfor (i = 0; i < nr; i++) {\n\t\titem = btrfs_item_nr(i);\n\n\t\tif (!empty && push_items > 0) {\n\t\t\tif (path->slots[0] < i)\n\t\t\t\tbreak;\n\t\t\tif (path->slots[0] == i) {\n\t\t\t\tint space = btrfs_leaf_free_space(root, right);\n\t\t\t\tif (space + push_space * 2 > free_space)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (path->slots[0] == i)\n\t\t\tpush_space += data_size;\n\n\t\tthis_item_size = btrfs_item_size(right, item);\n\t\tif (this_item_size + sizeof(*item) + push_space > free_space)\n\t\t\tbreak;\n\n\t\tpush_items++;\n\t\tpush_space += this_item_size + sizeof(*item);\n\t}\n\n\tif (push_items == 0) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tWARN_ON(!empty && push_items == btrfs_header_nritems(right));\n\n\t/* push data from right to left */\n\tcopy_extent_buffer(left, right,\n\t\t\t   btrfs_item_nr_offset(btrfs_header_nritems(left)),\n\t\t\t   btrfs_item_nr_offset(0),\n\t\t\t   push_items * sizeof(struct btrfs_item));\n\n\tpush_space = BTRFS_LEAF_DATA_SIZE(root) -\n\t\t     btrfs_item_offset_nr(right, push_items - 1);\n\n\tcopy_extent_buffer(left, right, btrfs_leaf_data(left) +\n\t\t     leaf_data_end(root, left) - push_space,\n\t\t     btrfs_leaf_data(right) +\n\t\t     btrfs_item_offset_nr(right, push_items - 1),\n\t\t     push_space);\n\told_left_nritems = btrfs_header_nritems(left);\n\tBUG_ON(old_left_nritems <= 0);\n\n\told_left_item_size = btrfs_item_offset_nr(left, old_left_nritems - 1);\n\tfor (i = old_left_nritems; i < old_left_nritems + push_items; i++) {\n\t\tu32 ioff;\n\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(left, item, &token);\n\t\tbtrfs_set_token_item_offset(left, item,\n\t\t      ioff - (BTRFS_LEAF_DATA_SIZE(root) - old_left_item_size),\n\t\t      &token);\n\t}\n\tbtrfs_set_header_nritems(left, old_left_nritems + push_items);\n\n\t/* fixup right node */\n\tif (push_items > right_nritems)\n\t\tWARN(1, KERN_CRIT \"push items %d nr %u\\n\", push_items,\n\t\t       right_nritems);\n\n\tif (push_items < right_nritems) {\n\t\tpush_space = btrfs_item_offset_nr(right, push_items - 1) -\n\t\t\t\t\t\t  leaf_data_end(root, right);\n\t\tmemmove_extent_buffer(right, btrfs_leaf_data(right) +\n\t\t\t\t      BTRFS_LEAF_DATA_SIZE(root) - push_space,\n\t\t\t\t      btrfs_leaf_data(right) +\n\t\t\t\t      leaf_data_end(root, right), push_space);\n\n\t\tmemmove_extent_buffer(right, btrfs_item_nr_offset(0),\n\t\t\t      btrfs_item_nr_offset(push_items),\n\t\t\t     (btrfs_header_nritems(right) - push_items) *\n\t\t\t     sizeof(struct btrfs_item));\n\t}\n\tright_nritems -= push_items;\n\tbtrfs_set_header_nritems(right, right_nritems);\n\tpush_space = BTRFS_LEAF_DATA_SIZE(root);\n\tfor (i = 0; i < right_nritems; i++) {\n\t\titem = btrfs_item_nr(i);\n\n\t\tpush_space = push_space - btrfs_token_item_size(right,\n\t\t\t\t\t\t\t\titem, &token);\n\t\tbtrfs_set_token_item_offset(right, item, push_space, &token);\n\t}\n\n\tbtrfs_mark_buffer_dirty(left);\n\tif (right_nritems)\n\t\tbtrfs_mark_buffer_dirty(right);\n\telse\n\t\tclean_tree_block(trans, root, right);\n\n\tbtrfs_item_key(right, &disk_key, 0);\n\tfixup_low_keys(root, path, &disk_key, 1);\n\n\t/* then fixup the leaf pointer in the path */\n\tif (path->slots[0] < push_items) {\n\t\tpath->slots[0] += old_left_nritems;\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = left;\n\t\tpath->slots[1] -= 1;\n\t} else {\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->slots[0] -= push_items;\n\t}\n\tBUG_ON(path->slots[0] < 0);\n\treturn ret;\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "left"
          ],
          "line": 3952
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "left"
          ],
          "line": 3951
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path->slots[0] < 0"
          ],
          "line": 3948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixup_low_keys",
          "args": [
            "root",
            "path",
            "&disk_key",
            "1"
          ],
          "line": 3934
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_low_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3129-3146",
          "snippet": "static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key",
          "args": [
            "right",
            "&disk_key",
            "0"
          ],
          "line": 3933
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_tree_block",
          "args": [
            "trans",
            "root",
            "right"
          ],
          "line": 3931
        },
        "resolved": true,
        "details": {
          "function_name": "clean_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1168-1186",
          "snippet": "void clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "right"
          ],
          "line": 3929
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_item_offset",
          "args": [
            "right",
            "item",
            "push_space",
            "&token"
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_token_item_size",
          "args": [
            "right",
            "item",
            "&token"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "i"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "right",
            "right_nritems"
          ],
          "line": 3917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "right",
            "btrfs_item_nr_offset(0)",
            "btrfs_item_nr_offset(push_items)",
            "(btrfs_header_nritems(right) - push_items) *\n\t\t\t     sizeof(struct btrfs_item)"
          ],
          "line": 3911
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "right"
          ],
          "line": 3913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr_offset",
          "args": [
            "push_items"
          ],
          "line": 3912
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2622-2626",
          "snippet": "static inline unsigned long btrfs_item_nr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_leaf, items) +\n\t\tsizeof(struct btrfs_item) * nr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_item_nr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_leaf, items) +\n\t\tsizeof(struct btrfs_item) * nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_data_end",
          "args": [
            "root",
            "right"
          ],
          "line": 3909
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1729-1736",
          "snippet": "static inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_data",
          "args": [
            "right"
          ],
          "line": 3908
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3075-3078",
          "snippet": "static inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 3907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_offset_nr",
          "args": [
            "right",
            "push_items - 1"
          ],
          "line": 3904
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_offset_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2644-2647",
          "snippet": "static inline u32 btrfs_item_offset_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_offset(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_offset_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_offset(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_CRIT \"push items %d nr %u\\n\"",
            "push_items",
            "right_nritems"
          ],
          "line": 3900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "left",
            "old_left_nritems + push_items"
          ],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_item_offset",
          "args": [
            "left",
            "item",
            "ioff - (BTRFS_LEAF_DATA_SIZE(root) - old_left_item_size)",
            "&token"
          ],
          "line": 3892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 3893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_token_item_offset",
          "args": [
            "left",
            "item",
            "&token"
          ],
          "line": 3891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "old_left_nritems <= 0"
          ],
          "line": 3883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "left"
          ],
          "line": 3882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_extent_buffer",
          "args": [
            "left",
            "right",
            "btrfs_leaf_data(left) +\n\t\t     leaf_data_end(root, left) - push_space",
            "btrfs_leaf_data(right) +\n\t\t     btrfs_item_offset_nr(right, push_items - 1)",
            "push_space"
          ],
          "line": 3877
        },
        "resolved": true,
        "details": {
          "function_name": "copy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5416-5447",
          "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 3874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "left"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!empty && push_items == btrfs_header_nritems(right)"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "right"
          ],
          "line": 3866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size",
          "args": [
            "right",
            "item"
          ],
          "line": 3854
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "right"
          ],
          "line": 3845
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "right_nritems - 1",
            "max_slot"
          ],
          "line": 3836
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_map_token",
          "args": [
            "&token"
          ],
          "line": 3831
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_map_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2214-2217",
          "snippet": "static inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic noinline struct;\n\nstatic noinline int __push_leaf_left(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t     struct btrfs_path *path, int data_size,\n\t\t\t\t     int empty, struct extent_buffer *left,\n\t\t\t\t     int free_space, u32 right_nritems,\n\t\t\t\t     u32 max_slot)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *right = path->nodes[0];\n\tint i;\n\tint push_space = 0;\n\tint push_items = 0;\n\tstruct btrfs_item *item;\n\tu32 old_left_nritems;\n\tu32 nr;\n\tint ret = 0;\n\tu32 this_item_size;\n\tu32 old_left_item_size;\n\tstruct btrfs_map_token token;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (empty)\n\t\tnr = min(right_nritems, max_slot);\n\telse\n\t\tnr = min(right_nritems - 1, max_slot);\n\n\tfor (i = 0; i < nr; i++) {\n\t\titem = btrfs_item_nr(i);\n\n\t\tif (!empty && push_items > 0) {\n\t\t\tif (path->slots[0] < i)\n\t\t\t\tbreak;\n\t\t\tif (path->slots[0] == i) {\n\t\t\t\tint space = btrfs_leaf_free_space(root, right);\n\t\t\t\tif (space + push_space * 2 > free_space)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (path->slots[0] == i)\n\t\t\tpush_space += data_size;\n\n\t\tthis_item_size = btrfs_item_size(right, item);\n\t\tif (this_item_size + sizeof(*item) + push_space > free_space)\n\t\t\tbreak;\n\n\t\tpush_items++;\n\t\tpush_space += this_item_size + sizeof(*item);\n\t}\n\n\tif (push_items == 0) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\tWARN_ON(!empty && push_items == btrfs_header_nritems(right));\n\n\t/* push data from right to left */\n\tcopy_extent_buffer(left, right,\n\t\t\t   btrfs_item_nr_offset(btrfs_header_nritems(left)),\n\t\t\t   btrfs_item_nr_offset(0),\n\t\t\t   push_items * sizeof(struct btrfs_item));\n\n\tpush_space = BTRFS_LEAF_DATA_SIZE(root) -\n\t\t     btrfs_item_offset_nr(right, push_items - 1);\n\n\tcopy_extent_buffer(left, right, btrfs_leaf_data(left) +\n\t\t     leaf_data_end(root, left) - push_space,\n\t\t     btrfs_leaf_data(right) +\n\t\t     btrfs_item_offset_nr(right, push_items - 1),\n\t\t     push_space);\n\told_left_nritems = btrfs_header_nritems(left);\n\tBUG_ON(old_left_nritems <= 0);\n\n\told_left_item_size = btrfs_item_offset_nr(left, old_left_nritems - 1);\n\tfor (i = old_left_nritems; i < old_left_nritems + push_items; i++) {\n\t\tu32 ioff;\n\n\t\titem = btrfs_item_nr(i);\n\n\t\tioff = btrfs_token_item_offset(left, item, &token);\n\t\tbtrfs_set_token_item_offset(left, item,\n\t\t      ioff - (BTRFS_LEAF_DATA_SIZE(root) - old_left_item_size),\n\t\t      &token);\n\t}\n\tbtrfs_set_header_nritems(left, old_left_nritems + push_items);\n\n\t/* fixup right node */\n\tif (push_items > right_nritems)\n\t\tWARN(1, KERN_CRIT \"push items %d nr %u\\n\", push_items,\n\t\t       right_nritems);\n\n\tif (push_items < right_nritems) {\n\t\tpush_space = btrfs_item_offset_nr(right, push_items - 1) -\n\t\t\t\t\t\t  leaf_data_end(root, right);\n\t\tmemmove_extent_buffer(right, btrfs_leaf_data(right) +\n\t\t\t\t      BTRFS_LEAF_DATA_SIZE(root) - push_space,\n\t\t\t\t      btrfs_leaf_data(right) +\n\t\t\t\t      leaf_data_end(root, right), push_space);\n\n\t\tmemmove_extent_buffer(right, btrfs_item_nr_offset(0),\n\t\t\t      btrfs_item_nr_offset(push_items),\n\t\t\t     (btrfs_header_nritems(right) - push_items) *\n\t\t\t     sizeof(struct btrfs_item));\n\t}\n\tright_nritems -= push_items;\n\tbtrfs_set_header_nritems(right, right_nritems);\n\tpush_space = BTRFS_LEAF_DATA_SIZE(root);\n\tfor (i = 0; i < right_nritems; i++) {\n\t\titem = btrfs_item_nr(i);\n\n\t\tpush_space = push_space - btrfs_token_item_size(right,\n\t\t\t\t\t\t\t\titem, &token);\n\t\tbtrfs_set_token_item_offset(right, item, push_space, &token);\n\t}\n\n\tbtrfs_mark_buffer_dirty(left);\n\tif (right_nritems)\n\t\tbtrfs_mark_buffer_dirty(right);\n\telse\n\t\tclean_tree_block(trans, root, right);\n\n\tbtrfs_item_key(right, &disk_key, 0);\n\tfixup_low_keys(root, path, &disk_key, 1);\n\n\t/* then fixup the leaf pointer in the path */\n\tif (path->slots[0] < push_items) {\n\t\tpath->slots[0] += old_left_nritems;\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = left;\n\t\tpath->slots[1] -= 1;\n\t} else {\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->slots[0] -= push_items;\n\t}\n\tBUG_ON(path->slots[0] < 0);\n\treturn ret;\nout:\n\tbtrfs_tree_unlock(left);\n\tfree_extent_buffer(left);\n\treturn ret;\n}"
  },
  {
    "function_name": "push_leaf_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3734-3801",
    "snippet": "static int push_leaf_right(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t   *root, struct btrfs_path *path,\n\t\t\t   int min_data_size, int data_size,\n\t\t\t   int empty, u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *right;\n\tstruct extent_buffer *upper;\n\tint slot;\n\tint free_space;\n\tu32 left_nritems;\n\tint ret;\n\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tslot = path->slots[1];\n\tupper = path->nodes[1];\n\tif (slot >= btrfs_header_nritems(upper) - 1)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tright = read_node_slot(root, upper, slot + 1);\n\tif (right == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(right);\n\tbtrfs_set_lock_blocking(right);\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, right, upper,\n\t\t\t      slot + 1, &right);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\tleft_nritems = btrfs_header_nritems(left);\n\tif (left_nritems == 0)\n\t\tgoto out_unlock;\n\n\tif (path->slots[0] == left_nritems && !empty) {\n\t\t/* Key greater than all keys in the leaf, right neighbor has\n\t\t * enough room for it and we're not emptying our leaf to delete\n\t\t * it, therefore use right neighbor to insert the new item and\n\t\t * no need to touch/dirty our left leaft. */\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] = 0;\n\t\tpath->slots[1]++;\n\t\treturn 0;\n\t}\n\n\treturn __push_leaf_right(trans, root, path, min_data_size, empty,\n\t\t\t\tright, free_space, left_nritems, min_slot);\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "right"
          ],
          "line": 3799
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "right"
          ],
          "line": 3798
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__push_leaf_right",
          "args": [
            "trans",
            "root",
            "path",
            "min_data_size",
            "empty",
            "right",
            "free_space",
            "left_nritems",
            "min_slot"
          ],
          "line": 3795
        },
        "resolved": true,
        "details": {
          "function_name": "__push_leaf_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3585-3722",
          "snippet": "static noinline int __push_leaf_right(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      int data_size, int empty,\n\t\t\t\t      struct extent_buffer *right,\n\t\t\t\t      int free_space, u32 left_nritems,\n\t\t\t\t      u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *upper = path->nodes[1];\n\tstruct btrfs_map_token token;\n\tstruct btrfs_disk_key disk_key;\n\tint slot;\n\tu32 i;\n\tint push_space = 0;\n\tint push_items = 0;\n\tstruct btrfs_item *item;\n\tu32 nr;\n\tu32 right_nritems;\n\tu32 data_end;\n\tu32 this_item_size;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (empty)\n\t\tnr = 0;\n\telse\n\t\tnr = max_t(u32, 1, min_slot);\n\n\tif (path->slots[0] >= left_nritems)\n\t\tpush_space += data_size;\n\n\tslot = path->slots[1];\n\ti = left_nritems - 1;\n\twhile (i >= nr) {\n\t\titem = btrfs_item_nr(i);\n\n\t\tif (!empty && push_items > 0) {\n\t\t\tif (path->slots[0] > i)\n\t\t\t\tbreak;\n\t\t\tif (path->slots[0] == i) {\n\t\t\t\tint space = btrfs_leaf_free_space(root, left);\n\t\t\t\tif (space + push_space * 2 > free_space)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (path->slots[0] == i)\n\t\t\tpush_space += data_size;\n\n\t\tthis_item_size = btrfs_item_size(left, item);\n\t\tif (this_item_size + sizeof(*item) + push_space > free_space)\n\t\t\tbreak;\n\n\t\tpush_items++;\n\t\tpush_space += this_item_size + sizeof(*item);\n\t\tif (i == 0)\n\t\t\tbreak;\n\t\ti--;\n\t}\n\n\tif (push_items == 0)\n\t\tgoto out_unlock;\n\n\tWARN_ON(!empty && push_items == left_nritems);\n\n\t/* push left to right */\n\tright_nritems = btrfs_header_nritems(right);\n\n\tpush_space = btrfs_item_end_nr(left, left_nritems - push_items);\n\tpush_space -= leaf_data_end(root, left);\n\n\t/* make room in the right data area */\n\tdata_end = leaf_data_end(root, right);\n\tmemmove_extent_buffer(right,\n\t\t\t      btrfs_leaf_data(right) + data_end - push_space,\n\t\t\t      btrfs_leaf_data(right) + data_end,\n\t\t\t      BTRFS_LEAF_DATA_SIZE(root) - data_end);\n\n\t/* copy from the left data area */\n\tcopy_extent_buffer(right, left, btrfs_leaf_data(right) +\n\t\t     BTRFS_LEAF_DATA_SIZE(root) - push_space,\n\t\t     btrfs_leaf_data(left) + leaf_data_end(root, left),\n\t\t     push_space);\n\n\tmemmove_extent_buffer(right, btrfs_item_nr_offset(push_items),\n\t\t\t      btrfs_item_nr_offset(0),\n\t\t\t      right_nritems * sizeof(struct btrfs_item));\n\n\t/* copy the items from left to right */\n\tcopy_extent_buffer(right, left, btrfs_item_nr_offset(0),\n\t\t   btrfs_item_nr_offset(left_nritems - push_items),\n\t\t   push_items * sizeof(struct btrfs_item));\n\n\t/* update the item pointers */\n\tright_nritems += push_items;\n\tbtrfs_set_header_nritems(right, right_nritems);\n\tpush_space = BTRFS_LEAF_DATA_SIZE(root);\n\tfor (i = 0; i < right_nritems; i++) {\n\t\titem = btrfs_item_nr(i);\n\t\tpush_space -= btrfs_token_item_size(right, item, &token);\n\t\tbtrfs_set_token_item_offset(right, item, push_space, &token);\n\t}\n\n\tleft_nritems -= push_items;\n\tbtrfs_set_header_nritems(left, left_nritems);\n\n\tif (left_nritems)\n\t\tbtrfs_mark_buffer_dirty(left);\n\telse\n\t\tclean_tree_block(trans, root, left);\n\n\tbtrfs_mark_buffer_dirty(right);\n\n\tbtrfs_item_key(right, &disk_key, 0);\n\tbtrfs_set_node_key(upper, &disk_key, slot + 1);\n\tbtrfs_mark_buffer_dirty(upper);\n\n\t/* then fixup the leaf pointer in the path */\n\tif (path->slots[0] >= left_nritems) {\n\t\tpath->slots[0] -= left_nritems;\n\t\tif (btrfs_header_nritems(path->nodes[0]) == 0)\n\t\t\tclean_tree_block(trans, root, path->nodes[0]);\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\treturn 0;\n\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic noinline int __push_leaf_right(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      int data_size, int empty,\n\t\t\t\t      struct extent_buffer *right,\n\t\t\t\t      int free_space, u32 left_nritems,\n\t\t\t\t      u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *upper = path->nodes[1];\n\tstruct btrfs_map_token token;\n\tstruct btrfs_disk_key disk_key;\n\tint slot;\n\tu32 i;\n\tint push_space = 0;\n\tint push_items = 0;\n\tstruct btrfs_item *item;\n\tu32 nr;\n\tu32 right_nritems;\n\tu32 data_end;\n\tu32 this_item_size;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (empty)\n\t\tnr = 0;\n\telse\n\t\tnr = max_t(u32, 1, min_slot);\n\n\tif (path->slots[0] >= left_nritems)\n\t\tpush_space += data_size;\n\n\tslot = path->slots[1];\n\ti = left_nritems - 1;\n\twhile (i >= nr) {\n\t\titem = btrfs_item_nr(i);\n\n\t\tif (!empty && push_items > 0) {\n\t\t\tif (path->slots[0] > i)\n\t\t\t\tbreak;\n\t\t\tif (path->slots[0] == i) {\n\t\t\t\tint space = btrfs_leaf_free_space(root, left);\n\t\t\t\tif (space + push_space * 2 > free_space)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (path->slots[0] == i)\n\t\t\tpush_space += data_size;\n\n\t\tthis_item_size = btrfs_item_size(left, item);\n\t\tif (this_item_size + sizeof(*item) + push_space > free_space)\n\t\t\tbreak;\n\n\t\tpush_items++;\n\t\tpush_space += this_item_size + sizeof(*item);\n\t\tif (i == 0)\n\t\t\tbreak;\n\t\ti--;\n\t}\n\n\tif (push_items == 0)\n\t\tgoto out_unlock;\n\n\tWARN_ON(!empty && push_items == left_nritems);\n\n\t/* push left to right */\n\tright_nritems = btrfs_header_nritems(right);\n\n\tpush_space = btrfs_item_end_nr(left, left_nritems - push_items);\n\tpush_space -= leaf_data_end(root, left);\n\n\t/* make room in the right data area */\n\tdata_end = leaf_data_end(root, right);\n\tmemmove_extent_buffer(right,\n\t\t\t      btrfs_leaf_data(right) + data_end - push_space,\n\t\t\t      btrfs_leaf_data(right) + data_end,\n\t\t\t      BTRFS_LEAF_DATA_SIZE(root) - data_end);\n\n\t/* copy from the left data area */\n\tcopy_extent_buffer(right, left, btrfs_leaf_data(right) +\n\t\t     BTRFS_LEAF_DATA_SIZE(root) - push_space,\n\t\t     btrfs_leaf_data(left) + leaf_data_end(root, left),\n\t\t     push_space);\n\n\tmemmove_extent_buffer(right, btrfs_item_nr_offset(push_items),\n\t\t\t      btrfs_item_nr_offset(0),\n\t\t\t      right_nritems * sizeof(struct btrfs_item));\n\n\t/* copy the items from left to right */\n\tcopy_extent_buffer(right, left, btrfs_item_nr_offset(0),\n\t\t   btrfs_item_nr_offset(left_nritems - push_items),\n\t\t   push_items * sizeof(struct btrfs_item));\n\n\t/* update the item pointers */\n\tright_nritems += push_items;\n\tbtrfs_set_header_nritems(right, right_nritems);\n\tpush_space = BTRFS_LEAF_DATA_SIZE(root);\n\tfor (i = 0; i < right_nritems; i++) {\n\t\titem = btrfs_item_nr(i);\n\t\tpush_space -= btrfs_token_item_size(right, item, &token);\n\t\tbtrfs_set_token_item_offset(right, item, push_space, &token);\n\t}\n\n\tleft_nritems -= push_items;\n\tbtrfs_set_header_nritems(left, left_nritems);\n\n\tif (left_nritems)\n\t\tbtrfs_mark_buffer_dirty(left);\n\telse\n\t\tclean_tree_block(trans, root, left);\n\n\tbtrfs_mark_buffer_dirty(right);\n\n\tbtrfs_item_key(right, &disk_key, 0);\n\tbtrfs_set_node_key(upper, &disk_key, slot + 1);\n\tbtrfs_mark_buffer_dirty(upper);\n\n\t/* then fixup the leaf pointer in the path */\n\tif (path->slots[0] >= left_nritems) {\n\t\tpath->slots[0] -= left_nritems;\n\t\tif (btrfs_header_nritems(path->nodes[0]) == 0)\n\t\t\tclean_tree_block(trans, root, path->nodes[0]);\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\treturn 0;\n\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "left"
          ],
          "line": 3778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "right"
          ],
          "line": 3774
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cow_block",
          "args": [
            "trans",
            "root",
            "right",
            "upper",
            "slot + 1",
            "&right"
          ],
          "line": 3769
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1534-1568",
          "snippet": "noinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "right"
          ],
          "line": 3762
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "right"
          ],
          "line": 3761
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_node_slot",
          "args": [
            "root",
            "upper",
            "slot + 1"
          ],
          "line": 3757
        },
        "resolved": true,
        "details": {
          "function_name": "read_node_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1853-1874",
          "snippet": "extent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nextent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_locked",
          "args": [
            "path->nodes[1]"
          ],
          "line": 3755
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "292-295",
          "snippet": "void btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "upper"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int push_leaf_right(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t\t   *root, struct btrfs_path *path,\n\t\t\t   int min_data_size, int data_size,\n\t\t\t   int empty, u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *right;\n\tstruct extent_buffer *upper;\n\tint slot;\n\tint free_space;\n\tu32 left_nritems;\n\tint ret;\n\n\tif (!path->nodes[1])\n\t\treturn 1;\n\n\tslot = path->slots[1];\n\tupper = path->nodes[1];\n\tif (slot >= btrfs_header_nritems(upper) - 1)\n\t\treturn 1;\n\n\tbtrfs_assert_tree_locked(path->nodes[1]);\n\n\tright = read_node_slot(root, upper, slot + 1);\n\tif (right == NULL)\n\t\treturn 1;\n\n\tbtrfs_tree_lock(right);\n\tbtrfs_set_lock_blocking(right);\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\t/* cow and double check */\n\tret = btrfs_cow_block(trans, root, right, upper,\n\t\t\t      slot + 1, &right);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tfree_space = btrfs_leaf_free_space(root, right);\n\tif (free_space < data_size)\n\t\tgoto out_unlock;\n\n\tleft_nritems = btrfs_header_nritems(left);\n\tif (left_nritems == 0)\n\t\tgoto out_unlock;\n\n\tif (path->slots[0] == left_nritems && !empty) {\n\t\t/* Key greater than all keys in the leaf, right neighbor has\n\t\t * enough room for it and we're not emptying our leaf to delete\n\t\t * it, therefore use right neighbor to insert the new item and\n\t\t * no need to touch/dirty our left leaft. */\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[0] = 0;\n\t\tpath->slots[1]++;\n\t\treturn 0;\n\t}\n\n\treturn __push_leaf_right(trans, root, path, min_data_size, empty,\n\t\t\t\tright, free_space, left_nritems, min_slot);\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}"
  },
  {
    "function_name": "__push_leaf_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3585-3722",
    "snippet": "static noinline int __push_leaf_right(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      int data_size, int empty,\n\t\t\t\t      struct extent_buffer *right,\n\t\t\t\t      int free_space, u32 left_nritems,\n\t\t\t\t      u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *upper = path->nodes[1];\n\tstruct btrfs_map_token token;\n\tstruct btrfs_disk_key disk_key;\n\tint slot;\n\tu32 i;\n\tint push_space = 0;\n\tint push_items = 0;\n\tstruct btrfs_item *item;\n\tu32 nr;\n\tu32 right_nritems;\n\tu32 data_end;\n\tu32 this_item_size;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (empty)\n\t\tnr = 0;\n\telse\n\t\tnr = max_t(u32, 1, min_slot);\n\n\tif (path->slots[0] >= left_nritems)\n\t\tpush_space += data_size;\n\n\tslot = path->slots[1];\n\ti = left_nritems - 1;\n\twhile (i >= nr) {\n\t\titem = btrfs_item_nr(i);\n\n\t\tif (!empty && push_items > 0) {\n\t\t\tif (path->slots[0] > i)\n\t\t\t\tbreak;\n\t\t\tif (path->slots[0] == i) {\n\t\t\t\tint space = btrfs_leaf_free_space(root, left);\n\t\t\t\tif (space + push_space * 2 > free_space)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (path->slots[0] == i)\n\t\t\tpush_space += data_size;\n\n\t\tthis_item_size = btrfs_item_size(left, item);\n\t\tif (this_item_size + sizeof(*item) + push_space > free_space)\n\t\t\tbreak;\n\n\t\tpush_items++;\n\t\tpush_space += this_item_size + sizeof(*item);\n\t\tif (i == 0)\n\t\t\tbreak;\n\t\ti--;\n\t}\n\n\tif (push_items == 0)\n\t\tgoto out_unlock;\n\n\tWARN_ON(!empty && push_items == left_nritems);\n\n\t/* push left to right */\n\tright_nritems = btrfs_header_nritems(right);\n\n\tpush_space = btrfs_item_end_nr(left, left_nritems - push_items);\n\tpush_space -= leaf_data_end(root, left);\n\n\t/* make room in the right data area */\n\tdata_end = leaf_data_end(root, right);\n\tmemmove_extent_buffer(right,\n\t\t\t      btrfs_leaf_data(right) + data_end - push_space,\n\t\t\t      btrfs_leaf_data(right) + data_end,\n\t\t\t      BTRFS_LEAF_DATA_SIZE(root) - data_end);\n\n\t/* copy from the left data area */\n\tcopy_extent_buffer(right, left, btrfs_leaf_data(right) +\n\t\t     BTRFS_LEAF_DATA_SIZE(root) - push_space,\n\t\t     btrfs_leaf_data(left) + leaf_data_end(root, left),\n\t\t     push_space);\n\n\tmemmove_extent_buffer(right, btrfs_item_nr_offset(push_items),\n\t\t\t      btrfs_item_nr_offset(0),\n\t\t\t      right_nritems * sizeof(struct btrfs_item));\n\n\t/* copy the items from left to right */\n\tcopy_extent_buffer(right, left, btrfs_item_nr_offset(0),\n\t\t   btrfs_item_nr_offset(left_nritems - push_items),\n\t\t   push_items * sizeof(struct btrfs_item));\n\n\t/* update the item pointers */\n\tright_nritems += push_items;\n\tbtrfs_set_header_nritems(right, right_nritems);\n\tpush_space = BTRFS_LEAF_DATA_SIZE(root);\n\tfor (i = 0; i < right_nritems; i++) {\n\t\titem = btrfs_item_nr(i);\n\t\tpush_space -= btrfs_token_item_size(right, item, &token);\n\t\tbtrfs_set_token_item_offset(right, item, push_space, &token);\n\t}\n\n\tleft_nritems -= push_items;\n\tbtrfs_set_header_nritems(left, left_nritems);\n\n\tif (left_nritems)\n\t\tbtrfs_mark_buffer_dirty(left);\n\telse\n\t\tclean_tree_block(trans, root, left);\n\n\tbtrfs_mark_buffer_dirty(right);\n\n\tbtrfs_item_key(right, &disk_key, 0);\n\tbtrfs_set_node_key(upper, &disk_key, slot + 1);\n\tbtrfs_mark_buffer_dirty(upper);\n\n\t/* then fixup the leaf pointer in the path */\n\tif (path->slots[0] >= left_nritems) {\n\t\tpath->slots[0] -= left_nritems;\n\t\tif (btrfs_header_nritems(path->nodes[0]) == 0)\n\t\t\tclean_tree_block(trans, root, path->nodes[0]);\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\treturn 0;\n\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "right"
          ],
          "line": 3720
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "right"
          ],
          "line": 3719
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_tree_block",
          "args": [
            "trans",
            "root",
            "path->nodes[0]"
          ],
          "line": 3707
        },
        "resolved": true,
        "details": {
          "function_name": "clean_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1168-1186",
          "snippet": "void clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 3706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "upper"
          ],
          "line": 3701
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_key",
          "args": [
            "upper",
            "&disk_key",
            "slot + 1"
          ],
          "line": 3700
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2607-2614",
          "snippet": "static inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key",
          "args": [
            "right",
            "&disk_key",
            "0"
          ],
          "line": 3699
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "left",
            "left_nritems"
          ],
          "line": 3690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_token_item_offset",
          "args": [
            "right",
            "item",
            "push_space",
            "&token"
          ],
          "line": 3686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_token_item_size",
          "args": [
            "right",
            "item",
            "&token"
          ],
          "line": 3685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "i"
          ],
          "line": 3684
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "right",
            "right_nritems"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_extent_buffer",
          "args": [
            "right",
            "left",
            "btrfs_item_nr_offset(0)",
            "btrfs_item_nr_offset(left_nritems - push_items)",
            "push_items * sizeof(struct btrfs_item)"
          ],
          "line": 3675
        },
        "resolved": true,
        "details": {
          "function_name": "copy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5416-5447",
          "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr_offset",
          "args": [
            "left_nritems - push_items"
          ],
          "line": 3676
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2622-2626",
          "snippet": "static inline unsigned long btrfs_item_nr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_leaf, items) +\n\t\tsizeof(struct btrfs_item) * nr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_item_nr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_leaf, items) +\n\t\tsizeof(struct btrfs_item) * nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "right",
            "btrfs_item_nr_offset(push_items)",
            "btrfs_item_nr_offset(0)",
            "right_nritems * sizeof(struct btrfs_item)"
          ],
          "line": 3670
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "leaf_data_end",
          "args": [
            "root",
            "left"
          ],
          "line": 3667
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_data_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1729-1736",
          "snippet": "static inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_data",
          "args": [
            "left"
          ],
          "line": 3667
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3075-3078",
          "snippet": "static inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_leaf_data(struct extent_buffer *l)\n{\n\treturn offsetof(struct btrfs_leaf, items);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_end_nr",
          "args": [
            "left",
            "left_nritems - push_items"
          ],
          "line": 3654
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_end_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2639-2642",
          "snippet": "static inline u32 btrfs_item_end_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_end(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_end_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_end(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "right"
          ],
          "line": 3652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!empty && push_items == left_nritems"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size",
          "args": [
            "left",
            "item"
          ],
          "line": 3635
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "left"
          ],
          "line": 3626
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "u32",
            "1",
            "min_slot"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_init_map_token",
          "args": [
            "&token"
          ],
          "line": 3607
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_map_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2214-2217",
          "snippet": "static inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic noinline int __push_leaf_right(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *path,\n\t\t\t\t      int data_size, int empty,\n\t\t\t\t      struct extent_buffer *right,\n\t\t\t\t      int free_space, u32 left_nritems,\n\t\t\t\t      u32 min_slot)\n{\n\tstruct extent_buffer *left = path->nodes[0];\n\tstruct extent_buffer *upper = path->nodes[1];\n\tstruct btrfs_map_token token;\n\tstruct btrfs_disk_key disk_key;\n\tint slot;\n\tu32 i;\n\tint push_space = 0;\n\tint push_items = 0;\n\tstruct btrfs_item *item;\n\tu32 nr;\n\tu32 right_nritems;\n\tu32 data_end;\n\tu32 this_item_size;\n\n\tbtrfs_init_map_token(&token);\n\n\tif (empty)\n\t\tnr = 0;\n\telse\n\t\tnr = max_t(u32, 1, min_slot);\n\n\tif (path->slots[0] >= left_nritems)\n\t\tpush_space += data_size;\n\n\tslot = path->slots[1];\n\ti = left_nritems - 1;\n\twhile (i >= nr) {\n\t\titem = btrfs_item_nr(i);\n\n\t\tif (!empty && push_items > 0) {\n\t\t\tif (path->slots[0] > i)\n\t\t\t\tbreak;\n\t\t\tif (path->slots[0] == i) {\n\t\t\t\tint space = btrfs_leaf_free_space(root, left);\n\t\t\t\tif (space + push_space * 2 > free_space)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (path->slots[0] == i)\n\t\t\tpush_space += data_size;\n\n\t\tthis_item_size = btrfs_item_size(left, item);\n\t\tif (this_item_size + sizeof(*item) + push_space > free_space)\n\t\t\tbreak;\n\n\t\tpush_items++;\n\t\tpush_space += this_item_size + sizeof(*item);\n\t\tif (i == 0)\n\t\t\tbreak;\n\t\ti--;\n\t}\n\n\tif (push_items == 0)\n\t\tgoto out_unlock;\n\n\tWARN_ON(!empty && push_items == left_nritems);\n\n\t/* push left to right */\n\tright_nritems = btrfs_header_nritems(right);\n\n\tpush_space = btrfs_item_end_nr(left, left_nritems - push_items);\n\tpush_space -= leaf_data_end(root, left);\n\n\t/* make room in the right data area */\n\tdata_end = leaf_data_end(root, right);\n\tmemmove_extent_buffer(right,\n\t\t\t      btrfs_leaf_data(right) + data_end - push_space,\n\t\t\t      btrfs_leaf_data(right) + data_end,\n\t\t\t      BTRFS_LEAF_DATA_SIZE(root) - data_end);\n\n\t/* copy from the left data area */\n\tcopy_extent_buffer(right, left, btrfs_leaf_data(right) +\n\t\t     BTRFS_LEAF_DATA_SIZE(root) - push_space,\n\t\t     btrfs_leaf_data(left) + leaf_data_end(root, left),\n\t\t     push_space);\n\n\tmemmove_extent_buffer(right, btrfs_item_nr_offset(push_items),\n\t\t\t      btrfs_item_nr_offset(0),\n\t\t\t      right_nritems * sizeof(struct btrfs_item));\n\n\t/* copy the items from left to right */\n\tcopy_extent_buffer(right, left, btrfs_item_nr_offset(0),\n\t\t   btrfs_item_nr_offset(left_nritems - push_items),\n\t\t   push_items * sizeof(struct btrfs_item));\n\n\t/* update the item pointers */\n\tright_nritems += push_items;\n\tbtrfs_set_header_nritems(right, right_nritems);\n\tpush_space = BTRFS_LEAF_DATA_SIZE(root);\n\tfor (i = 0; i < right_nritems; i++) {\n\t\titem = btrfs_item_nr(i);\n\t\tpush_space -= btrfs_token_item_size(right, item, &token);\n\t\tbtrfs_set_token_item_offset(right, item, push_space, &token);\n\t}\n\n\tleft_nritems -= push_items;\n\tbtrfs_set_header_nritems(left, left_nritems);\n\n\tif (left_nritems)\n\t\tbtrfs_mark_buffer_dirty(left);\n\telse\n\t\tclean_tree_block(trans, root, left);\n\n\tbtrfs_mark_buffer_dirty(right);\n\n\tbtrfs_item_key(right, &disk_key, 0);\n\tbtrfs_set_node_key(upper, &disk_key, slot + 1);\n\tbtrfs_mark_buffer_dirty(upper);\n\n\t/* then fixup the leaf pointer in the path */\n\tif (path->slots[0] >= left_nritems) {\n\t\tpath->slots[0] -= left_nritems;\n\t\tif (btrfs_header_nritems(path->nodes[0]) == 0)\n\t\t\tclean_tree_block(trans, root, path->nodes[0]);\n\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\tfree_extent_buffer(path->nodes[0]);\n\t\tpath->nodes[0] = right;\n\t\tpath->slots[1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\treturn 0;\n\nout_unlock:\n\tbtrfs_tree_unlock(right);\n\tfree_extent_buffer(right);\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_leaf_free_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3566-3579",
    "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "root->fs_info",
            "\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\"",
            "ret",
            "(unsigned long) BTRFS_LEAF_DATA_SIZE(root)",
            "leaf_space_used(leaf, 0, nritems)",
            "nritems"
          ],
          "line": 3573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leaf_space_used",
          "args": [
            "leaf",
            "0",
            "nritems"
          ],
          "line": 3576
        },
        "resolved": true,
        "details": {
          "function_name": "leaf_space_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3539-3559",
          "snippet": "static int leaf_space_used(struct extent_buffer *l, int start, int nr)\n{\n\tstruct btrfs_item *start_item;\n\tstruct btrfs_item *end_item;\n\tstruct btrfs_map_token token;\n\tint data_len;\n\tint nritems = btrfs_header_nritems(l);\n\tint end = min(nritems, start + nr) - 1;\n\n\tif (!nr)\n\t\treturn 0;\n\tbtrfs_init_map_token(&token);\n\tstart_item = btrfs_item_nr(start);\n\tend_item = btrfs_item_nr(end);\n\tdata_len = btrfs_token_item_offset(l, start_item, &token) +\n\t\tbtrfs_token_item_size(l, start_item, &token);\n\tdata_len = data_len - btrfs_token_item_offset(l, end_item, &token);\n\tdata_len += sizeof(struct btrfs_item) * nr;\n\tWARN_ON(data_len < 0);\n\treturn data_len;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int leaf_space_used(struct extent_buffer *l, int start, int nr)\n{\n\tstruct btrfs_item *start_item;\n\tstruct btrfs_item *end_item;\n\tstruct btrfs_map_token token;\n\tint data_len;\n\tint nritems = btrfs_header_nritems(l);\n\tint end = min(nritems, start + nr) - 1;\n\n\tif (!nr)\n\t\treturn 0;\n\tbtrfs_init_map_token(&token);\n\tstart_item = btrfs_item_nr(start);\n\tend_item = btrfs_item_nr(end);\n\tdata_len = btrfs_token_item_offset(l, start_item, &token) +\n\t\tbtrfs_token_item_size(l, start_item, &token);\n\tdata_len = data_len - btrfs_token_item_offset(l, end_item, &token);\n\tdata_len += sizeof(struct btrfs_item) * nr;\n\tWARN_ON(data_len < 0);\n\treturn data_len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 3571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 3569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "leaf_space_used",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3539-3559",
    "snippet": "static int leaf_space_used(struct extent_buffer *l, int start, int nr)\n{\n\tstruct btrfs_item *start_item;\n\tstruct btrfs_item *end_item;\n\tstruct btrfs_map_token token;\n\tint data_len;\n\tint nritems = btrfs_header_nritems(l);\n\tint end = min(nritems, start + nr) - 1;\n\n\tif (!nr)\n\t\treturn 0;\n\tbtrfs_init_map_token(&token);\n\tstart_item = btrfs_item_nr(start);\n\tend_item = btrfs_item_nr(end);\n\tdata_len = btrfs_token_item_offset(l, start_item, &token) +\n\t\tbtrfs_token_item_size(l, start_item, &token);\n\tdata_len = data_len - btrfs_token_item_offset(l, end_item, &token);\n\tdata_len += sizeof(struct btrfs_item) * nr;\n\tWARN_ON(data_len < 0);\n\treturn data_len;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "data_len < 0"
          ],
          "line": 3557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_token_item_offset",
          "args": [
            "l",
            "end_item",
            "&token"
          ],
          "line": 3555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_token_item_size",
          "args": [
            "l",
            "start_item",
            "&token"
          ],
          "line": 3554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_token_item_offset",
          "args": [
            "l",
            "start_item",
            "&token"
          ],
          "line": 3553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "end"
          ],
          "line": 3552
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_map_token",
          "args": [
            "&token"
          ],
          "line": 3550
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_map_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2214-2217",
          "snippet": "static inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_init_map_token (struct btrfs_map_token *token)\n{\n\ttoken->kaddr = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nritems",
            "start + nr"
          ],
          "line": 3546
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "l"
          ],
          "line": 3545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int leaf_space_used(struct extent_buffer *l, int start, int nr)\n{\n\tstruct btrfs_item *start_item;\n\tstruct btrfs_item *end_item;\n\tstruct btrfs_map_token token;\n\tint data_len;\n\tint nritems = btrfs_header_nritems(l);\n\tint end = min(nritems, start + nr) - 1;\n\n\tif (!nr)\n\t\treturn 0;\n\tbtrfs_init_map_token(&token);\n\tstart_item = btrfs_item_nr(start);\n\tend_item = btrfs_item_nr(end);\n\tdata_len = btrfs_token_item_offset(l, start_item, &token) +\n\t\tbtrfs_token_item_size(l, start_item, &token);\n\tdata_len = data_len - btrfs_token_item_offset(l, end_item, &token);\n\tdata_len += sizeof(struct btrfs_item) * nr;\n\tWARN_ON(data_len < 0);\n\treturn data_len;\n}"
  },
  {
    "function_name": "split_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3441-3532",
    "snippet": "static noinline int split_node(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *split;\n\tstruct btrfs_disk_key disk_key;\n\tint mid;\n\tint ret;\n\tu32 c_nritems;\n\n\tc = path->nodes[level];\n\tWARN_ON(btrfs_header_generation(c) != trans->transid);\n\tif (c == root->node) {\n\t\t/*\n\t\t * trying to split the root, lets make a new one\n\t\t *\n\t\t * tree mod log: We don't log_removal old root in\n\t\t * insert_new_root, because that root buffer will be kept as a\n\t\t * normal node. We are going to log removal of half of the\n\t\t * elements below with tree_mod_log_eb_copy. We're holding a\n\t\t * tree lock on the buffer, which is why we cannot race with\n\t\t * other tree_mod_log users.\n\t\t */\n\t\tret = insert_new_root(trans, root, path, level + 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = push_nodes_for_insert(trans, root, path, level);\n\t\tc = path->nodes[level];\n\t\tif (!ret && btrfs_header_nritems(c) <\n\t\t    BTRFS_NODEPTRS_PER_BLOCK(root) - 3)\n\t\t\treturn 0;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tc_nritems = btrfs_header_nritems(c);\n\tmid = (c_nritems + 1) / 2;\n\tbtrfs_node_key(c, &disk_key, mid);\n\n\tsplit = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t&disk_key, level, c->start, 0);\n\tif (IS_ERR(split))\n\t\treturn PTR_ERR(split);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(split, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_level(split, btrfs_header_level(c));\n\tbtrfs_set_header_bytenr(split, split->start);\n\tbtrfs_set_header_generation(split, trans->transid);\n\tbtrfs_set_header_backref_rev(split, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(split, root->root_key.objectid);\n\twrite_extent_buffer(split, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\twrite_extent_buffer(split, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(split),\n\t\t\t    BTRFS_UUID_SIZE);\n\n\tret = tree_mod_log_eb_copy(root->fs_info, split, c, 0,\n\t\t\t\t   mid, c_nritems - mid);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(split, c,\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   btrfs_node_key_ptr_offset(mid),\n\t\t\t   (c_nritems - mid) * sizeof(struct btrfs_key_ptr));\n\tbtrfs_set_header_nritems(split, c_nritems - mid);\n\tbtrfs_set_header_nritems(c, mid);\n\tret = 0;\n\n\tbtrfs_mark_buffer_dirty(c);\n\tbtrfs_mark_buffer_dirty(split);\n\n\tinsert_ptr(trans, root, path, &disk_key, split->start,\n\t\t   path->slots[level + 1] + 1, level + 1);\n\n\tif (path->slots[level] >= mid) {\n\t\tpath->slots[level] -= mid;\n\t\tbtrfs_tree_unlock(c);\n\t\tfree_extent_buffer(c);\n\t\tpath->nodes[level] = split;\n\t\tpath->slots[level + 1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(split);\n\t\tfree_extent_buffer(split);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "split"
          ],
          "line": 3529
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "split"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_ptr",
          "args": [
            "trans",
            "root",
            "path",
            "&disk_key",
            "split->start",
            "path->slots[level + 1] + 1",
            "level + 1"
          ],
          "line": 3518
        },
        "resolved": true,
        "details": {
          "function_name": "insert_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3395-3430",
          "snippet": "static void insert_ptr(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *path,\n\t\t       struct btrfs_disk_key *key, u64 bytenr,\n\t\t       int slot, int level)\n{\n\tstruct extent_buffer *lower;\n\tint nritems;\n\tint ret;\n\n\tBUG_ON(!path->nodes[level]);\n\tbtrfs_assert_tree_locked(path->nodes[level]);\n\tlower = path->nodes[level];\n\tnritems = btrfs_header_nritems(lower);\n\tBUG_ON(slot > nritems);\n\tBUG_ON(nritems == BTRFS_NODEPTRS_PER_BLOCK(root));\n\tif (slot != nritems) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, lower, slot + 1,\n\t\t\t\t\t     slot, nritems - slot);\n\t\tmemmove_extent_buffer(lower,\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_key_ptr));\n\t}\n\tif (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, lower, slot,\n\t\t\t\t\t      MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\tbtrfs_set_node_key(lower, key, slot);\n\tbtrfs_set_node_blockptr(lower, slot, bytenr);\n\tWARN_ON(trans->transid == 0);\n\tbtrfs_set_node_ptr_generation(lower, slot, trans->transid);\n\tbtrfs_set_header_nritems(lower, nritems + 1);\n\tbtrfs_mark_buffer_dirty(lower);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic void insert_ptr(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *path,\n\t\t       struct btrfs_disk_key *key, u64 bytenr,\n\t\t       int slot, int level)\n{\n\tstruct extent_buffer *lower;\n\tint nritems;\n\tint ret;\n\n\tBUG_ON(!path->nodes[level]);\n\tbtrfs_assert_tree_locked(path->nodes[level]);\n\tlower = path->nodes[level];\n\tnritems = btrfs_header_nritems(lower);\n\tBUG_ON(slot > nritems);\n\tBUG_ON(nritems == BTRFS_NODEPTRS_PER_BLOCK(root));\n\tif (slot != nritems) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, lower, slot + 1,\n\t\t\t\t\t     slot, nritems - slot);\n\t\tmemmove_extent_buffer(lower,\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_key_ptr));\n\t}\n\tif (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, lower, slot,\n\t\t\t\t\t      MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\tbtrfs_set_node_key(lower, key, slot);\n\tbtrfs_set_node_blockptr(lower, slot, bytenr);\n\tWARN_ON(trans->transid == 0);\n\tbtrfs_set_node_ptr_generation(lower, slot, trans->transid);\n\tbtrfs_set_header_nritems(lower, nritems + 1);\n\tbtrfs_mark_buffer_dirty(lower);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "split"
          ],
          "line": 3516
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "c",
            "mid"
          ],
          "line": 3512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "split",
            "c_nritems - mid"
          ],
          "line": 3511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_extent_buffer",
          "args": [
            "split",
            "c",
            "btrfs_node_key_ptr_offset(0)",
            "btrfs_node_key_ptr_offset(mid)",
            "(c_nritems - mid) * sizeof(struct btrfs_key_ptr)"
          ],
          "line": 3507
        },
        "resolved": true,
        "details": {
          "function_name": "copy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5416-5447",
          "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_ptr_offset",
          "args": [
            "mid"
          ],
          "line": 3509
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_ptr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2598-2602",
          "snippet": "static inline unsigned long btrfs_node_key_ptr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_node_key_ptr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_eb_copy",
          "args": [
            "root->fs_info",
            "split",
            "c",
            "0",
            "mid",
            "c_nritems - mid"
          ],
          "line": 3501
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_eb_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "800-869",
          "snippet": "static noinline int\ntree_mod_log_eb_copy(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     struct extent_buffer *src, unsigned long dst_offset,\n\t\t     unsigned long src_offset, int nr_items)\n{\n\tint ret = 0;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tstruct tree_mod_elem **tm_list_add, **tm_list_rem;\n\tint i;\n\tint locked = 0;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (btrfs_header_level(dst) == 0 && btrfs_header_level(src) == 0)\n\t\treturn 0;\n\n\ttm_list = kzalloc(nr_items * 2 * sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\ttm_list_add = tm_list;\n\ttm_list_rem = tm_list + nr_items;\n\tfor (i = 0; i < nr_items; i++) {\n\t\ttm_list_rem[i] = alloc_tree_mod_elem(src, i + src_offset,\n\t\t    MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tif (!tm_list_rem[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\n\t\ttm_list_add[i] = alloc_tree_mod_elem(dst, i + dst_offset,\n\t\t    MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tif (!tm_list_add[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, NULL))\n\t\tgoto free_tms;\n\tlocked = 1;\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_rem[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_add[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tfor (i = 0; i < nr_items * 2; i++) {\n\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\tkfree(tm_list[i]);\n\t}\n\tif (locked)\n\t\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_eb_copy(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     struct extent_buffer *src, unsigned long dst_offset,\n\t\t     unsigned long src_offset, int nr_items)\n{\n\tint ret = 0;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tstruct tree_mod_elem **tm_list_add, **tm_list_rem;\n\tint i;\n\tint locked = 0;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (btrfs_header_level(dst) == 0 && btrfs_header_level(src) == 0)\n\t\treturn 0;\n\n\ttm_list = kzalloc(nr_items * 2 * sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\ttm_list_add = tm_list;\n\ttm_list_rem = tm_list + nr_items;\n\tfor (i = 0; i < nr_items; i++) {\n\t\ttm_list_rem[i] = alloc_tree_mod_elem(src, i + src_offset,\n\t\t    MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tif (!tm_list_rem[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\n\t\ttm_list_add[i] = alloc_tree_mod_elem(dst, i + dst_offset,\n\t\t    MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tif (!tm_list_add[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, NULL))\n\t\tgoto free_tms;\n\tlocked = 1;\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_rem[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_add[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tfor (i = 0; i < nr_items * 2; i++) {\n\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\tkfree(tm_list[i]);\n\t}\n\tif (locked)\n\t\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "split",
            "root->fs_info->chunk_tree_uuid",
            "btrfs_header_chunk_tree_uuid(split)",
            "BTRFS_UUID_SIZE"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_chunk_tree_uuid",
          "args": [
            "split"
          ],
          "line": 3498
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_chunk_tree_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2837-2840",
          "snippet": "static inline unsigned long btrfs_header_chunk_tree_uuid(struct extent_buffer *eb)\n{\n\treturn offsetof(struct btrfs_header, chunk_tree_uuid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_chunk_tree_uuid(struct extent_buffer *eb)\n{\n\treturn offsetof(struct btrfs_header, chunk_tree_uuid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_fsid",
          "args": [],
          "line": 3496
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2832-2835",
          "snippet": "static inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_owner",
          "args": [
            "split",
            "root->root_key.objectid"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_backref_rev",
          "args": [
            "split",
            "BTRFS_MIXED_BACKREF_REV"
          ],
          "line": 3493
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2823-2830",
          "snippet": "static inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)",
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_generation",
          "args": [
            "split",
            "trans->transid"
          ],
          "line": 3492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_bytenr",
          "args": [
            "split",
            "split->start"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_level",
          "args": [
            "split",
            "btrfs_header_level(c)"
          ],
          "line": 3490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "c"
          ],
          "line": 3490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset_extent_buffer",
          "args": [
            "split",
            "0",
            "0",
            "sizeof(struct btrfs_header)"
          ],
          "line": 3489
        },
        "resolved": true,
        "details": {
          "function_name": "memset_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5387-5414",
          "snippet": "void memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "root_add_used",
          "args": [
            "root",
            "root->nodesize"
          ],
          "line": 3487
        },
        "resolved": true,
        "details": {
          "function_name": "root_add_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1833-1839",
          "snippet": "static void root_add_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) + size);\n\tspin_unlock(&root->accounting_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void root_add_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) + size);\n\tspin_unlock(&root->accounting_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "split"
          ],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "split"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_tree_block",
          "args": [
            "trans",
            "root",
            "0",
            "root->root_key.objectid",
            "&disk_key",
            "level",
            "c->start",
            "0"
          ],
          "line": 3482
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "7316-7385",
          "snippet": "struct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key",
          "args": [
            "c",
            "&disk_key",
            "mid"
          ],
          "line": 3480
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "c"
          ],
          "line": 3478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_NODEPTRS_PER_BLOCK",
          "args": [
            "root"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "c"
          ],
          "line": 3471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "push_nodes_for_insert",
          "args": [
            "trans",
            "root",
            "path",
            "level"
          ],
          "line": 3469
        },
        "resolved": true,
        "details": {
          "function_name": "push_nodes_for_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2099-2229",
          "snippet": "static noinline int push_nodes_for_insert(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *right = NULL;\n\tstruct extent_buffer *mid;\n\tstruct extent_buffer *left = NULL;\n\tstruct extent_buffer *parent = NULL;\n\tint ret = 0;\n\tint wret;\n\tint pslot;\n\tint orig_slot = path->slots[level];\n\n\tif (level == 0)\n\t\treturn 1;\n\n\tmid = path->nodes[level];\n\tWARN_ON(btrfs_header_generation(mid) != trans->transid);\n\n\tif (level < BTRFS_MAX_LEVEL - 1) {\n\t\tparent = path->nodes[level + 1];\n\t\tpslot = path->slots[level + 1];\n\t}\n\n\tif (!parent)\n\t\treturn 1;\n\n\tleft = read_node_slot(root, parent, pslot - 1);\n\n\t/* first, try to make some room in the middle buffer */\n\tif (left) {\n\t\tu32 left_nr;\n\n\t\tbtrfs_tree_lock(left);\n\t\tbtrfs_set_lock_blocking(left);\n\n\t\tleft_nr = btrfs_header_nritems(left);\n\t\tif (left_nr >= BTRFS_NODEPTRS_PER_BLOCK(root) - 1) {\n\t\t\twret = 1;\n\t\t} else {\n\t\t\tret = btrfs_cow_block(trans, root, left, parent,\n\t\t\t\t\t      pslot - 1, &left);\n\t\t\tif (ret)\n\t\t\t\twret = 1;\n\t\t\telse {\n\t\t\t\twret = push_node_left(trans, root,\n\t\t\t\t\t\t      left, mid, 0);\n\t\t\t}\n\t\t}\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t\tif (wret == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\t\t\torig_slot += left_nr;\n\t\t\tbtrfs_node_key(mid, &disk_key, 0);\n\t\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t\t  pslot, 0);\n\t\t\tbtrfs_set_node_key(parent, &disk_key, pslot);\n\t\t\tbtrfs_mark_buffer_dirty(parent);\n\t\t\tif (btrfs_header_nritems(left) > orig_slot) {\n\t\t\t\tpath->nodes[level] = left;\n\t\t\t\tpath->slots[level + 1] -= 1;\n\t\t\t\tpath->slots[level] = orig_slot;\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t} else {\n\t\t\t\torig_slot -=\n\t\t\t\t\tbtrfs_header_nritems(left);\n\t\t\t\tpath->slots[level] = orig_slot;\n\t\t\t\tbtrfs_tree_unlock(left);\n\t\t\t\tfree_extent_buffer(left);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t}\n\tright = read_node_slot(root, parent, pslot + 1);\n\n\t/*\n\t * then try to empty the right most buffer into the middle\n\t */\n\tif (right) {\n\t\tu32 right_nr;\n\n\t\tbtrfs_tree_lock(right);\n\t\tbtrfs_set_lock_blocking(right);\n\n\t\tright_nr = btrfs_header_nritems(right);\n\t\tif (right_nr >= BTRFS_NODEPTRS_PER_BLOCK(root) - 1) {\n\t\t\twret = 1;\n\t\t} else {\n\t\t\tret = btrfs_cow_block(trans, root, right,\n\t\t\t\t\t      parent, pslot + 1,\n\t\t\t\t\t      &right);\n\t\t\tif (ret)\n\t\t\t\twret = 1;\n\t\t\telse {\n\t\t\t\twret = balance_node_right(trans, root,\n\t\t\t\t\t\t\t  right, mid);\n\t\t\t}\n\t\t}\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t\tif (wret == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_node_key(right, &disk_key, 0);\n\t\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t\t  pslot + 1, 0);\n\t\t\tbtrfs_set_node_key(parent, &disk_key, pslot + 1);\n\t\t\tbtrfs_mark_buffer_dirty(parent);\n\n\t\t\tif (btrfs_header_nritems(mid) <= orig_slot) {\n\t\t\t\tpath->nodes[level] = right;\n\t\t\t\tpath->slots[level + 1] += 1;\n\t\t\t\tpath->slots[level] = orig_slot -\n\t\t\t\t\tbtrfs_header_nritems(mid);\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t} else {\n\t\t\t\tbtrfs_tree_unlock(right);\n\t\t\t\tfree_extent_buffer(right);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic noinline struct;\n\nstatic noinline int push_nodes_for_insert(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *right = NULL;\n\tstruct extent_buffer *mid;\n\tstruct extent_buffer *left = NULL;\n\tstruct extent_buffer *parent = NULL;\n\tint ret = 0;\n\tint wret;\n\tint pslot;\n\tint orig_slot = path->slots[level];\n\n\tif (level == 0)\n\t\treturn 1;\n\n\tmid = path->nodes[level];\n\tWARN_ON(btrfs_header_generation(mid) != trans->transid);\n\n\tif (level < BTRFS_MAX_LEVEL - 1) {\n\t\tparent = path->nodes[level + 1];\n\t\tpslot = path->slots[level + 1];\n\t}\n\n\tif (!parent)\n\t\treturn 1;\n\n\tleft = read_node_slot(root, parent, pslot - 1);\n\n\t/* first, try to make some room in the middle buffer */\n\tif (left) {\n\t\tu32 left_nr;\n\n\t\tbtrfs_tree_lock(left);\n\t\tbtrfs_set_lock_blocking(left);\n\n\t\tleft_nr = btrfs_header_nritems(left);\n\t\tif (left_nr >= BTRFS_NODEPTRS_PER_BLOCK(root) - 1) {\n\t\t\twret = 1;\n\t\t} else {\n\t\t\tret = btrfs_cow_block(trans, root, left, parent,\n\t\t\t\t\t      pslot - 1, &left);\n\t\t\tif (ret)\n\t\t\t\twret = 1;\n\t\t\telse {\n\t\t\t\twret = push_node_left(trans, root,\n\t\t\t\t\t\t      left, mid, 0);\n\t\t\t}\n\t\t}\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t\tif (wret == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\t\t\torig_slot += left_nr;\n\t\t\tbtrfs_node_key(mid, &disk_key, 0);\n\t\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t\t  pslot, 0);\n\t\t\tbtrfs_set_node_key(parent, &disk_key, pslot);\n\t\t\tbtrfs_mark_buffer_dirty(parent);\n\t\t\tif (btrfs_header_nritems(left) > orig_slot) {\n\t\t\t\tpath->nodes[level] = left;\n\t\t\t\tpath->slots[level + 1] -= 1;\n\t\t\t\tpath->slots[level] = orig_slot;\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t} else {\n\t\t\t\torig_slot -=\n\t\t\t\t\tbtrfs_header_nritems(left);\n\t\t\t\tpath->slots[level] = orig_slot;\n\t\t\t\tbtrfs_tree_unlock(left);\n\t\t\t\tfree_extent_buffer(left);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t}\n\tright = read_node_slot(root, parent, pslot + 1);\n\n\t/*\n\t * then try to empty the right most buffer into the middle\n\t */\n\tif (right) {\n\t\tu32 right_nr;\n\n\t\tbtrfs_tree_lock(right);\n\t\tbtrfs_set_lock_blocking(right);\n\n\t\tright_nr = btrfs_header_nritems(right);\n\t\tif (right_nr >= BTRFS_NODEPTRS_PER_BLOCK(root) - 1) {\n\t\t\twret = 1;\n\t\t} else {\n\t\t\tret = btrfs_cow_block(trans, root, right,\n\t\t\t\t\t      parent, pslot + 1,\n\t\t\t\t\t      &right);\n\t\t\tif (ret)\n\t\t\t\twret = 1;\n\t\t\telse {\n\t\t\t\twret = balance_node_right(trans, root,\n\t\t\t\t\t\t\t  right, mid);\n\t\t\t}\n\t\t}\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t\tif (wret == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_node_key(right, &disk_key, 0);\n\t\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t\t  pslot + 1, 0);\n\t\t\tbtrfs_set_node_key(parent, &disk_key, pslot + 1);\n\t\t\tbtrfs_mark_buffer_dirty(parent);\n\n\t\t\tif (btrfs_header_nritems(mid) <= orig_slot) {\n\t\t\t\tpath->nodes[level] = right;\n\t\t\t\tpath->slots[level + 1] += 1;\n\t\t\t\tpath->slots[level] = orig_slot -\n\t\t\t\t\tbtrfs_header_nritems(mid);\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t} else {\n\t\t\t\tbtrfs_tree_unlock(right);\n\t\t\t\tfree_extent_buffer(right);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_new_root",
          "args": [
            "trans",
            "root",
            "path",
            "level + 1"
          ],
          "line": 3465
        },
        "resolved": true,
        "details": {
          "function_name": "insert_new_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3324-3386",
          "snippet": "static noinline int insert_new_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_path *path, int level)\n{\n\tu64 lower_gen;\n\tstruct extent_buffer *lower;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *old;\n\tstruct btrfs_disk_key lower_key;\n\n\tBUG_ON(path->nodes[level]);\n\tBUG_ON(path->nodes[level-1] != root->node);\n\n\tlower = path->nodes[level-1];\n\tif (level == 1)\n\t\tbtrfs_item_key(lower, &lower_key, 0);\n\telse\n\t\tbtrfs_node_key(lower, &lower_key, 0);\n\n\tc = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t\t   &lower_key, level, root->node->start, 0);\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(c, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_nritems(c, 1);\n\tbtrfs_set_header_level(c, level);\n\tbtrfs_set_header_bytenr(c, c->start);\n\tbtrfs_set_header_generation(c, trans->transid);\n\tbtrfs_set_header_backref_rev(c, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(c, root->root_key.objectid);\n\n\twrite_extent_buffer(c, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(c, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(c), BTRFS_UUID_SIZE);\n\n\tbtrfs_set_node_key(c, &lower_key, 0);\n\tbtrfs_set_node_blockptr(c, 0, lower->start);\n\tlower_gen = btrfs_header_generation(lower);\n\tWARN_ON(lower_gen != trans->transid);\n\n\tbtrfs_set_node_ptr_generation(c, 0, lower_gen);\n\n\tbtrfs_mark_buffer_dirty(c);\n\n\told = root->node;\n\ttree_mod_log_set_root_pointer(root, c, 0);\n\trcu_assign_pointer(root->node, c);\n\n\t/* the super has an extra ref to root->node */\n\tfree_extent_buffer(old);\n\n\tadd_root_to_dirty_list(root);\n\textent_buffer_get(c);\n\tpath->nodes[level] = c;\n\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\tpath->slots[level] = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline int insert_new_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_path *path, int level)\n{\n\tu64 lower_gen;\n\tstruct extent_buffer *lower;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *old;\n\tstruct btrfs_disk_key lower_key;\n\n\tBUG_ON(path->nodes[level]);\n\tBUG_ON(path->nodes[level-1] != root->node);\n\n\tlower = path->nodes[level-1];\n\tif (level == 1)\n\t\tbtrfs_item_key(lower, &lower_key, 0);\n\telse\n\t\tbtrfs_node_key(lower, &lower_key, 0);\n\n\tc = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t\t   &lower_key, level, root->node->start, 0);\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(c, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_nritems(c, 1);\n\tbtrfs_set_header_level(c, level);\n\tbtrfs_set_header_bytenr(c, c->start);\n\tbtrfs_set_header_generation(c, trans->transid);\n\tbtrfs_set_header_backref_rev(c, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(c, root->root_key.objectid);\n\n\twrite_extent_buffer(c, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(c, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(c), BTRFS_UUID_SIZE);\n\n\tbtrfs_set_node_key(c, &lower_key, 0);\n\tbtrfs_set_node_blockptr(c, 0, lower->start);\n\tlower_gen = btrfs_header_generation(lower);\n\tWARN_ON(lower_gen != trans->transid);\n\n\tbtrfs_set_node_ptr_generation(c, 0, lower_gen);\n\n\tbtrfs_mark_buffer_dirty(c);\n\n\told = root->node;\n\ttree_mod_log_set_root_pointer(root, c, 0);\n\trcu_assign_pointer(root->node, c);\n\n\t/* the super has an extra ref to root->node */\n\tfree_extent_buffer(old);\n\n\tadd_root_to_dirty_list(root);\n\textent_buffer_get(c);\n\tpath->nodes[level] = c;\n\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\tpath->slots[level] = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_generation(c) != trans->transid"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "c"
          ],
          "line": 3453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline int split_node(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *split;\n\tstruct btrfs_disk_key disk_key;\n\tint mid;\n\tint ret;\n\tu32 c_nritems;\n\n\tc = path->nodes[level];\n\tWARN_ON(btrfs_header_generation(c) != trans->transid);\n\tif (c == root->node) {\n\t\t/*\n\t\t * trying to split the root, lets make a new one\n\t\t *\n\t\t * tree mod log: We don't log_removal old root in\n\t\t * insert_new_root, because that root buffer will be kept as a\n\t\t * normal node. We are going to log removal of half of the\n\t\t * elements below with tree_mod_log_eb_copy. We're holding a\n\t\t * tree lock on the buffer, which is why we cannot race with\n\t\t * other tree_mod_log users.\n\t\t */\n\t\tret = insert_new_root(trans, root, path, level + 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = push_nodes_for_insert(trans, root, path, level);\n\t\tc = path->nodes[level];\n\t\tif (!ret && btrfs_header_nritems(c) <\n\t\t    BTRFS_NODEPTRS_PER_BLOCK(root) - 3)\n\t\t\treturn 0;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tc_nritems = btrfs_header_nritems(c);\n\tmid = (c_nritems + 1) / 2;\n\tbtrfs_node_key(c, &disk_key, mid);\n\n\tsplit = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t&disk_key, level, c->start, 0);\n\tif (IS_ERR(split))\n\t\treturn PTR_ERR(split);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(split, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_level(split, btrfs_header_level(c));\n\tbtrfs_set_header_bytenr(split, split->start);\n\tbtrfs_set_header_generation(split, trans->transid);\n\tbtrfs_set_header_backref_rev(split, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(split, root->root_key.objectid);\n\twrite_extent_buffer(split, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\twrite_extent_buffer(split, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(split),\n\t\t\t    BTRFS_UUID_SIZE);\n\n\tret = tree_mod_log_eb_copy(root->fs_info, split, c, 0,\n\t\t\t\t   mid, c_nritems - mid);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(split, c,\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   btrfs_node_key_ptr_offset(mid),\n\t\t\t   (c_nritems - mid) * sizeof(struct btrfs_key_ptr));\n\tbtrfs_set_header_nritems(split, c_nritems - mid);\n\tbtrfs_set_header_nritems(c, mid);\n\tret = 0;\n\n\tbtrfs_mark_buffer_dirty(c);\n\tbtrfs_mark_buffer_dirty(split);\n\n\tinsert_ptr(trans, root, path, &disk_key, split->start,\n\t\t   path->slots[level + 1] + 1, level + 1);\n\n\tif (path->slots[level] >= mid) {\n\t\tpath->slots[level] -= mid;\n\t\tbtrfs_tree_unlock(c);\n\t\tfree_extent_buffer(c);\n\t\tpath->nodes[level] = split;\n\t\tpath->slots[level + 1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(split);\n\t\tfree_extent_buffer(split);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "insert_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3395-3430",
    "snippet": "static void insert_ptr(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *path,\n\t\t       struct btrfs_disk_key *key, u64 bytenr,\n\t\t       int slot, int level)\n{\n\tstruct extent_buffer *lower;\n\tint nritems;\n\tint ret;\n\n\tBUG_ON(!path->nodes[level]);\n\tbtrfs_assert_tree_locked(path->nodes[level]);\n\tlower = path->nodes[level];\n\tnritems = btrfs_header_nritems(lower);\n\tBUG_ON(slot > nritems);\n\tBUG_ON(nritems == BTRFS_NODEPTRS_PER_BLOCK(root));\n\tif (slot != nritems) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, lower, slot + 1,\n\t\t\t\t\t     slot, nritems - slot);\n\t\tmemmove_extent_buffer(lower,\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_key_ptr));\n\t}\n\tif (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, lower, slot,\n\t\t\t\t\t      MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\tbtrfs_set_node_key(lower, key, slot);\n\tbtrfs_set_node_blockptr(lower, slot, bytenr);\n\tWARN_ON(trans->transid == 0);\n\tbtrfs_set_node_ptr_generation(lower, slot, trans->transid);\n\tbtrfs_set_header_nritems(lower, nritems + 1);\n\tbtrfs_mark_buffer_dirty(lower);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "lower"
          ],
          "line": 3429
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "lower",
            "nritems + 1"
          ],
          "line": 3428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_ptr_generation",
          "args": [
            "lower",
            "slot",
            "trans->transid"
          ],
          "line": 3427
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2589-2596",
          "snippet": "static inline void btrfs_set_node_ptr_generation(struct extent_buffer *eb,\n\t\t\t\t\t\t int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_generation(eb, (struct btrfs_key_ptr *)ptr, val);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_ptr_generation(struct extent_buffer *eb,\n\t\t\t\t\t\t int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_generation(eb, (struct btrfs_key_ptr *)ptr, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trans->transid == 0"
          ],
          "line": 3426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_blockptr",
          "args": [
            "lower",
            "slot",
            "bytenr"
          ],
          "line": 3425
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2572-2579",
          "snippet": "static inline void btrfs_set_node_blockptr(struct extent_buffer *eb,\n\t\t\t\t\t   int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_blockptr(eb, (struct btrfs_key_ptr *)ptr, val);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_blockptr(struct extent_buffer *eb,\n\t\t\t\t\t   int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_blockptr(eb, (struct btrfs_key_ptr *)ptr, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_key",
          "args": [
            "lower",
            "key",
            "slot"
          ],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2607-2614",
          "snippet": "static inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0"
          ],
          "line": 3422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_insert_key",
          "args": [
            "root->fs_info",
            "lower",
            "slot",
            "MOD_LOG_KEY_ADD",
            "GFP_NOFS"
          ],
          "line": 3420
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_insert_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "539-565",
          "snippet": "static noinline int\ntree_mod_log_insert_key(struct btrfs_fs_info *fs_info,\n\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\tenum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\tint ret;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm = alloc_tree_mod_elem(eb, slot, op, flags);\n\tif (!tm)\n\t\treturn -ENOMEM;\n\n\tif (tree_mod_dont_log(fs_info, eb)) {\n\t\tkfree(tm);\n\t\treturn 0;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tkfree(tm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_insert_key(struct btrfs_fs_info *fs_info,\n\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\tenum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\tint ret;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm = alloc_tree_mod_elem(eb, slot, op, flags);\n\tif (!tm)\n\t\treturn -ENOMEM;\n\n\tif (tree_mod_dont_log(fs_info, eb)) {\n\t\tkfree(tm);\n\t\treturn 0;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tkfree(tm);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "lower",
            "btrfs_node_key_ptr_offset(slot + 1)",
            "btrfs_node_key_ptr_offset(slot)",
            "(nritems - slot) * sizeof(struct btrfs_key_ptr)"
          ],
          "line": 3414
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_ptr_offset",
          "args": [
            "slot"
          ],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_ptr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2598-2602",
          "snippet": "static inline unsigned long btrfs_node_key_ptr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_node_key_ptr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_log_eb_move",
          "args": [
            "root->fs_info",
            "lower",
            "slot + 1",
            "slot",
            "nritems - slot"
          ],
          "line": 3412
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_eb_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "871-879",
          "snippet": "static inline void\ntree_mod_log_eb_move(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     int dst_offset, int src_offset, int nr_items)\n{\n\tint ret;\n\tret = tree_mod_log_insert_move(fs_info, dst, dst_offset, src_offset,\n\t\t\t\t       nr_items, GFP_NOFS);\n\tBUG_ON(ret < 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void\ntree_mod_log_eb_move(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     int dst_offset, int src_offset, int nr_items)\n{\n\tint ret;\n\tret = tree_mod_log_insert_move(fs_info, dst, dst_offset, src_offset,\n\t\t\t\t       nr_items, GFP_NOFS);\n\tBUG_ON(ret < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nritems == BTRFS_NODEPTRS_PER_BLOCK(root)"
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_NODEPTRS_PER_BLOCK",
          "args": [
            "root"
          ],
          "line": 3409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "slot > nritems"
          ],
          "line": 3408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "lower"
          ],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_locked",
          "args": [
            "path->nodes[level]"
          ],
          "line": 3405
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "292-295",
          "snippet": "void btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!path->nodes[level]"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic void insert_ptr(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *path,\n\t\t       struct btrfs_disk_key *key, u64 bytenr,\n\t\t       int slot, int level)\n{\n\tstruct extent_buffer *lower;\n\tint nritems;\n\tint ret;\n\n\tBUG_ON(!path->nodes[level]);\n\tbtrfs_assert_tree_locked(path->nodes[level]);\n\tlower = path->nodes[level];\n\tnritems = btrfs_header_nritems(lower);\n\tBUG_ON(slot > nritems);\n\tBUG_ON(nritems == BTRFS_NODEPTRS_PER_BLOCK(root));\n\tif (slot != nritems) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, lower, slot + 1,\n\t\t\t\t\t     slot, nritems - slot);\n\t\tmemmove_extent_buffer(lower,\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      (nritems - slot) * sizeof(struct btrfs_key_ptr));\n\t}\n\tif (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, lower, slot,\n\t\t\t\t\t      MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\tbtrfs_set_node_key(lower, key, slot);\n\tbtrfs_set_node_blockptr(lower, slot, bytenr);\n\tWARN_ON(trans->transid == 0);\n\tbtrfs_set_node_ptr_generation(lower, slot, trans->transid);\n\tbtrfs_set_header_nritems(lower, nritems + 1);\n\tbtrfs_mark_buffer_dirty(lower);\n}"
  },
  {
    "function_name": "insert_new_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3324-3386",
    "snippet": "static noinline int insert_new_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_path *path, int level)\n{\n\tu64 lower_gen;\n\tstruct extent_buffer *lower;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *old;\n\tstruct btrfs_disk_key lower_key;\n\n\tBUG_ON(path->nodes[level]);\n\tBUG_ON(path->nodes[level-1] != root->node);\n\n\tlower = path->nodes[level-1];\n\tif (level == 1)\n\t\tbtrfs_item_key(lower, &lower_key, 0);\n\telse\n\t\tbtrfs_node_key(lower, &lower_key, 0);\n\n\tc = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t\t   &lower_key, level, root->node->start, 0);\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(c, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_nritems(c, 1);\n\tbtrfs_set_header_level(c, level);\n\tbtrfs_set_header_bytenr(c, c->start);\n\tbtrfs_set_header_generation(c, trans->transid);\n\tbtrfs_set_header_backref_rev(c, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(c, root->root_key.objectid);\n\n\twrite_extent_buffer(c, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(c, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(c), BTRFS_UUID_SIZE);\n\n\tbtrfs_set_node_key(c, &lower_key, 0);\n\tbtrfs_set_node_blockptr(c, 0, lower->start);\n\tlower_gen = btrfs_header_generation(lower);\n\tWARN_ON(lower_gen != trans->transid);\n\n\tbtrfs_set_node_ptr_generation(c, 0, lower_gen);\n\n\tbtrfs_mark_buffer_dirty(c);\n\n\told = root->node;\n\ttree_mod_log_set_root_pointer(root, c, 0);\n\trcu_assign_pointer(root->node, c);\n\n\t/* the super has an extra ref to root->node */\n\tfree_extent_buffer(old);\n\n\tadd_root_to_dirty_list(root);\n\textent_buffer_get(c);\n\tpath->nodes[level] = c;\n\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\tpath->slots[level] = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "c"
          ],
          "line": 3381
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_root_to_dirty_list",
          "args": [
            "root"
          ],
          "line": 3380
        },
        "resolved": true,
        "details": {
          "function_name": "add_root_to_dirty_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "214-231",
          "snippet": "static void add_root_to_dirty_list(struct btrfs_root *root)\n{\n\tif (test_bit(BTRFS_ROOT_DIRTY, &root->state) ||\n\t    !test_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state))\n\t\treturn;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (!test_and_set_bit(BTRFS_ROOT_DIRTY, &root->state)) {\n\t\t/* Want the extent tree to be the last on the list */\n\t\tif (root->objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\t\tlist_move_tail(&root->dirty_list,\n\t\t\t\t       &root->fs_info->dirty_cowonly_roots);\n\t\telse\n\t\t\tlist_move(&root->dirty_list,\n\t\t\t\t  &root->fs_info->dirty_cowonly_roots);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void add_root_to_dirty_list(struct btrfs_root *root)\n{\n\tif (test_bit(BTRFS_ROOT_DIRTY, &root->state) ||\n\t    !test_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state))\n\t\treturn;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (!test_and_set_bit(BTRFS_ROOT_DIRTY, &root->state)) {\n\t\t/* Want the extent tree to be the last on the list */\n\t\tif (root->objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\t\tlist_move_tail(&root->dirty_list,\n\t\t\t\t       &root->fs_info->dirty_cowonly_roots);\n\t\telse\n\t\t\tlist_move(&root->dirty_list,\n\t\t\t\t  &root->fs_info->dirty_cowonly_roots);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "old"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "root->node",
            "c"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_set_root_pointer",
          "args": [
            "root",
            "c",
            "0"
          ],
          "line": 3374
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_set_root_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "941-950",
          "snippet": "static noinline void\ntree_mod_log_set_root_pointer(struct btrfs_root *root,\n\t\t\t      struct extent_buffer *new_root_node,\n\t\t\t      int log_removal)\n{\n\tint ret;\n\tret = tree_mod_log_insert_root(root->fs_info, root->node,\n\t\t\t\t       new_root_node, GFP_NOFS, log_removal);\n\tBUG_ON(ret < 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline void\ntree_mod_log_set_root_pointer(struct btrfs_root *root,\n\t\t\t      struct extent_buffer *new_root_node,\n\t\t\t      int log_removal)\n{\n\tint ret;\n\tret = tree_mod_log_insert_root(root->fs_info, root->node,\n\t\t\t\t       new_root_node, GFP_NOFS, log_removal);\n\tBUG_ON(ret < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "c"
          ],
          "line": 3371
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_ptr_generation",
          "args": [
            "c",
            "0",
            "lower_gen"
          ],
          "line": 3369
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2589-2596",
          "snippet": "static inline void btrfs_set_node_ptr_generation(struct extent_buffer *eb,\n\t\t\t\t\t\t int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_generation(eb, (struct btrfs_key_ptr *)ptr, val);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_ptr_generation(struct extent_buffer *eb,\n\t\t\t\t\t\t int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_generation(eb, (struct btrfs_key_ptr *)ptr, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "lower_gen != trans->transid"
          ],
          "line": 3367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "lower"
          ],
          "line": 3366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_blockptr",
          "args": [
            "c",
            "0",
            "lower->start"
          ],
          "line": 3365
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2572-2579",
          "snippet": "static inline void btrfs_set_node_blockptr(struct extent_buffer *eb,\n\t\t\t\t\t   int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_blockptr(eb, (struct btrfs_key_ptr *)ptr, val);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_blockptr(struct extent_buffer *eb,\n\t\t\t\t\t   int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_blockptr(eb, (struct btrfs_key_ptr *)ptr, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_key",
          "args": [
            "c",
            "&lower_key",
            "0"
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2607-2614",
          "snippet": "static inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "c",
            "root->fs_info->chunk_tree_uuid",
            "btrfs_header_chunk_tree_uuid(c)",
            "BTRFS_UUID_SIZE"
          ],
          "line": 3361
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_chunk_tree_uuid",
          "args": [
            "c"
          ],
          "line": 3362
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_chunk_tree_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2837-2840",
          "snippet": "static inline unsigned long btrfs_header_chunk_tree_uuid(struct extent_buffer *eb)\n{\n\treturn offsetof(struct btrfs_header, chunk_tree_uuid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_chunk_tree_uuid(struct extent_buffer *eb)\n{\n\treturn offsetof(struct btrfs_header, chunk_tree_uuid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_fsid",
          "args": [],
          "line": 3358
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2832-2835",
          "snippet": "static inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_owner",
          "args": [
            "c",
            "root->root_key.objectid"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_backref_rev",
          "args": [
            "c",
            "BTRFS_MIXED_BACKREF_REV"
          ],
          "line": 3355
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2823-2830",
          "snippet": "static inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)",
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_generation",
          "args": [
            "c",
            "trans->transid"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_bytenr",
          "args": [
            "c",
            "c->start"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_level",
          "args": [
            "c",
            "level"
          ],
          "line": 3352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "c",
            "1"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset_extent_buffer",
          "args": [
            "c",
            "0",
            "0",
            "sizeof(struct btrfs_header)"
          ],
          "line": 3350
        },
        "resolved": true,
        "details": {
          "function_name": "memset_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5387-5414",
          "snippet": "void memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memset_extent_buffer(struct extent_buffer *eb, char c,\n\t\t\t  unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemset(kaddr + offset, c, cur);\n\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "root_add_used",
          "args": [
            "root",
            "root->nodesize"
          ],
          "line": 3348
        },
        "resolved": true,
        "details": {
          "function_name": "root_add_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1833-1839",
          "snippet": "static void root_add_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) + size);\n\tspin_unlock(&root->accounting_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void root_add_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) + size);\n\tspin_unlock(&root->accounting_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "c"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "c"
          ],
          "line": 3345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_tree_block",
          "args": [
            "trans",
            "root",
            "0",
            "root->root_key.objectid",
            "&lower_key",
            "level",
            "root->node->start",
            "0"
          ],
          "line": 3343
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "7316-7385",
          "snippet": "struct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key",
          "args": [
            "lower",
            "&lower_key",
            "0"
          ],
          "line": 3341
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key",
          "args": [
            "lower",
            "&lower_key",
            "0"
          ],
          "line": 3339
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path->nodes[level-1] != root->node"
          ],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "path->nodes[level]"
          ],
          "line": 3334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline int insert_new_root(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct btrfs_path *path, int level)\n{\n\tu64 lower_gen;\n\tstruct extent_buffer *lower;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *old;\n\tstruct btrfs_disk_key lower_key;\n\n\tBUG_ON(path->nodes[level]);\n\tBUG_ON(path->nodes[level-1] != root->node);\n\n\tlower = path->nodes[level-1];\n\tif (level == 1)\n\t\tbtrfs_item_key(lower, &lower_key, 0);\n\telse\n\t\tbtrfs_node_key(lower, &lower_key, 0);\n\n\tc = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t\t   &lower_key, level, root->node->start, 0);\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(c, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_nritems(c, 1);\n\tbtrfs_set_header_level(c, level);\n\tbtrfs_set_header_bytenr(c, c->start);\n\tbtrfs_set_header_generation(c, trans->transid);\n\tbtrfs_set_header_backref_rev(c, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(c, root->root_key.objectid);\n\n\twrite_extent_buffer(c, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(c, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(c), BTRFS_UUID_SIZE);\n\n\tbtrfs_set_node_key(c, &lower_key, 0);\n\tbtrfs_set_node_blockptr(c, 0, lower->start);\n\tlower_gen = btrfs_header_generation(lower);\n\tWARN_ON(lower_gen != trans->transid);\n\n\tbtrfs_set_node_ptr_generation(c, 0, lower_gen);\n\n\tbtrfs_mark_buffer_dirty(c);\n\n\told = root->node;\n\ttree_mod_log_set_root_pointer(root, c, 0);\n\trcu_assign_pointer(root->node, c);\n\n\t/* the super has an extra ref to root->node */\n\tfree_extent_buffer(old);\n\n\tadd_root_to_dirty_list(root);\n\textent_buffer_get(c);\n\tpath->nodes[level] = c;\n\tpath->locks[level] = BTRFS_WRITE_LOCK_BLOCKING;\n\tpath->slots[level] = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "balance_node_right",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3260-3315",
    "snippet": "static int balance_node_right(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct extent_buffer *dst,\n\t\t\t      struct extent_buffer *src)\n{\n\tint push_items = 0;\n\tint max_push;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (src_nritems < 4)\n\t\treturn 1;\n\n\tmax_push = src_nritems / 2 + 1;\n\t/* don't try to empty the node */\n\tif (max_push >= src_nritems)\n\t\treturn 1;\n\n\tif (max_push < push_items)\n\t\tpush_items = max_push;\n\n\ttree_mod_log_eb_move(root->fs_info, dst, push_items, 0, dst_nritems);\n\tmemmove_extent_buffer(dst, btrfs_node_key_ptr_offset(push_items),\n\t\t\t\t      btrfs_node_key_ptr_offset(0),\n\t\t\t\t      (dst_nritems) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\n\tret = tree_mod_log_eb_copy(root->fs_info, dst, src, 0,\n\t\t\t\t   src_nritems - push_items, push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   btrfs_node_key_ptr_offset(src_nritems - push_items),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\n\tbtrfs_mark_buffer_dirty(src);\n\tbtrfs_mark_buffer_dirty(dst);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "dst"
          ],
          "line": 3312
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "dst",
            "dst_nritems + push_items"
          ],
          "line": 3309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "src",
            "src_nritems - push_items"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_extent_buffer",
          "args": [
            "dst",
            "src",
            "btrfs_node_key_ptr_offset(0)",
            "btrfs_node_key_ptr_offset(src_nritems - push_items)",
            "push_items * sizeof(struct btrfs_key_ptr)"
          ],
          "line": 3303
        },
        "resolved": true,
        "details": {
          "function_name": "copy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5416-5447",
          "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_ptr_offset",
          "args": [
            "src_nritems - push_items"
          ],
          "line": 3305
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_ptr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2598-2602",
          "snippet": "static inline unsigned long btrfs_node_key_ptr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_node_key_ptr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_eb_copy",
          "args": [
            "root->fs_info",
            "dst",
            "src",
            "0",
            "src_nritems - push_items",
            "push_items"
          ],
          "line": 3297
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_eb_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "800-869",
          "snippet": "static noinline int\ntree_mod_log_eb_copy(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     struct extent_buffer *src, unsigned long dst_offset,\n\t\t     unsigned long src_offset, int nr_items)\n{\n\tint ret = 0;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tstruct tree_mod_elem **tm_list_add, **tm_list_rem;\n\tint i;\n\tint locked = 0;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (btrfs_header_level(dst) == 0 && btrfs_header_level(src) == 0)\n\t\treturn 0;\n\n\ttm_list = kzalloc(nr_items * 2 * sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\ttm_list_add = tm_list;\n\ttm_list_rem = tm_list + nr_items;\n\tfor (i = 0; i < nr_items; i++) {\n\t\ttm_list_rem[i] = alloc_tree_mod_elem(src, i + src_offset,\n\t\t    MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tif (!tm_list_rem[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\n\t\ttm_list_add[i] = alloc_tree_mod_elem(dst, i + dst_offset,\n\t\t    MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tif (!tm_list_add[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, NULL))\n\t\tgoto free_tms;\n\tlocked = 1;\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_rem[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_add[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tfor (i = 0; i < nr_items * 2; i++) {\n\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\tkfree(tm_list[i]);\n\t}\n\tif (locked)\n\t\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_eb_copy(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     struct extent_buffer *src, unsigned long dst_offset,\n\t\t     unsigned long src_offset, int nr_items)\n{\n\tint ret = 0;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tstruct tree_mod_elem **tm_list_add, **tm_list_rem;\n\tint i;\n\tint locked = 0;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (btrfs_header_level(dst) == 0 && btrfs_header_level(src) == 0)\n\t\treturn 0;\n\n\ttm_list = kzalloc(nr_items * 2 * sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\ttm_list_add = tm_list;\n\ttm_list_rem = tm_list + nr_items;\n\tfor (i = 0; i < nr_items; i++) {\n\t\ttm_list_rem[i] = alloc_tree_mod_elem(src, i + src_offset,\n\t\t    MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tif (!tm_list_rem[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\n\t\ttm_list_add[i] = alloc_tree_mod_elem(dst, i + dst_offset,\n\t\t    MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tif (!tm_list_add[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, NULL))\n\t\tgoto free_tms;\n\tlocked = 1;\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_rem[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_add[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tfor (i = 0; i < nr_items * 2; i++) {\n\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\tkfree(tm_list[i]);\n\t}\n\tif (locked)\n\t\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "dst",
            "btrfs_node_key_ptr_offset(push_items)",
            "btrfs_node_key_ptr_offset(0)",
            "(dst_nritems) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr)"
          ],
          "line": 3292
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_log_eb_move",
          "args": [
            "root->fs_info",
            "dst",
            "push_items",
            "0",
            "dst_nritems"
          ],
          "line": 3291
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_eb_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "871-879",
          "snippet": "static inline void\ntree_mod_log_eb_move(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     int dst_offset, int src_offset, int nr_items)\n{\n\tint ret;\n\tret = tree_mod_log_insert_move(fs_info, dst, dst_offset, src_offset,\n\t\t\t\t       nr_items, GFP_NOFS);\n\tBUG_ON(ret < 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void\ntree_mod_log_eb_move(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     int dst_offset, int src_offset, int nr_items)\n{\n\tint ret;\n\tret = tree_mod_log_insert_move(fs_info, dst, dst_offset, src_offset,\n\t\t\t\t       nr_items, GFP_NOFS);\n\tBUG_ON(ret < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_NODEPTRS_PER_BLOCK",
          "args": [
            "root"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "dst"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "src"
          ],
          "line": 3274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_generation(dst) != trans->transid"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "dst"
          ],
          "line": 3272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_generation(src) != trans->transid"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "src"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic noinline struct;\n\nstatic int balance_node_right(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct extent_buffer *dst,\n\t\t\t      struct extent_buffer *src)\n{\n\tint push_items = 0;\n\tint max_push;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (src_nritems < 4)\n\t\treturn 1;\n\n\tmax_push = src_nritems / 2 + 1;\n\t/* don't try to empty the node */\n\tif (max_push >= src_nritems)\n\t\treturn 1;\n\n\tif (max_push < push_items)\n\t\tpush_items = max_push;\n\n\ttree_mod_log_eb_move(root->fs_info, dst, push_items, 0, dst_nritems);\n\tmemmove_extent_buffer(dst, btrfs_node_key_ptr_offset(push_items),\n\t\t\t\t      btrfs_node_key_ptr_offset(0),\n\t\t\t\t      (dst_nritems) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\n\tret = tree_mod_log_eb_copy(root->fs_info, dst, src, 0,\n\t\t\t\t   src_nritems - push_items, push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   btrfs_node_key_ptr_offset(src_nritems - push_items),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\n\tbtrfs_mark_buffer_dirty(src);\n\tbtrfs_mark_buffer_dirty(dst);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "push_node_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3186-3249",
    "snippet": "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty)\n{\n\tint push_items = 0;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tif (!empty && src_nritems <= 8)\n\t\treturn 1;\n\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (empty) {\n\t\tpush_items = min(src_nritems, push_items);\n\t\tif (push_items < src_nritems) {\n\t\t\t/* leave at least 8 pointers in the node if\n\t\t\t * we aren't going to empty it\n\t\t\t */\n\t\t\tif (src_nritems - push_items < 8) {\n\t\t\t\tif (push_items <= 8)\n\t\t\t\t\treturn 1;\n\t\t\t\tpush_items -= 8;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpush_items = min(src_nritems - 8, push_items);\n\n\tret = tree_mod_log_eb_copy(root->fs_info, dst, src, dst_nritems, 0,\n\t\t\t\t   push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(dst_nritems),\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tif (push_items < src_nritems) {\n\t\t/*\n\t\t * don't call tree_mod_log_eb_move here, key removal was already\n\t\t * fully logged by tree_mod_log_eb_copy above.\n\t\t */\n\t\tmemmove_extent_buffer(src, btrfs_node_key_ptr_offset(0),\n\t\t\t\t      btrfs_node_key_ptr_offset(push_items),\n\t\t\t\t      (src_nritems - push_items) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\t}\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\tbtrfs_mark_buffer_dirty(src);\n\tbtrfs_mark_buffer_dirty(dst);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "dst"
          ],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "dst",
            "dst_nritems + push_items"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "src",
            "src_nritems - push_items"
          ],
          "line": 3243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "src",
            "btrfs_node_key_ptr_offset(0)",
            "btrfs_node_key_ptr_offset(push_items)",
            "(src_nritems - push_items) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr)"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_ptr_offset",
          "args": [
            "push_items"
          ],
          "line": 3239
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_ptr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2598-2602",
          "snippet": "static inline unsigned long btrfs_node_key_ptr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_node_key_ptr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_extent_buffer",
          "args": [
            "dst",
            "src",
            "btrfs_node_key_ptr_offset(dst_nritems)",
            "btrfs_node_key_ptr_offset(0)",
            "push_items * sizeof(struct btrfs_key_ptr)"
          ],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "copy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5416-5447",
          "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 3225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_eb_copy",
          "args": [
            "root->fs_info",
            "dst",
            "src",
            "dst_nritems",
            "0",
            "push_items"
          ],
          "line": 3222
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_eb_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "800-869",
          "snippet": "static noinline int\ntree_mod_log_eb_copy(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     struct extent_buffer *src, unsigned long dst_offset,\n\t\t     unsigned long src_offset, int nr_items)\n{\n\tint ret = 0;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tstruct tree_mod_elem **tm_list_add, **tm_list_rem;\n\tint i;\n\tint locked = 0;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (btrfs_header_level(dst) == 0 && btrfs_header_level(src) == 0)\n\t\treturn 0;\n\n\ttm_list = kzalloc(nr_items * 2 * sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\ttm_list_add = tm_list;\n\ttm_list_rem = tm_list + nr_items;\n\tfor (i = 0; i < nr_items; i++) {\n\t\ttm_list_rem[i] = alloc_tree_mod_elem(src, i + src_offset,\n\t\t    MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tif (!tm_list_rem[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\n\t\ttm_list_add[i] = alloc_tree_mod_elem(dst, i + dst_offset,\n\t\t    MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tif (!tm_list_add[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, NULL))\n\t\tgoto free_tms;\n\tlocked = 1;\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_rem[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_add[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tfor (i = 0; i < nr_items * 2; i++) {\n\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\tkfree(tm_list[i]);\n\t}\n\tif (locked)\n\t\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_eb_copy(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     struct extent_buffer *src, unsigned long dst_offset,\n\t\t     unsigned long src_offset, int nr_items)\n{\n\tint ret = 0;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tstruct tree_mod_elem **tm_list_add, **tm_list_rem;\n\tint i;\n\tint locked = 0;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (btrfs_header_level(dst) == 0 && btrfs_header_level(src) == 0)\n\t\treturn 0;\n\n\ttm_list = kzalloc(nr_items * 2 * sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\ttm_list_add = tm_list;\n\ttm_list_rem = tm_list + nr_items;\n\tfor (i = 0; i < nr_items; i++) {\n\t\ttm_list_rem[i] = alloc_tree_mod_elem(src, i + src_offset,\n\t\t    MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tif (!tm_list_rem[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\n\t\ttm_list_add[i] = alloc_tree_mod_elem(dst, i + dst_offset,\n\t\t    MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tif (!tm_list_add[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, NULL))\n\t\tgoto free_tms;\n\tlocked = 1;\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_rem[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_add[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tfor (i = 0; i < nr_items * 2; i++) {\n\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\tkfree(tm_list[i]);\n\t}\n\tif (locked)\n\t\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "src_nritems - 8",
            "push_items"
          ],
          "line": 3220
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_generation(dst) != trans->transid"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "dst"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_generation(src) != trans->transid"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "src"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_NODEPTRS_PER_BLOCK",
          "args": [
            "root"
          ],
          "line": 3197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "dst"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "src"
          ],
          "line": 3195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic noinline struct;\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty)\n{\n\tint push_items = 0;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tif (!empty && src_nritems <= 8)\n\t\treturn 1;\n\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (empty) {\n\t\tpush_items = min(src_nritems, push_items);\n\t\tif (push_items < src_nritems) {\n\t\t\t/* leave at least 8 pointers in the node if\n\t\t\t * we aren't going to empty it\n\t\t\t */\n\t\t\tif (src_nritems - push_items < 8) {\n\t\t\t\tif (push_items <= 8)\n\t\t\t\t\treturn 1;\n\t\t\t\tpush_items -= 8;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpush_items = min(src_nritems - 8, push_items);\n\n\tret = tree_mod_log_eb_copy(root->fs_info, dst, src, dst_nritems, 0,\n\t\t\t\t   push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(dst_nritems),\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tif (push_items < src_nritems) {\n\t\t/*\n\t\t * don't call tree_mod_log_eb_move here, key removal was already\n\t\t * fully logged by tree_mod_log_eb_copy above.\n\t\t */\n\t\tmemmove_extent_buffer(src, btrfs_node_key_ptr_offset(0),\n\t\t\t\t      btrfs_node_key_ptr_offset(push_items),\n\t\t\t\t      (src_nritems - push_items) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\t}\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\tbtrfs_mark_buffer_dirty(src);\n\tbtrfs_mark_buffer_dirty(dst);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_set_item_key_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3154-3177",
    "snippet": "void btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fixup_low_keys",
          "args": [
            "root",
            "path",
            "&disk_key",
            "1"
          ],
          "line": 3176
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_low_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3129-3146",
          "snippet": "static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "eb"
          ],
          "line": 3174
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_item_key",
          "args": [
            "eb",
            "&disk_key",
            "slot"
          ],
          "line": 3173
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_item_key_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3154-3177",
          "snippet": "void btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cpu_key_to_disk",
          "args": [
            "&disk_key",
            "new_key"
          ],
          "line": 3172
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cpu_key_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2739-2745",
          "snippet": "static inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "comp_keys(&disk_key, new_key) <= 0"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "comp_keys",
          "args": [
            "&disk_key",
            "new_key"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "comp_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1586-1593",
          "snippet": "static int comp_keys(struct btrfs_disk_key *disk, struct btrfs_key *k2)\n{\n\tstruct btrfs_key k1;\n\n\tbtrfs_disk_key_to_cpu(&k1, disk);\n\n\treturn btrfs_comp_cpu_keys(&k1, k2);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int comp_keys(struct btrfs_disk_key *disk, struct btrfs_key *k2)\n{\n\tstruct btrfs_key k1;\n\n\tbtrfs_disk_key_to_cpu(&k1, disk);\n\n\treturn btrfs_comp_cpu_keys(&k1, k2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key",
          "args": [
            "eb",
            "&disk_key",
            "slot + 1"
          ],
          "line": 3168
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 3167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "comp_keys(&disk_key, new_key) >= 0"
          ],
          "line": 3165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nvoid btrfs_set_item_key_safe(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t     struct btrfs_key *new_key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *eb;\n\tint slot;\n\n\teb = path->nodes[0];\n\tslot = path->slots[0];\n\tif (slot > 0) {\n\t\tbtrfs_item_key(eb, &disk_key, slot - 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) >= 0);\n\t}\n\tif (slot < btrfs_header_nritems(eb) - 1) {\n\t\tbtrfs_item_key(eb, &disk_key, slot + 1);\n\t\tBUG_ON(comp_keys(&disk_key, new_key) <= 0);\n\t}\n\n\tbtrfs_cpu_key_to_disk(&disk_key, new_key);\n\tbtrfs_set_item_key(eb, &disk_key, slot);\n\tbtrfs_mark_buffer_dirty(eb);\n\tif (slot == 0)\n\t\tfixup_low_keys(root, path, &disk_key, 1);\n}"
  },
  {
    "function_name": "fixup_low_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3129-3146",
    "snippet": "static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "path->nodes[i]"
          ],
          "line": 3142
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_key",
          "args": [
            "t",
            "key",
            "tslot"
          ],
          "line": 3141
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2607-2614",
          "snippet": "static inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_log_set_node_key",
          "args": [
            "root->fs_info",
            "t",
            "tslot",
            "1"
          ],
          "line": 3140
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_set_node_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "881-891",
          "snippet": "static noinline void\ntree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_buffer *eb, int slot, int atomic)\n{\n\tint ret;\n\n\tret = tree_mod_log_insert_key(fs_info, eb, slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE,\n\t\t\t\t\tatomic ? GFP_ATOMIC : GFP_NOFS);\n\tBUG_ON(ret < 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline void\ntree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_buffer *eb, int slot, int atomic)\n{\n\tint ret;\n\n\tret = tree_mod_log_insert_key(fs_info, eb, slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE,\n\t\t\t\t\tatomic ? GFP_ATOMIC : GFP_NOFS);\n\tBUG_ON(ret < 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct btrfs_disk_key *key, int level)\n{\n\tint i;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tint tslot = path->slots[i];\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tt = path->nodes[i];\n\t\ttree_mod_log_set_node_key(root->fs_info, t, tslot, 1);\n\t\tbtrfs_set_node_key(t, key, tslot);\n\t\tbtrfs_mark_buffer_dirty(path->nodes[i]);\n\t\tif (tslot != 0)\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "btrfs_search_slot_for_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "3057-3119",
    "snippet": "int btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "p"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_prev_leaf",
          "args": [
            "root",
            "p"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_prev_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5049-5089",
          "snippet": "int btrfs_prev_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key found_key;\n\tint ret;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, 0);\n\n\tif (key.offset > 0) {\n\t\tkey.offset--;\n\t} else if (key.type > 0) {\n\t\tkey.type--;\n\t\tkey.offset = (u64)-1;\n\t} else if (key.objectid > 0) {\n\t\tkey.objectid--;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\treturn 1;\n\t}\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tbtrfs_item_key(path->nodes[0], &found_key, 0);\n\tret = comp_keys(&found_key, &key);\n\t/*\n\t * We might have had an item with the previous key in the tree right\n\t * before we released our path. And after we released our path, that\n\t * item might have been pushed to the first slot (0) of the leaf we\n\t * were holding due to a tree balance. Alternatively, an item with the\n\t * previous key can exist as the only element of a leaf (big fat item).\n\t * Therefore account for these 2 cases, so that our callers (like\n\t * btrfs_previous_item) don't miss an existing item with a key matching\n\t * the previous key we computed above.\n\t */\n\tif (ret <= 0)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_prev_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_disk_key found_key;\n\tint ret;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, 0);\n\n\tif (key.offset > 0) {\n\t\tkey.offset--;\n\t} else if (key.type > 0) {\n\t\tkey.type--;\n\t\tkey.offset = (u64)-1;\n\t} else if (key.objectid > 0) {\n\t\tkey.objectid--;\n\t\tkey.type = (u8)-1;\n\t\tkey.offset = (u64)-1;\n\t} else {\n\t\treturn 1;\n\t}\n\n\tbtrfs_release_path(path);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tbtrfs_item_key(path->nodes[0], &found_key, 0);\n\tret = comp_keys(&found_key, &key);\n\t/*\n\t * We might have had an item with the previous key in the tree right\n\t * before we released our path. And after we released our path, that\n\t * item might have been pushed to the first slot (0) of the leaf we\n\t * were holding due to a tree balance. Alternatively, an item with the\n\t * previous key can exist as the only element of a leaf (big fat item).\n\t * Therefore account for these 2 cases, so that our callers (like\n\t * btrfs_previous_item) don't miss an existing item with a key matching\n\t * the previous key we computed above.\n\t */\n\tif (ret <= 0)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "p"
          ],
          "line": 3079
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "key",
            "p",
            "0",
            "0"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot_for_read(struct btrfs_root *root,\n\t\t\t       struct btrfs_key *key, struct btrfs_path *p,\n\t\t\t       int find_higher, int return_any)\n{\n\tint ret;\n\tstruct extent_buffer *leaf;\n\nagain:\n\tret = btrfs_search_slot(NULL, root, key, p, 0, 0);\n\tif (ret <= 0)\n\t\treturn ret;\n\t/*\n\t * a return value of 1 means the path is at the position where the\n\t * item should be inserted. Normally this is the next bigger item,\n\t * but in case the previous item is the last in a leaf, path points\n\t * to the first free slot in the previous leaf, i.e. at an invalid\n\t * item.\n\t */\n\tleaf = p->nodes[0];\n\n\tif (find_higher) {\n\t\tif (p->slots[0] >= btrfs_header_nritems(leaf)) {\n\t\t\tret = btrfs_next_leaf(root, p);\n\t\t\tif (ret <= 0)\n\t\t\t\treturn ret;\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no higher item found, return the next\n\t\t\t * lower instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 0;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t} else {\n\t\tif (p->slots[0] == 0) {\n\t\t\tret = btrfs_prev_leaf(root, p);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (!ret) {\n\t\t\t\tleaf = p->nodes[0];\n\t\t\t\tif (p->slots[0] == btrfs_header_nritems(leaf))\n\t\t\t\t\tp->slots[0]--;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (!return_any)\n\t\t\t\treturn 1;\n\t\t\t/*\n\t\t\t * no lower item found, return the next\n\t\t\t * higher instead\n\t\t\t */\n\t\t\treturn_any = 0;\n\t\t\tfind_higher = 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t} else {\n\t\t\t--p->slots[0];\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_search_old_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "2945-3043",
    "snippet": "int btrfs_search_old_slot(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct btrfs_path *p, u64 time_seq)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tu8 lowest_level = 0;\n\tint prev_cmp = -1;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(p->nodes[0] != NULL);\n\n\tif (p->search_commit_root) {\n\t\tBUG_ON(time_seq);\n\t\treturn btrfs_search_slot(NULL, root, key, p, 0, 0);\n\t}\n\nagain:\n\tb = get_old_root(root, time_seq);\n\tlevel = btrfs_header_level(b);\n\tp->locks[level] = BTRFS_READ_LOCK;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t */\n\t\tbtrfs_unlock_up_safe(p, level + 1);\n\n\t\t/*\n\t\t * Since we can unwind eb's we want to do a real search every\n\t\t * time.\n\t\t */\n\t\tprev_cmp = -1;\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(NULL, root, p, &b, level,\n\t\t\t\t\t\t    slot, key, time_seq);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\tif (!err) {\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tb = tree_mod_log_rewind(root->fs_info, p, b, time_seq);\n\t\t\tif (!b) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\tp->nodes[level] = b;\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0)\n\t\tbtrfs_release_path(p);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "p"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "p"
          ],
          "line": 3038
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_up",
          "args": [
            "p",
            "level",
            "lowest_unlock",
            "0",
            "NULL"
          ],
          "line": 3031
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2361-2402",
          "snippet": "static noinline void unlock_up(struct btrfs_path *path, int level,\n\t\t\t       int lowest_unlock, int min_write_lock_level,\n\t\t\t       int *write_lock_level)\n{\n\tint i;\n\tint skip_level = level;\n\tint no_skips = 0;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tif (!path->locks[i])\n\t\t\tbreak;\n\t\tif (!no_skips && path->slots[i] == 0) {\n\t\t\tskip_level = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!no_skips && path->keep_locks) {\n\t\t\tu32 nritems;\n\t\t\tt = path->nodes[i];\n\t\t\tnritems = btrfs_header_nritems(t);\n\t\t\tif (nritems < 1 || path->slots[i] >= nritems - 1) {\n\t\t\t\tskip_level = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (skip_level < i && i >= lowest_unlock)\n\t\t\tno_skips = 1;\n\n\t\tt = path->nodes[i];\n\t\tif (i >= lowest_unlock && i > skip_level && path->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(t, path->locks[i]);\n\t\t\tpath->locks[i] = 0;\n\t\t\tif (write_lock_level &&\n\t\t\t    i > min_write_lock_level &&\n\t\t\t    i <= *write_lock_level) {\n\t\t\t\t*write_lock_level = i - 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline void unlock_up(struct btrfs_path *path, int level,\n\t\t\t       int lowest_unlock, int min_write_lock_level,\n\t\t\t       int *write_lock_level)\n{\n\tint i;\n\tint skip_level = level;\n\tint no_skips = 0;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tif (!path->locks[i])\n\t\t\tbreak;\n\t\tif (!no_skips && path->slots[i] == 0) {\n\t\t\tskip_level = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!no_skips && path->keep_locks) {\n\t\t\tu32 nritems;\n\t\t\tt = path->nodes[i];\n\t\t\tnritems = btrfs_header_nritems(t);\n\t\t\tif (nritems < 1 || path->slots[i] >= nritems - 1) {\n\t\t\t\tskip_level = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (skip_level < i && i >= lowest_unlock)\n\t\t\tno_skips = 1;\n\n\t\tt = path->nodes[i];\n\t\tif (i >= lowest_unlock && i > skip_level && path->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(t, path->locks[i]);\n\t\t\tpath->locks[i] = 0;\n\t\t\tif (write_lock_level &&\n\t\t\t    i > min_write_lock_level &&\n\t\t\t    i <= *write_lock_level) {\n\t\t\t\t*write_lock_level = i - 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_log_rewind",
          "args": [
            "root->fs_info",
            "p",
            "b",
            "time_seq"
          ],
          "line": 3022
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_rewind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1352-1405",
          "snippet": "static struct extent_buffer *\ntree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct btrfs_path *path,\n\t\t    struct extent_buffer *eb, u64 time_seq)\n{\n\tstruct extent_buffer *eb_rewin;\n\tstruct tree_mod_elem *tm;\n\n\tif (!time_seq)\n\t\treturn eb;\n\n\tif (btrfs_header_level(eb) == 0)\n\t\treturn eb;\n\n\ttm = tree_mod_log_search(fs_info, eb->start, time_seq);\n\tif (!tm)\n\t\treturn eb;\n\n\tbtrfs_set_path_blocking(path);\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\n\tif (tm->op == MOD_LOG_KEY_REMOVE_WHILE_FREEING) {\n\t\tBUG_ON(tm->slot != 0);\n\t\teb_rewin = alloc_dummy_extent_buffer(fs_info, eb->start);\n\t\tif (!eb_rewin) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn NULL;\n\t\t}\n\t\tbtrfs_set_header_bytenr(eb_rewin, eb->start);\n\t\tbtrfs_set_header_backref_rev(eb_rewin,\n\t\t\t\t\t     btrfs_header_backref_rev(eb));\n\t\tbtrfs_set_header_owner(eb_rewin, btrfs_header_owner(eb));\n\t\tbtrfs_set_header_level(eb_rewin, btrfs_header_level(eb));\n\t} else {\n\t\teb_rewin = btrfs_clone_extent_buffer(eb);\n\t\tif (!eb_rewin) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tbtrfs_clear_path_blocking(path, NULL, BTRFS_READ_LOCK);\n\tbtrfs_tree_read_unlock_blocking(eb);\n\tfree_extent_buffer(eb);\n\n\textent_buffer_get(eb_rewin);\n\tbtrfs_tree_read_lock(eb_rewin);\n\t__tree_mod_log_rewind(fs_info, eb_rewin, time_seq, tm);\n\tWARN_ON(btrfs_header_nritems(eb_rewin) >\n\t\tBTRFS_NODEPTRS_PER_BLOCK(fs_info->tree_root));\n\n\treturn eb_rewin;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic struct extent_buffer *\ntree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct btrfs_path *path,\n\t\t    struct extent_buffer *eb, u64 time_seq)\n{\n\tstruct extent_buffer *eb_rewin;\n\tstruct tree_mod_elem *tm;\n\n\tif (!time_seq)\n\t\treturn eb;\n\n\tif (btrfs_header_level(eb) == 0)\n\t\treturn eb;\n\n\ttm = tree_mod_log_search(fs_info, eb->start, time_seq);\n\tif (!tm)\n\t\treturn eb;\n\n\tbtrfs_set_path_blocking(path);\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\n\tif (tm->op == MOD_LOG_KEY_REMOVE_WHILE_FREEING) {\n\t\tBUG_ON(tm->slot != 0);\n\t\teb_rewin = alloc_dummy_extent_buffer(fs_info, eb->start);\n\t\tif (!eb_rewin) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn NULL;\n\t\t}\n\t\tbtrfs_set_header_bytenr(eb_rewin, eb->start);\n\t\tbtrfs_set_header_backref_rev(eb_rewin,\n\t\t\t\t\t     btrfs_header_backref_rev(eb));\n\t\tbtrfs_set_header_owner(eb_rewin, btrfs_header_owner(eb));\n\t\tbtrfs_set_header_level(eb_rewin, btrfs_header_level(eb));\n\t} else {\n\t\teb_rewin = btrfs_clone_extent_buffer(eb);\n\t\tif (!eb_rewin) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tbtrfs_clear_path_blocking(path, NULL, BTRFS_READ_LOCK);\n\tbtrfs_tree_read_unlock_blocking(eb);\n\tfree_extent_buffer(eb);\n\n\textent_buffer_get(eb_rewin);\n\tbtrfs_tree_read_lock(eb_rewin);\n\t__tree_mod_log_rewind(fs_info, eb_rewin, time_seq, tm);\n\tWARN_ON(btrfs_header_nritems(eb_rewin) >\n\t\tBTRFS_NODEPTRS_PER_BLOCK(fs_info->tree_root));\n\n\treturn eb_rewin;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clear_path_blocking",
          "args": [
            "p",
            "b",
            "BTRFS_READ_LOCK"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "78-104",
          "snippet": "noinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_lock",
          "args": [
            "b"
          ],
          "line": 3018
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_lock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "135-148",
          "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "b"
          ],
          "line": 3014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_block_for_search",
          "args": [
            "NULL",
            "root",
            "p",
            "&b",
            "level",
            "slot",
            "key",
            "time_seq"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "read_block_for_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2438-2510",
          "snippet": "static int\nread_block_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer **eb_ret, int level, int slot,\n\t\t       struct btrfs_key *key, u64 time_seq)\n{\n\tu64 blocknr;\n\tu64 gen;\n\tstruct extent_buffer *b = *eb_ret;\n\tstruct extent_buffer *tmp;\n\tint ret;\n\n\tblocknr = btrfs_node_blockptr(b, slot);\n\tgen = btrfs_node_ptr_generation(b, slot);\n\n\ttmp = btrfs_find_tree_block(root, blocknr);\n\tif (tmp) {\n\t\t/* first we do an atomic uptodate check */\n\t\tif (btrfs_buffer_uptodate(tmp, gen, 1) > 0) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* the pages were up to date, but we failed\n\t\t * the generation number check.  Do a full\n\t\t * read for the generation number that is correct.\n\t\t * We must do this without dropping locks so\n\t\t * we can trust our generation number\n\t\t */\n\t\tbtrfs_set_path_blocking(p);\n\n\t\t/* now we're allowed to do a blocking uptodate check */\n\t\tret = btrfs_read_buffer(tmp, gen);\n\t\tif (!ret) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(tmp);\n\t\tbtrfs_release_path(p);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * reduce lock contention at high levels\n\t * of the btree by dropping locks before\n\t * we read.  Don't release the lock on the current\n\t * level because we need to walk this node to figure\n\t * out which blocks to read.\n\t */\n\tbtrfs_unlock_up_safe(p, level + 1);\n\tbtrfs_set_path_blocking(p);\n\n\tfree_extent_buffer(tmp);\n\tif (p->reada)\n\t\treada_for_search(root, p, level, slot, key->objectid);\n\n\tbtrfs_release_path(p);\n\n\tret = -EAGAIN;\n\ttmp = read_tree_block(root, blocknr, 0);\n\tif (tmp) {\n\t\t/*\n\t\t * If the read above didn't mark this buffer up to date,\n\t\t * it will never end up being up to date.  Set ret to EIO now\n\t\t * and give up so that our caller doesn't loop forever\n\t\t * on our EAGAINs.\n\t\t */\n\t\tif (!btrfs_buffer_uptodate(tmp, 0, 0))\n\t\t\tret = -EIO;\n\t\tfree_extent_buffer(tmp);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int\nread_block_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer **eb_ret, int level, int slot,\n\t\t       struct btrfs_key *key, u64 time_seq)\n{\n\tu64 blocknr;\n\tu64 gen;\n\tstruct extent_buffer *b = *eb_ret;\n\tstruct extent_buffer *tmp;\n\tint ret;\n\n\tblocknr = btrfs_node_blockptr(b, slot);\n\tgen = btrfs_node_ptr_generation(b, slot);\n\n\ttmp = btrfs_find_tree_block(root, blocknr);\n\tif (tmp) {\n\t\t/* first we do an atomic uptodate check */\n\t\tif (btrfs_buffer_uptodate(tmp, gen, 1) > 0) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* the pages were up to date, but we failed\n\t\t * the generation number check.  Do a full\n\t\t * read for the generation number that is correct.\n\t\t * We must do this without dropping locks so\n\t\t * we can trust our generation number\n\t\t */\n\t\tbtrfs_set_path_blocking(p);\n\n\t\t/* now we're allowed to do a blocking uptodate check */\n\t\tret = btrfs_read_buffer(tmp, gen);\n\t\tif (!ret) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(tmp);\n\t\tbtrfs_release_path(p);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * reduce lock contention at high levels\n\t * of the btree by dropping locks before\n\t * we read.  Don't release the lock on the current\n\t * level because we need to walk this node to figure\n\t * out which blocks to read.\n\t */\n\tbtrfs_unlock_up_safe(p, level + 1);\n\tbtrfs_set_path_blocking(p);\n\n\tfree_extent_buffer(tmp);\n\tif (p->reada)\n\t\treada_for_search(root, p, level, slot, key->objectid);\n\n\tbtrfs_release_path(p);\n\n\tret = -EAGAIN;\n\ttmp = read_tree_block(root, blocknr, 0);\n\tif (tmp) {\n\t\t/*\n\t\t * If the read above didn't mark this buffer up to date,\n\t\t * it will never end up being up to date.  Set ret to EIO now\n\t\t * and give up so that our caller doesn't loop forever\n\t\t * on our EAGAINs.\n\t\t */\n\t\tif (!btrfs_buffer_uptodate(tmp, 0, 0))\n\t\t\tret = -EIO;\n\t\tfree_extent_buffer(tmp);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_search",
          "args": [
            "b",
            "key",
            "level",
            "&prev_cmp",
            "&slot"
          ],
          "line": 2988
        },
        "resolved": true,
        "details": {
          "function_name": "key_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2603-2615",
          "snippet": "static int key_search(struct extent_buffer *b, struct btrfs_key *key,\n\t\t      int level, int *prev_cmp, int *slot)\n{\n\tif (*prev_cmp != 0) {\n\t\t*prev_cmp = bin_search(b, key, level, slot);\n\t\treturn *prev_cmp;\n\t}\n\n\tkey_search_validate(b, key, level);\n\t*slot = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int key_search(struct extent_buffer *b, struct btrfs_key *key,\n\t\t      int level, int *prev_cmp, int *slot)\n{\n\tif (*prev_cmp != 0) {\n\t\t*prev_cmp = bin_search(b, key, level, slot);\n\t\treturn *prev_cmp;\n\t}\n\n\tkey_search_validate(b, key, level);\n\t*slot = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_unlock_up_safe",
          "args": [
            "p",
            "level + 1"
          ],
          "line": 2981
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unlock_up_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2413-2428",
          "snippet": "noinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nnoinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "b"
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "b"
          ],
          "line": 2967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_old_root",
          "args": [
            "root",
            "time_seq"
          ],
          "line": 2966
        },
        "resolved": true,
        "details": {
          "function_name": "get_old_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1414-1480",
          "snippet": "static inline struct extent_buffer *\nget_old_root(struct btrfs_root *root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tstruct extent_buffer *eb = NULL;\n\tstruct extent_buffer *eb_root;\n\tstruct extent_buffer *old;\n\tstruct tree_mod_root *old_root = NULL;\n\tu64 old_generation = 0;\n\tu64 logical;\n\n\teb_root = btrfs_read_lock_root_node(root);\n\ttm = __tree_mod_log_oldest_root(root->fs_info, eb_root, time_seq);\n\tif (!tm)\n\t\treturn eb_root;\n\n\tif (tm->op == MOD_LOG_ROOT_REPLACE) {\n\t\told_root = &tm->old_root;\n\t\told_generation = tm->generation;\n\t\tlogical = old_root->logical;\n\t} else {\n\t\tlogical = eb_root->start;\n\t}\n\n\ttm = tree_mod_log_search(root->fs_info, logical, time_seq);\n\tif (old_root && tm && tm->op != MOD_LOG_KEY_REMOVE_WHILE_FREEING) {\n\t\tbtrfs_tree_read_unlock(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t\told = read_tree_block(root, logical, 0);\n\t\tif (WARN_ON(!old || !extent_buffer_uptodate(old))) {\n\t\t\tfree_extent_buffer(old);\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t\t\"failed to read tree block %llu from get_old_root\", logical);\n\t\t} else {\n\t\t\teb = btrfs_clone_extent_buffer(old);\n\t\t\tfree_extent_buffer(old);\n\t\t}\n\t} else if (old_root) {\n\t\tbtrfs_tree_read_unlock(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t\teb = alloc_dummy_extent_buffer(root->fs_info, logical);\n\t} else {\n\t\tbtrfs_set_lock_blocking_rw(eb_root, BTRFS_READ_LOCK);\n\t\teb = btrfs_clone_extent_buffer(eb_root);\n\t\tbtrfs_tree_read_unlock_blocking(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t}\n\n\tif (!eb)\n\t\treturn NULL;\n\textent_buffer_get(eb);\n\tbtrfs_tree_read_lock(eb);\n\tif (old_root) {\n\t\tbtrfs_set_header_bytenr(eb, eb->start);\n\t\tbtrfs_set_header_backref_rev(eb, BTRFS_MIXED_BACKREF_REV);\n\t\tbtrfs_set_header_owner(eb, btrfs_header_owner(eb_root));\n\t\tbtrfs_set_header_level(eb, old_root->level);\n\t\tbtrfs_set_header_generation(eb, old_generation);\n\t}\n\tif (tm)\n\t\t__tree_mod_log_rewind(root->fs_info, eb, time_seq, tm);\n\telse\n\t\tWARN_ON(btrfs_header_level(eb) != 0);\n\tWARN_ON(btrfs_header_nritems(eb) > BTRFS_NODEPTRS_PER_BLOCK(root));\n\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline struct extent_buffer *\nget_old_root(struct btrfs_root *root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tstruct extent_buffer *eb = NULL;\n\tstruct extent_buffer *eb_root;\n\tstruct extent_buffer *old;\n\tstruct tree_mod_root *old_root = NULL;\n\tu64 old_generation = 0;\n\tu64 logical;\n\n\teb_root = btrfs_read_lock_root_node(root);\n\ttm = __tree_mod_log_oldest_root(root->fs_info, eb_root, time_seq);\n\tif (!tm)\n\t\treturn eb_root;\n\n\tif (tm->op == MOD_LOG_ROOT_REPLACE) {\n\t\told_root = &tm->old_root;\n\t\told_generation = tm->generation;\n\t\tlogical = old_root->logical;\n\t} else {\n\t\tlogical = eb_root->start;\n\t}\n\n\ttm = tree_mod_log_search(root->fs_info, logical, time_seq);\n\tif (old_root && tm && tm->op != MOD_LOG_KEY_REMOVE_WHILE_FREEING) {\n\t\tbtrfs_tree_read_unlock(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t\told = read_tree_block(root, logical, 0);\n\t\tif (WARN_ON(!old || !extent_buffer_uptodate(old))) {\n\t\t\tfree_extent_buffer(old);\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t\t\"failed to read tree block %llu from get_old_root\", logical);\n\t\t} else {\n\t\t\teb = btrfs_clone_extent_buffer(old);\n\t\t\tfree_extent_buffer(old);\n\t\t}\n\t} else if (old_root) {\n\t\tbtrfs_tree_read_unlock(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t\teb = alloc_dummy_extent_buffer(root->fs_info, logical);\n\t} else {\n\t\tbtrfs_set_lock_blocking_rw(eb_root, BTRFS_READ_LOCK);\n\t\teb = btrfs_clone_extent_buffer(eb_root);\n\t\tbtrfs_tree_read_unlock_blocking(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t}\n\n\tif (!eb)\n\t\treturn NULL;\n\textent_buffer_get(eb);\n\tbtrfs_tree_read_lock(eb);\n\tif (old_root) {\n\t\tbtrfs_set_header_bytenr(eb, eb->start);\n\t\tbtrfs_set_header_backref_rev(eb, BTRFS_MIXED_BACKREF_REV);\n\t\tbtrfs_set_header_owner(eb, btrfs_header_owner(eb_root));\n\t\tbtrfs_set_header_level(eb, old_root->level);\n\t\tbtrfs_set_header_generation(eb, old_generation);\n\t}\n\tif (tm)\n\t\t__tree_mod_log_rewind(root->fs_info, eb, time_seq, tm);\n\telse\n\t\tWARN_ON(btrfs_header_level(eb) != 0);\n\tWARN_ON(btrfs_header_nritems(eb) > BTRFS_NODEPTRS_PER_BLOCK(root));\n\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "key",
            "p",
            "0",
            "0"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "time_seq"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "p->nodes[0] != NULL"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nint btrfs_search_old_slot(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct btrfs_path *p, u64 time_seq)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tu8 lowest_level = 0;\n\tint prev_cmp = -1;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(p->nodes[0] != NULL);\n\n\tif (p->search_commit_root) {\n\t\tBUG_ON(time_seq);\n\t\treturn btrfs_search_slot(NULL, root, key, p, 0, 0);\n\t}\n\nagain:\n\tb = get_old_root(root, time_seq);\n\tlevel = btrfs_header_level(b);\n\tp->locks[level] = BTRFS_READ_LOCK;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t */\n\t\tbtrfs_unlock_up_safe(p, level + 1);\n\n\t\t/*\n\t\t * Since we can unwind eb's we want to do a real search every\n\t\t * time.\n\t\t */\n\t\tprev_cmp = -1;\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(NULL, root, p, &b, level,\n\t\t\t\t\t\t    slot, key, time_seq);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\tif (!err) {\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tb = tree_mod_log_rewind(root->fs_info, p, b, time_seq);\n\t\t\tif (!b) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\tp->nodes[level] = b;\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0)\n\t\tbtrfs_release_path(p);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_search_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "2665-2932",
    "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "p"
          ],
          "line": 2930
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "p"
          ],
          "line": 2928
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_up",
          "args": [
            "p",
            "level",
            "lowest_unlock",
            "min_write_lock_level",
            "&write_lock_level"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_up",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2361-2402",
          "snippet": "static noinline void unlock_up(struct btrfs_path *path, int level,\n\t\t\t       int lowest_unlock, int min_write_lock_level,\n\t\t\t       int *write_lock_level)\n{\n\tint i;\n\tint skip_level = level;\n\tint no_skips = 0;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tif (!path->locks[i])\n\t\t\tbreak;\n\t\tif (!no_skips && path->slots[i] == 0) {\n\t\t\tskip_level = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!no_skips && path->keep_locks) {\n\t\t\tu32 nritems;\n\t\t\tt = path->nodes[i];\n\t\t\tnritems = btrfs_header_nritems(t);\n\t\t\tif (nritems < 1 || path->slots[i] >= nritems - 1) {\n\t\t\t\tskip_level = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (skip_level < i && i >= lowest_unlock)\n\t\t\tno_skips = 1;\n\n\t\tt = path->nodes[i];\n\t\tif (i >= lowest_unlock && i > skip_level && path->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(t, path->locks[i]);\n\t\t\tpath->locks[i] = 0;\n\t\t\tif (write_lock_level &&\n\t\t\t    i > min_write_lock_level &&\n\t\t\t    i <= *write_lock_level) {\n\t\t\t\t*write_lock_level = i - 1;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline void unlock_up(struct btrfs_path *path, int level,\n\t\t\t       int lowest_unlock, int min_write_lock_level,\n\t\t\t       int *write_lock_level)\n{\n\tint i;\n\tint skip_level = level;\n\tint no_skips = 0;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tif (!path->locks[i])\n\t\t\tbreak;\n\t\tif (!no_skips && path->slots[i] == 0) {\n\t\t\tskip_level = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!no_skips && path->keep_locks) {\n\t\t\tu32 nritems;\n\t\t\tt = path->nodes[i];\n\t\t\tnritems = btrfs_header_nritems(t);\n\t\t\tif (nritems < 1 || path->slots[i] >= nritems - 1) {\n\t\t\t\tskip_level = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (skip_level < i && i >= lowest_unlock)\n\t\t\tno_skips = 1;\n\n\t\tt = path->nodes[i];\n\t\tif (i >= lowest_unlock && i > skip_level && path->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(t, path->locks[i]);\n\t\t\tpath->locks[i] = 0;\n\t\t\tif (write_lock_level &&\n\t\t\t    i > min_write_lock_level &&\n\t\t\t    i <= *write_lock_level) {\n\t\t\t\t*write_lock_level = i - 1;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err > 0"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_path_blocking",
          "args": [
            "p",
            "NULL",
            "0"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "78-104",
          "snippet": "noinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "split_leaf",
          "args": [
            "trans",
            "root",
            "key",
            "p",
            "ins_len",
            "ret == 0"
          ],
          "line": 2905
        },
        "resolved": true,
        "details": {
          "function_name": "split_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4159-4322",
          "snippet": "static noinline int split_leaf(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_key *ins_key,\n\t\t\t       struct btrfs_path *path, int data_size,\n\t\t\t       int extend)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *l;\n\tu32 nritems;\n\tint mid;\n\tint slot;\n\tstruct extent_buffer *right;\n\tint ret = 0;\n\tint wret;\n\tint split;\n\tint num_doubles = 0;\n\tint tried_avoid_double = 0;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tif (extend && data_size + btrfs_item_size_nr(l, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root))\n\t\treturn -EOVERFLOW;\n\n\t/* first try to make some room by pushing left and right */\n\tif (data_size && path->nodes[1]) {\n\t\tint space_needed = data_size;\n\n\t\tif (slot < btrfs_header_nritems(l))\n\t\t\tspace_needed -= btrfs_leaf_free_space(root, l);\n\n\t\twret = push_leaf_right(trans, root, path, space_needed,\n\t\t\t\t       space_needed, 0, 0);\n\t\tif (wret < 0)\n\t\t\treturn wret;\n\t\tif (wret) {\n\t\t\twret = push_leaf_left(trans, root, path, space_needed,\n\t\t\t\t\t      space_needed, 0, (u32)-1);\n\t\t\tif (wret < 0)\n\t\t\t\treturn wret;\n\t\t}\n\t\tl = path->nodes[0];\n\n\t\t/* did the pushes work? */\n\t\tif (btrfs_leaf_free_space(root, l) >= data_size)\n\t\t\treturn 0;\n\t}\n\n\tif (!path->nodes[1]) {\n\t\tret = insert_new_root(trans, root, path, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\nagain:\n\tsplit = 1;\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(l);\n\tmid = (nritems + 1) / 2;\n\n\tif (mid <= slot) {\n\t\tif (nritems == 1 ||\n\t\t    leaf_space_used(l, mid, nritems - mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (slot >= nritems) {\n\t\t\t\tsplit = 0;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (leaf_space_used(l, 0, mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (!extend && data_size && slot == 0) {\n\t\t\t\tsplit = 0;\n\t\t\t} else if ((extend || !data_size) && slot == 0) {\n\t\t\t\tmid = 1;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (split == 0)\n\t\tbtrfs_cpu_key_to_disk(&disk_key, ins_key);\n\telse\n\t\tbtrfs_item_key(l, &disk_key, mid);\n\n\tright = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t&disk_key, 0, l->start, 0);\n\tif (IS_ERR(right))\n\t\treturn PTR_ERR(right);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(right, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(right, right->start);\n\tbtrfs_set_header_generation(right, trans->transid);\n\tbtrfs_set_header_backref_rev(right, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(right, root->root_key.objectid);\n\tbtrfs_set_header_level(right, 0);\n\twrite_extent_buffer(right, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(right, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(right),\n\t\t\t    BTRFS_UUID_SIZE);\n\n\tif (split == 0) {\n\t\tif (mid <= slot) {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t   path->slots[1] + 1, 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tpath->slots[1] += 1;\n\t\t} else {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t\t  path->slots[1], 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tif (path->slots[1] == 0)\n\t\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\t\tbtrfs_mark_buffer_dirty(right);\n\t\treturn ret;\n\t}\n\n\tcopy_for_split(trans, root, path, l, right, slot, mid, nritems);\n\n\tif (split == 2) {\n\t\tBUG_ON(num_doubles != 0);\n\t\tnum_doubles++;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n\npush_for_double:\n\tpush_for_double_split(trans, root, path, data_size);\n\ttried_avoid_double = 1;\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= data_size)\n\t\treturn 0;\n\tgoto again;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_leaf(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *ins_key,\n\t\t      struct btrfs_path *path, int data_size, int extend);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_leaf(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *ins_key,\n\t\t      struct btrfs_path *path, int data_size, int extend);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic noinline int split_leaf(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_key *ins_key,\n\t\t\t       struct btrfs_path *path, int data_size,\n\t\t\t       int extend)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *l;\n\tu32 nritems;\n\tint mid;\n\tint slot;\n\tstruct extent_buffer *right;\n\tint ret = 0;\n\tint wret;\n\tint split;\n\tint num_doubles = 0;\n\tint tried_avoid_double = 0;\n\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tif (extend && data_size + btrfs_item_size_nr(l, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root))\n\t\treturn -EOVERFLOW;\n\n\t/* first try to make some room by pushing left and right */\n\tif (data_size && path->nodes[1]) {\n\t\tint space_needed = data_size;\n\n\t\tif (slot < btrfs_header_nritems(l))\n\t\t\tspace_needed -= btrfs_leaf_free_space(root, l);\n\n\t\twret = push_leaf_right(trans, root, path, space_needed,\n\t\t\t\t       space_needed, 0, 0);\n\t\tif (wret < 0)\n\t\t\treturn wret;\n\t\tif (wret) {\n\t\t\twret = push_leaf_left(trans, root, path, space_needed,\n\t\t\t\t\t      space_needed, 0, (u32)-1);\n\t\t\tif (wret < 0)\n\t\t\t\treturn wret;\n\t\t}\n\t\tl = path->nodes[0];\n\n\t\t/* did the pushes work? */\n\t\tif (btrfs_leaf_free_space(root, l) >= data_size)\n\t\t\treturn 0;\n\t}\n\n\tif (!path->nodes[1]) {\n\t\tret = insert_new_root(trans, root, path, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\nagain:\n\tsplit = 1;\n\tl = path->nodes[0];\n\tslot = path->slots[0];\n\tnritems = btrfs_header_nritems(l);\n\tmid = (nritems + 1) / 2;\n\n\tif (mid <= slot) {\n\t\tif (nritems == 1 ||\n\t\t    leaf_space_used(l, mid, nritems - mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (slot >= nritems) {\n\t\t\t\tsplit = 0;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (leaf_space_used(l, 0, mid) + data_size >\n\t\t\tBTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\tif (!extend && data_size && slot == 0) {\n\t\t\t\tsplit = 0;\n\t\t\t} else if ((extend || !data_size) && slot == 0) {\n\t\t\t\tmid = 1;\n\t\t\t} else {\n\t\t\t\tmid = slot;\n\t\t\t\tif (mid != nritems &&\n\t\t\t\t    leaf_space_used(l, mid, nritems - mid) +\n\t\t\t\t    data_size > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\t\t\t\tif (data_size && !tried_avoid_double)\n\t\t\t\t\t\tgoto push_for_double;\n\t\t\t\t\tsplit = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (split == 0)\n\t\tbtrfs_cpu_key_to_disk(&disk_key, ins_key);\n\telse\n\t\tbtrfs_item_key(l, &disk_key, mid);\n\n\tright = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t&disk_key, 0, l->start, 0);\n\tif (IS_ERR(right))\n\t\treturn PTR_ERR(right);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(right, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_bytenr(right, right->start);\n\tbtrfs_set_header_generation(right, trans->transid);\n\tbtrfs_set_header_backref_rev(right, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(right, root->root_key.objectid);\n\tbtrfs_set_header_level(right, 0);\n\twrite_extent_buffer(right, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\n\twrite_extent_buffer(right, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(right),\n\t\t\t    BTRFS_UUID_SIZE);\n\n\tif (split == 0) {\n\t\tif (mid <= slot) {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t   path->slots[1] + 1, 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tpath->slots[1] += 1;\n\t\t} else {\n\t\t\tbtrfs_set_header_nritems(right, 0);\n\t\t\tinsert_ptr(trans, root, path, &disk_key, right->start,\n\t\t\t\t\t  path->slots[1], 1);\n\t\t\tbtrfs_tree_unlock(path->nodes[0]);\n\t\t\tfree_extent_buffer(path->nodes[0]);\n\t\t\tpath->nodes[0] = right;\n\t\t\tpath->slots[0] = 0;\n\t\t\tif (path->slots[1] == 0)\n\t\t\t\tfixup_low_keys(root, path, &disk_key, 1);\n\t\t}\n\t\tbtrfs_mark_buffer_dirty(right);\n\t\treturn ret;\n\t}\n\n\tcopy_for_split(trans, root, path, l, right, slot, mid, nritems);\n\n\tif (split == 2) {\n\t\tBUG_ON(num_doubles != 0);\n\t\tnum_doubles++;\n\t\tgoto again;\n\t}\n\n\treturn 0;\n\npush_for_double:\n\tpush_for_double_split(trans, root, path, data_size);\n\ttried_avoid_double = 1;\n\tif (btrfs_leaf_free_space(root, path->nodes[0]) >= data_size)\n\t\treturn 0;\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_leaf_free_space",
          "args": [
            "root",
            "b"
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_leaf_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3566-3579",
          "snippet": "noinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_leaf_free_space(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *leaf)\n{\n\tint nritems = btrfs_header_nritems(leaf);\n\tint ret;\n\tret = BTRFS_LEAF_DATA_SIZE(root) - leaf_space_used(leaf, 0, nritems);\n\tif (ret < 0) {\n\t\tbtrfs_crit(root->fs_info,\n\t\t\t\"leaf free space ret %d, leaf data size %lu, used %d nritems %d\",\n\t\t       ret, (unsigned long) BTRFS_LEAF_DATA_SIZE(root),\n\t\t       leaf_space_used(leaf, 0, nritems), nritems);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_lock",
          "args": [
            "b"
          ],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_lock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "135-148",
          "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "b"
          ],
          "line": 2877
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_try_tree_write_lock",
          "args": [
            "b"
          ],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_try_tree_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "175-191",
          "snippet": "int btrfs_try_tree_write_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers))\n\t\treturn 0;\n\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->write_locks);\n\tatomic_inc(&eb->spinning_writers);\n\teb->lock_owner = current->pid;\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_try_tree_write_lock(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers))\n\t\treturn 0;\n\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers) ||\n\t    atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->write_locks);\n\tatomic_inc(&eb->spinning_writers);\n\teb->lock_owner = current->pid;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "b"
          ],
          "line": 2872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_block_for_search",
          "args": [
            "trans",
            "root",
            "p",
            "&b",
            "level",
            "slot",
            "key",
            "0"
          ],
          "line": 2862
        },
        "resolved": true,
        "details": {
          "function_name": "read_block_for_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2438-2510",
          "snippet": "static int\nread_block_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer **eb_ret, int level, int slot,\n\t\t       struct btrfs_key *key, u64 time_seq)\n{\n\tu64 blocknr;\n\tu64 gen;\n\tstruct extent_buffer *b = *eb_ret;\n\tstruct extent_buffer *tmp;\n\tint ret;\n\n\tblocknr = btrfs_node_blockptr(b, slot);\n\tgen = btrfs_node_ptr_generation(b, slot);\n\n\ttmp = btrfs_find_tree_block(root, blocknr);\n\tif (tmp) {\n\t\t/* first we do an atomic uptodate check */\n\t\tif (btrfs_buffer_uptodate(tmp, gen, 1) > 0) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* the pages were up to date, but we failed\n\t\t * the generation number check.  Do a full\n\t\t * read for the generation number that is correct.\n\t\t * We must do this without dropping locks so\n\t\t * we can trust our generation number\n\t\t */\n\t\tbtrfs_set_path_blocking(p);\n\n\t\t/* now we're allowed to do a blocking uptodate check */\n\t\tret = btrfs_read_buffer(tmp, gen);\n\t\tif (!ret) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(tmp);\n\t\tbtrfs_release_path(p);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * reduce lock contention at high levels\n\t * of the btree by dropping locks before\n\t * we read.  Don't release the lock on the current\n\t * level because we need to walk this node to figure\n\t * out which blocks to read.\n\t */\n\tbtrfs_unlock_up_safe(p, level + 1);\n\tbtrfs_set_path_blocking(p);\n\n\tfree_extent_buffer(tmp);\n\tif (p->reada)\n\t\treada_for_search(root, p, level, slot, key->objectid);\n\n\tbtrfs_release_path(p);\n\n\tret = -EAGAIN;\n\ttmp = read_tree_block(root, blocknr, 0);\n\tif (tmp) {\n\t\t/*\n\t\t * If the read above didn't mark this buffer up to date,\n\t\t * it will never end up being up to date.  Set ret to EIO now\n\t\t * and give up so that our caller doesn't loop forever\n\t\t * on our EAGAINs.\n\t\t */\n\t\tif (!btrfs_buffer_uptodate(tmp, 0, 0))\n\t\t\tret = -EIO;\n\t\tfree_extent_buffer(tmp);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int\nread_block_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer **eb_ret, int level, int slot,\n\t\t       struct btrfs_key *key, u64 time_seq)\n{\n\tu64 blocknr;\n\tu64 gen;\n\tstruct extent_buffer *b = *eb_ret;\n\tstruct extent_buffer *tmp;\n\tint ret;\n\n\tblocknr = btrfs_node_blockptr(b, slot);\n\tgen = btrfs_node_ptr_generation(b, slot);\n\n\ttmp = btrfs_find_tree_block(root, blocknr);\n\tif (tmp) {\n\t\t/* first we do an atomic uptodate check */\n\t\tif (btrfs_buffer_uptodate(tmp, gen, 1) > 0) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* the pages were up to date, but we failed\n\t\t * the generation number check.  Do a full\n\t\t * read for the generation number that is correct.\n\t\t * We must do this without dropping locks so\n\t\t * we can trust our generation number\n\t\t */\n\t\tbtrfs_set_path_blocking(p);\n\n\t\t/* now we're allowed to do a blocking uptodate check */\n\t\tret = btrfs_read_buffer(tmp, gen);\n\t\tif (!ret) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(tmp);\n\t\tbtrfs_release_path(p);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * reduce lock contention at high levels\n\t * of the btree by dropping locks before\n\t * we read.  Don't release the lock on the current\n\t * level because we need to walk this node to figure\n\t * out which blocks to read.\n\t */\n\tbtrfs_unlock_up_safe(p, level + 1);\n\tbtrfs_set_path_blocking(p);\n\n\tfree_extent_buffer(tmp);\n\tif (p->reada)\n\t\treada_for_search(root, p, level, slot, key->objectid);\n\n\tbtrfs_release_path(p);\n\n\tret = -EAGAIN;\n\ttmp = read_tree_block(root, blocknr, 0);\n\tif (tmp) {\n\t\t/*\n\t\t * If the read above didn't mark this buffer up to date,\n\t\t * it will never end up being up to date.  Set ret to EIO now\n\t\t * and give up so that our caller doesn't loop forever\n\t\t * on our EAGAINs.\n\t\t */\n\t\tif (!btrfs_buffer_uptodate(tmp, 0, 0))\n\t\t\tret = -EIO;\n\t\tfree_extent_buffer(tmp);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_nodes_for_search",
          "args": [
            "trans",
            "root",
            "p",
            "b",
            "level",
            "ins_len",
            "&write_lock_level"
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "setup_nodes_for_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2521-2581",
          "snippet": "static int\nsetup_nodes_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer *b, int level, int ins_len,\n\t\t       int *write_lock_level)\n{\n\tint ret;\n\tif ((p->search_for_split || ins_len > 0) && btrfs_header_nritems(b) >=\n\t    BTRFS_NODEPTRS_PER_BLOCK(root) - 3) {\n\t\tint sret;\n\n\t\tif (*write_lock_level < level + 1) {\n\t\t\t*write_lock_level = level + 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_set_path_blocking(p);\n\t\treada_for_balance(root, p, level);\n\t\tsret = split_node(trans, root, p, level);\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\tBUG_ON(sret > 0);\n\t\tif (sret) {\n\t\t\tret = sret;\n\t\t\tgoto done;\n\t\t}\n\t\tb = p->nodes[level];\n\t} else if (ins_len < 0 && btrfs_header_nritems(b) <\n\t\t   BTRFS_NODEPTRS_PER_BLOCK(root) / 2) {\n\t\tint sret;\n\n\t\tif (*write_lock_level < level + 1) {\n\t\t\t*write_lock_level = level + 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_set_path_blocking(p);\n\t\treada_for_balance(root, p, level);\n\t\tsret = balance_level(trans, root, p, level);\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\tif (sret) {\n\t\t\tret = sret;\n\t\t\tgoto done;\n\t\t}\n\t\tb = p->nodes[level];\n\t\tif (!b) {\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t\tBUG_ON(btrfs_header_nritems(b) == 1);\n\t}\n\treturn 0;\n\nagain:\n\tret = -EAGAIN;\ndone:\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic int\nsetup_nodes_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer *b, int level, int ins_len,\n\t\t       int *write_lock_level)\n{\n\tint ret;\n\tif ((p->search_for_split || ins_len > 0) && btrfs_header_nritems(b) >=\n\t    BTRFS_NODEPTRS_PER_BLOCK(root) - 3) {\n\t\tint sret;\n\n\t\tif (*write_lock_level < level + 1) {\n\t\t\t*write_lock_level = level + 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_set_path_blocking(p);\n\t\treada_for_balance(root, p, level);\n\t\tsret = split_node(trans, root, p, level);\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\tBUG_ON(sret > 0);\n\t\tif (sret) {\n\t\t\tret = sret;\n\t\t\tgoto done;\n\t\t}\n\t\tb = p->nodes[level];\n\t} else if (ins_len < 0 && btrfs_header_nritems(b) <\n\t\t   BTRFS_NODEPTRS_PER_BLOCK(root) / 2) {\n\t\tint sret;\n\n\t\tif (*write_lock_level < level + 1) {\n\t\t\t*write_lock_level = level + 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_set_path_blocking(p);\n\t\treada_for_balance(root, p, level);\n\t\tsret = balance_level(trans, root, p, level);\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\tif (sret) {\n\t\t\tret = sret;\n\t\t\tgoto done;\n\t\t}\n\t\tb = p->nodes[level];\n\t\tif (!b) {\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t\tBUG_ON(btrfs_header_nritems(b) == 1);\n\t}\n\treturn 0;\n\nagain:\n\tret = -EAGAIN;\ndone:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_search",
          "args": [
            "b",
            "key",
            "level",
            "&prev_cmp",
            "&slot"
          ],
          "line": 2820
        },
        "resolved": true,
        "details": {
          "function_name": "key_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2603-2615",
          "snippet": "static int key_search(struct extent_buffer *b, struct btrfs_key *key,\n\t\t      int level, int *prev_cmp, int *slot)\n{\n\tif (*prev_cmp != 0) {\n\t\t*prev_cmp = bin_search(b, key, level, slot);\n\t\treturn *prev_cmp;\n\t}\n\n\tkey_search_validate(b, key, level);\n\t*slot = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int key_search(struct extent_buffer *b, struct btrfs_key *key,\n\t\t      int level, int *prev_cmp, int *slot)\n{\n\tif (*prev_cmp != 0) {\n\t\t*prev_cmp = bin_search(b, key, level, slot);\n\t\treturn *prev_cmp;\n\t}\n\n\tkey_search_validate(b, key, level);\n\t*slot = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock_rw",
          "args": [
            "p->nodes[u]",
            "p->locks[u]"
          ],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "41-51",
          "snippet": "static inline void btrfs_tree_unlock_rw(struct extent_buffer *eb, int rw)\n{\n\tif (rw == BTRFS_WRITE_LOCK || rw == BTRFS_WRITE_LOCK_BLOCKING)\n\t\tbtrfs_tree_unlock(eb);\n\telse if (rw == BTRFS_READ_LOCK_BLOCKING)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\telse if (rw == BTRFS_READ_LOCK)\n\t\tbtrfs_tree_read_unlock(eb);\n\telse\n\t\tBUG();\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_READ_LOCK_BLOCKING 4",
            "#define BTRFS_WRITE_LOCK_BLOCKING 3",
            "#define BTRFS_READ_LOCK 2",
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_READ_LOCK_BLOCKING 4\n#define BTRFS_WRITE_LOCK_BLOCKING 3\n#define BTRFS_READ_LOCK 2\n#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_tree_unlock_rw(struct extent_buffer *eb, int rw)\n{\n\tif (rw == BTRFS_WRITE_LOCK || rw == BTRFS_WRITE_LOCK_BLOCKING)\n\t\tbtrfs_tree_unlock(eb);\n\telse if (rw == BTRFS_READ_LOCK_BLOCKING)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\telse if (rw == BTRFS_READ_LOCK)\n\t\tbtrfs_tree_read_unlock(eb);\n\telse\n\t\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cow_block",
          "args": [
            "trans",
            "root",
            "b",
            "p->nodes[level + 1]",
            "p->slots[level + 1]",
            "&b"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1534-1568",
          "snippet": "noinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "should_cow_block",
          "args": [
            "trans",
            "root",
            "b"
          ],
          "line": 2771
        },
        "resolved": true,
        "details": {
          "function_name": "should_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1499-1527",
          "snippet": "static inline int should_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *buf)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\t/* ensure we can see the force_cow */\n\tsmp_rmb();\n\n\t/*\n\t * We do not need to cow a block if\n\t * 1) this block is not created or changed in this transaction;\n\t * 2) this block does not belong to TREE_RELOC tree;\n\t * 3) the root is not forced COW.\n\t *\n\t * What is forced COW:\n\t *    when we create snapshot during commiting the transaction,\n\t *    after we've finished coping src root, we must COW the shared\n\t *    block to ensure the metadata consistency.\n\t */\n\tif (btrfs_header_generation(buf) == trans->transid &&\n\t    !btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN) &&\n\t    !(root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID &&\n\t      btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)) &&\n\t    !test_bit(BTRFS_ROOT_FORCE_COW, &root->state))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline int should_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *buf)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\t/* ensure we can see the force_cow */\n\tsmp_rmb();\n\n\t/*\n\t * We do not need to cow a block if\n\t * 1) this block is not created or changed in this transaction;\n\t * 2) this block does not belong to TREE_RELOC tree;\n\t * 3) the root is not forced COW.\n\t *\n\t * What is forced COW:\n\t *    when we create snapshot during commiting the transaction,\n\t *    after we've finished coping src root, we must COW the shared\n\t *    block to ensure the metadata consistency.\n\t */\n\tif (btrfs_header_generation(buf) == trans->transid &&\n\t    !btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN) &&\n\t    !(root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID &&\n\t      btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)) &&\n\t    !test_bit(BTRFS_ROOT_FORCE_COW, &root->state))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "b"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "b"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lock_root_node",
          "args": [
            "root"
          ],
          "line": 2746
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lock_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "176-189",
          "snippet": "struct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "b"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_unlock",
          "args": [
            "b"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "b"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_lock_root_node",
          "args": [
            "root"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_lock_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "195-208",
          "snippet": "static struct extent_buffer *btrfs_read_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_read_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_read_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic struct extent_buffer *btrfs_read_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_read_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_read_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "b"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_node",
          "args": [
            "root"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "148-170",
          "snippet": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&root->fs_info->commit_root_sem"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "b"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "b"
          ],
          "line": 2726
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&root->fs_info->commit_root_sem"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cow && ins_len"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "p->nodes[0] != NULL"
          ],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "lowest_level && ins_len > 0"
          ],
          "line": 2683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_find_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "2617-2650",
    "snippet": "int btrfs_find_item(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\tu64 iobjectid, u64 ioff, u8 key_type,\n\t\tstruct btrfs_key *found_key)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\n\tASSERT(path);\n\tASSERT(found_key);\n\n\tkey.type = key_type;\n\tkey.objectid = iobjectid;\n\tkey.offset = ioff;\n\n\tret = btrfs_search_slot(NULL, fs_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\teb = path->nodes[0];\n\tif (ret && path->slots[0] >= btrfs_header_nritems(eb)) {\n\t\tret = btrfs_next_leaf(fs_root, path);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\teb = path->nodes[0];\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, found_key, path->slots[0]);\n\tif (found_key->type != key.type ||\n\t\t\tfound_key->objectid != key.objectid)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "found_key",
            "path->slots[0]"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "fs_root",
            "path"
          ],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "fs_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "found_key"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "path"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nint btrfs_find_item(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\tu64 iobjectid, u64 ioff, u8 key_type,\n\t\tstruct btrfs_key *found_key)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\n\tASSERT(path);\n\tASSERT(found_key);\n\n\tkey.type = key_type;\n\tkey.objectid = iobjectid;\n\tkey.offset = ioff;\n\n\tret = btrfs_search_slot(NULL, fs_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\teb = path->nodes[0];\n\tif (ret && path->slots[0] >= btrfs_header_nritems(eb)) {\n\t\tret = btrfs_next_leaf(fs_root, path);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\teb = path->nodes[0];\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, found_key, path->slots[0]);\n\tif (found_key->type != key.type ||\n\t\t\tfound_key->objectid != key.objectid)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "key_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "2603-2615",
    "snippet": "static int key_search(struct extent_buffer *b, struct btrfs_key *key,\n\t\t      int level, int *prev_cmp, int *slot)\n{\n\tif (*prev_cmp != 0) {\n\t\t*prev_cmp = bin_search(b, key, level, slot);\n\t\treturn *prev_cmp;\n\t}\n\n\tkey_search_validate(b, key, level);\n\t*slot = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_search_validate",
          "args": [
            "b",
            "key",
            "level"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "key_search_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2583-2601",
          "snippet": "static void key_search_validate(struct extent_buffer *b,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tint level)\n{\n#ifdef CONFIG_BTRFS_ASSERT\n\tstruct btrfs_disk_key disk_key;\n\n\tbtrfs_cpu_key_to_disk(&disk_key, key);\n\n\tif (level == 0)\n\t\tASSERT(!memcmp_extent_buffer(b, &disk_key,\n\t\t    offsetof(struct btrfs_leaf, items[0].key),\n\t\t    sizeof(disk_key)));\n\telse\n\t\tASSERT(!memcmp_extent_buffer(b, &disk_key,\n\t\t    offsetof(struct btrfs_node, ptrs[0].key),\n\t\t    sizeof(disk_key)));\n#endif\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic void key_search_validate(struct extent_buffer *b,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tint level)\n{\n#ifdef CONFIG_BTRFS_ASSERT\n\tstruct btrfs_disk_key disk_key;\n\n\tbtrfs_cpu_key_to_disk(&disk_key, key);\n\n\tif (level == 0)\n\t\tASSERT(!memcmp_extent_buffer(b, &disk_key,\n\t\t    offsetof(struct btrfs_leaf, items[0].key),\n\t\t    sizeof(disk_key)));\n\telse\n\t\tASSERT(!memcmp_extent_buffer(b, &disk_key,\n\t\t    offsetof(struct btrfs_node, ptrs[0].key),\n\t\t    sizeof(disk_key)));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "bin_search",
          "args": [
            "b",
            "key",
            "level",
            "slot"
          ],
          "line": 2607
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bin_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1827-1831",
          "snippet": "int btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nint btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int key_search(struct extent_buffer *b, struct btrfs_key *key,\n\t\t      int level, int *prev_cmp, int *slot)\n{\n\tif (*prev_cmp != 0) {\n\t\t*prev_cmp = bin_search(b, key, level, slot);\n\t\treturn *prev_cmp;\n\t}\n\n\tkey_search_validate(b, key, level);\n\t*slot = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "key_search_validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "2583-2601",
    "snippet": "static void key_search_validate(struct extent_buffer *b,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tint level)\n{\n#ifdef CONFIG_BTRFS_ASSERT\n\tstruct btrfs_disk_key disk_key;\n\n\tbtrfs_cpu_key_to_disk(&disk_key, key);\n\n\tif (level == 0)\n\t\tASSERT(!memcmp_extent_buffer(b, &disk_key,\n\t\t    offsetof(struct btrfs_leaf, items[0].key),\n\t\t    sizeof(disk_key)));\n\telse\n\t\tASSERT(!memcmp_extent_buffer(b, &disk_key,\n\t\t    offsetof(struct btrfs_node, ptrs[0].key),\n\t\t    sizeof(disk_key)));\n#endif\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!memcmp_extent_buffer(b, &disk_key,\n\t\t    offsetof(struct btrfs_node, ptrs[0].key)",
            "sizeof(disk_key)"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp_extent_buffer",
          "args": [
            "b",
            "&disk_key",
            "offsetof(struct btrfs_node, ptrs[0].key"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!memcmp_extent_buffer(b, &disk_key,\n\t\t    offsetof(struct btrfs_leaf, items[0].key)",
            "sizeof(disk_key)"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp_extent_buffer",
          "args": [
            "b",
            "&disk_key",
            "offsetof(struct btrfs_leaf, items[0].key"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_cpu_key_to_disk",
          "args": [
            "&disk_key",
            "key"
          ],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cpu_key_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2739-2745",
          "snippet": "static inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_cpu_key_to_disk(struct btrfs_disk_key *disk,\n\t\t\t\t\t struct btrfs_key *cpu)\n{\n\tdisk->offset = cpu_to_le64(cpu->offset);\n\tdisk->type = cpu->type;\n\tdisk->objectid = cpu_to_le64(cpu->objectid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic void key_search_validate(struct extent_buffer *b,\n\t\t\t\tstruct btrfs_key *key,\n\t\t\t\tint level)\n{\n#ifdef CONFIG_BTRFS_ASSERT\n\tstruct btrfs_disk_key disk_key;\n\n\tbtrfs_cpu_key_to_disk(&disk_key, key);\n\n\tif (level == 0)\n\t\tASSERT(!memcmp_extent_buffer(b, &disk_key,\n\t\t    offsetof(struct btrfs_leaf, items[0].key),\n\t\t    sizeof(disk_key)));\n\telse\n\t\tASSERT(!memcmp_extent_buffer(b, &disk_key,\n\t\t    offsetof(struct btrfs_node, ptrs[0].key),\n\t\t    sizeof(disk_key)));\n#endif\n}"
  },
  {
    "function_name": "setup_nodes_for_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "2521-2581",
    "snippet": "static int\nsetup_nodes_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer *b, int level, int ins_len,\n\t\t       int *write_lock_level)\n{\n\tint ret;\n\tif ((p->search_for_split || ins_len > 0) && btrfs_header_nritems(b) >=\n\t    BTRFS_NODEPTRS_PER_BLOCK(root) - 3) {\n\t\tint sret;\n\n\t\tif (*write_lock_level < level + 1) {\n\t\t\t*write_lock_level = level + 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_set_path_blocking(p);\n\t\treada_for_balance(root, p, level);\n\t\tsret = split_node(trans, root, p, level);\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\tBUG_ON(sret > 0);\n\t\tif (sret) {\n\t\t\tret = sret;\n\t\t\tgoto done;\n\t\t}\n\t\tb = p->nodes[level];\n\t} else if (ins_len < 0 && btrfs_header_nritems(b) <\n\t\t   BTRFS_NODEPTRS_PER_BLOCK(root) / 2) {\n\t\tint sret;\n\n\t\tif (*write_lock_level < level + 1) {\n\t\t\t*write_lock_level = level + 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_set_path_blocking(p);\n\t\treada_for_balance(root, p, level);\n\t\tsret = balance_level(trans, root, p, level);\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\tif (sret) {\n\t\t\tret = sret;\n\t\t\tgoto done;\n\t\t}\n\t\tb = p->nodes[level];\n\t\tif (!b) {\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t\tBUG_ON(btrfs_header_nritems(b) == 1);\n\t}\n\treturn 0;\n\nagain:\n\tret = -EAGAIN;\ndone:\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "btrfs_header_nritems(b) == 1"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "b"
          ],
          "line": 2573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "p"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clear_path_blocking",
          "args": [
            "p",
            "NULL",
            "0"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "78-104",
          "snippet": "noinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_level",
          "args": [
            "trans",
            "root",
            "p",
            "level"
          ],
          "line": 2561
        },
        "resolved": true,
        "details": {
          "function_name": "balance_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1881-2093",
          "snippet": "static noinline int balance_level(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *right = NULL;\n\tstruct extent_buffer *mid;\n\tstruct extent_buffer *left = NULL;\n\tstruct extent_buffer *parent = NULL;\n\tint ret = 0;\n\tint wret;\n\tint pslot;\n\tint orig_slot = path->slots[level];\n\tu64 orig_ptr;\n\n\tif (level == 0)\n\t\treturn 0;\n\n\tmid = path->nodes[level];\n\n\tWARN_ON(path->locks[level] != BTRFS_WRITE_LOCK &&\n\t\tpath->locks[level] != BTRFS_WRITE_LOCK_BLOCKING);\n\tWARN_ON(btrfs_header_generation(mid) != trans->transid);\n\n\torig_ptr = btrfs_node_blockptr(mid, orig_slot);\n\n\tif (level < BTRFS_MAX_LEVEL - 1) {\n\t\tparent = path->nodes[level + 1];\n\t\tpslot = path->slots[level + 1];\n\t}\n\n\t/*\n\t * deal with the case where there is only one pointer in the root\n\t * by promoting the node below to a root\n\t */\n\tif (!parent) {\n\t\tstruct extent_buffer *child;\n\n\t\tif (btrfs_header_nritems(mid) != 1)\n\t\t\treturn 0;\n\n\t\t/* promote the child to a root */\n\t\tchild = read_node_slot(root, mid, 0);\n\t\tif (!child) {\n\t\t\tret = -EROFS;\n\t\t\tbtrfs_std_error(root->fs_info, ret);\n\t\t\tgoto enospc;\n\t\t}\n\n\t\tbtrfs_tree_lock(child);\n\t\tbtrfs_set_lock_blocking(child);\n\t\tret = btrfs_cow_block(trans, root, child, mid, 0, &child);\n\t\tif (ret) {\n\t\t\tbtrfs_tree_unlock(child);\n\t\t\tfree_extent_buffer(child);\n\t\t\tgoto enospc;\n\t\t}\n\n\t\ttree_mod_log_set_root_pointer(root, child, 1);\n\t\trcu_assign_pointer(root->node, child);\n\n\t\tadd_root_to_dirty_list(root);\n\t\tbtrfs_tree_unlock(child);\n\n\t\tpath->locks[level] = 0;\n\t\tpath->nodes[level] = NULL;\n\t\tclean_tree_block(trans, root, mid);\n\t\tbtrfs_tree_unlock(mid);\n\t\t/* once for the path */\n\t\tfree_extent_buffer(mid);\n\n\t\troot_sub_used(root, mid->len);\n\t\tbtrfs_free_tree_block(trans, root, mid, 0, 1);\n\t\t/* once for the root ptr */\n\t\tfree_extent_buffer_stale(mid);\n\t\treturn 0;\n\t}\n\tif (btrfs_header_nritems(mid) >\n\t    BTRFS_NODEPTRS_PER_BLOCK(root) / 4)\n\t\treturn 0;\n\n\tleft = read_node_slot(root, parent, pslot - 1);\n\tif (left) {\n\t\tbtrfs_tree_lock(left);\n\t\tbtrfs_set_lock_blocking(left);\n\t\twret = btrfs_cow_block(trans, root, left,\n\t\t\t\t       parent, pslot - 1, &left);\n\t\tif (wret) {\n\t\t\tret = wret;\n\t\t\tgoto enospc;\n\t\t}\n\t}\n\tright = read_node_slot(root, parent, pslot + 1);\n\tif (right) {\n\t\tbtrfs_tree_lock(right);\n\t\tbtrfs_set_lock_blocking(right);\n\t\twret = btrfs_cow_block(trans, root, right,\n\t\t\t\t       parent, pslot + 1, &right);\n\t\tif (wret) {\n\t\t\tret = wret;\n\t\t\tgoto enospc;\n\t\t}\n\t}\n\n\t/* first, try to make some room in the middle buffer */\n\tif (left) {\n\t\torig_slot += btrfs_header_nritems(left);\n\t\twret = push_node_left(trans, root, left, mid, 1);\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t}\n\n\t/*\n\t * then try to empty the right most buffer into the middle\n\t */\n\tif (right) {\n\t\twret = push_node_left(trans, root, mid, right, 1);\n\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\tret = wret;\n\t\tif (btrfs_header_nritems(right) == 0) {\n\t\t\tclean_tree_block(trans, root, right);\n\t\t\tbtrfs_tree_unlock(right);\n\t\t\tdel_ptr(root, path, level + 1, pslot + 1);\n\t\t\troot_sub_used(root, right->len);\n\t\t\tbtrfs_free_tree_block(trans, root, right, 0, 1);\n\t\t\tfree_extent_buffer_stale(right);\n\t\t\tright = NULL;\n\t\t} else {\n\t\t\tstruct btrfs_disk_key right_key;\n\t\t\tbtrfs_node_key(right, &right_key, 0);\n\t\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t\t  pslot + 1, 0);\n\t\t\tbtrfs_set_node_key(parent, &right_key, pslot + 1);\n\t\t\tbtrfs_mark_buffer_dirty(parent);\n\t\t}\n\t}\n\tif (btrfs_header_nritems(mid) == 1) {\n\t\t/*\n\t\t * we're not allowed to leave a node with one item in the\n\t\t * tree during a delete.  A deletion from lower in the tree\n\t\t * could try to delete the only pointer in this node.\n\t\t * So, pull some keys from the left.\n\t\t * There has to be a left pointer at this point because\n\t\t * otherwise we would have pulled some pointers from the\n\t\t * right\n\t\t */\n\t\tif (!left) {\n\t\t\tret = -EROFS;\n\t\t\tbtrfs_std_error(root->fs_info, ret);\n\t\t\tgoto enospc;\n\t\t}\n\t\twret = balance_node_right(trans, root, mid, left);\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto enospc;\n\t\t}\n\t\tif (wret == 1) {\n\t\t\twret = push_node_left(trans, root, left, mid, 1);\n\t\t\tif (wret < 0)\n\t\t\t\tret = wret;\n\t\t}\n\t\tBUG_ON(wret == 1);\n\t}\n\tif (btrfs_header_nritems(mid) == 0) {\n\t\tclean_tree_block(trans, root, mid);\n\t\tbtrfs_tree_unlock(mid);\n\t\tdel_ptr(root, path, level + 1, pslot);\n\t\troot_sub_used(root, mid->len);\n\t\tbtrfs_free_tree_block(trans, root, mid, 0, 1);\n\t\tfree_extent_buffer_stale(mid);\n\t\tmid = NULL;\n\t} else {\n\t\t/* update the parent key to reflect our changes */\n\t\tstruct btrfs_disk_key mid_key;\n\t\tbtrfs_node_key(mid, &mid_key, 0);\n\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t  pslot, 0);\n\t\tbtrfs_set_node_key(parent, &mid_key, pslot);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\t}\n\n\t/* update the path */\n\tif (left) {\n\t\tif (btrfs_header_nritems(left) > orig_slot) {\n\t\t\textent_buffer_get(left);\n\t\t\t/* left was locked after cow */\n\t\t\tpath->nodes[level] = left;\n\t\t\tpath->slots[level + 1] -= 1;\n\t\t\tpath->slots[level] = orig_slot;\n\t\t\tif (mid) {\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t}\n\t\t} else {\n\t\t\torig_slot -= btrfs_header_nritems(left);\n\t\t\tpath->slots[level] = orig_slot;\n\t\t}\n\t}\n\t/* double check we haven't messed things up */\n\tif (orig_ptr !=\n\t    btrfs_node_blockptr(path->nodes[level], path->slots[level]))\n\t\tBUG();\nenospc:\n\tif (right) {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\tif (left) {\n\t\tif (path->nodes[level] != left)\n\t\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic noinline struct;\n\nstatic noinline int balance_level(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *right = NULL;\n\tstruct extent_buffer *mid;\n\tstruct extent_buffer *left = NULL;\n\tstruct extent_buffer *parent = NULL;\n\tint ret = 0;\n\tint wret;\n\tint pslot;\n\tint orig_slot = path->slots[level];\n\tu64 orig_ptr;\n\n\tif (level == 0)\n\t\treturn 0;\n\n\tmid = path->nodes[level];\n\n\tWARN_ON(path->locks[level] != BTRFS_WRITE_LOCK &&\n\t\tpath->locks[level] != BTRFS_WRITE_LOCK_BLOCKING);\n\tWARN_ON(btrfs_header_generation(mid) != trans->transid);\n\n\torig_ptr = btrfs_node_blockptr(mid, orig_slot);\n\n\tif (level < BTRFS_MAX_LEVEL - 1) {\n\t\tparent = path->nodes[level + 1];\n\t\tpslot = path->slots[level + 1];\n\t}\n\n\t/*\n\t * deal with the case where there is only one pointer in the root\n\t * by promoting the node below to a root\n\t */\n\tif (!parent) {\n\t\tstruct extent_buffer *child;\n\n\t\tif (btrfs_header_nritems(mid) != 1)\n\t\t\treturn 0;\n\n\t\t/* promote the child to a root */\n\t\tchild = read_node_slot(root, mid, 0);\n\t\tif (!child) {\n\t\t\tret = -EROFS;\n\t\t\tbtrfs_std_error(root->fs_info, ret);\n\t\t\tgoto enospc;\n\t\t}\n\n\t\tbtrfs_tree_lock(child);\n\t\tbtrfs_set_lock_blocking(child);\n\t\tret = btrfs_cow_block(trans, root, child, mid, 0, &child);\n\t\tif (ret) {\n\t\t\tbtrfs_tree_unlock(child);\n\t\t\tfree_extent_buffer(child);\n\t\t\tgoto enospc;\n\t\t}\n\n\t\ttree_mod_log_set_root_pointer(root, child, 1);\n\t\trcu_assign_pointer(root->node, child);\n\n\t\tadd_root_to_dirty_list(root);\n\t\tbtrfs_tree_unlock(child);\n\n\t\tpath->locks[level] = 0;\n\t\tpath->nodes[level] = NULL;\n\t\tclean_tree_block(trans, root, mid);\n\t\tbtrfs_tree_unlock(mid);\n\t\t/* once for the path */\n\t\tfree_extent_buffer(mid);\n\n\t\troot_sub_used(root, mid->len);\n\t\tbtrfs_free_tree_block(trans, root, mid, 0, 1);\n\t\t/* once for the root ptr */\n\t\tfree_extent_buffer_stale(mid);\n\t\treturn 0;\n\t}\n\tif (btrfs_header_nritems(mid) >\n\t    BTRFS_NODEPTRS_PER_BLOCK(root) / 4)\n\t\treturn 0;\n\n\tleft = read_node_slot(root, parent, pslot - 1);\n\tif (left) {\n\t\tbtrfs_tree_lock(left);\n\t\tbtrfs_set_lock_blocking(left);\n\t\twret = btrfs_cow_block(trans, root, left,\n\t\t\t\t       parent, pslot - 1, &left);\n\t\tif (wret) {\n\t\t\tret = wret;\n\t\t\tgoto enospc;\n\t\t}\n\t}\n\tright = read_node_slot(root, parent, pslot + 1);\n\tif (right) {\n\t\tbtrfs_tree_lock(right);\n\t\tbtrfs_set_lock_blocking(right);\n\t\twret = btrfs_cow_block(trans, root, right,\n\t\t\t\t       parent, pslot + 1, &right);\n\t\tif (wret) {\n\t\t\tret = wret;\n\t\t\tgoto enospc;\n\t\t}\n\t}\n\n\t/* first, try to make some room in the middle buffer */\n\tif (left) {\n\t\torig_slot += btrfs_header_nritems(left);\n\t\twret = push_node_left(trans, root, left, mid, 1);\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t}\n\n\t/*\n\t * then try to empty the right most buffer into the middle\n\t */\n\tif (right) {\n\t\twret = push_node_left(trans, root, mid, right, 1);\n\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\tret = wret;\n\t\tif (btrfs_header_nritems(right) == 0) {\n\t\t\tclean_tree_block(trans, root, right);\n\t\t\tbtrfs_tree_unlock(right);\n\t\t\tdel_ptr(root, path, level + 1, pslot + 1);\n\t\t\troot_sub_used(root, right->len);\n\t\t\tbtrfs_free_tree_block(trans, root, right, 0, 1);\n\t\t\tfree_extent_buffer_stale(right);\n\t\t\tright = NULL;\n\t\t} else {\n\t\t\tstruct btrfs_disk_key right_key;\n\t\t\tbtrfs_node_key(right, &right_key, 0);\n\t\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t\t  pslot + 1, 0);\n\t\t\tbtrfs_set_node_key(parent, &right_key, pslot + 1);\n\t\t\tbtrfs_mark_buffer_dirty(parent);\n\t\t}\n\t}\n\tif (btrfs_header_nritems(mid) == 1) {\n\t\t/*\n\t\t * we're not allowed to leave a node with one item in the\n\t\t * tree during a delete.  A deletion from lower in the tree\n\t\t * could try to delete the only pointer in this node.\n\t\t * So, pull some keys from the left.\n\t\t * There has to be a left pointer at this point because\n\t\t * otherwise we would have pulled some pointers from the\n\t\t * right\n\t\t */\n\t\tif (!left) {\n\t\t\tret = -EROFS;\n\t\t\tbtrfs_std_error(root->fs_info, ret);\n\t\t\tgoto enospc;\n\t\t}\n\t\twret = balance_node_right(trans, root, mid, left);\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto enospc;\n\t\t}\n\t\tif (wret == 1) {\n\t\t\twret = push_node_left(trans, root, left, mid, 1);\n\t\t\tif (wret < 0)\n\t\t\t\tret = wret;\n\t\t}\n\t\tBUG_ON(wret == 1);\n\t}\n\tif (btrfs_header_nritems(mid) == 0) {\n\t\tclean_tree_block(trans, root, mid);\n\t\tbtrfs_tree_unlock(mid);\n\t\tdel_ptr(root, path, level + 1, pslot);\n\t\troot_sub_used(root, mid->len);\n\t\tbtrfs_free_tree_block(trans, root, mid, 0, 1);\n\t\tfree_extent_buffer_stale(mid);\n\t\tmid = NULL;\n\t} else {\n\t\t/* update the parent key to reflect our changes */\n\t\tstruct btrfs_disk_key mid_key;\n\t\tbtrfs_node_key(mid, &mid_key, 0);\n\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t  pslot, 0);\n\t\tbtrfs_set_node_key(parent, &mid_key, pslot);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\t}\n\n\t/* update the path */\n\tif (left) {\n\t\tif (btrfs_header_nritems(left) > orig_slot) {\n\t\t\textent_buffer_get(left);\n\t\t\t/* left was locked after cow */\n\t\t\tpath->nodes[level] = left;\n\t\t\tpath->slots[level + 1] -= 1;\n\t\t\tpath->slots[level] = orig_slot;\n\t\t\tif (mid) {\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t}\n\t\t} else {\n\t\t\torig_slot -= btrfs_header_nritems(left);\n\t\t\tpath->slots[level] = orig_slot;\n\t\t}\n\t}\n\t/* double check we haven't messed things up */\n\tif (orig_ptr !=\n\t    btrfs_node_blockptr(path->nodes[level], path->slots[level]))\n\t\tBUG();\nenospc:\n\tif (right) {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\tif (left) {\n\t\tif (path->nodes[level] != left)\n\t\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reada_for_balance",
          "args": [
            "root",
            "p",
            "level"
          ],
          "line": 2560
        },
        "resolved": true,
        "details": {
          "function_name": "reada_for_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2301-2345",
          "snippet": "static noinline void reada_for_balance(struct btrfs_root *root,\n\t\t\t\t       struct btrfs_path *path, int level)\n{\n\tint slot;\n\tint nritems;\n\tstruct extent_buffer *parent;\n\tstruct extent_buffer *eb;\n\tu64 gen;\n\tu64 block1 = 0;\n\tu64 block2 = 0;\n\n\tparent = path->nodes[level + 1];\n\tif (!parent)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(parent);\n\tslot = path->slots[level + 1];\n\n\tif (slot > 0) {\n\t\tblock1 = btrfs_node_blockptr(parent, slot - 1);\n\t\tgen = btrfs_node_ptr_generation(parent, slot - 1);\n\t\teb = btrfs_find_tree_block(root, block1);\n\t\t/*\n\t\t * if we get -eagain from btrfs_buffer_uptodate, we\n\t\t * don't want to return eagain here.  That will loop\n\t\t * forever\n\t\t */\n\t\tif (eb && btrfs_buffer_uptodate(eb, gen, 1) != 0)\n\t\t\tblock1 = 0;\n\t\tfree_extent_buffer(eb);\n\t}\n\tif (slot + 1 < nritems) {\n\t\tblock2 = btrfs_node_blockptr(parent, slot + 1);\n\t\tgen = btrfs_node_ptr_generation(parent, slot + 1);\n\t\teb = btrfs_find_tree_block(root, block2);\n\t\tif (eb && btrfs_buffer_uptodate(eb, gen, 1) != 0)\n\t\t\tblock2 = 0;\n\t\tfree_extent_buffer(eb);\n\t}\n\n\tif (block1)\n\t\treadahead_tree_block(root, block1);\n\tif (block2)\n\t\treadahead_tree_block(root, block2);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline void reada_for_balance(struct btrfs_root *root,\n\t\t\t\t       struct btrfs_path *path, int level)\n{\n\tint slot;\n\tint nritems;\n\tstruct extent_buffer *parent;\n\tstruct extent_buffer *eb;\n\tu64 gen;\n\tu64 block1 = 0;\n\tu64 block2 = 0;\n\n\tparent = path->nodes[level + 1];\n\tif (!parent)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(parent);\n\tslot = path->slots[level + 1];\n\n\tif (slot > 0) {\n\t\tblock1 = btrfs_node_blockptr(parent, slot - 1);\n\t\tgen = btrfs_node_ptr_generation(parent, slot - 1);\n\t\teb = btrfs_find_tree_block(root, block1);\n\t\t/*\n\t\t * if we get -eagain from btrfs_buffer_uptodate, we\n\t\t * don't want to return eagain here.  That will loop\n\t\t * forever\n\t\t */\n\t\tif (eb && btrfs_buffer_uptodate(eb, gen, 1) != 0)\n\t\t\tblock1 = 0;\n\t\tfree_extent_buffer(eb);\n\t}\n\tif (slot + 1 < nritems) {\n\t\tblock2 = btrfs_node_blockptr(parent, slot + 1);\n\t\tgen = btrfs_node_ptr_generation(parent, slot + 1);\n\t\teb = btrfs_find_tree_block(root, block2);\n\t\tif (eb && btrfs_buffer_uptodate(eb, gen, 1) != 0)\n\t\t\tblock2 = 0;\n\t\tfree_extent_buffer(eb);\n\t}\n\n\tif (block1)\n\t\treadahead_tree_block(root, block1);\n\tif (block2)\n\t\treadahead_tree_block(root, block2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "p"
          ],
          "line": 2559
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_NODEPTRS_PER_BLOCK",
          "args": [
            "root"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "b"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sret > 0"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_node",
          "args": [
            "trans",
            "root",
            "p",
            "level"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "split_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3441-3532",
          "snippet": "static noinline int split_node(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *split;\n\tstruct btrfs_disk_key disk_key;\n\tint mid;\n\tint ret;\n\tu32 c_nritems;\n\n\tc = path->nodes[level];\n\tWARN_ON(btrfs_header_generation(c) != trans->transid);\n\tif (c == root->node) {\n\t\t/*\n\t\t * trying to split the root, lets make a new one\n\t\t *\n\t\t * tree mod log: We don't log_removal old root in\n\t\t * insert_new_root, because that root buffer will be kept as a\n\t\t * normal node. We are going to log removal of half of the\n\t\t * elements below with tree_mod_log_eb_copy. We're holding a\n\t\t * tree lock on the buffer, which is why we cannot race with\n\t\t * other tree_mod_log users.\n\t\t */\n\t\tret = insert_new_root(trans, root, path, level + 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = push_nodes_for_insert(trans, root, path, level);\n\t\tc = path->nodes[level];\n\t\tif (!ret && btrfs_header_nritems(c) <\n\t\t    BTRFS_NODEPTRS_PER_BLOCK(root) - 3)\n\t\t\treturn 0;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tc_nritems = btrfs_header_nritems(c);\n\tmid = (c_nritems + 1) / 2;\n\tbtrfs_node_key(c, &disk_key, mid);\n\n\tsplit = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t&disk_key, level, c->start, 0);\n\tif (IS_ERR(split))\n\t\treturn PTR_ERR(split);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(split, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_level(split, btrfs_header_level(c));\n\tbtrfs_set_header_bytenr(split, split->start);\n\tbtrfs_set_header_generation(split, trans->transid);\n\tbtrfs_set_header_backref_rev(split, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(split, root->root_key.objectid);\n\twrite_extent_buffer(split, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\twrite_extent_buffer(split, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(split),\n\t\t\t    BTRFS_UUID_SIZE);\n\n\tret = tree_mod_log_eb_copy(root->fs_info, split, c, 0,\n\t\t\t\t   mid, c_nritems - mid);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(split, c,\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   btrfs_node_key_ptr_offset(mid),\n\t\t\t   (c_nritems - mid) * sizeof(struct btrfs_key_ptr));\n\tbtrfs_set_header_nritems(split, c_nritems - mid);\n\tbtrfs_set_header_nritems(c, mid);\n\tret = 0;\n\n\tbtrfs_mark_buffer_dirty(c);\n\tbtrfs_mark_buffer_dirty(split);\n\n\tinsert_ptr(trans, root, path, &disk_key, split->start,\n\t\t   path->slots[level + 1] + 1, level + 1);\n\n\tif (path->slots[level] >= mid) {\n\t\tpath->slots[level] -= mid;\n\t\tbtrfs_tree_unlock(c);\n\t\tfree_extent_buffer(c);\n\t\tpath->nodes[level] = split;\n\t\tpath->slots[level + 1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(split);\n\t\tfree_extent_buffer(split);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline int split_node(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root,\n\t\t\t       struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *split;\n\tstruct btrfs_disk_key disk_key;\n\tint mid;\n\tint ret;\n\tu32 c_nritems;\n\n\tc = path->nodes[level];\n\tWARN_ON(btrfs_header_generation(c) != trans->transid);\n\tif (c == root->node) {\n\t\t/*\n\t\t * trying to split the root, lets make a new one\n\t\t *\n\t\t * tree mod log: We don't log_removal old root in\n\t\t * insert_new_root, because that root buffer will be kept as a\n\t\t * normal node. We are going to log removal of half of the\n\t\t * elements below with tree_mod_log_eb_copy. We're holding a\n\t\t * tree lock on the buffer, which is why we cannot race with\n\t\t * other tree_mod_log users.\n\t\t */\n\t\tret = insert_new_root(trans, root, path, level + 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = push_nodes_for_insert(trans, root, path, level);\n\t\tc = path->nodes[level];\n\t\tif (!ret && btrfs_header_nritems(c) <\n\t\t    BTRFS_NODEPTRS_PER_BLOCK(root) - 3)\n\t\t\treturn 0;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tc_nritems = btrfs_header_nritems(c);\n\tmid = (c_nritems + 1) / 2;\n\tbtrfs_node_key(c, &disk_key, mid);\n\n\tsplit = btrfs_alloc_tree_block(trans, root, 0, root->root_key.objectid,\n\t\t\t&disk_key, level, c->start, 0);\n\tif (IS_ERR(split))\n\t\treturn PTR_ERR(split);\n\n\troot_add_used(root, root->nodesize);\n\n\tmemset_extent_buffer(split, 0, 0, sizeof(struct btrfs_header));\n\tbtrfs_set_header_level(split, btrfs_header_level(c));\n\tbtrfs_set_header_bytenr(split, split->start);\n\tbtrfs_set_header_generation(split, trans->transid);\n\tbtrfs_set_header_backref_rev(split, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_set_header_owner(split, root->root_key.objectid);\n\twrite_extent_buffer(split, root->fs_info->fsid,\n\t\t\t    btrfs_header_fsid(), BTRFS_FSID_SIZE);\n\twrite_extent_buffer(split, root->fs_info->chunk_tree_uuid,\n\t\t\t    btrfs_header_chunk_tree_uuid(split),\n\t\t\t    BTRFS_UUID_SIZE);\n\n\tret = tree_mod_log_eb_copy(root->fs_info, split, c, 0,\n\t\t\t\t   mid, c_nritems - mid);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(split, c,\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   btrfs_node_key_ptr_offset(mid),\n\t\t\t   (c_nritems - mid) * sizeof(struct btrfs_key_ptr));\n\tbtrfs_set_header_nritems(split, c_nritems - mid);\n\tbtrfs_set_header_nritems(c, mid);\n\tret = 0;\n\n\tbtrfs_mark_buffer_dirty(c);\n\tbtrfs_mark_buffer_dirty(split);\n\n\tinsert_ptr(trans, root, path, &disk_key, split->start,\n\t\t   path->slots[level + 1] + 1, level + 1);\n\n\tif (path->slots[level] >= mid) {\n\t\tpath->slots[level] -= mid;\n\t\tbtrfs_tree_unlock(c);\n\t\tfree_extent_buffer(c);\n\t\tpath->nodes[level] = split;\n\t\tpath->slots[level + 1] += 1;\n\t} else {\n\t\tbtrfs_tree_unlock(split);\n\t\tfree_extent_buffer(split);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_NODEPTRS_PER_BLOCK",
          "args": [
            "root"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "b"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic int\nsetup_nodes_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer *b, int level, int ins_len,\n\t\t       int *write_lock_level)\n{\n\tint ret;\n\tif ((p->search_for_split || ins_len > 0) && btrfs_header_nritems(b) >=\n\t    BTRFS_NODEPTRS_PER_BLOCK(root) - 3) {\n\t\tint sret;\n\n\t\tif (*write_lock_level < level + 1) {\n\t\t\t*write_lock_level = level + 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_set_path_blocking(p);\n\t\treada_for_balance(root, p, level);\n\t\tsret = split_node(trans, root, p, level);\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\tBUG_ON(sret > 0);\n\t\tif (sret) {\n\t\t\tret = sret;\n\t\t\tgoto done;\n\t\t}\n\t\tb = p->nodes[level];\n\t} else if (ins_len < 0 && btrfs_header_nritems(b) <\n\t\t   BTRFS_NODEPTRS_PER_BLOCK(root) / 2) {\n\t\tint sret;\n\n\t\tif (*write_lock_level < level + 1) {\n\t\t\t*write_lock_level = level + 1;\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\n\t\tbtrfs_set_path_blocking(p);\n\t\treada_for_balance(root, p, level);\n\t\tsret = balance_level(trans, root, p, level);\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\tif (sret) {\n\t\t\tret = sret;\n\t\t\tgoto done;\n\t\t}\n\t\tb = p->nodes[level];\n\t\tif (!b) {\n\t\t\tbtrfs_release_path(p);\n\t\t\tgoto again;\n\t\t}\n\t\tBUG_ON(btrfs_header_nritems(b) == 1);\n\t}\n\treturn 0;\n\nagain:\n\tret = -EAGAIN;\ndone:\n\treturn ret;\n}"
  },
  {
    "function_name": "read_block_for_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "2438-2510",
    "snippet": "static int\nread_block_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer **eb_ret, int level, int slot,\n\t\t       struct btrfs_key *key, u64 time_seq)\n{\n\tu64 blocknr;\n\tu64 gen;\n\tstruct extent_buffer *b = *eb_ret;\n\tstruct extent_buffer *tmp;\n\tint ret;\n\n\tblocknr = btrfs_node_blockptr(b, slot);\n\tgen = btrfs_node_ptr_generation(b, slot);\n\n\ttmp = btrfs_find_tree_block(root, blocknr);\n\tif (tmp) {\n\t\t/* first we do an atomic uptodate check */\n\t\tif (btrfs_buffer_uptodate(tmp, gen, 1) > 0) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* the pages were up to date, but we failed\n\t\t * the generation number check.  Do a full\n\t\t * read for the generation number that is correct.\n\t\t * We must do this without dropping locks so\n\t\t * we can trust our generation number\n\t\t */\n\t\tbtrfs_set_path_blocking(p);\n\n\t\t/* now we're allowed to do a blocking uptodate check */\n\t\tret = btrfs_read_buffer(tmp, gen);\n\t\tif (!ret) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(tmp);\n\t\tbtrfs_release_path(p);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * reduce lock contention at high levels\n\t * of the btree by dropping locks before\n\t * we read.  Don't release the lock on the current\n\t * level because we need to walk this node to figure\n\t * out which blocks to read.\n\t */\n\tbtrfs_unlock_up_safe(p, level + 1);\n\tbtrfs_set_path_blocking(p);\n\n\tfree_extent_buffer(tmp);\n\tif (p->reada)\n\t\treada_for_search(root, p, level, slot, key->objectid);\n\n\tbtrfs_release_path(p);\n\n\tret = -EAGAIN;\n\ttmp = read_tree_block(root, blocknr, 0);\n\tif (tmp) {\n\t\t/*\n\t\t * If the read above didn't mark this buffer up to date,\n\t\t * it will never end up being up to date.  Set ret to EIO now\n\t\t * and give up so that our caller doesn't loop forever\n\t\t * on our EAGAINs.\n\t\t */\n\t\tif (!btrfs_buffer_uptodate(tmp, 0, 0))\n\t\t\tret = -EIO;\n\t\tfree_extent_buffer(tmp);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "tmp"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_buffer_uptodate",
          "args": [
            "tmp",
            "0",
            "0"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3741-3756",
          "snippet": "int btrfs_buffer_uptodate(struct extent_buffer *buf, u64 parent_transid,\n\t\t\t  int atomic)\n{\n\tint ret;\n\tstruct inode *btree_inode = buf->pages[0]->mapping->host;\n\n\tret = extent_buffer_uptodate(buf);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = verify_parent_transid(&BTRFS_I(btree_inode)->io_tree, buf,\n\t\t\t\t    parent_transid, atomic);\n\tif (ret == -EAGAIN)\n\t\treturn ret;\n\treturn !ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_buffer_uptodate(struct extent_buffer *buf, u64 parent_transid,\n\t\t\t  int atomic)\n{\n\tint ret;\n\tstruct inode *btree_inode = buf->pages[0]->mapping->host;\n\n\tret = extent_buffer_uptodate(buf);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = verify_parent_transid(&BTRFS_I(btree_inode)->io_tree, buf,\n\t\t\t\t    parent_transid, atomic);\n\tif (ret == -EAGAIN)\n\t\treturn ret;\n\treturn !ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_block",
          "args": [
            "root",
            "blocknr",
            "0"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1149-1166",
          "snippet": "struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "p"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reada_for_search",
          "args": [
            "root",
            "p",
            "level",
            "slot",
            "key->objectid"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "reada_for_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2235-2299",
          "snippet": "static void reada_for_search(struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     int level, int slot, u64 objectid)\n{\n\tstruct extent_buffer *node;\n\tstruct btrfs_disk_key disk_key;\n\tu32 nritems;\n\tu64 search;\n\tu64 target;\n\tu64 nread = 0;\n\tu64 gen;\n\tint direction = path->reada;\n\tstruct extent_buffer *eb;\n\tu32 nr;\n\tu32 blocksize;\n\tu32 nscan = 0;\n\n\tif (level != 1)\n\t\treturn;\n\n\tif (!path->nodes[level])\n\t\treturn;\n\n\tnode = path->nodes[level];\n\n\tsearch = btrfs_node_blockptr(node, slot);\n\tblocksize = root->nodesize;\n\teb = btrfs_find_tree_block(root, search);\n\tif (eb) {\n\t\tfree_extent_buffer(eb);\n\t\treturn;\n\t}\n\n\ttarget = search;\n\n\tnritems = btrfs_header_nritems(node);\n\tnr = slot;\n\n\twhile (1) {\n\t\tif (direction < 0) {\n\t\t\tif (nr == 0)\n\t\t\t\tbreak;\n\t\t\tnr--;\n\t\t} else if (direction > 0) {\n\t\t\tnr++;\n\t\t\tif (nr >= nritems)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (path->reada < 0 && objectid) {\n\t\t\tbtrfs_node_key(node, &disk_key, nr);\n\t\t\tif (btrfs_disk_key_objectid(&disk_key) != objectid)\n\t\t\t\tbreak;\n\t\t}\n\t\tsearch = btrfs_node_blockptr(node, nr);\n\t\tif ((search <= target && target - search <= 65536) ||\n\t\t    (search > target && search - target <= 65536)) {\n\t\t\tgen = btrfs_node_ptr_generation(node, nr);\n\t\t\treadahead_tree_block(root, search);\n\t\t\tnread += blocksize;\n\t\t}\n\t\tnscan++;\n\t\tif ((nread > 65536 || nscan > 32))\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic void reada_for_search(struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     int level, int slot, u64 objectid)\n{\n\tstruct extent_buffer *node;\n\tstruct btrfs_disk_key disk_key;\n\tu32 nritems;\n\tu64 search;\n\tu64 target;\n\tu64 nread = 0;\n\tu64 gen;\n\tint direction = path->reada;\n\tstruct extent_buffer *eb;\n\tu32 nr;\n\tu32 blocksize;\n\tu32 nscan = 0;\n\n\tif (level != 1)\n\t\treturn;\n\n\tif (!path->nodes[level])\n\t\treturn;\n\n\tnode = path->nodes[level];\n\n\tsearch = btrfs_node_blockptr(node, slot);\n\tblocksize = root->nodesize;\n\teb = btrfs_find_tree_block(root, search);\n\tif (eb) {\n\t\tfree_extent_buffer(eb);\n\t\treturn;\n\t}\n\n\ttarget = search;\n\n\tnritems = btrfs_header_nritems(node);\n\tnr = slot;\n\n\twhile (1) {\n\t\tif (direction < 0) {\n\t\t\tif (nr == 0)\n\t\t\t\tbreak;\n\t\t\tnr--;\n\t\t} else if (direction > 0) {\n\t\t\tnr++;\n\t\t\tif (nr >= nritems)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (path->reada < 0 && objectid) {\n\t\t\tbtrfs_node_key(node, &disk_key, nr);\n\t\t\tif (btrfs_disk_key_objectid(&disk_key) != objectid)\n\t\t\t\tbreak;\n\t\t}\n\t\tsearch = btrfs_node_blockptr(node, nr);\n\t\tif ((search <= target && target - search <= 65536) ||\n\t\t    (search > target && search - target <= 65536)) {\n\t\t\tgen = btrfs_node_ptr_generation(node, nr);\n\t\t\treadahead_tree_block(root, search);\n\t\t\tnread += blocksize;\n\t\t}\n\t\tnscan++;\n\t\tif ((nread > 65536 || nscan > 32))\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "p"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_unlock_up_safe",
          "args": [
            "p",
            "level + 1"
          ],
          "line": 2487
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_unlock_up_safe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2413-2428",
          "snippet": "noinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nnoinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_read_buffer",
          "args": [
            "tmp",
            "gen"
          ],
          "line": 2470
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3831-3835",
          "snippet": "int btrfs_read_buffer(struct extent_buffer *buf, u64 parent_transid)\n{\n\tstruct btrfs_root *root = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\treturn btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_read_buffer(struct extent_buffer *buf, u64 parent_transid)\n{\n\tstruct btrfs_root *root = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\treturn btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_tree_block",
          "args": [
            "root",
            "blocknr"
          ],
          "line": 2453
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1122-1126",
          "snippet": "struct extent_buffer *btrfs_find_tree_block(struct btrfs_root *root,\n\t\t\t\t\t    u64 bytenr)\n{\n\treturn find_extent_buffer(root->fs_info, bytenr);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *btrfs_find_tree_block(struct btrfs_root *root,\n\t\t\t\t\t    u64 bytenr)\n{\n\treturn find_extent_buffer(root->fs_info, bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "b",
            "slot"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "b",
            "slot"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic int\nread_block_for_search(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct btrfs_path *p,\n\t\t       struct extent_buffer **eb_ret, int level, int slot,\n\t\t       struct btrfs_key *key, u64 time_seq)\n{\n\tu64 blocknr;\n\tu64 gen;\n\tstruct extent_buffer *b = *eb_ret;\n\tstruct extent_buffer *tmp;\n\tint ret;\n\n\tblocknr = btrfs_node_blockptr(b, slot);\n\tgen = btrfs_node_ptr_generation(b, slot);\n\n\ttmp = btrfs_find_tree_block(root, blocknr);\n\tif (tmp) {\n\t\t/* first we do an atomic uptodate check */\n\t\tif (btrfs_buffer_uptodate(tmp, gen, 1) > 0) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\n\t\t/* the pages were up to date, but we failed\n\t\t * the generation number check.  Do a full\n\t\t * read for the generation number that is correct.\n\t\t * We must do this without dropping locks so\n\t\t * we can trust our generation number\n\t\t */\n\t\tbtrfs_set_path_blocking(p);\n\n\t\t/* now we're allowed to do a blocking uptodate check */\n\t\tret = btrfs_read_buffer(tmp, gen);\n\t\tif (!ret) {\n\t\t\t*eb_ret = tmp;\n\t\t\treturn 0;\n\t\t}\n\t\tfree_extent_buffer(tmp);\n\t\tbtrfs_release_path(p);\n\t\treturn -EIO;\n\t}\n\n\t/*\n\t * reduce lock contention at high levels\n\t * of the btree by dropping locks before\n\t * we read.  Don't release the lock on the current\n\t * level because we need to walk this node to figure\n\t * out which blocks to read.\n\t */\n\tbtrfs_unlock_up_safe(p, level + 1);\n\tbtrfs_set_path_blocking(p);\n\n\tfree_extent_buffer(tmp);\n\tif (p->reada)\n\t\treada_for_search(root, p, level, slot, key->objectid);\n\n\tbtrfs_release_path(p);\n\n\tret = -EAGAIN;\n\ttmp = read_tree_block(root, blocknr, 0);\n\tif (tmp) {\n\t\t/*\n\t\t * If the read above didn't mark this buffer up to date,\n\t\t * it will never end up being up to date.  Set ret to EIO now\n\t\t * and give up so that our caller doesn't loop forever\n\t\t * on our EAGAINs.\n\t\t */\n\t\tif (!btrfs_buffer_uptodate(tmp, 0, 0))\n\t\t\tret = -EIO;\n\t\tfree_extent_buffer(tmp);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_unlock_up_safe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "2413-2428",
    "snippet": "noinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_tree_unlock_rw",
          "args": [
            "path->nodes[i]",
            "path->locks[i]"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "41-51",
          "snippet": "static inline void btrfs_tree_unlock_rw(struct extent_buffer *eb, int rw)\n{\n\tif (rw == BTRFS_WRITE_LOCK || rw == BTRFS_WRITE_LOCK_BLOCKING)\n\t\tbtrfs_tree_unlock(eb);\n\telse if (rw == BTRFS_READ_LOCK_BLOCKING)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\telse if (rw == BTRFS_READ_LOCK)\n\t\tbtrfs_tree_read_unlock(eb);\n\telse\n\t\tBUG();\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_READ_LOCK_BLOCKING 4",
            "#define BTRFS_WRITE_LOCK_BLOCKING 3",
            "#define BTRFS_READ_LOCK 2",
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_READ_LOCK_BLOCKING 4\n#define BTRFS_WRITE_LOCK_BLOCKING 3\n#define BTRFS_READ_LOCK 2\n#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_tree_unlock_rw(struct extent_buffer *eb, int rw)\n{\n\tif (rw == BTRFS_WRITE_LOCK || rw == BTRFS_WRITE_LOCK_BLOCKING)\n\t\tbtrfs_tree_unlock(eb);\n\telse if (rw == BTRFS_READ_LOCK_BLOCKING)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\telse if (rw == BTRFS_READ_LOCK)\n\t\tbtrfs_tree_read_unlock(eb);\n\telse\n\t\tBUG();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nnoinline void btrfs_unlock_up_safe(struct btrfs_path *path, int level)\n{\n\tint i;\n\n\tif (path->keep_locks)\n\t\treturn;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tcontinue;\n\t\tif (!path->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_tree_unlock_rw(path->nodes[i], path->locks[i]);\n\t\tpath->locks[i] = 0;\n\t}\n}"
  },
  {
    "function_name": "unlock_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "2361-2402",
    "snippet": "static noinline void unlock_up(struct btrfs_path *path, int level,\n\t\t\t       int lowest_unlock, int min_write_lock_level,\n\t\t\t       int *write_lock_level)\n{\n\tint i;\n\tint skip_level = level;\n\tint no_skips = 0;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tif (!path->locks[i])\n\t\t\tbreak;\n\t\tif (!no_skips && path->slots[i] == 0) {\n\t\t\tskip_level = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!no_skips && path->keep_locks) {\n\t\t\tu32 nritems;\n\t\t\tt = path->nodes[i];\n\t\t\tnritems = btrfs_header_nritems(t);\n\t\t\tif (nritems < 1 || path->slots[i] >= nritems - 1) {\n\t\t\t\tskip_level = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (skip_level < i && i >= lowest_unlock)\n\t\t\tno_skips = 1;\n\n\t\tt = path->nodes[i];\n\t\tif (i >= lowest_unlock && i > skip_level && path->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(t, path->locks[i]);\n\t\t\tpath->locks[i] = 0;\n\t\t\tif (write_lock_level &&\n\t\t\t    i > min_write_lock_level &&\n\t\t\t    i <= *write_lock_level) {\n\t\t\t\t*write_lock_level = i - 1;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_tree_unlock_rw",
          "args": [
            "t",
            "path->locks[i]"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "41-51",
          "snippet": "static inline void btrfs_tree_unlock_rw(struct extent_buffer *eb, int rw)\n{\n\tif (rw == BTRFS_WRITE_LOCK || rw == BTRFS_WRITE_LOCK_BLOCKING)\n\t\tbtrfs_tree_unlock(eb);\n\telse if (rw == BTRFS_READ_LOCK_BLOCKING)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\telse if (rw == BTRFS_READ_LOCK)\n\t\tbtrfs_tree_read_unlock(eb);\n\telse\n\t\tBUG();\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_READ_LOCK_BLOCKING 4",
            "#define BTRFS_WRITE_LOCK_BLOCKING 3",
            "#define BTRFS_READ_LOCK 2",
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_READ_LOCK_BLOCKING 4\n#define BTRFS_WRITE_LOCK_BLOCKING 3\n#define BTRFS_READ_LOCK 2\n#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_tree_unlock_rw(struct extent_buffer *eb, int rw)\n{\n\tif (rw == BTRFS_WRITE_LOCK || rw == BTRFS_WRITE_LOCK_BLOCKING)\n\t\tbtrfs_tree_unlock(eb);\n\telse if (rw == BTRFS_READ_LOCK_BLOCKING)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\telse if (rw == BTRFS_READ_LOCK)\n\t\tbtrfs_tree_read_unlock(eb);\n\telse\n\t\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "t"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline void unlock_up(struct btrfs_path *path, int level,\n\t\t\t       int lowest_unlock, int min_write_lock_level,\n\t\t\t       int *write_lock_level)\n{\n\tint i;\n\tint skip_level = level;\n\tint no_skips = 0;\n\tstruct extent_buffer *t;\n\n\tfor (i = level; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!path->nodes[i])\n\t\t\tbreak;\n\t\tif (!path->locks[i])\n\t\t\tbreak;\n\t\tif (!no_skips && path->slots[i] == 0) {\n\t\t\tskip_level = i + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!no_skips && path->keep_locks) {\n\t\t\tu32 nritems;\n\t\t\tt = path->nodes[i];\n\t\t\tnritems = btrfs_header_nritems(t);\n\t\t\tif (nritems < 1 || path->slots[i] >= nritems - 1) {\n\t\t\t\tskip_level = i + 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (skip_level < i && i >= lowest_unlock)\n\t\t\tno_skips = 1;\n\n\t\tt = path->nodes[i];\n\t\tif (i >= lowest_unlock && i > skip_level && path->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(t, path->locks[i]);\n\t\t\tpath->locks[i] = 0;\n\t\t\tif (write_lock_level &&\n\t\t\t    i > min_write_lock_level &&\n\t\t\t    i <= *write_lock_level) {\n\t\t\t\t*write_lock_level = i - 1;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "reada_for_balance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "2301-2345",
    "snippet": "static noinline void reada_for_balance(struct btrfs_root *root,\n\t\t\t\t       struct btrfs_path *path, int level)\n{\n\tint slot;\n\tint nritems;\n\tstruct extent_buffer *parent;\n\tstruct extent_buffer *eb;\n\tu64 gen;\n\tu64 block1 = 0;\n\tu64 block2 = 0;\n\n\tparent = path->nodes[level + 1];\n\tif (!parent)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(parent);\n\tslot = path->slots[level + 1];\n\n\tif (slot > 0) {\n\t\tblock1 = btrfs_node_blockptr(parent, slot - 1);\n\t\tgen = btrfs_node_ptr_generation(parent, slot - 1);\n\t\teb = btrfs_find_tree_block(root, block1);\n\t\t/*\n\t\t * if we get -eagain from btrfs_buffer_uptodate, we\n\t\t * don't want to return eagain here.  That will loop\n\t\t * forever\n\t\t */\n\t\tif (eb && btrfs_buffer_uptodate(eb, gen, 1) != 0)\n\t\t\tblock1 = 0;\n\t\tfree_extent_buffer(eb);\n\t}\n\tif (slot + 1 < nritems) {\n\t\tblock2 = btrfs_node_blockptr(parent, slot + 1);\n\t\tgen = btrfs_node_ptr_generation(parent, slot + 1);\n\t\teb = btrfs_find_tree_block(root, block2);\n\t\tif (eb && btrfs_buffer_uptodate(eb, gen, 1) != 0)\n\t\t\tblock2 = 0;\n\t\tfree_extent_buffer(eb);\n\t}\n\n\tif (block1)\n\t\treadahead_tree_block(root, block1);\n\tif (block2)\n\t\treadahead_tree_block(root, block2);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "readahead_tree_block",
          "args": [
            "root",
            "block2"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "readahead_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1077-1088",
          "snippet": "void readahead_tree_block(struct btrfs_root *root, u64 bytenr)\n{\n\tstruct extent_buffer *buf = NULL;\n\tstruct inode *btree_inode = root->fs_info->btree_inode;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn;\n\tread_extent_buffer_pages(&BTRFS_I(btree_inode)->io_tree,\n\t\t\t\t buf, 0, WAIT_NONE, btree_get_extent, 0);\n\tfree_extent_buffer(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid readahead_tree_block(struct btrfs_root *root, u64 bytenr)\n{\n\tstruct extent_buffer *buf = NULL;\n\tstruct inode *btree_inode = root->fs_info->btree_inode;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn;\n\tread_extent_buffer_pages(&BTRFS_I(btree_inode)->io_tree,\n\t\t\t\t buf, 0, WAIT_NONE, btree_get_extent, 0);\n\tfree_extent_buffer(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_buffer_uptodate",
          "args": [
            "eb",
            "gen",
            "1"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3741-3756",
          "snippet": "int btrfs_buffer_uptodate(struct extent_buffer *buf, u64 parent_transid,\n\t\t\t  int atomic)\n{\n\tint ret;\n\tstruct inode *btree_inode = buf->pages[0]->mapping->host;\n\n\tret = extent_buffer_uptodate(buf);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = verify_parent_transid(&BTRFS_I(btree_inode)->io_tree, buf,\n\t\t\t\t    parent_transid, atomic);\n\tif (ret == -EAGAIN)\n\t\treturn ret;\n\treturn !ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_buffer_uptodate(struct extent_buffer *buf, u64 parent_transid,\n\t\t\t  int atomic)\n{\n\tint ret;\n\tstruct inode *btree_inode = buf->pages[0]->mapping->host;\n\n\tret = extent_buffer_uptodate(buf);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = verify_parent_transid(&BTRFS_I(btree_inode)->io_tree, buf,\n\t\t\t\t    parent_transid, atomic);\n\tif (ret == -EAGAIN)\n\t\treturn ret;\n\treturn !ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_tree_block",
          "args": [
            "root",
            "block2"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1122-1126",
          "snippet": "struct extent_buffer *btrfs_find_tree_block(struct btrfs_root *root,\n\t\t\t\t\t    u64 bytenr)\n{\n\treturn find_extent_buffer(root->fs_info, bytenr);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *btrfs_find_tree_block(struct btrfs_root *root,\n\t\t\t\t\t    u64 bytenr)\n{\n\treturn find_extent_buffer(root->fs_info, bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "parent",
            "slot + 1"
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "parent",
            "slot + 1"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "parent"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline void reada_for_balance(struct btrfs_root *root,\n\t\t\t\t       struct btrfs_path *path, int level)\n{\n\tint slot;\n\tint nritems;\n\tstruct extent_buffer *parent;\n\tstruct extent_buffer *eb;\n\tu64 gen;\n\tu64 block1 = 0;\n\tu64 block2 = 0;\n\n\tparent = path->nodes[level + 1];\n\tif (!parent)\n\t\treturn;\n\n\tnritems = btrfs_header_nritems(parent);\n\tslot = path->slots[level + 1];\n\n\tif (slot > 0) {\n\t\tblock1 = btrfs_node_blockptr(parent, slot - 1);\n\t\tgen = btrfs_node_ptr_generation(parent, slot - 1);\n\t\teb = btrfs_find_tree_block(root, block1);\n\t\t/*\n\t\t * if we get -eagain from btrfs_buffer_uptodate, we\n\t\t * don't want to return eagain here.  That will loop\n\t\t * forever\n\t\t */\n\t\tif (eb && btrfs_buffer_uptodate(eb, gen, 1) != 0)\n\t\t\tblock1 = 0;\n\t\tfree_extent_buffer(eb);\n\t}\n\tif (slot + 1 < nritems) {\n\t\tblock2 = btrfs_node_blockptr(parent, slot + 1);\n\t\tgen = btrfs_node_ptr_generation(parent, slot + 1);\n\t\teb = btrfs_find_tree_block(root, block2);\n\t\tif (eb && btrfs_buffer_uptodate(eb, gen, 1) != 0)\n\t\t\tblock2 = 0;\n\t\tfree_extent_buffer(eb);\n\t}\n\n\tif (block1)\n\t\treadahead_tree_block(root, block1);\n\tif (block2)\n\t\treadahead_tree_block(root, block2);\n}"
  },
  {
    "function_name": "reada_for_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "2235-2299",
    "snippet": "static void reada_for_search(struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     int level, int slot, u64 objectid)\n{\n\tstruct extent_buffer *node;\n\tstruct btrfs_disk_key disk_key;\n\tu32 nritems;\n\tu64 search;\n\tu64 target;\n\tu64 nread = 0;\n\tu64 gen;\n\tint direction = path->reada;\n\tstruct extent_buffer *eb;\n\tu32 nr;\n\tu32 blocksize;\n\tu32 nscan = 0;\n\n\tif (level != 1)\n\t\treturn;\n\n\tif (!path->nodes[level])\n\t\treturn;\n\n\tnode = path->nodes[level];\n\n\tsearch = btrfs_node_blockptr(node, slot);\n\tblocksize = root->nodesize;\n\teb = btrfs_find_tree_block(root, search);\n\tif (eb) {\n\t\tfree_extent_buffer(eb);\n\t\treturn;\n\t}\n\n\ttarget = search;\n\n\tnritems = btrfs_header_nritems(node);\n\tnr = slot;\n\n\twhile (1) {\n\t\tif (direction < 0) {\n\t\t\tif (nr == 0)\n\t\t\t\tbreak;\n\t\t\tnr--;\n\t\t} else if (direction > 0) {\n\t\t\tnr++;\n\t\t\tif (nr >= nritems)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (path->reada < 0 && objectid) {\n\t\t\tbtrfs_node_key(node, &disk_key, nr);\n\t\t\tif (btrfs_disk_key_objectid(&disk_key) != objectid)\n\t\t\t\tbreak;\n\t\t}\n\t\tsearch = btrfs_node_blockptr(node, nr);\n\t\tif ((search <= target && target - search <= 65536) ||\n\t\t    (search > target && search - target <= 65536)) {\n\t\t\tgen = btrfs_node_ptr_generation(node, nr);\n\t\t\treadahead_tree_block(root, search);\n\t\t\tnread += blocksize;\n\t\t}\n\t\tnscan++;\n\t\tif ((nread > 65536 || nscan > 32))\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "readahead_tree_block",
          "args": [
            "root",
            "search"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "readahead_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1077-1088",
          "snippet": "void readahead_tree_block(struct btrfs_root *root, u64 bytenr)\n{\n\tstruct extent_buffer *buf = NULL;\n\tstruct inode *btree_inode = root->fs_info->btree_inode;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn;\n\tread_extent_buffer_pages(&BTRFS_I(btree_inode)->io_tree,\n\t\t\t\t buf, 0, WAIT_NONE, btree_get_extent, 0);\n\tfree_extent_buffer(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid readahead_tree_block(struct btrfs_root *root, u64 bytenr)\n{\n\tstruct extent_buffer *buf = NULL;\n\tstruct inode *btree_inode = root->fs_info->btree_inode;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn;\n\tread_extent_buffer_pages(&BTRFS_I(btree_inode)->io_tree,\n\t\t\t\t buf, 0, WAIT_NONE, btree_get_extent, 0);\n\tfree_extent_buffer(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "node",
            "nr"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "node",
            "nr"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_objectid",
          "args": [
            "&disk_key"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_node_key",
          "args": [
            "node",
            "&disk_key",
            "nr"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "node"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_tree_block",
          "args": [
            "root",
            "search"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1122-1126",
          "snippet": "struct extent_buffer *btrfs_find_tree_block(struct btrfs_root *root,\n\t\t\t\t\t    u64 bytenr)\n{\n\treturn find_extent_buffer(root->fs_info, bytenr);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *btrfs_find_tree_block(struct btrfs_root *root,\n\t\t\t\t\t    u64 bytenr)\n{\n\treturn find_extent_buffer(root->fs_info, bytenr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic void reada_for_search(struct btrfs_root *root,\n\t\t\t     struct btrfs_path *path,\n\t\t\t     int level, int slot, u64 objectid)\n{\n\tstruct extent_buffer *node;\n\tstruct btrfs_disk_key disk_key;\n\tu32 nritems;\n\tu64 search;\n\tu64 target;\n\tu64 nread = 0;\n\tu64 gen;\n\tint direction = path->reada;\n\tstruct extent_buffer *eb;\n\tu32 nr;\n\tu32 blocksize;\n\tu32 nscan = 0;\n\n\tif (level != 1)\n\t\treturn;\n\n\tif (!path->nodes[level])\n\t\treturn;\n\n\tnode = path->nodes[level];\n\n\tsearch = btrfs_node_blockptr(node, slot);\n\tblocksize = root->nodesize;\n\teb = btrfs_find_tree_block(root, search);\n\tif (eb) {\n\t\tfree_extent_buffer(eb);\n\t\treturn;\n\t}\n\n\ttarget = search;\n\n\tnritems = btrfs_header_nritems(node);\n\tnr = slot;\n\n\twhile (1) {\n\t\tif (direction < 0) {\n\t\t\tif (nr == 0)\n\t\t\t\tbreak;\n\t\t\tnr--;\n\t\t} else if (direction > 0) {\n\t\t\tnr++;\n\t\t\tif (nr >= nritems)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (path->reada < 0 && objectid) {\n\t\t\tbtrfs_node_key(node, &disk_key, nr);\n\t\t\tif (btrfs_disk_key_objectid(&disk_key) != objectid)\n\t\t\t\tbreak;\n\t\t}\n\t\tsearch = btrfs_node_blockptr(node, nr);\n\t\tif ((search <= target && target - search <= 65536) ||\n\t\t    (search > target && search - target <= 65536)) {\n\t\t\tgen = btrfs_node_ptr_generation(node, nr);\n\t\t\treadahead_tree_block(root, search);\n\t\t\tnread += blocksize;\n\t\t}\n\t\tnscan++;\n\t\tif ((nread > 65536 || nscan > 32))\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "push_nodes_for_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "2099-2229",
    "snippet": "static noinline int push_nodes_for_insert(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *right = NULL;\n\tstruct extent_buffer *mid;\n\tstruct extent_buffer *left = NULL;\n\tstruct extent_buffer *parent = NULL;\n\tint ret = 0;\n\tint wret;\n\tint pslot;\n\tint orig_slot = path->slots[level];\n\n\tif (level == 0)\n\t\treturn 1;\n\n\tmid = path->nodes[level];\n\tWARN_ON(btrfs_header_generation(mid) != trans->transid);\n\n\tif (level < BTRFS_MAX_LEVEL - 1) {\n\t\tparent = path->nodes[level + 1];\n\t\tpslot = path->slots[level + 1];\n\t}\n\n\tif (!parent)\n\t\treturn 1;\n\n\tleft = read_node_slot(root, parent, pslot - 1);\n\n\t/* first, try to make some room in the middle buffer */\n\tif (left) {\n\t\tu32 left_nr;\n\n\t\tbtrfs_tree_lock(left);\n\t\tbtrfs_set_lock_blocking(left);\n\n\t\tleft_nr = btrfs_header_nritems(left);\n\t\tif (left_nr >= BTRFS_NODEPTRS_PER_BLOCK(root) - 1) {\n\t\t\twret = 1;\n\t\t} else {\n\t\t\tret = btrfs_cow_block(trans, root, left, parent,\n\t\t\t\t\t      pslot - 1, &left);\n\t\t\tif (ret)\n\t\t\t\twret = 1;\n\t\t\telse {\n\t\t\t\twret = push_node_left(trans, root,\n\t\t\t\t\t\t      left, mid, 0);\n\t\t\t}\n\t\t}\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t\tif (wret == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\t\t\torig_slot += left_nr;\n\t\t\tbtrfs_node_key(mid, &disk_key, 0);\n\t\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t\t  pslot, 0);\n\t\t\tbtrfs_set_node_key(parent, &disk_key, pslot);\n\t\t\tbtrfs_mark_buffer_dirty(parent);\n\t\t\tif (btrfs_header_nritems(left) > orig_slot) {\n\t\t\t\tpath->nodes[level] = left;\n\t\t\t\tpath->slots[level + 1] -= 1;\n\t\t\t\tpath->slots[level] = orig_slot;\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t} else {\n\t\t\t\torig_slot -=\n\t\t\t\t\tbtrfs_header_nritems(left);\n\t\t\t\tpath->slots[level] = orig_slot;\n\t\t\t\tbtrfs_tree_unlock(left);\n\t\t\t\tfree_extent_buffer(left);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t}\n\tright = read_node_slot(root, parent, pslot + 1);\n\n\t/*\n\t * then try to empty the right most buffer into the middle\n\t */\n\tif (right) {\n\t\tu32 right_nr;\n\n\t\tbtrfs_tree_lock(right);\n\t\tbtrfs_set_lock_blocking(right);\n\n\t\tright_nr = btrfs_header_nritems(right);\n\t\tif (right_nr >= BTRFS_NODEPTRS_PER_BLOCK(root) - 1) {\n\t\t\twret = 1;\n\t\t} else {\n\t\t\tret = btrfs_cow_block(trans, root, right,\n\t\t\t\t\t      parent, pslot + 1,\n\t\t\t\t\t      &right);\n\t\t\tif (ret)\n\t\t\t\twret = 1;\n\t\t\telse {\n\t\t\t\twret = balance_node_right(trans, root,\n\t\t\t\t\t\t\t  right, mid);\n\t\t\t}\n\t\t}\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t\tif (wret == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_node_key(right, &disk_key, 0);\n\t\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t\t  pslot + 1, 0);\n\t\t\tbtrfs_set_node_key(parent, &disk_key, pslot + 1);\n\t\t\tbtrfs_mark_buffer_dirty(parent);\n\n\t\t\tif (btrfs_header_nritems(mid) <= orig_slot) {\n\t\t\t\tpath->nodes[level] = right;\n\t\t\t\tpath->slots[level + 1] += 1;\n\t\t\t\tpath->slots[level] = orig_slot -\n\t\t\t\t\tbtrfs_header_nritems(mid);\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t} else {\n\t\t\t\tbtrfs_tree_unlock(right);\n\t\t\t\tfree_extent_buffer(right);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "right"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "right"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "mid"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "mid"
          ],
          "line": 2212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "parent"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_key",
          "args": [
            "parent",
            "&disk_key",
            "pslot + 1"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2607-2614",
          "snippet": "static inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_log_set_node_key",
          "args": [
            "root->fs_info",
            "parent",
            "pslot + 1",
            "0"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_set_node_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "881-891",
          "snippet": "static noinline void\ntree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_buffer *eb, int slot, int atomic)\n{\n\tint ret;\n\n\tret = tree_mod_log_insert_key(fs_info, eb, slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE,\n\t\t\t\t\tatomic ? GFP_ATOMIC : GFP_NOFS);\n\tBUG_ON(ret < 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline void\ntree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_buffer *eb, int slot, int atomic)\n{\n\tint ret;\n\n\tret = tree_mod_log_insert_key(fs_info, eb, slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE,\n\t\t\t\t\tatomic ? GFP_ATOMIC : GFP_NOFS);\n\tBUG_ON(ret < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key",
          "args": [
            "right",
            "&disk_key",
            "0"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_node_right",
          "args": [
            "trans",
            "root",
            "right",
            "mid"
          ],
          "line": 2197
        },
        "resolved": true,
        "details": {
          "function_name": "balance_node_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3260-3315",
          "snippet": "static int balance_node_right(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct extent_buffer *dst,\n\t\t\t      struct extent_buffer *src)\n{\n\tint push_items = 0;\n\tint max_push;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (src_nritems < 4)\n\t\treturn 1;\n\n\tmax_push = src_nritems / 2 + 1;\n\t/* don't try to empty the node */\n\tif (max_push >= src_nritems)\n\t\treturn 1;\n\n\tif (max_push < push_items)\n\t\tpush_items = max_push;\n\n\ttree_mod_log_eb_move(root->fs_info, dst, push_items, 0, dst_nritems);\n\tmemmove_extent_buffer(dst, btrfs_node_key_ptr_offset(push_items),\n\t\t\t\t      btrfs_node_key_ptr_offset(0),\n\t\t\t\t      (dst_nritems) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\n\tret = tree_mod_log_eb_copy(root->fs_info, dst, src, 0,\n\t\t\t\t   src_nritems - push_items, push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   btrfs_node_key_ptr_offset(src_nritems - push_items),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\n\tbtrfs_mark_buffer_dirty(src);\n\tbtrfs_mark_buffer_dirty(dst);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic noinline struct;\n\nstatic int balance_node_right(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct extent_buffer *dst,\n\t\t\t      struct extent_buffer *src)\n{\n\tint push_items = 0;\n\tint max_push;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (src_nritems < 4)\n\t\treturn 1;\n\n\tmax_push = src_nritems / 2 + 1;\n\t/* don't try to empty the node */\n\tif (max_push >= src_nritems)\n\t\treturn 1;\n\n\tif (max_push < push_items)\n\t\tpush_items = max_push;\n\n\ttree_mod_log_eb_move(root->fs_info, dst, push_items, 0, dst_nritems);\n\tmemmove_extent_buffer(dst, btrfs_node_key_ptr_offset(push_items),\n\t\t\t\t      btrfs_node_key_ptr_offset(0),\n\t\t\t\t      (dst_nritems) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\n\tret = tree_mod_log_eb_copy(root->fs_info, dst, src, 0,\n\t\t\t\t   src_nritems - push_items, push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   btrfs_node_key_ptr_offset(src_nritems - push_items),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\n\tbtrfs_mark_buffer_dirty(src);\n\tbtrfs_mark_buffer_dirty(dst);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cow_block",
          "args": [
            "trans",
            "root",
            "right",
            "parent",
            "pslot + 1",
            "&right"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1534-1568",
          "snippet": "noinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_NODEPTRS_PER_BLOCK",
          "args": [
            "root"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "right"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "right"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "right"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_node_slot",
          "args": [
            "root",
            "parent",
            "pslot + 1"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "read_node_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1853-1874",
          "snippet": "extent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nextent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "left"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "left"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "push_node_left",
          "args": [
            "trans",
            "root",
            "left",
            "mid",
            "0"
          ],
          "line": 2144
        },
        "resolved": true,
        "details": {
          "function_name": "push_node_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3186-3249",
          "snippet": "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty)\n{\n\tint push_items = 0;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tif (!empty && src_nritems <= 8)\n\t\treturn 1;\n\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (empty) {\n\t\tpush_items = min(src_nritems, push_items);\n\t\tif (push_items < src_nritems) {\n\t\t\t/* leave at least 8 pointers in the node if\n\t\t\t * we aren't going to empty it\n\t\t\t */\n\t\t\tif (src_nritems - push_items < 8) {\n\t\t\t\tif (push_items <= 8)\n\t\t\t\t\treturn 1;\n\t\t\t\tpush_items -= 8;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpush_items = min(src_nritems - 8, push_items);\n\n\tret = tree_mod_log_eb_copy(root->fs_info, dst, src, dst_nritems, 0,\n\t\t\t\t   push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(dst_nritems),\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tif (push_items < src_nritems) {\n\t\t/*\n\t\t * don't call tree_mod_log_eb_move here, key removal was already\n\t\t * fully logged by tree_mod_log_eb_copy above.\n\t\t */\n\t\tmemmove_extent_buffer(src, btrfs_node_key_ptr_offset(0),\n\t\t\t\t      btrfs_node_key_ptr_offset(push_items),\n\t\t\t\t      (src_nritems - push_items) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\t}\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\tbtrfs_mark_buffer_dirty(src);\n\tbtrfs_mark_buffer_dirty(dst);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic noinline struct;\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty)\n{\n\tint push_items = 0;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tif (!empty && src_nritems <= 8)\n\t\treturn 1;\n\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (empty) {\n\t\tpush_items = min(src_nritems, push_items);\n\t\tif (push_items < src_nritems) {\n\t\t\t/* leave at least 8 pointers in the node if\n\t\t\t * we aren't going to empty it\n\t\t\t */\n\t\t\tif (src_nritems - push_items < 8) {\n\t\t\t\tif (push_items <= 8)\n\t\t\t\t\treturn 1;\n\t\t\t\tpush_items -= 8;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpush_items = min(src_nritems - 8, push_items);\n\n\tret = tree_mod_log_eb_copy(root->fs_info, dst, src, dst_nritems, 0,\n\t\t\t\t   push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(dst_nritems),\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tif (push_items < src_nritems) {\n\t\t/*\n\t\t * don't call tree_mod_log_eb_move here, key removal was already\n\t\t * fully logged by tree_mod_log_eb_copy above.\n\t\t */\n\t\tmemmove_extent_buffer(src, btrfs_node_key_ptr_offset(0),\n\t\t\t\t      btrfs_node_key_ptr_offset(push_items),\n\t\t\t\t      (src_nritems - push_items) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\t}\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\tbtrfs_mark_buffer_dirty(src);\n\tbtrfs_mark_buffer_dirty(dst);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_NODEPTRS_PER_BLOCK",
          "args": [
            "root"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "left"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_generation(mid) != trans->transid"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "mid"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic noinline struct;\n\nstatic noinline int push_nodes_for_insert(struct btrfs_trans_handle *trans,\n\t\t\t\t\t  struct btrfs_root *root,\n\t\t\t\t\t  struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *right = NULL;\n\tstruct extent_buffer *mid;\n\tstruct extent_buffer *left = NULL;\n\tstruct extent_buffer *parent = NULL;\n\tint ret = 0;\n\tint wret;\n\tint pslot;\n\tint orig_slot = path->slots[level];\n\n\tif (level == 0)\n\t\treturn 1;\n\n\tmid = path->nodes[level];\n\tWARN_ON(btrfs_header_generation(mid) != trans->transid);\n\n\tif (level < BTRFS_MAX_LEVEL - 1) {\n\t\tparent = path->nodes[level + 1];\n\t\tpslot = path->slots[level + 1];\n\t}\n\n\tif (!parent)\n\t\treturn 1;\n\n\tleft = read_node_slot(root, parent, pslot - 1);\n\n\t/* first, try to make some room in the middle buffer */\n\tif (left) {\n\t\tu32 left_nr;\n\n\t\tbtrfs_tree_lock(left);\n\t\tbtrfs_set_lock_blocking(left);\n\n\t\tleft_nr = btrfs_header_nritems(left);\n\t\tif (left_nr >= BTRFS_NODEPTRS_PER_BLOCK(root) - 1) {\n\t\t\twret = 1;\n\t\t} else {\n\t\t\tret = btrfs_cow_block(trans, root, left, parent,\n\t\t\t\t\t      pslot - 1, &left);\n\t\t\tif (ret)\n\t\t\t\twret = 1;\n\t\t\telse {\n\t\t\t\twret = push_node_left(trans, root,\n\t\t\t\t\t\t      left, mid, 0);\n\t\t\t}\n\t\t}\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t\tif (wret == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\t\t\torig_slot += left_nr;\n\t\t\tbtrfs_node_key(mid, &disk_key, 0);\n\t\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t\t  pslot, 0);\n\t\t\tbtrfs_set_node_key(parent, &disk_key, pslot);\n\t\t\tbtrfs_mark_buffer_dirty(parent);\n\t\t\tif (btrfs_header_nritems(left) > orig_slot) {\n\t\t\t\tpath->nodes[level] = left;\n\t\t\t\tpath->slots[level + 1] -= 1;\n\t\t\t\tpath->slots[level] = orig_slot;\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t} else {\n\t\t\t\torig_slot -=\n\t\t\t\t\tbtrfs_header_nritems(left);\n\t\t\t\tpath->slots[level] = orig_slot;\n\t\t\t\tbtrfs_tree_unlock(left);\n\t\t\t\tfree_extent_buffer(left);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t}\n\tright = read_node_slot(root, parent, pslot + 1);\n\n\t/*\n\t * then try to empty the right most buffer into the middle\n\t */\n\tif (right) {\n\t\tu32 right_nr;\n\n\t\tbtrfs_tree_lock(right);\n\t\tbtrfs_set_lock_blocking(right);\n\n\t\tright_nr = btrfs_header_nritems(right);\n\t\tif (right_nr >= BTRFS_NODEPTRS_PER_BLOCK(root) - 1) {\n\t\t\twret = 1;\n\t\t} else {\n\t\t\tret = btrfs_cow_block(trans, root, right,\n\t\t\t\t\t      parent, pslot + 1,\n\t\t\t\t\t      &right);\n\t\t\tif (ret)\n\t\t\t\twret = 1;\n\t\t\telse {\n\t\t\t\twret = balance_node_right(trans, root,\n\t\t\t\t\t\t\t  right, mid);\n\t\t\t}\n\t\t}\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t\tif (wret == 0) {\n\t\t\tstruct btrfs_disk_key disk_key;\n\n\t\t\tbtrfs_node_key(right, &disk_key, 0);\n\t\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t\t  pslot + 1, 0);\n\t\t\tbtrfs_set_node_key(parent, &disk_key, pslot + 1);\n\t\t\tbtrfs_mark_buffer_dirty(parent);\n\n\t\t\tif (btrfs_header_nritems(mid) <= orig_slot) {\n\t\t\t\tpath->nodes[level] = right;\n\t\t\t\tpath->slots[level + 1] += 1;\n\t\t\t\tpath->slots[level] = orig_slot -\n\t\t\t\t\tbtrfs_header_nritems(mid);\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t} else {\n\t\t\t\tbtrfs_tree_unlock(right);\n\t\t\t\tfree_extent_buffer(right);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "balance_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1881-2093",
    "snippet": "static noinline int balance_level(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *right = NULL;\n\tstruct extent_buffer *mid;\n\tstruct extent_buffer *left = NULL;\n\tstruct extent_buffer *parent = NULL;\n\tint ret = 0;\n\tint wret;\n\tint pslot;\n\tint orig_slot = path->slots[level];\n\tu64 orig_ptr;\n\n\tif (level == 0)\n\t\treturn 0;\n\n\tmid = path->nodes[level];\n\n\tWARN_ON(path->locks[level] != BTRFS_WRITE_LOCK &&\n\t\tpath->locks[level] != BTRFS_WRITE_LOCK_BLOCKING);\n\tWARN_ON(btrfs_header_generation(mid) != trans->transid);\n\n\torig_ptr = btrfs_node_blockptr(mid, orig_slot);\n\n\tif (level < BTRFS_MAX_LEVEL - 1) {\n\t\tparent = path->nodes[level + 1];\n\t\tpslot = path->slots[level + 1];\n\t}\n\n\t/*\n\t * deal with the case where there is only one pointer in the root\n\t * by promoting the node below to a root\n\t */\n\tif (!parent) {\n\t\tstruct extent_buffer *child;\n\n\t\tif (btrfs_header_nritems(mid) != 1)\n\t\t\treturn 0;\n\n\t\t/* promote the child to a root */\n\t\tchild = read_node_slot(root, mid, 0);\n\t\tif (!child) {\n\t\t\tret = -EROFS;\n\t\t\tbtrfs_std_error(root->fs_info, ret);\n\t\t\tgoto enospc;\n\t\t}\n\n\t\tbtrfs_tree_lock(child);\n\t\tbtrfs_set_lock_blocking(child);\n\t\tret = btrfs_cow_block(trans, root, child, mid, 0, &child);\n\t\tif (ret) {\n\t\t\tbtrfs_tree_unlock(child);\n\t\t\tfree_extent_buffer(child);\n\t\t\tgoto enospc;\n\t\t}\n\n\t\ttree_mod_log_set_root_pointer(root, child, 1);\n\t\trcu_assign_pointer(root->node, child);\n\n\t\tadd_root_to_dirty_list(root);\n\t\tbtrfs_tree_unlock(child);\n\n\t\tpath->locks[level] = 0;\n\t\tpath->nodes[level] = NULL;\n\t\tclean_tree_block(trans, root, mid);\n\t\tbtrfs_tree_unlock(mid);\n\t\t/* once for the path */\n\t\tfree_extent_buffer(mid);\n\n\t\troot_sub_used(root, mid->len);\n\t\tbtrfs_free_tree_block(trans, root, mid, 0, 1);\n\t\t/* once for the root ptr */\n\t\tfree_extent_buffer_stale(mid);\n\t\treturn 0;\n\t}\n\tif (btrfs_header_nritems(mid) >\n\t    BTRFS_NODEPTRS_PER_BLOCK(root) / 4)\n\t\treturn 0;\n\n\tleft = read_node_slot(root, parent, pslot - 1);\n\tif (left) {\n\t\tbtrfs_tree_lock(left);\n\t\tbtrfs_set_lock_blocking(left);\n\t\twret = btrfs_cow_block(trans, root, left,\n\t\t\t\t       parent, pslot - 1, &left);\n\t\tif (wret) {\n\t\t\tret = wret;\n\t\t\tgoto enospc;\n\t\t}\n\t}\n\tright = read_node_slot(root, parent, pslot + 1);\n\tif (right) {\n\t\tbtrfs_tree_lock(right);\n\t\tbtrfs_set_lock_blocking(right);\n\t\twret = btrfs_cow_block(trans, root, right,\n\t\t\t\t       parent, pslot + 1, &right);\n\t\tif (wret) {\n\t\t\tret = wret;\n\t\t\tgoto enospc;\n\t\t}\n\t}\n\n\t/* first, try to make some room in the middle buffer */\n\tif (left) {\n\t\torig_slot += btrfs_header_nritems(left);\n\t\twret = push_node_left(trans, root, left, mid, 1);\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t}\n\n\t/*\n\t * then try to empty the right most buffer into the middle\n\t */\n\tif (right) {\n\t\twret = push_node_left(trans, root, mid, right, 1);\n\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\tret = wret;\n\t\tif (btrfs_header_nritems(right) == 0) {\n\t\t\tclean_tree_block(trans, root, right);\n\t\t\tbtrfs_tree_unlock(right);\n\t\t\tdel_ptr(root, path, level + 1, pslot + 1);\n\t\t\troot_sub_used(root, right->len);\n\t\t\tbtrfs_free_tree_block(trans, root, right, 0, 1);\n\t\t\tfree_extent_buffer_stale(right);\n\t\t\tright = NULL;\n\t\t} else {\n\t\t\tstruct btrfs_disk_key right_key;\n\t\t\tbtrfs_node_key(right, &right_key, 0);\n\t\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t\t  pslot + 1, 0);\n\t\t\tbtrfs_set_node_key(parent, &right_key, pslot + 1);\n\t\t\tbtrfs_mark_buffer_dirty(parent);\n\t\t}\n\t}\n\tif (btrfs_header_nritems(mid) == 1) {\n\t\t/*\n\t\t * we're not allowed to leave a node with one item in the\n\t\t * tree during a delete.  A deletion from lower in the tree\n\t\t * could try to delete the only pointer in this node.\n\t\t * So, pull some keys from the left.\n\t\t * There has to be a left pointer at this point because\n\t\t * otherwise we would have pulled some pointers from the\n\t\t * right\n\t\t */\n\t\tif (!left) {\n\t\t\tret = -EROFS;\n\t\t\tbtrfs_std_error(root->fs_info, ret);\n\t\t\tgoto enospc;\n\t\t}\n\t\twret = balance_node_right(trans, root, mid, left);\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto enospc;\n\t\t}\n\t\tif (wret == 1) {\n\t\t\twret = push_node_left(trans, root, left, mid, 1);\n\t\t\tif (wret < 0)\n\t\t\t\tret = wret;\n\t\t}\n\t\tBUG_ON(wret == 1);\n\t}\n\tif (btrfs_header_nritems(mid) == 0) {\n\t\tclean_tree_block(trans, root, mid);\n\t\tbtrfs_tree_unlock(mid);\n\t\tdel_ptr(root, path, level + 1, pslot);\n\t\troot_sub_used(root, mid->len);\n\t\tbtrfs_free_tree_block(trans, root, mid, 0, 1);\n\t\tfree_extent_buffer_stale(mid);\n\t\tmid = NULL;\n\t} else {\n\t\t/* update the parent key to reflect our changes */\n\t\tstruct btrfs_disk_key mid_key;\n\t\tbtrfs_node_key(mid, &mid_key, 0);\n\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t  pslot, 0);\n\t\tbtrfs_set_node_key(parent, &mid_key, pslot);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\t}\n\n\t/* update the path */\n\tif (left) {\n\t\tif (btrfs_header_nritems(left) > orig_slot) {\n\t\t\textent_buffer_get(left);\n\t\t\t/* left was locked after cow */\n\t\t\tpath->nodes[level] = left;\n\t\t\tpath->slots[level + 1] -= 1;\n\t\t\tpath->slots[level] = orig_slot;\n\t\t\tif (mid) {\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t}\n\t\t} else {\n\t\t\torig_slot -= btrfs_header_nritems(left);\n\t\t\tpath->slots[level] = orig_slot;\n\t\t}\n\t}\n\t/* double check we haven't messed things up */\n\tif (orig_ptr !=\n\t    btrfs_node_blockptr(path->nodes[level], path->slots[level]))\n\t\tBUG();\nenospc:\n\tif (right) {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\tif (left) {\n\t\tif (path->nodes[level] != left)\n\t\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "left"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "left"
          ],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "path->nodes[level]",
            "path->slots[level]"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "left"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "left"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "left"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "parent"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_key",
          "args": [
            "parent",
            "&mid_key",
            "pslot"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2607-2614",
          "snippet": "static inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_log_set_node_key",
          "args": [
            "root->fs_info",
            "parent",
            "pslot",
            "0"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_set_node_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "881-891",
          "snippet": "static noinline void\ntree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_buffer *eb, int slot, int atomic)\n{\n\tint ret;\n\n\tret = tree_mod_log_insert_key(fs_info, eb, slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE,\n\t\t\t\t\tatomic ? GFP_ATOMIC : GFP_NOFS);\n\tBUG_ON(ret < 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline void\ntree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_buffer *eb, int slot, int atomic)\n{\n\tint ret;\n\n\tret = tree_mod_log_insert_key(fs_info, eb, slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE,\n\t\t\t\t\tatomic ? GFP_ATOMIC : GFP_NOFS);\n\tBUG_ON(ret < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key",
          "args": [
            "mid",
            "&mid_key",
            "0"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_tree_block",
          "args": [
            "trans",
            "root",
            "mid",
            "0",
            "1"
          ],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "6190-6246",
          "snippet": "void btrfs_free_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct extent_buffer *buf,\n\t\t\t   u64 parent, int last_ref)\n{\n\tint pin = 1;\n\tint ret;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tbuf->start, buf->len,\n\t\t\t\t\tparent, root->root_key.objectid,\n\t\t\t\t\tbtrfs_header_level(buf),\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tif (!last_ref)\n\t\treturn;\n\n\tif (btrfs_header_generation(buf) == trans->transid) {\n\t\tstruct btrfs_block_group_cache *cache;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\t\tret = check_ref_cleanup(trans, root, buf->start);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcache = btrfs_lookup_block_group(root->fs_info, buf->start);\n\n\t\tif (btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN)) {\n\t\t\tpin_down_extent(root, cache, buf->start, buf->len, 1);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto out;\n\t\t}\n\n\t\tWARN_ON(test_bit(EXTENT_BUFFER_DIRTY, &buf->bflags));\n\n\t\tbtrfs_add_free_space(cache, buf->start, buf->len);\n\t\tbtrfs_update_reserved_bytes(cache, buf->len, RESERVE_FREE, 0);\n\t\tbtrfs_put_block_group(cache);\n\t\ttrace_btrfs_reserved_extent_free(root, buf->start, buf->len);\n\t\tpin = 0;\n\t}\nout:\n\tif (pin)\n\t\tadd_pinned_bytes(root->fs_info, buf->len,\n\t\t\t\t btrfs_header_level(buf),\n\t\t\t\t root->root_key.objectid);\n\n\t/*\n\t * Deleting the buffer, clear the corrupt flag since it doesn't matter\n\t * anymore.\n\t */\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &buf->bflags);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct extent_buffer *buf,\n\t\t\t   u64 parent, int last_ref)\n{\n\tint pin = 1;\n\tint ret;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tbuf->start, buf->len,\n\t\t\t\t\tparent, root->root_key.objectid,\n\t\t\t\t\tbtrfs_header_level(buf),\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tif (!last_ref)\n\t\treturn;\n\n\tif (btrfs_header_generation(buf) == trans->transid) {\n\t\tstruct btrfs_block_group_cache *cache;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\t\tret = check_ref_cleanup(trans, root, buf->start);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcache = btrfs_lookup_block_group(root->fs_info, buf->start);\n\n\t\tif (btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN)) {\n\t\t\tpin_down_extent(root, cache, buf->start, buf->len, 1);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto out;\n\t\t}\n\n\t\tWARN_ON(test_bit(EXTENT_BUFFER_DIRTY, &buf->bflags));\n\n\t\tbtrfs_add_free_space(cache, buf->start, buf->len);\n\t\tbtrfs_update_reserved_bytes(cache, buf->len, RESERVE_FREE, 0);\n\t\tbtrfs_put_block_group(cache);\n\t\ttrace_btrfs_reserved_extent_free(root, buf->start, buf->len);\n\t\tpin = 0;\n\t}\nout:\n\tif (pin)\n\t\tadd_pinned_bytes(root->fs_info, buf->len,\n\t\t\t\t btrfs_header_level(buf),\n\t\t\t\t root->root_key.objectid);\n\n\t/*\n\t * Deleting the buffer, clear the corrupt flag since it doesn't matter\n\t * anymore.\n\t */\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &buf->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "root_sub_used",
          "args": [
            "root",
            "mid->len"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "root_sub_used",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1841-1847",
          "snippet": "static void root_sub_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) - size);\n\tspin_unlock(&root->accounting_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void root_sub_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) - size);\n\tspin_unlock(&root->accounting_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_ptr",
          "args": [
            "root",
            "path",
            "level + 1",
            "pslot"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "del_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "4858-4894",
          "snippet": "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot)\n{\n\tstruct extent_buffer *parent = path->nodes[level];\n\tu32 nritems;\n\tint ret;\n\n\tnritems = btrfs_header_nritems(parent);\n\tif (slot != nritems - 1) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, parent, slot,\n\t\t\t\t\t     slot + 1, nritems - slot - 1);\n\t\tmemmove_extent_buffer(parent,\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      sizeof(struct btrfs_key_ptr) *\n\t\t\t      (nritems - slot - 1));\n\t} else if (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, parent, slot,\n\t\t\t\t\t      MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\n\tnritems--;\n\tbtrfs_set_header_nritems(parent, nritems);\n\tif (nritems == 0 && parent == root->node) {\n\t\tBUG_ON(btrfs_header_level(root->node) != 1);\n\t\t/* just turn the root into a leaf and break */\n\t\tbtrfs_set_header_level(root->node, 0);\n\t} else if (slot == 0) {\n\t\tstruct btrfs_disk_key disk_key;\n\n\t\tbtrfs_node_key(parent, &disk_key, 0);\n\t\tfixup_low_keys(root, path, &disk_key, level + 1);\n\t}\n\tbtrfs_mark_buffer_dirty(parent);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot)\n{\n\tstruct extent_buffer *parent = path->nodes[level];\n\tu32 nritems;\n\tint ret;\n\n\tnritems = btrfs_header_nritems(parent);\n\tif (slot != nritems - 1) {\n\t\tif (level)\n\t\t\ttree_mod_log_eb_move(root->fs_info, parent, slot,\n\t\t\t\t\t     slot + 1, nritems - slot - 1);\n\t\tmemmove_extent_buffer(parent,\n\t\t\t      btrfs_node_key_ptr_offset(slot),\n\t\t\t      btrfs_node_key_ptr_offset(slot + 1),\n\t\t\t      sizeof(struct btrfs_key_ptr) *\n\t\t\t      (nritems - slot - 1));\n\t} else if (level) {\n\t\tret = tree_mod_log_insert_key(root->fs_info, parent, slot,\n\t\t\t\t\t      MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tBUG_ON(ret < 0);\n\t}\n\n\tnritems--;\n\tbtrfs_set_header_nritems(parent, nritems);\n\tif (nritems == 0 && parent == root->node) {\n\t\tBUG_ON(btrfs_header_level(root->node) != 1);\n\t\t/* just turn the root into a leaf and break */\n\t\tbtrfs_set_header_level(root->node, 0);\n\t} else if (slot == 0) {\n\t\tstruct btrfs_disk_key disk_key;\n\n\t\tbtrfs_node_key(parent, &disk_key, 0);\n\t\tfixup_low_keys(root, path, &disk_key, level + 1);\n\t}\n\tbtrfs_mark_buffer_dirty(parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clean_tree_block",
          "args": [
            "trans",
            "root",
            "mid"
          ],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "clean_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1168-1186",
          "snippet": "void clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "mid"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "wret == 1"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "push_node_left",
          "args": [
            "trans",
            "root",
            "left",
            "mid",
            "1"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "push_node_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3186-3249",
          "snippet": "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty)\n{\n\tint push_items = 0;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tif (!empty && src_nritems <= 8)\n\t\treturn 1;\n\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (empty) {\n\t\tpush_items = min(src_nritems, push_items);\n\t\tif (push_items < src_nritems) {\n\t\t\t/* leave at least 8 pointers in the node if\n\t\t\t * we aren't going to empty it\n\t\t\t */\n\t\t\tif (src_nritems - push_items < 8) {\n\t\t\t\tif (push_items <= 8)\n\t\t\t\t\treturn 1;\n\t\t\t\tpush_items -= 8;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpush_items = min(src_nritems - 8, push_items);\n\n\tret = tree_mod_log_eb_copy(root->fs_info, dst, src, dst_nritems, 0,\n\t\t\t\t   push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(dst_nritems),\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tif (push_items < src_nritems) {\n\t\t/*\n\t\t * don't call tree_mod_log_eb_move here, key removal was already\n\t\t * fully logged by tree_mod_log_eb_copy above.\n\t\t */\n\t\tmemmove_extent_buffer(src, btrfs_node_key_ptr_offset(0),\n\t\t\t\t      btrfs_node_key_ptr_offset(push_items),\n\t\t\t\t      (src_nritems - push_items) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\t}\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\tbtrfs_mark_buffer_dirty(src);\n\tbtrfs_mark_buffer_dirty(dst);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic noinline struct;\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty)\n{\n\tint push_items = 0;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tif (!empty && src_nritems <= 8)\n\t\treturn 1;\n\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (empty) {\n\t\tpush_items = min(src_nritems, push_items);\n\t\tif (push_items < src_nritems) {\n\t\t\t/* leave at least 8 pointers in the node if\n\t\t\t * we aren't going to empty it\n\t\t\t */\n\t\t\tif (src_nritems - push_items < 8) {\n\t\t\t\tif (push_items <= 8)\n\t\t\t\t\treturn 1;\n\t\t\t\tpush_items -= 8;\n\t\t\t}\n\t\t}\n\t} else\n\t\tpush_items = min(src_nritems - 8, push_items);\n\n\tret = tree_mod_log_eb_copy(root->fs_info, dst, src, dst_nritems, 0,\n\t\t\t\t   push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(dst_nritems),\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tif (push_items < src_nritems) {\n\t\t/*\n\t\t * don't call tree_mod_log_eb_move here, key removal was already\n\t\t * fully logged by tree_mod_log_eb_copy above.\n\t\t */\n\t\tmemmove_extent_buffer(src, btrfs_node_key_ptr_offset(0),\n\t\t\t\t      btrfs_node_key_ptr_offset(push_items),\n\t\t\t\t      (src_nritems - push_items) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\t}\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\tbtrfs_mark_buffer_dirty(src);\n\tbtrfs_mark_buffer_dirty(dst);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "balance_node_right",
          "args": [
            "trans",
            "root",
            "mid",
            "left"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "balance_node_right",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "3260-3315",
          "snippet": "static int balance_node_right(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct extent_buffer *dst,\n\t\t\t      struct extent_buffer *src)\n{\n\tint push_items = 0;\n\tint max_push;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (src_nritems < 4)\n\t\treturn 1;\n\n\tmax_push = src_nritems / 2 + 1;\n\t/* don't try to empty the node */\n\tif (max_push >= src_nritems)\n\t\treturn 1;\n\n\tif (max_push < push_items)\n\t\tpush_items = max_push;\n\n\ttree_mod_log_eb_move(root->fs_info, dst, push_items, 0, dst_nritems);\n\tmemmove_extent_buffer(dst, btrfs_node_key_ptr_offset(push_items),\n\t\t\t\t      btrfs_node_key_ptr_offset(0),\n\t\t\t\t      (dst_nritems) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\n\tret = tree_mod_log_eb_copy(root->fs_info, dst, src, 0,\n\t\t\t\t   src_nritems - push_items, push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   btrfs_node_key_ptr_offset(src_nritems - push_items),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\n\tbtrfs_mark_buffer_dirty(src);\n\tbtrfs_mark_buffer_dirty(dst);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic noinline struct;\n\nstatic int balance_node_right(struct btrfs_trans_handle *trans,\n\t\t\t      struct btrfs_root *root,\n\t\t\t      struct extent_buffer *dst,\n\t\t\t      struct extent_buffer *src)\n{\n\tint push_items = 0;\n\tint max_push;\n\tint src_nritems;\n\tint dst_nritems;\n\tint ret = 0;\n\n\tWARN_ON(btrfs_header_generation(src) != trans->transid);\n\tWARN_ON(btrfs_header_generation(dst) != trans->transid);\n\n\tsrc_nritems = btrfs_header_nritems(src);\n\tdst_nritems = btrfs_header_nritems(dst);\n\tpush_items = BTRFS_NODEPTRS_PER_BLOCK(root) - dst_nritems;\n\tif (push_items <= 0)\n\t\treturn 1;\n\n\tif (src_nritems < 4)\n\t\treturn 1;\n\n\tmax_push = src_nritems / 2 + 1;\n\t/* don't try to empty the node */\n\tif (max_push >= src_nritems)\n\t\treturn 1;\n\n\tif (max_push < push_items)\n\t\tpush_items = max_push;\n\n\ttree_mod_log_eb_move(root->fs_info, dst, push_items, 0, dst_nritems);\n\tmemmove_extent_buffer(dst, btrfs_node_key_ptr_offset(push_items),\n\t\t\t\t      btrfs_node_key_ptr_offset(0),\n\t\t\t\t      (dst_nritems) *\n\t\t\t\t      sizeof(struct btrfs_key_ptr));\n\n\tret = tree_mod_log_eb_copy(root->fs_info, dst, src, 0,\n\t\t\t\t   src_nritems - push_items, push_items);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\tcopy_extent_buffer(dst, src,\n\t\t\t   btrfs_node_key_ptr_offset(0),\n\t\t\t   btrfs_node_key_ptr_offset(src_nritems - push_items),\n\t\t\t   push_items * sizeof(struct btrfs_key_ptr));\n\n\tbtrfs_set_header_nritems(src, src_nritems - push_items);\n\tbtrfs_set_header_nritems(dst, dst_nritems + push_items);\n\n\tbtrfs_mark_buffer_dirty(src);\n\tbtrfs_mark_buffer_dirty(dst);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_std_error",
          "args": [
            "root->fs_info",
            "ret"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "mid"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "right"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "left"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_cow_block",
          "args": [
            "trans",
            "root",
            "right",
            "parent",
            "pslot + 1",
            "&right"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1534-1568",
          "snippet": "noinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "right"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "right"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_node_slot",
          "args": [
            "root",
            "parent",
            "pslot + 1"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "read_node_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1853-1874",
          "snippet": "extent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nextent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_NODEPTRS_PER_BLOCK",
          "args": [
            "root"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "mid"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_root_to_dirty_list",
          "args": [
            "root"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "add_root_to_dirty_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "214-231",
          "snippet": "static void add_root_to_dirty_list(struct btrfs_root *root)\n{\n\tif (test_bit(BTRFS_ROOT_DIRTY, &root->state) ||\n\t    !test_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state))\n\t\treturn;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (!test_and_set_bit(BTRFS_ROOT_DIRTY, &root->state)) {\n\t\t/* Want the extent tree to be the last on the list */\n\t\tif (root->objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\t\tlist_move_tail(&root->dirty_list,\n\t\t\t\t       &root->fs_info->dirty_cowonly_roots);\n\t\telse\n\t\t\tlist_move(&root->dirty_list,\n\t\t\t\t  &root->fs_info->dirty_cowonly_roots);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void add_root_to_dirty_list(struct btrfs_root *root)\n{\n\tif (test_bit(BTRFS_ROOT_DIRTY, &root->state) ||\n\t    !test_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state))\n\t\treturn;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (!test_and_set_bit(BTRFS_ROOT_DIRTY, &root->state)) {\n\t\t/* Want the extent tree to be the last on the list */\n\t\tif (root->objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\t\tlist_move_tail(&root->dirty_list,\n\t\t\t\t       &root->fs_info->dirty_cowonly_roots);\n\t\telse\n\t\t\tlist_move(&root->dirty_list,\n\t\t\t\t  &root->fs_info->dirty_cowonly_roots);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "root->node",
            "child"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_set_root_pointer",
          "args": [
            "root",
            "child",
            "1"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_set_root_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "941-950",
          "snippet": "static noinline void\ntree_mod_log_set_root_pointer(struct btrfs_root *root,\n\t\t\t      struct extent_buffer *new_root_node,\n\t\t\t      int log_removal)\n{\n\tint ret;\n\tret = tree_mod_log_insert_root(root->fs_info, root->node,\n\t\t\t\t       new_root_node, GFP_NOFS, log_removal);\n\tBUG_ON(ret < 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline void\ntree_mod_log_set_root_pointer(struct btrfs_root *root,\n\t\t\t      struct extent_buffer *new_root_node,\n\t\t\t      int log_removal)\n{\n\tint ret;\n\tret = tree_mod_log_insert_root(root->fs_info, root->node,\n\t\t\t\t       new_root_node, GFP_NOFS, log_removal);\n\tBUG_ON(ret < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_std_error",
          "args": [
            "root->fs_info",
            "ret"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "mid"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_generation(mid) != trans->transid"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "mid"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "path->locks[level] != BTRFS_WRITE_LOCK &&\n\t\tpath->locks[level] != BTRFS_WRITE_LOCK_BLOCKING"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic noinline struct;\n\nstatic noinline int balance_level(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_root *root,\n\t\t\t struct btrfs_path *path, int level)\n{\n\tstruct extent_buffer *right = NULL;\n\tstruct extent_buffer *mid;\n\tstruct extent_buffer *left = NULL;\n\tstruct extent_buffer *parent = NULL;\n\tint ret = 0;\n\tint wret;\n\tint pslot;\n\tint orig_slot = path->slots[level];\n\tu64 orig_ptr;\n\n\tif (level == 0)\n\t\treturn 0;\n\n\tmid = path->nodes[level];\n\n\tWARN_ON(path->locks[level] != BTRFS_WRITE_LOCK &&\n\t\tpath->locks[level] != BTRFS_WRITE_LOCK_BLOCKING);\n\tWARN_ON(btrfs_header_generation(mid) != trans->transid);\n\n\torig_ptr = btrfs_node_blockptr(mid, orig_slot);\n\n\tif (level < BTRFS_MAX_LEVEL - 1) {\n\t\tparent = path->nodes[level + 1];\n\t\tpslot = path->slots[level + 1];\n\t}\n\n\t/*\n\t * deal with the case where there is only one pointer in the root\n\t * by promoting the node below to a root\n\t */\n\tif (!parent) {\n\t\tstruct extent_buffer *child;\n\n\t\tif (btrfs_header_nritems(mid) != 1)\n\t\t\treturn 0;\n\n\t\t/* promote the child to a root */\n\t\tchild = read_node_slot(root, mid, 0);\n\t\tif (!child) {\n\t\t\tret = -EROFS;\n\t\t\tbtrfs_std_error(root->fs_info, ret);\n\t\t\tgoto enospc;\n\t\t}\n\n\t\tbtrfs_tree_lock(child);\n\t\tbtrfs_set_lock_blocking(child);\n\t\tret = btrfs_cow_block(trans, root, child, mid, 0, &child);\n\t\tif (ret) {\n\t\t\tbtrfs_tree_unlock(child);\n\t\t\tfree_extent_buffer(child);\n\t\t\tgoto enospc;\n\t\t}\n\n\t\ttree_mod_log_set_root_pointer(root, child, 1);\n\t\trcu_assign_pointer(root->node, child);\n\n\t\tadd_root_to_dirty_list(root);\n\t\tbtrfs_tree_unlock(child);\n\n\t\tpath->locks[level] = 0;\n\t\tpath->nodes[level] = NULL;\n\t\tclean_tree_block(trans, root, mid);\n\t\tbtrfs_tree_unlock(mid);\n\t\t/* once for the path */\n\t\tfree_extent_buffer(mid);\n\n\t\troot_sub_used(root, mid->len);\n\t\tbtrfs_free_tree_block(trans, root, mid, 0, 1);\n\t\t/* once for the root ptr */\n\t\tfree_extent_buffer_stale(mid);\n\t\treturn 0;\n\t}\n\tif (btrfs_header_nritems(mid) >\n\t    BTRFS_NODEPTRS_PER_BLOCK(root) / 4)\n\t\treturn 0;\n\n\tleft = read_node_slot(root, parent, pslot - 1);\n\tif (left) {\n\t\tbtrfs_tree_lock(left);\n\t\tbtrfs_set_lock_blocking(left);\n\t\twret = btrfs_cow_block(trans, root, left,\n\t\t\t\t       parent, pslot - 1, &left);\n\t\tif (wret) {\n\t\t\tret = wret;\n\t\t\tgoto enospc;\n\t\t}\n\t}\n\tright = read_node_slot(root, parent, pslot + 1);\n\tif (right) {\n\t\tbtrfs_tree_lock(right);\n\t\tbtrfs_set_lock_blocking(right);\n\t\twret = btrfs_cow_block(trans, root, right,\n\t\t\t\t       parent, pslot + 1, &right);\n\t\tif (wret) {\n\t\t\tret = wret;\n\t\t\tgoto enospc;\n\t\t}\n\t}\n\n\t/* first, try to make some room in the middle buffer */\n\tif (left) {\n\t\torig_slot += btrfs_header_nritems(left);\n\t\twret = push_node_left(trans, root, left, mid, 1);\n\t\tif (wret < 0)\n\t\t\tret = wret;\n\t}\n\n\t/*\n\t * then try to empty the right most buffer into the middle\n\t */\n\tif (right) {\n\t\twret = push_node_left(trans, root, mid, right, 1);\n\t\tif (wret < 0 && wret != -ENOSPC)\n\t\t\tret = wret;\n\t\tif (btrfs_header_nritems(right) == 0) {\n\t\t\tclean_tree_block(trans, root, right);\n\t\t\tbtrfs_tree_unlock(right);\n\t\t\tdel_ptr(root, path, level + 1, pslot + 1);\n\t\t\troot_sub_used(root, right->len);\n\t\t\tbtrfs_free_tree_block(trans, root, right, 0, 1);\n\t\t\tfree_extent_buffer_stale(right);\n\t\t\tright = NULL;\n\t\t} else {\n\t\t\tstruct btrfs_disk_key right_key;\n\t\t\tbtrfs_node_key(right, &right_key, 0);\n\t\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t\t  pslot + 1, 0);\n\t\t\tbtrfs_set_node_key(parent, &right_key, pslot + 1);\n\t\t\tbtrfs_mark_buffer_dirty(parent);\n\t\t}\n\t}\n\tif (btrfs_header_nritems(mid) == 1) {\n\t\t/*\n\t\t * we're not allowed to leave a node with one item in the\n\t\t * tree during a delete.  A deletion from lower in the tree\n\t\t * could try to delete the only pointer in this node.\n\t\t * So, pull some keys from the left.\n\t\t * There has to be a left pointer at this point because\n\t\t * otherwise we would have pulled some pointers from the\n\t\t * right\n\t\t */\n\t\tif (!left) {\n\t\t\tret = -EROFS;\n\t\t\tbtrfs_std_error(root->fs_info, ret);\n\t\t\tgoto enospc;\n\t\t}\n\t\twret = balance_node_right(trans, root, mid, left);\n\t\tif (wret < 0) {\n\t\t\tret = wret;\n\t\t\tgoto enospc;\n\t\t}\n\t\tif (wret == 1) {\n\t\t\twret = push_node_left(trans, root, left, mid, 1);\n\t\t\tif (wret < 0)\n\t\t\t\tret = wret;\n\t\t}\n\t\tBUG_ON(wret == 1);\n\t}\n\tif (btrfs_header_nritems(mid) == 0) {\n\t\tclean_tree_block(trans, root, mid);\n\t\tbtrfs_tree_unlock(mid);\n\t\tdel_ptr(root, path, level + 1, pslot);\n\t\troot_sub_used(root, mid->len);\n\t\tbtrfs_free_tree_block(trans, root, mid, 0, 1);\n\t\tfree_extent_buffer_stale(mid);\n\t\tmid = NULL;\n\t} else {\n\t\t/* update the parent key to reflect our changes */\n\t\tstruct btrfs_disk_key mid_key;\n\t\tbtrfs_node_key(mid, &mid_key, 0);\n\t\ttree_mod_log_set_node_key(root->fs_info, parent,\n\t\t\t\t\t  pslot, 0);\n\t\tbtrfs_set_node_key(parent, &mid_key, pslot);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\t}\n\n\t/* update the path */\n\tif (left) {\n\t\tif (btrfs_header_nritems(left) > orig_slot) {\n\t\t\textent_buffer_get(left);\n\t\t\t/* left was locked after cow */\n\t\t\tpath->nodes[level] = left;\n\t\t\tpath->slots[level + 1] -= 1;\n\t\t\tpath->slots[level] = orig_slot;\n\t\t\tif (mid) {\n\t\t\t\tbtrfs_tree_unlock(mid);\n\t\t\t\tfree_extent_buffer(mid);\n\t\t\t}\n\t\t} else {\n\t\t\torig_slot -= btrfs_header_nritems(left);\n\t\t\tpath->slots[level] = orig_slot;\n\t\t}\n\t}\n\t/* double check we haven't messed things up */\n\tif (orig_ptr !=\n\t    btrfs_node_blockptr(path->nodes[level], path->slots[level]))\n\t\tBUG();\nenospc:\n\tif (right) {\n\t\tbtrfs_tree_unlock(right);\n\t\tfree_extent_buffer(right);\n\t}\n\tif (left) {\n\t\tif (path->nodes[level] != left)\n\t\t\tbtrfs_tree_unlock(left);\n\t\tfree_extent_buffer(left);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "read_node_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1853-1874",
    "snippet": "extent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "eb"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_block",
          "args": [
            "root",
            "btrfs_node_blockptr(parent, slot)",
            "btrfs_node_ptr_generation(parent, slot)"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1149-1166",
          "snippet": "struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "parent",
            "slot"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "parent",
            "slot"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "level == 0"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "parent"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "parent"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nextent_buffer *read_node_slot(struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *parent, int slot)\n{\n\tint level = btrfs_header_level(parent);\n\tstruct extent_buffer *eb;\n\n\tif (slot < 0)\n\t\treturn NULL;\n\tif (slot >= btrfs_header_nritems(parent))\n\t\treturn NULL;\n\n\tBUG_ON(level == 0);\n\n\teb = read_tree_block(root, btrfs_node_blockptr(parent, slot),\n\t\t\t     btrfs_node_ptr_generation(parent, slot));\n\tif (eb && !extent_buffer_uptodate(eb)) {\n\t\tfree_extent_buffer(eb);\n\t\teb = NULL;\n\t}\n\n\treturn eb;\n}"
  },
  {
    "function_name": "root_sub_used",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1841-1847",
    "snippet": "static void root_sub_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) - size);\n\tspin_unlock(&root->accounting_lock);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->accounting_lock"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_used",
          "args": [
            "&root->root_item",
            "btrfs_root_used(&root->root_item) - size"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_used",
          "args": [
            "&root->root_item"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->accounting_lock"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void root_sub_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) - size);\n\tspin_unlock(&root->accounting_lock);\n}"
  },
  {
    "function_name": "root_add_used",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1833-1839",
    "snippet": "static void root_add_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) + size);\n\tspin_unlock(&root->accounting_lock);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->accounting_lock"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_root_used",
          "args": [
            "&root->root_item",
            "btrfs_root_used(&root->root_item) + size"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_used",
          "args": [
            "&root->root_item"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->accounting_lock"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void root_add_used(struct btrfs_root *root, u32 size)\n{\n\tspin_lock(&root->accounting_lock);\n\tbtrfs_set_root_used(&root->root_item,\n\t\t\t    btrfs_root_used(&root->root_item) + size);\n\tspin_unlock(&root->accounting_lock);\n}"
  },
  {
    "function_name": "btrfs_bin_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1827-1831",
    "snippet": "int btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bin_search",
          "args": [
            "eb",
            "key",
            "level",
            "slot"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_bin_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1827-1831",
          "snippet": "int btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nint btrfs_bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t     int level, int *slot)\n{\n\treturn bin_search(eb, key, level, slot);\n}"
  },
  {
    "function_name": "bin_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1810-1825",
    "snippet": "static int bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t      int level, int *slot)\n{\n\tif (level == 0)\n\t\treturn generic_bin_search(eb,\n\t\t\t\t\t  offsetof(struct btrfs_leaf, items),\n\t\t\t\t\t  sizeof(struct btrfs_item),\n\t\t\t\t\t  key, btrfs_header_nritems(eb),\n\t\t\t\t\t  slot);\n\telse\n\t\treturn generic_bin_search(eb,\n\t\t\t\t\t  offsetof(struct btrfs_node, ptrs),\n\t\t\t\t\t  sizeof(struct btrfs_key_ptr),\n\t\t\t\t\t  key, btrfs_header_nritems(eb),\n\t\t\t\t\t  slot);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_bin_search",
          "args": [
            "eb",
            "offsetof(struct btrfs_node, ptrs)",
            "sizeof(struct btrfs_key_ptr)",
            "key",
            "btrfs_header_nritems(eb)",
            "slot"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "generic_bin_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1749-1804",
          "snippet": "static noinline int generic_bin_search(struct extent_buffer *eb,\n\t\t\t\t       unsigned long p,\n\t\t\t\t       int item_size, struct btrfs_key *key,\n\t\t\t\t       int max, int *slot)\n{\n\tint low = 0;\n\tint high = max;\n\tint mid;\n\tint ret;\n\tstruct btrfs_disk_key *tmp = NULL;\n\tstruct btrfs_disk_key unaligned;\n\tunsigned long offset;\n\tchar *kaddr = NULL;\n\tunsigned long map_start = 0;\n\tunsigned long map_len = 0;\n\tint err;\n\n\twhile (low < high) {\n\t\tmid = (low + high) / 2;\n\t\toffset = p + mid * item_size;\n\n\t\tif (!kaddr || offset < map_start ||\n\t\t    (offset + sizeof(struct btrfs_disk_key)) >\n\t\t    map_start + map_len) {\n\n\t\t\terr = map_private_extent_buffer(eb, offset,\n\t\t\t\t\t\tsizeof(struct btrfs_disk_key),\n\t\t\t\t\t\t&kaddr, &map_start, &map_len);\n\n\t\t\tif (!err) {\n\t\t\t\ttmp = (struct btrfs_disk_key *)(kaddr + offset -\n\t\t\t\t\t\t\tmap_start);\n\t\t\t} else {\n\t\t\t\tread_extent_buffer(eb, &unaligned,\n\t\t\t\t\t\t   offset, sizeof(unaligned));\n\t\t\t\ttmp = &unaligned;\n\t\t\t}\n\n\t\t} else {\n\t\t\ttmp = (struct btrfs_disk_key *)(kaddr + offset -\n\t\t\t\t\t\t\tmap_start);\n\t\t}\n\t\tret = comp_keys(tmp, key);\n\n\t\tif (ret < 0)\n\t\t\tlow = mid + 1;\n\t\telse if (ret > 0)\n\t\t\thigh = mid;\n\t\telse {\n\t\t\t*slot = mid;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*slot = low;\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline int generic_bin_search(struct extent_buffer *eb,\n\t\t\t\t       unsigned long p,\n\t\t\t\t       int item_size, struct btrfs_key *key,\n\t\t\t\t       int max, int *slot)\n{\n\tint low = 0;\n\tint high = max;\n\tint mid;\n\tint ret;\n\tstruct btrfs_disk_key *tmp = NULL;\n\tstruct btrfs_disk_key unaligned;\n\tunsigned long offset;\n\tchar *kaddr = NULL;\n\tunsigned long map_start = 0;\n\tunsigned long map_len = 0;\n\tint err;\n\n\twhile (low < high) {\n\t\tmid = (low + high) / 2;\n\t\toffset = p + mid * item_size;\n\n\t\tif (!kaddr || offset < map_start ||\n\t\t    (offset + sizeof(struct btrfs_disk_key)) >\n\t\t    map_start + map_len) {\n\n\t\t\terr = map_private_extent_buffer(eb, offset,\n\t\t\t\t\t\tsizeof(struct btrfs_disk_key),\n\t\t\t\t\t\t&kaddr, &map_start, &map_len);\n\n\t\t\tif (!err) {\n\t\t\t\ttmp = (struct btrfs_disk_key *)(kaddr + offset -\n\t\t\t\t\t\t\tmap_start);\n\t\t\t} else {\n\t\t\t\tread_extent_buffer(eb, &unaligned,\n\t\t\t\t\t\t   offset, sizeof(unaligned));\n\t\t\t\ttmp = &unaligned;\n\t\t\t}\n\n\t\t} else {\n\t\t\ttmp = (struct btrfs_disk_key *)(kaddr + offset -\n\t\t\t\t\t\t\tmap_start);\n\t\t}\n\t\tret = comp_keys(tmp, key);\n\n\t\tif (ret < 0)\n\t\t\tlow = mid + 1;\n\t\telse if (ret > 0)\n\t\t\thigh = mid;\n\t\telse {\n\t\t\t*slot = mid;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*slot = low;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic int bin_search(struct extent_buffer *eb, struct btrfs_key *key,\n\t\t      int level, int *slot)\n{\n\tif (level == 0)\n\t\treturn generic_bin_search(eb,\n\t\t\t\t\t  offsetof(struct btrfs_leaf, items),\n\t\t\t\t\t  sizeof(struct btrfs_item),\n\t\t\t\t\t  key, btrfs_header_nritems(eb),\n\t\t\t\t\t  slot);\n\telse\n\t\treturn generic_bin_search(eb,\n\t\t\t\t\t  offsetof(struct btrfs_node, ptrs),\n\t\t\t\t\t  sizeof(struct btrfs_key_ptr),\n\t\t\t\t\t  key, btrfs_header_nritems(eb),\n\t\t\t\t\t  slot);\n}"
  },
  {
    "function_name": "generic_bin_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1749-1804",
    "snippet": "static noinline int generic_bin_search(struct extent_buffer *eb,\n\t\t\t\t       unsigned long p,\n\t\t\t\t       int item_size, struct btrfs_key *key,\n\t\t\t\t       int max, int *slot)\n{\n\tint low = 0;\n\tint high = max;\n\tint mid;\n\tint ret;\n\tstruct btrfs_disk_key *tmp = NULL;\n\tstruct btrfs_disk_key unaligned;\n\tunsigned long offset;\n\tchar *kaddr = NULL;\n\tunsigned long map_start = 0;\n\tunsigned long map_len = 0;\n\tint err;\n\n\twhile (low < high) {\n\t\tmid = (low + high) / 2;\n\t\toffset = p + mid * item_size;\n\n\t\tif (!kaddr || offset < map_start ||\n\t\t    (offset + sizeof(struct btrfs_disk_key)) >\n\t\t    map_start + map_len) {\n\n\t\t\terr = map_private_extent_buffer(eb, offset,\n\t\t\t\t\t\tsizeof(struct btrfs_disk_key),\n\t\t\t\t\t\t&kaddr, &map_start, &map_len);\n\n\t\t\tif (!err) {\n\t\t\t\ttmp = (struct btrfs_disk_key *)(kaddr + offset -\n\t\t\t\t\t\t\tmap_start);\n\t\t\t} else {\n\t\t\t\tread_extent_buffer(eb, &unaligned,\n\t\t\t\t\t\t   offset, sizeof(unaligned));\n\t\t\t\ttmp = &unaligned;\n\t\t\t}\n\n\t\t} else {\n\t\t\ttmp = (struct btrfs_disk_key *)(kaddr + offset -\n\t\t\t\t\t\t\tmap_start);\n\t\t}\n\t\tret = comp_keys(tmp, key);\n\n\t\tif (ret < 0)\n\t\t\tlow = mid + 1;\n\t\telse if (ret > 0)\n\t\t\thigh = mid;\n\t\telse {\n\t\t\t*slot = mid;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*slot = low;\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "comp_keys",
          "args": [
            "tmp",
            "key"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "comp_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1586-1593",
          "snippet": "static int comp_keys(struct btrfs_disk_key *disk, struct btrfs_key *k2)\n{\n\tstruct btrfs_key k1;\n\n\tbtrfs_disk_key_to_cpu(&k1, disk);\n\n\treturn btrfs_comp_cpu_keys(&k1, k2);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int comp_keys(struct btrfs_disk_key *disk, struct btrfs_key *k2)\n{\n\tstruct btrfs_key k1;\n\n\tbtrfs_disk_key_to_cpu(&k1, disk);\n\n\treturn btrfs_comp_cpu_keys(&k1, k2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "&unaligned",
            "offset",
            "sizeof(unaligned)"
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_private_extent_buffer",
          "args": [
            "eb",
            "offset",
            "sizeof(struct btrfs_disk_key)",
            "&kaddr",
            "&map_start",
            "&map_len"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "map_private_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5282-5318",
          "snippet": "int map_private_extent_buffer(struct extent_buffer *eb, unsigned long start,\n\t\t\t       unsigned long min_len, char **map,\n\t\t\t       unsigned long *map_start,\n\t\t\t       unsigned long *map_len)\n{\n\tsize_t offset = start & (PAGE_CACHE_SIZE - 1);\n\tchar *kaddr;\n\tstruct page *p;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tunsigned long end_i = (start_offset + start + min_len - 1) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tif (i != end_i)\n\t\treturn -EINVAL;\n\n\tif (i == 0) {\n\t\toffset = start_offset;\n\t\t*map_start = 0;\n\t} else {\n\t\toffset = 0;\n\t\t*map_start = ((u64)i << PAGE_CACHE_SHIFT) - start_offset;\n\t}\n\n\tif (start + min_len > eb->len) {\n\t\tWARN(1, KERN_ERR \"btrfs bad mapping eb start %llu len %lu, \"\n\t\t       \"wanted %lu %lu\\n\",\n\t\t       eb->start, eb->len, start, min_len);\n\t\treturn -EINVAL;\n\t}\n\n\tp = eb->pages[i];\n\tkaddr = page_address(p);\n\t*map = kaddr + offset;\n\t*map_len = PAGE_CACHE_SIZE - offset;\n\treturn 0;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint map_private_extent_buffer(struct extent_buffer *eb, unsigned long start,\n\t\t\t       unsigned long min_len, char **map,\n\t\t\t       unsigned long *map_start,\n\t\t\t       unsigned long *map_len)\n{\n\tsize_t offset = start & (PAGE_CACHE_SIZE - 1);\n\tchar *kaddr;\n\tstruct page *p;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\tunsigned long end_i = (start_offset + start + min_len - 1) >>\n\t\tPAGE_CACHE_SHIFT;\n\n\tif (i != end_i)\n\t\treturn -EINVAL;\n\n\tif (i == 0) {\n\t\toffset = start_offset;\n\t\t*map_start = 0;\n\t} else {\n\t\toffset = 0;\n\t\t*map_start = ((u64)i << PAGE_CACHE_SHIFT) - start_offset;\n\t}\n\n\tif (start + min_len > eb->len) {\n\t\tWARN(1, KERN_ERR \"btrfs bad mapping eb start %llu len %lu, \"\n\t\t       \"wanted %lu %lu\\n\",\n\t\t       eb->start, eb->len, start, min_len);\n\t\treturn -EINVAL;\n\t}\n\n\tp = eb->pages[i];\n\tkaddr = page_address(p);\n\t*map = kaddr + offset;\n\t*map_len = PAGE_CACHE_SIZE - offset;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline int generic_bin_search(struct extent_buffer *eb,\n\t\t\t\t       unsigned long p,\n\t\t\t\t       int item_size, struct btrfs_key *key,\n\t\t\t\t       int max, int *slot)\n{\n\tint low = 0;\n\tint high = max;\n\tint mid;\n\tint ret;\n\tstruct btrfs_disk_key *tmp = NULL;\n\tstruct btrfs_disk_key unaligned;\n\tunsigned long offset;\n\tchar *kaddr = NULL;\n\tunsigned long map_start = 0;\n\tunsigned long map_len = 0;\n\tint err;\n\n\twhile (low < high) {\n\t\tmid = (low + high) / 2;\n\t\toffset = p + mid * item_size;\n\n\t\tif (!kaddr || offset < map_start ||\n\t\t    (offset + sizeof(struct btrfs_disk_key)) >\n\t\t    map_start + map_len) {\n\n\t\t\terr = map_private_extent_buffer(eb, offset,\n\t\t\t\t\t\tsizeof(struct btrfs_disk_key),\n\t\t\t\t\t\t&kaddr, &map_start, &map_len);\n\n\t\t\tif (!err) {\n\t\t\t\ttmp = (struct btrfs_disk_key *)(kaddr + offset -\n\t\t\t\t\t\t\tmap_start);\n\t\t\t} else {\n\t\t\t\tread_extent_buffer(eb, &unaligned,\n\t\t\t\t\t\t   offset, sizeof(unaligned));\n\t\t\t\ttmp = &unaligned;\n\t\t\t}\n\n\t\t} else {\n\t\t\ttmp = (struct btrfs_disk_key *)(kaddr + offset -\n\t\t\t\t\t\t\tmap_start);\n\t\t}\n\t\tret = comp_keys(tmp, key);\n\n\t\tif (ret < 0)\n\t\t\tlow = mid + 1;\n\t\telse if (ret > 0)\n\t\t\thigh = mid;\n\t\telse {\n\t\t\t*slot = mid;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*slot = low;\n\treturn 1;\n}"
  },
  {
    "function_name": "leaf_data_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1729-1736",
    "snippet": "static inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_item_offset_nr",
          "args": [
            "leaf",
            "nr - 1"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_offset_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2644-2647",
          "snippet": "static inline u32 btrfs_item_offset_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_offset(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_offset_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_offset(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTRFS_LEAF_DATA_SIZE",
          "args": [
            "root"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline unsigned int leaf_data_end(struct btrfs_root *root,\n\t\t\t\t\t struct extent_buffer *leaf)\n{\n\tu32 nr = btrfs_header_nritems(leaf);\n\tif (nr == 0)\n\t\treturn BTRFS_LEAF_DATA_SIZE(root);\n\treturn btrfs_item_offset_nr(leaf, nr - 1);\n}"
  },
  {
    "function_name": "btrfs_realloc_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1620-1722",
    "snippet": "int btrfs_realloc_node(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct extent_buffer *parent,\n\t\t       int start_slot, u64 *last_ret,\n\t\t       struct btrfs_key *progress)\n{\n\tstruct extent_buffer *cur;\n\tu64 blocknr;\n\tu64 gen;\n\tu64 search_start = *last_ret;\n\tu64 last_block = 0;\n\tu64 other;\n\tu32 parent_nritems;\n\tint end_slot;\n\tint i;\n\tint err = 0;\n\tint parent_level;\n\tint uptodate;\n\tu32 blocksize;\n\tint progress_passed = 0;\n\tstruct btrfs_disk_key disk_key;\n\n\tparent_level = btrfs_header_level(parent);\n\n\tWARN_ON(trans->transaction != root->fs_info->running_transaction);\n\tWARN_ON(trans->transid != root->fs_info->generation);\n\n\tparent_nritems = btrfs_header_nritems(parent);\n\tblocksize = root->nodesize;\n\tend_slot = parent_nritems - 1;\n\n\tif (parent_nritems <= 1)\n\t\treturn 0;\n\n\tbtrfs_set_lock_blocking(parent);\n\n\tfor (i = start_slot; i <= end_slot; i++) {\n\t\tint close = 1;\n\n\t\tbtrfs_node_key(parent, &disk_key, i);\n\t\tif (!progress_passed && comp_keys(&disk_key, progress) < 0)\n\t\t\tcontinue;\n\n\t\tprogress_passed = 1;\n\t\tblocknr = btrfs_node_blockptr(parent, i);\n\t\tgen = btrfs_node_ptr_generation(parent, i);\n\t\tif (last_block == 0)\n\t\t\tlast_block = blocknr;\n\n\t\tif (i > 0) {\n\t\t\tother = btrfs_node_blockptr(parent, i - 1);\n\t\t\tclose = close_blocks(blocknr, other, blocksize);\n\t\t}\n\t\tif (!close && i < end_slot) {\n\t\t\tother = btrfs_node_blockptr(parent, i + 1);\n\t\t\tclose = close_blocks(blocknr, other, blocksize);\n\t\t}\n\t\tif (close) {\n\t\t\tlast_block = blocknr;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur = btrfs_find_tree_block(root, blocknr);\n\t\tif (cur)\n\t\t\tuptodate = btrfs_buffer_uptodate(cur, gen, 0);\n\t\telse\n\t\t\tuptodate = 0;\n\t\tif (!cur || !uptodate) {\n\t\t\tif (!cur) {\n\t\t\t\tcur = read_tree_block(root, blocknr, gen);\n\t\t\t\tif (!cur || !extent_buffer_uptodate(cur)) {\n\t\t\t\t\tfree_extent_buffer(cur);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t} else if (!uptodate) {\n\t\t\t\terr = btrfs_read_buffer(cur, gen);\n\t\t\t\tif (err) {\n\t\t\t\t\tfree_extent_buffer(cur);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (search_start == 0)\n\t\t\tsearch_start = last_block;\n\n\t\tbtrfs_tree_lock(cur);\n\t\tbtrfs_set_lock_blocking(cur);\n\t\terr = __btrfs_cow_block(trans, root, cur, parent, i,\n\t\t\t\t\t&cur, search_start,\n\t\t\t\t\tmin(16 * blocksize,\n\t\t\t\t\t    (end_slot - i) * blocksize));\n\t\tif (err) {\n\t\t\tbtrfs_tree_unlock(cur);\n\t\t\tfree_extent_buffer(cur);\n\t\t\tbreak;\n\t\t}\n\t\tsearch_start = cur->start;\n\t\tlast_block = cur->start;\n\t\t*last_ret = search_start;\n\t\tbtrfs_tree_unlock(cur);\n\t\tfree_extent_buffer(cur);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "cur"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "cur"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__btrfs_cow_block",
          "args": [
            "trans",
            "root",
            "cur",
            "parent",
            "i",
            "&cur",
            "search_start",
            "min(16 * blocksize,\n\t\t\t\t\t    (end_slot - i) * blocksize)"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1094-1213",
          "snippet": "static noinline int __btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct extent_buffer *buf,\n\t\t\t     struct extent_buffer *parent, int parent_slot,\n\t\t\t     struct extent_buffer **cow_ret,\n\t\t\t     u64 search_start, u64 empty_size)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *cow;\n\tint level, ret;\n\tint last_ref = 0;\n\tint unlock_orig = 0;\n\tu64 parent_start;\n\n\tif (*cow_ret == buf)\n\t\tunlock_orig = 1;\n\n\tbtrfs_assert_tree_locked(buf);\n\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent)\n\t\t\tparent_start = parent->start;\n\t\telse\n\t\t\tparent_start = 0;\n\t} else\n\t\tparent_start = 0;\n\n\tcow = btrfs_alloc_tree_block(trans, root, parent_start,\n\t\t\troot->root_key.objectid, &disk_key, level,\n\t\t\tsearch_start, empty_size);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\t/* cow is set to blocking by btrfs_init_new_buffer */\n\n\tcopy_extent_buffer(cow, buf, 0, 0, cow->len);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, root->root_key.objectid);\n\n\twrite_extent_buffer(cow, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\tret = update_ref_for_cow(trans, root, buf, cow, &last_ref);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\tret = btrfs_reloc_cow_block(trans, root, buf, cow);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (buf == root->node) {\n\t\tWARN_ON(parent && parent != buf);\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\t\tparent_start = buf->start;\n\t\telse\n\t\t\tparent_start = 0;\n\n\t\textent_buffer_get(cow);\n\t\ttree_mod_log_set_root_pointer(root, cow, 1);\n\t\trcu_assign_pointer(root->node, cow);\n\n\t\tbtrfs_free_tree_block(trans, root, buf, parent_start,\n\t\t\t\t      last_ref);\n\t\tfree_extent_buffer(buf);\n\t\tadd_root_to_dirty_list(root);\n\t} else {\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\t\tparent_start = parent->start;\n\t\telse\n\t\t\tparent_start = 0;\n\n\t\tWARN_ON(trans->transid != btrfs_header_generation(parent));\n\t\ttree_mod_log_insert_key(root->fs_info, parent, parent_slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE, GFP_NOFS);\n\t\tbtrfs_set_node_blockptr(parent, parent_slot,\n\t\t\t\t\tcow->start);\n\t\tbtrfs_set_node_ptr_generation(parent, parent_slot,\n\t\t\t\t\t      trans->transid);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\t\tif (last_ref) {\n\t\t\tret = tree_mod_log_free_eb(root->fs_info, buf);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbtrfs_free_tree_block(trans, root, buf, parent_start,\n\t\t\t\t      last_ref);\n\t}\n\tif (unlock_orig)\n\t\tbtrfs_tree_unlock(buf);\n\tfree_extent_buffer_stale(buf);\n\tbtrfs_mark_buffer_dirty(cow);\n\t*cow_ret = cow;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline int __btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct extent_buffer *buf,\n\t\t\t     struct extent_buffer *parent, int parent_slot,\n\t\t\t     struct extent_buffer **cow_ret,\n\t\t\t     u64 search_start, u64 empty_size)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *cow;\n\tint level, ret;\n\tint last_ref = 0;\n\tint unlock_orig = 0;\n\tu64 parent_start;\n\n\tif (*cow_ret == buf)\n\t\tunlock_orig = 1;\n\n\tbtrfs_assert_tree_locked(buf);\n\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent)\n\t\t\tparent_start = parent->start;\n\t\telse\n\t\t\tparent_start = 0;\n\t} else\n\t\tparent_start = 0;\n\n\tcow = btrfs_alloc_tree_block(trans, root, parent_start,\n\t\t\troot->root_key.objectid, &disk_key, level,\n\t\t\tsearch_start, empty_size);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\t/* cow is set to blocking by btrfs_init_new_buffer */\n\n\tcopy_extent_buffer(cow, buf, 0, 0, cow->len);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, root->root_key.objectid);\n\n\twrite_extent_buffer(cow, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\tret = update_ref_for_cow(trans, root, buf, cow, &last_ref);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\tret = btrfs_reloc_cow_block(trans, root, buf, cow);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (buf == root->node) {\n\t\tWARN_ON(parent && parent != buf);\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\t\tparent_start = buf->start;\n\t\telse\n\t\t\tparent_start = 0;\n\n\t\textent_buffer_get(cow);\n\t\ttree_mod_log_set_root_pointer(root, cow, 1);\n\t\trcu_assign_pointer(root->node, cow);\n\n\t\tbtrfs_free_tree_block(trans, root, buf, parent_start,\n\t\t\t\t      last_ref);\n\t\tfree_extent_buffer(buf);\n\t\tadd_root_to_dirty_list(root);\n\t} else {\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\t\tparent_start = parent->start;\n\t\telse\n\t\t\tparent_start = 0;\n\n\t\tWARN_ON(trans->transid != btrfs_header_generation(parent));\n\t\ttree_mod_log_insert_key(root->fs_info, parent, parent_slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE, GFP_NOFS);\n\t\tbtrfs_set_node_blockptr(parent, parent_slot,\n\t\t\t\t\tcow->start);\n\t\tbtrfs_set_node_ptr_generation(parent, parent_slot,\n\t\t\t\t\t      trans->transid);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\t\tif (last_ref) {\n\t\t\tret = tree_mod_log_free_eb(root->fs_info, buf);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbtrfs_free_tree_block(trans, root, buf, parent_start,\n\t\t\t\t      last_ref);\n\t}\n\tif (unlock_orig)\n\t\tbtrfs_tree_unlock(buf);\n\tfree_extent_buffer_stale(buf);\n\tbtrfs_mark_buffer_dirty(cow);\n\t*cow_ret = cow;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "16 * blocksize",
            "(end_slot - i) * blocksize"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "cur"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "cur"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_read_buffer",
          "args": [
            "cur",
            "gen"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3831-3835",
          "snippet": "int btrfs_read_buffer(struct extent_buffer *buf, u64 parent_transid)\n{\n\tstruct btrfs_root *root = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\treturn btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_read_buffer(struct extent_buffer *buf, u64 parent_transid)\n{\n\tstruct btrfs_root *root = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\treturn btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "cur"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_block",
          "args": [
            "root",
            "blocknr",
            "gen"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1149-1166",
          "snippet": "struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_buffer_uptodate",
          "args": [
            "cur",
            "gen",
            "0"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3741-3756",
          "snippet": "int btrfs_buffer_uptodate(struct extent_buffer *buf, u64 parent_transid,\n\t\t\t  int atomic)\n{\n\tint ret;\n\tstruct inode *btree_inode = buf->pages[0]->mapping->host;\n\n\tret = extent_buffer_uptodate(buf);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = verify_parent_transid(&BTRFS_I(btree_inode)->io_tree, buf,\n\t\t\t\t    parent_transid, atomic);\n\tif (ret == -EAGAIN)\n\t\treturn ret;\n\treturn !ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_buffer_uptodate(struct extent_buffer *buf, u64 parent_transid,\n\t\t\t  int atomic)\n{\n\tint ret;\n\tstruct inode *btree_inode = buf->pages[0]->mapping->host;\n\n\tret = extent_buffer_uptodate(buf);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = verify_parent_transid(&BTRFS_I(btree_inode)->io_tree, buf,\n\t\t\t\t    parent_transid, atomic);\n\tif (ret == -EAGAIN)\n\t\treturn ret;\n\treturn !ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_tree_block",
          "args": [
            "root",
            "blocknr"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1122-1126",
          "snippet": "struct extent_buffer *btrfs_find_tree_block(struct btrfs_root *root,\n\t\t\t\t\t    u64 bytenr)\n{\n\treturn find_extent_buffer(root->fs_info, bytenr);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *btrfs_find_tree_block(struct btrfs_root *root,\n\t\t\t\t\t    u64 bytenr)\n{\n\treturn find_extent_buffer(root->fs_info, bytenr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_blocks",
          "args": [
            "blocknr",
            "other",
            "blocksize"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "close_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1574-1581",
          "snippet": "static int close_blocks(u64 blocknr, u64 other, u32 blocksize)\n{\n\tif (blocknr < other && other - (blocknr + blocksize) < 32768)\n\t\treturn 1;\n\tif (blocknr > other && blocknr - (other + blocksize) < 32768)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int close_blocks(u64 blocknr, u64 other, u32 blocksize)\n{\n\tif (blocknr < other && other - (blocknr + blocksize) < 32768)\n\t\treturn 1;\n\tif (blocknr > other && blocknr - (other + blocksize) < 32768)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "parent",
            "i + 1"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "parent",
            "i"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "comp_keys",
          "args": [
            "&disk_key",
            "progress"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "comp_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1586-1593",
          "snippet": "static int comp_keys(struct btrfs_disk_key *disk, struct btrfs_key *k2)\n{\n\tstruct btrfs_key k1;\n\n\tbtrfs_disk_key_to_cpu(&k1, disk);\n\n\treturn btrfs_comp_cpu_keys(&k1, k2);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int comp_keys(struct btrfs_disk_key *disk, struct btrfs_key *k2)\n{\n\tstruct btrfs_key k1;\n\n\tbtrfs_disk_key_to_cpu(&k1, disk);\n\n\treturn btrfs_comp_cpu_keys(&k1, k2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key",
          "args": [
            "parent",
            "&disk_key",
            "i"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "parent"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trans->transid != root->fs_info->generation"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trans->transaction != root->fs_info->running_transaction"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "parent"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_realloc_node(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_root *root, struct extent_buffer *parent,\n\t\t       int start_slot, u64 *last_ret,\n\t\t       struct btrfs_key *progress)\n{\n\tstruct extent_buffer *cur;\n\tu64 blocknr;\n\tu64 gen;\n\tu64 search_start = *last_ret;\n\tu64 last_block = 0;\n\tu64 other;\n\tu32 parent_nritems;\n\tint end_slot;\n\tint i;\n\tint err = 0;\n\tint parent_level;\n\tint uptodate;\n\tu32 blocksize;\n\tint progress_passed = 0;\n\tstruct btrfs_disk_key disk_key;\n\n\tparent_level = btrfs_header_level(parent);\n\n\tWARN_ON(trans->transaction != root->fs_info->running_transaction);\n\tWARN_ON(trans->transid != root->fs_info->generation);\n\n\tparent_nritems = btrfs_header_nritems(parent);\n\tblocksize = root->nodesize;\n\tend_slot = parent_nritems - 1;\n\n\tif (parent_nritems <= 1)\n\t\treturn 0;\n\n\tbtrfs_set_lock_blocking(parent);\n\n\tfor (i = start_slot; i <= end_slot; i++) {\n\t\tint close = 1;\n\n\t\tbtrfs_node_key(parent, &disk_key, i);\n\t\tif (!progress_passed && comp_keys(&disk_key, progress) < 0)\n\t\t\tcontinue;\n\n\t\tprogress_passed = 1;\n\t\tblocknr = btrfs_node_blockptr(parent, i);\n\t\tgen = btrfs_node_ptr_generation(parent, i);\n\t\tif (last_block == 0)\n\t\t\tlast_block = blocknr;\n\n\t\tif (i > 0) {\n\t\t\tother = btrfs_node_blockptr(parent, i - 1);\n\t\t\tclose = close_blocks(blocknr, other, blocksize);\n\t\t}\n\t\tif (!close && i < end_slot) {\n\t\t\tother = btrfs_node_blockptr(parent, i + 1);\n\t\t\tclose = close_blocks(blocknr, other, blocksize);\n\t\t}\n\t\tif (close) {\n\t\t\tlast_block = blocknr;\n\t\t\tcontinue;\n\t\t}\n\n\t\tcur = btrfs_find_tree_block(root, blocknr);\n\t\tif (cur)\n\t\t\tuptodate = btrfs_buffer_uptodate(cur, gen, 0);\n\t\telse\n\t\t\tuptodate = 0;\n\t\tif (!cur || !uptodate) {\n\t\t\tif (!cur) {\n\t\t\t\tcur = read_tree_block(root, blocknr, gen);\n\t\t\t\tif (!cur || !extent_buffer_uptodate(cur)) {\n\t\t\t\t\tfree_extent_buffer(cur);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t} else if (!uptodate) {\n\t\t\t\terr = btrfs_read_buffer(cur, gen);\n\t\t\t\tif (err) {\n\t\t\t\t\tfree_extent_buffer(cur);\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (search_start == 0)\n\t\t\tsearch_start = last_block;\n\n\t\tbtrfs_tree_lock(cur);\n\t\tbtrfs_set_lock_blocking(cur);\n\t\terr = __btrfs_cow_block(trans, root, cur, parent, i,\n\t\t\t\t\t&cur, search_start,\n\t\t\t\t\tmin(16 * blocksize,\n\t\t\t\t\t    (end_slot - i) * blocksize));\n\t\tif (err) {\n\t\t\tbtrfs_tree_unlock(cur);\n\t\t\tfree_extent_buffer(cur);\n\t\t\tbreak;\n\t\t}\n\t\tsearch_start = cur->start;\n\t\tlast_block = cur->start;\n\t\t*last_ret = search_start;\n\t\tbtrfs_tree_unlock(cur);\n\t\tfree_extent_buffer(cur);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "btrfs_comp_cpu_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1598-1613",
    "snippet": "int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "comp_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1586-1593",
    "snippet": "static int comp_keys(struct btrfs_disk_key *disk, struct btrfs_key *k2)\n{\n\tstruct btrfs_key k1;\n\n\tbtrfs_disk_key_to_cpu(&k1, disk);\n\n\treturn btrfs_comp_cpu_keys(&k1, k2);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_comp_cpu_keys",
          "args": [
            "&k1",
            "k2"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_comp_cpu_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1598-1613",
          "snippet": "int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_to_cpu",
          "args": [
            "&k1",
            "disk"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_disk_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2731-2737",
          "snippet": "static inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic int comp_keys(struct btrfs_disk_key *disk, struct btrfs_key *k2)\n{\n\tstruct btrfs_key k1;\n\n\tbtrfs_disk_key_to_cpu(&k1, disk);\n\n\treturn btrfs_comp_cpu_keys(&k1, k2);\n}"
  },
  {
    "function_name": "close_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1574-1581",
    "snippet": "static int close_blocks(u64 blocknr, u64 other, u32 blocksize)\n{\n\tif (blocknr < other && other - (blocknr + blocksize) < 32768)\n\t\treturn 1;\n\tif (blocknr > other && blocknr - (other + blocksize) < 32768)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int close_blocks(u64 blocknr, u64 other, u32 blocksize)\n{\n\tif (blocknr < other && other - (blocknr + blocksize) < 32768)\n\t\treturn 1;\n\tif (blocknr > other && blocknr - (other + blocksize) < 32768)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_cow_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1534-1568",
    "snippet": "noinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_btrfs_cow_block",
          "args": [
            "root",
            "buf",
            "*cow_ret"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_cow_block",
          "args": [
            "trans",
            "root",
            "buf",
            "parent",
            "parent_slot",
            "cow_ret",
            "search_start",
            "0"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1094-1213",
          "snippet": "static noinline int __btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct extent_buffer *buf,\n\t\t\t     struct extent_buffer *parent, int parent_slot,\n\t\t\t     struct extent_buffer **cow_ret,\n\t\t\t     u64 search_start, u64 empty_size)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *cow;\n\tint level, ret;\n\tint last_ref = 0;\n\tint unlock_orig = 0;\n\tu64 parent_start;\n\n\tif (*cow_ret == buf)\n\t\tunlock_orig = 1;\n\n\tbtrfs_assert_tree_locked(buf);\n\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent)\n\t\t\tparent_start = parent->start;\n\t\telse\n\t\t\tparent_start = 0;\n\t} else\n\t\tparent_start = 0;\n\n\tcow = btrfs_alloc_tree_block(trans, root, parent_start,\n\t\t\troot->root_key.objectid, &disk_key, level,\n\t\t\tsearch_start, empty_size);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\t/* cow is set to blocking by btrfs_init_new_buffer */\n\n\tcopy_extent_buffer(cow, buf, 0, 0, cow->len);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, root->root_key.objectid);\n\n\twrite_extent_buffer(cow, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\tret = update_ref_for_cow(trans, root, buf, cow, &last_ref);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\tret = btrfs_reloc_cow_block(trans, root, buf, cow);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (buf == root->node) {\n\t\tWARN_ON(parent && parent != buf);\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\t\tparent_start = buf->start;\n\t\telse\n\t\t\tparent_start = 0;\n\n\t\textent_buffer_get(cow);\n\t\ttree_mod_log_set_root_pointer(root, cow, 1);\n\t\trcu_assign_pointer(root->node, cow);\n\n\t\tbtrfs_free_tree_block(trans, root, buf, parent_start,\n\t\t\t\t      last_ref);\n\t\tfree_extent_buffer(buf);\n\t\tadd_root_to_dirty_list(root);\n\t} else {\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\t\tparent_start = parent->start;\n\t\telse\n\t\t\tparent_start = 0;\n\n\t\tWARN_ON(trans->transid != btrfs_header_generation(parent));\n\t\ttree_mod_log_insert_key(root->fs_info, parent, parent_slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE, GFP_NOFS);\n\t\tbtrfs_set_node_blockptr(parent, parent_slot,\n\t\t\t\t\tcow->start);\n\t\tbtrfs_set_node_ptr_generation(parent, parent_slot,\n\t\t\t\t\t      trans->transid);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\t\tif (last_ref) {\n\t\t\tret = tree_mod_log_free_eb(root->fs_info, buf);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbtrfs_free_tree_block(trans, root, buf, parent_start,\n\t\t\t\t      last_ref);\n\t}\n\tif (unlock_orig)\n\t\tbtrfs_tree_unlock(buf);\n\tfree_extent_buffer_stale(buf);\n\tbtrfs_mark_buffer_dirty(cow);\n\t*cow_ret = cow;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline int __btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct extent_buffer *buf,\n\t\t\t     struct extent_buffer *parent, int parent_slot,\n\t\t\t     struct extent_buffer **cow_ret,\n\t\t\t     u64 search_start, u64 empty_size)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *cow;\n\tint level, ret;\n\tint last_ref = 0;\n\tint unlock_orig = 0;\n\tu64 parent_start;\n\n\tif (*cow_ret == buf)\n\t\tunlock_orig = 1;\n\n\tbtrfs_assert_tree_locked(buf);\n\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent)\n\t\t\tparent_start = parent->start;\n\t\telse\n\t\t\tparent_start = 0;\n\t} else\n\t\tparent_start = 0;\n\n\tcow = btrfs_alloc_tree_block(trans, root, parent_start,\n\t\t\troot->root_key.objectid, &disk_key, level,\n\t\t\tsearch_start, empty_size);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\t/* cow is set to blocking by btrfs_init_new_buffer */\n\n\tcopy_extent_buffer(cow, buf, 0, 0, cow->len);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, root->root_key.objectid);\n\n\twrite_extent_buffer(cow, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\tret = update_ref_for_cow(trans, root, buf, cow, &last_ref);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\tret = btrfs_reloc_cow_block(trans, root, buf, cow);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (buf == root->node) {\n\t\tWARN_ON(parent && parent != buf);\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\t\tparent_start = buf->start;\n\t\telse\n\t\t\tparent_start = 0;\n\n\t\textent_buffer_get(cow);\n\t\ttree_mod_log_set_root_pointer(root, cow, 1);\n\t\trcu_assign_pointer(root->node, cow);\n\n\t\tbtrfs_free_tree_block(trans, root, buf, parent_start,\n\t\t\t\t      last_ref);\n\t\tfree_extent_buffer(buf);\n\t\tadd_root_to_dirty_list(root);\n\t} else {\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\t\tparent_start = parent->start;\n\t\telse\n\t\t\tparent_start = 0;\n\n\t\tWARN_ON(trans->transid != btrfs_header_generation(parent));\n\t\ttree_mod_log_insert_key(root->fs_info, parent, parent_slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE, GFP_NOFS);\n\t\tbtrfs_set_node_blockptr(parent, parent_slot,\n\t\t\t\t\tcow->start);\n\t\tbtrfs_set_node_ptr_generation(parent, parent_slot,\n\t\t\t\t\t      trans->transid);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\t\tif (last_ref) {\n\t\t\tret = tree_mod_log_free_eb(root->fs_info, buf);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbtrfs_free_tree_block(trans, root, buf, parent_start,\n\t\t\t\t      last_ref);\n\t}\n\tif (unlock_orig)\n\t\tbtrfs_tree_unlock(buf);\n\tfree_extent_buffer_stale(buf);\n\tbtrfs_mark_buffer_dirty(cow);\n\t*cow_ret = cow;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking",
          "args": [
            "buf"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "53-56",
          "snippet": "static inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_set_lock_blocking(struct extent_buffer *eb)\n{\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_WRITE_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "1024 * 1024 * 1024"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "should_cow_block",
          "args": [
            "trans",
            "root",
            "buf"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "should_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1499-1527",
          "snippet": "static inline int should_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *buf)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\t/* ensure we can see the force_cow */\n\tsmp_rmb();\n\n\t/*\n\t * We do not need to cow a block if\n\t * 1) this block is not created or changed in this transaction;\n\t * 2) this block does not belong to TREE_RELOC tree;\n\t * 3) the root is not forced COW.\n\t *\n\t * What is forced COW:\n\t *    when we create snapshot during commiting the transaction,\n\t *    after we've finished coping src root, we must COW the shared\n\t *    block to ensure the metadata consistency.\n\t */\n\tif (btrfs_header_generation(buf) == trans->transid &&\n\t    !btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN) &&\n\t    !(root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID &&\n\t      btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)) &&\n\t    !test_bit(BTRFS_ROOT_FORCE_COW, &root->state))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline int should_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *buf)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\t/* ensure we can see the force_cow */\n\tsmp_rmb();\n\n\t/*\n\t * We do not need to cow a block if\n\t * 1) this block is not created or changed in this transaction;\n\t * 2) this block does not belong to TREE_RELOC tree;\n\t * 3) the root is not forced COW.\n\t *\n\t * What is forced COW:\n\t *    when we create snapshot during commiting the transaction,\n\t *    after we've finished coping src root, we must COW the shared\n\t *    block to ensure the metadata consistency.\n\t */\n\tif (btrfs_header_generation(buf) == trans->transid &&\n\t    !btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN) &&\n\t    !(root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID &&\n\t      btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)) &&\n\t    !test_bit(BTRFS_ROOT_FORCE_COW, &root->state))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_CRIT \"trans %llu running %llu\\n\"",
            "trans->transid",
            "root->fs_info->generation"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_CRIT \"trans %llu running %llu\\n\"",
            "trans->transid",
            "root->fs_info->running_transaction->transid"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline int btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t    struct btrfs_root *root, struct extent_buffer *buf,\n\t\t    struct extent_buffer *parent, int parent_slot,\n\t\t    struct extent_buffer **cow_ret)\n{\n\tu64 search_start;\n\tint ret;\n\n\tif (trans->transaction != root->fs_info->running_transaction)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid,\n\t\t       root->fs_info->running_transaction->transid);\n\n\tif (trans->transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"trans %llu running %llu\\n\",\n\t\t       trans->transid, root->fs_info->generation);\n\n\tif (!should_cow_block(trans, root, buf)) {\n\t\t*cow_ret = buf;\n\t\treturn 0;\n\t}\n\n\tsearch_start = buf->start & ~((u64)(1024 * 1024 * 1024) - 1);\n\n\tif (parent)\n\t\tbtrfs_set_lock_blocking(parent);\n\tbtrfs_set_lock_blocking(buf);\n\n\tret = __btrfs_cow_block(trans, root, buf, parent,\n\t\t\t\t parent_slot, cow_ret, search_start, 0);\n\n\ttrace_btrfs_cow_block(root, buf, *cow_ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "should_cow_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1499-1527",
    "snippet": "static inline int should_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *buf)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\t/* ensure we can see the force_cow */\n\tsmp_rmb();\n\n\t/*\n\t * We do not need to cow a block if\n\t * 1) this block is not created or changed in this transaction;\n\t * 2) this block does not belong to TREE_RELOC tree;\n\t * 3) the root is not forced COW.\n\t *\n\t * What is forced COW:\n\t *    when we create snapshot during commiting the transaction,\n\t *    after we've finished coping src root, we must COW the shared\n\t *    block to ensure the metadata consistency.\n\t */\n\tif (btrfs_header_generation(buf) == trans->transid &&\n\t    !btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN) &&\n\t    !(root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID &&\n\t      btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)) &&\n\t    !test_bit(BTRFS_ROOT_FORCE_COW, &root->state))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_FORCE_COW",
            "&root->state"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_flag",
          "args": [
            "buf",
            "BTRFS_HEADER_FLAG_RELOC"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2798-2801",
          "snippet": "static inline int btrfs_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\treturn (btrfs_header_flags(eb) & flag) == flag;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\treturn (btrfs_header_flags(eb) & flag) == flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "buf"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_is_dummy_root",
          "args": [
            "root"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_test_is_dummy_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4198-4205",
          "snippet": "static inline int btrfs_test_is_dummy_root(struct btrfs_root *root)\n{\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\tif (unlikely(test_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state)))\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_ROOT_DUMMY_ROOT\t\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_ROOT_DUMMY_ROOT\t\t4\n\nstatic inline int btrfs_test_is_dummy_root(struct btrfs_root *root)\n{\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\tif (unlikely(test_bit(BTRFS_ROOT_DUMMY_ROOT, &root->state)))\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline int should_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root,\n\t\t\t\t   struct extent_buffer *buf)\n{\n\tif (btrfs_test_is_dummy_root(root))\n\t\treturn 0;\n\n\t/* ensure we can see the force_cow */\n\tsmp_rmb();\n\n\t/*\n\t * We do not need to cow a block if\n\t * 1) this block is not created or changed in this transaction;\n\t * 2) this block does not belong to TREE_RELOC tree;\n\t * 3) the root is not forced COW.\n\t *\n\t * What is forced COW:\n\t *    when we create snapshot during commiting the transaction,\n\t *    after we've finished coping src root, we must COW the shared\n\t *    block to ensure the metadata consistency.\n\t */\n\tif (btrfs_header_generation(buf) == trans->transid &&\n\t    !btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN) &&\n\t    !(root->root_key.objectid != BTRFS_TREE_RELOC_OBJECTID &&\n\t      btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)) &&\n\t    !test_bit(BTRFS_ROOT_FORCE_COW, &root->state))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "btrfs_old_root_level",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1482-1497",
    "snippet": "int btrfs_old_root_level(struct btrfs_root *root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tint level;\n\tstruct extent_buffer *eb_root = btrfs_root_node(root);\n\n\ttm = __tree_mod_log_oldest_root(root->fs_info, eb_root, time_seq);\n\tif (tm && tm->op == MOD_LOG_ROOT_REPLACE) {\n\t\tlevel = tm->old_root.level;\n\t} else {\n\t\tlevel = btrfs_header_level(eb_root);\n\t}\n\tfree_extent_buffer(eb_root);\n\n\treturn level;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb_root"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb_root"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__tree_mod_log_oldest_root",
          "args": [
            "root->fs_info",
            "eb_root",
            "time_seq"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_oldest_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1219-1267",
          "snippet": "static struct tree_mod_elem *\n__tree_mod_log_oldest_root(struct btrfs_fs_info *fs_info,\n\t\t\t   struct extent_buffer *eb_root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 root_logical = eb_root->start;\n\tint looped = 0;\n\n\tif (!time_seq)\n\t\treturn NULL;\n\n\t/*\n\t * the very last operation that's logged for a root is the replacement\n\t * operation (if it is replaced at all). this has the index of the *new*\n\t * root, making it the very first operation that's logged for this root.\n\t */\n\twhile (1) {\n\t\ttm = tree_mod_log_search_oldest(fs_info, root_logical,\n\t\t\t\t\t\ttime_seq);\n\t\tif (!looped && !tm)\n\t\t\treturn NULL;\n\t\t/*\n\t\t * if there are no tree operation for the oldest root, we simply\n\t\t * return it. this should only happen if that (old) root is at\n\t\t * level 0.\n\t\t */\n\t\tif (!tm)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if there's an operation that's not a root replacement, we\n\t\t * found the oldest version of our root. normally, we'll find a\n\t\t * MOD_LOG_KEY_REMOVE_WHILE_FREEING operation here.\n\t\t */\n\t\tif (tm->op != MOD_LOG_ROOT_REPLACE)\n\t\t\tbreak;\n\n\t\tfound = tm;\n\t\troot_logical = tm->old_root.logical;\n\t\tlooped = 1;\n\t}\n\n\t/* if there's no old root to return, return what we found instead */\n\tif (!found)\n\t\tfound = tm;\n\n\treturn found;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\n__tree_mod_log_oldest_root(struct btrfs_fs_info *fs_info,\n\t\t\t   struct extent_buffer *eb_root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 root_logical = eb_root->start;\n\tint looped = 0;\n\n\tif (!time_seq)\n\t\treturn NULL;\n\n\t/*\n\t * the very last operation that's logged for a root is the replacement\n\t * operation (if it is replaced at all). this has the index of the *new*\n\t * root, making it the very first operation that's logged for this root.\n\t */\n\twhile (1) {\n\t\ttm = tree_mod_log_search_oldest(fs_info, root_logical,\n\t\t\t\t\t\ttime_seq);\n\t\tif (!looped && !tm)\n\t\t\treturn NULL;\n\t\t/*\n\t\t * if there are no tree operation for the oldest root, we simply\n\t\t * return it. this should only happen if that (old) root is at\n\t\t * level 0.\n\t\t */\n\t\tif (!tm)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if there's an operation that's not a root replacement, we\n\t\t * found the oldest version of our root. normally, we'll find a\n\t\t * MOD_LOG_KEY_REMOVE_WHILE_FREEING operation here.\n\t\t */\n\t\tif (tm->op != MOD_LOG_ROOT_REPLACE)\n\t\t\tbreak;\n\n\t\tfound = tm;\n\t\troot_logical = tm->old_root.logical;\n\t\tlooped = 1;\n\t}\n\n\t/* if there's no old root to return, return what we found instead */\n\tif (!found)\n\t\tfound = tm;\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_node",
          "args": [
            "root"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "148-170",
          "snippet": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nint btrfs_old_root_level(struct btrfs_root *root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tint level;\n\tstruct extent_buffer *eb_root = btrfs_root_node(root);\n\n\ttm = __tree_mod_log_oldest_root(root->fs_info, eb_root, time_seq);\n\tif (tm && tm->op == MOD_LOG_ROOT_REPLACE) {\n\t\tlevel = tm->old_root.level;\n\t} else {\n\t\tlevel = btrfs_header_level(eb_root);\n\t}\n\tfree_extent_buffer(eb_root);\n\n\treturn level;\n}"
  },
  {
    "function_name": "get_old_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1414-1480",
    "snippet": "static inline struct extent_buffer *\nget_old_root(struct btrfs_root *root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tstruct extent_buffer *eb = NULL;\n\tstruct extent_buffer *eb_root;\n\tstruct extent_buffer *old;\n\tstruct tree_mod_root *old_root = NULL;\n\tu64 old_generation = 0;\n\tu64 logical;\n\n\teb_root = btrfs_read_lock_root_node(root);\n\ttm = __tree_mod_log_oldest_root(root->fs_info, eb_root, time_seq);\n\tif (!tm)\n\t\treturn eb_root;\n\n\tif (tm->op == MOD_LOG_ROOT_REPLACE) {\n\t\told_root = &tm->old_root;\n\t\told_generation = tm->generation;\n\t\tlogical = old_root->logical;\n\t} else {\n\t\tlogical = eb_root->start;\n\t}\n\n\ttm = tree_mod_log_search(root->fs_info, logical, time_seq);\n\tif (old_root && tm && tm->op != MOD_LOG_KEY_REMOVE_WHILE_FREEING) {\n\t\tbtrfs_tree_read_unlock(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t\told = read_tree_block(root, logical, 0);\n\t\tif (WARN_ON(!old || !extent_buffer_uptodate(old))) {\n\t\t\tfree_extent_buffer(old);\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t\t\"failed to read tree block %llu from get_old_root\", logical);\n\t\t} else {\n\t\t\teb = btrfs_clone_extent_buffer(old);\n\t\t\tfree_extent_buffer(old);\n\t\t}\n\t} else if (old_root) {\n\t\tbtrfs_tree_read_unlock(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t\teb = alloc_dummy_extent_buffer(root->fs_info, logical);\n\t} else {\n\t\tbtrfs_set_lock_blocking_rw(eb_root, BTRFS_READ_LOCK);\n\t\teb = btrfs_clone_extent_buffer(eb_root);\n\t\tbtrfs_tree_read_unlock_blocking(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t}\n\n\tif (!eb)\n\t\treturn NULL;\n\textent_buffer_get(eb);\n\tbtrfs_tree_read_lock(eb);\n\tif (old_root) {\n\t\tbtrfs_set_header_bytenr(eb, eb->start);\n\t\tbtrfs_set_header_backref_rev(eb, BTRFS_MIXED_BACKREF_REV);\n\t\tbtrfs_set_header_owner(eb, btrfs_header_owner(eb_root));\n\t\tbtrfs_set_header_level(eb, old_root->level);\n\t\tbtrfs_set_header_generation(eb, old_generation);\n\t}\n\tif (tm)\n\t\t__tree_mod_log_rewind(root->fs_info, eb, time_seq, tm);\n\telse\n\t\tWARN_ON(btrfs_header_level(eb) != 0);\n\tWARN_ON(btrfs_header_nritems(eb) > BTRFS_NODEPTRS_PER_BLOCK(root));\n\n\treturn eb;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_nritems(eb) > BTRFS_NODEPTRS_PER_BLOCK(root)"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_NODEPTRS_PER_BLOCK",
          "args": [
            "root"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_level(eb) != 0"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__tree_mod_log_rewind",
          "args": [
            "root->fs_info",
            "eb",
            "time_seq",
            "tm"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_rewind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1274-1343",
          "snippet": "static void\n__tree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct extent_buffer *eb,\n\t\t      u64 time_seq, struct tree_mod_elem *first_tm)\n{\n\tu32 n;\n\tstruct rb_node *next;\n\tstruct tree_mod_elem *tm = first_tm;\n\tunsigned long o_dst;\n\tunsigned long o_src;\n\tunsigned long p_size = sizeof(struct btrfs_key_ptr);\n\n\tn = btrfs_header_nritems(eb);\n\ttree_mod_log_read_lock(fs_info);\n\twhile (tm && tm->seq >= time_seq) {\n\t\t/*\n\t\t * all the operations are recorded with the operator used for\n\t\t * the modification. as we're going backwards, we do the\n\t\t * opposite of each operation here.\n\t\t */\n\t\tswitch (tm->op) {\n\t\tcase MOD_LOG_KEY_REMOVE_WHILE_FREEING:\n\t\t\tBUG_ON(tm->slot < n);\n\t\t\t/* Fallthrough */\n\t\tcase MOD_LOG_KEY_REMOVE_WHILE_MOVING:\n\t\tcase MOD_LOG_KEY_REMOVE:\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tn++;\n\t\t\tbreak;\n\t\tcase MOD_LOG_KEY_REPLACE:\n\t\t\tBUG_ON(tm->slot >= n);\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tbreak;\n\t\tcase MOD_LOG_KEY_ADD:\n\t\t\t/* if a move operation is needed it's in the log */\n\t\t\tn--;\n\t\t\tbreak;\n\t\tcase MOD_LOG_MOVE_KEYS:\n\t\t\to_dst = btrfs_node_key_ptr_offset(tm->slot);\n\t\t\to_src = btrfs_node_key_ptr_offset(tm->move.dst_slot);\n\t\t\tmemmove_extent_buffer(eb, o_dst, o_src,\n\t\t\t\t\t      tm->move.nr_items * p_size);\n\t\t\tbreak;\n\t\tcase MOD_LOG_ROOT_REPLACE:\n\t\t\t/*\n\t\t\t * this operation is special. for roots, this must be\n\t\t\t * handled explicitly before rewinding.\n\t\t\t * for non-roots, this operation may exist if the node\n\t\t\t * was a root: root A -> child B; then A gets empty and\n\t\t\t * B is promoted to the new root. in the mod log, we'll\n\t\t\t * have a root-replace operation for B, a tree block\n\t\t\t * that is no root. we simply ignore that operation.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tnext = rb_next(&tm->node);\n\t\tif (!next)\n\t\t\tbreak;\n\t\ttm = container_of(next, struct tree_mod_elem, node);\n\t\tif (tm->index != first_tm->index)\n\t\t\tbreak;\n\t}\n\ttree_mod_log_read_unlock(fs_info);\n\tbtrfs_set_header_nritems(eb, n);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic void\n__tree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct extent_buffer *eb,\n\t\t      u64 time_seq, struct tree_mod_elem *first_tm)\n{\n\tu32 n;\n\tstruct rb_node *next;\n\tstruct tree_mod_elem *tm = first_tm;\n\tunsigned long o_dst;\n\tunsigned long o_src;\n\tunsigned long p_size = sizeof(struct btrfs_key_ptr);\n\n\tn = btrfs_header_nritems(eb);\n\ttree_mod_log_read_lock(fs_info);\n\twhile (tm && tm->seq >= time_seq) {\n\t\t/*\n\t\t * all the operations are recorded with the operator used for\n\t\t * the modification. as we're going backwards, we do the\n\t\t * opposite of each operation here.\n\t\t */\n\t\tswitch (tm->op) {\n\t\tcase MOD_LOG_KEY_REMOVE_WHILE_FREEING:\n\t\t\tBUG_ON(tm->slot < n);\n\t\t\t/* Fallthrough */\n\t\tcase MOD_LOG_KEY_REMOVE_WHILE_MOVING:\n\t\tcase MOD_LOG_KEY_REMOVE:\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tn++;\n\t\t\tbreak;\n\t\tcase MOD_LOG_KEY_REPLACE:\n\t\t\tBUG_ON(tm->slot >= n);\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tbreak;\n\t\tcase MOD_LOG_KEY_ADD:\n\t\t\t/* if a move operation is needed it's in the log */\n\t\t\tn--;\n\t\t\tbreak;\n\t\tcase MOD_LOG_MOVE_KEYS:\n\t\t\to_dst = btrfs_node_key_ptr_offset(tm->slot);\n\t\t\to_src = btrfs_node_key_ptr_offset(tm->move.dst_slot);\n\t\t\tmemmove_extent_buffer(eb, o_dst, o_src,\n\t\t\t\t\t      tm->move.nr_items * p_size);\n\t\t\tbreak;\n\t\tcase MOD_LOG_ROOT_REPLACE:\n\t\t\t/*\n\t\t\t * this operation is special. for roots, this must be\n\t\t\t * handled explicitly before rewinding.\n\t\t\t * for non-roots, this operation may exist if the node\n\t\t\t * was a root: root A -> child B; then A gets empty and\n\t\t\t * B is promoted to the new root. in the mod log, we'll\n\t\t\t * have a root-replace operation for B, a tree block\n\t\t\t * that is no root. we simply ignore that operation.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tnext = rb_next(&tm->node);\n\t\tif (!next)\n\t\t\tbreak;\n\t\ttm = container_of(next, struct tree_mod_elem, node);\n\t\tif (tm->index != first_tm->index)\n\t\t\tbreak;\n\t}\n\ttree_mod_log_read_unlock(fs_info);\n\tbtrfs_set_header_nritems(eb, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_generation",
          "args": [
            "eb",
            "old_generation"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_level",
          "args": [
            "eb",
            "old_root->level"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_owner",
          "args": [
            "eb",
            "btrfs_header_owner(eb_root)"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_owner",
          "args": [
            "eb_root"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_backref_rev",
          "args": [
            "eb",
            "BTRFS_MIXED_BACKREF_REV"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2823-2830",
          "snippet": "static inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)",
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_bytenr",
          "args": [
            "eb",
            "eb->start"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_lock",
          "args": [
            "eb"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_lock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "135-148",
          "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "eb"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb_root"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_unlock_blocking",
          "args": [
            "eb_root"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clone_extent_buffer",
          "args": [
            "eb_root"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clone_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4642-4670",
          "snippet": "struct extent_buffer *btrfs_clone_extent_buffer(struct extent_buffer *src)\n{\n\tunsigned long i;\n\tstruct page *p;\n\tstruct extent_buffer *new;\n\tunsigned long num_pages = num_extent_pages(src->start, src->len);\n\n\tnew = __alloc_extent_buffer(src->fs_info, src->start, src->len);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tp = alloc_page(GFP_NOFS);\n\t\tif (!p) {\n\t\t\tbtrfs_release_extent_buffer(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tattach_extent_buffer_page(new, p);\n\t\tWARN_ON(PageDirty(p));\n\t\tSetPageUptodate(p);\n\t\tnew->pages[i] = p;\n\t}\n\n\tcopy_extent_buffer(new, src, 0, 0, src->len);\n\tset_bit(EXTENT_BUFFER_UPTODATE, &new->bflags);\n\tset_bit(EXTENT_BUFFER_DUMMY, &new->bflags);\n\n\treturn new;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *btrfs_clone_extent_buffer(struct extent_buffer *src)\n{\n\tunsigned long i;\n\tstruct page *p;\n\tstruct extent_buffer *new;\n\tunsigned long num_pages = num_extent_pages(src->start, src->len);\n\n\tnew = __alloc_extent_buffer(src->fs_info, src->start, src->len);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tp = alloc_page(GFP_NOFS);\n\t\tif (!p) {\n\t\t\tbtrfs_release_extent_buffer(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tattach_extent_buffer_page(new, p);\n\t\tWARN_ON(PageDirty(p));\n\t\tSetPageUptodate(p);\n\t\tnew->pages[i] = p;\n\t}\n\n\tcopy_extent_buffer(new, src, 0, 0, src->len);\n\tset_bit(EXTENT_BUFFER_UPTODATE, &new->bflags);\n\tset_bit(EXTENT_BUFFER_DUMMY, &new->bflags);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking_rw",
          "args": [
            "eb_root",
            "BTRFS_READ_LOCK"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "34-60",
          "snippet": "void btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_dummy_extent_buffer",
          "args": [
            "root->fs_info",
            "logical"
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_dummy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4672-4710",
          "snippet": "struct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"failed to read tree block %llu from get_old_root\"",
            "logical"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!old || !extent_buffer_uptodate(old)"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "old"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_block",
          "args": [
            "root",
            "logical",
            "0"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1149-1166",
          "snippet": "struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_log_search",
          "args": [
            "root->fs_info",
            "logical",
            "time_seq"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "794-798",
          "snippet": "static struct tree_mod_elem *\ntree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq)\n{\n\treturn __tree_mod_log_search(fs_info, start, min_seq, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\ntree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq)\n{\n\treturn __tree_mod_log_search(fs_info, start, min_seq, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__tree_mod_log_oldest_root",
          "args": [
            "root->fs_info",
            "eb_root",
            "time_seq"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_oldest_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1219-1267",
          "snippet": "static struct tree_mod_elem *\n__tree_mod_log_oldest_root(struct btrfs_fs_info *fs_info,\n\t\t\t   struct extent_buffer *eb_root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 root_logical = eb_root->start;\n\tint looped = 0;\n\n\tif (!time_seq)\n\t\treturn NULL;\n\n\t/*\n\t * the very last operation that's logged for a root is the replacement\n\t * operation (if it is replaced at all). this has the index of the *new*\n\t * root, making it the very first operation that's logged for this root.\n\t */\n\twhile (1) {\n\t\ttm = tree_mod_log_search_oldest(fs_info, root_logical,\n\t\t\t\t\t\ttime_seq);\n\t\tif (!looped && !tm)\n\t\t\treturn NULL;\n\t\t/*\n\t\t * if there are no tree operation for the oldest root, we simply\n\t\t * return it. this should only happen if that (old) root is at\n\t\t * level 0.\n\t\t */\n\t\tif (!tm)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if there's an operation that's not a root replacement, we\n\t\t * found the oldest version of our root. normally, we'll find a\n\t\t * MOD_LOG_KEY_REMOVE_WHILE_FREEING operation here.\n\t\t */\n\t\tif (tm->op != MOD_LOG_ROOT_REPLACE)\n\t\t\tbreak;\n\n\t\tfound = tm;\n\t\troot_logical = tm->old_root.logical;\n\t\tlooped = 1;\n\t}\n\n\t/* if there's no old root to return, return what we found instead */\n\tif (!found)\n\t\tfound = tm;\n\n\treturn found;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\n__tree_mod_log_oldest_root(struct btrfs_fs_info *fs_info,\n\t\t\t   struct extent_buffer *eb_root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 root_logical = eb_root->start;\n\tint looped = 0;\n\n\tif (!time_seq)\n\t\treturn NULL;\n\n\t/*\n\t * the very last operation that's logged for a root is the replacement\n\t * operation (if it is replaced at all). this has the index of the *new*\n\t * root, making it the very first operation that's logged for this root.\n\t */\n\twhile (1) {\n\t\ttm = tree_mod_log_search_oldest(fs_info, root_logical,\n\t\t\t\t\t\ttime_seq);\n\t\tif (!looped && !tm)\n\t\t\treturn NULL;\n\t\t/*\n\t\t * if there are no tree operation for the oldest root, we simply\n\t\t * return it. this should only happen if that (old) root is at\n\t\t * level 0.\n\t\t */\n\t\tif (!tm)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if there's an operation that's not a root replacement, we\n\t\t * found the oldest version of our root. normally, we'll find a\n\t\t * MOD_LOG_KEY_REMOVE_WHILE_FREEING operation here.\n\t\t */\n\t\tif (tm->op != MOD_LOG_ROOT_REPLACE)\n\t\t\tbreak;\n\n\t\tfound = tm;\n\t\troot_logical = tm->old_root.logical;\n\t\tlooped = 1;\n\t}\n\n\t/* if there's no old root to return, return what we found instead */\n\tif (!found)\n\t\tfound = tm;\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_read_lock_root_node",
          "args": [
            "root"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_lock_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "195-208",
          "snippet": "static struct extent_buffer *btrfs_read_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_read_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_read_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic struct extent_buffer *btrfs_read_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_read_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_read_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline struct extent_buffer *\nget_old_root(struct btrfs_root *root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tstruct extent_buffer *eb = NULL;\n\tstruct extent_buffer *eb_root;\n\tstruct extent_buffer *old;\n\tstruct tree_mod_root *old_root = NULL;\n\tu64 old_generation = 0;\n\tu64 logical;\n\n\teb_root = btrfs_read_lock_root_node(root);\n\ttm = __tree_mod_log_oldest_root(root->fs_info, eb_root, time_seq);\n\tif (!tm)\n\t\treturn eb_root;\n\n\tif (tm->op == MOD_LOG_ROOT_REPLACE) {\n\t\told_root = &tm->old_root;\n\t\told_generation = tm->generation;\n\t\tlogical = old_root->logical;\n\t} else {\n\t\tlogical = eb_root->start;\n\t}\n\n\ttm = tree_mod_log_search(root->fs_info, logical, time_seq);\n\tif (old_root && tm && tm->op != MOD_LOG_KEY_REMOVE_WHILE_FREEING) {\n\t\tbtrfs_tree_read_unlock(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t\told = read_tree_block(root, logical, 0);\n\t\tif (WARN_ON(!old || !extent_buffer_uptodate(old))) {\n\t\t\tfree_extent_buffer(old);\n\t\t\tbtrfs_warn(root->fs_info,\n\t\t\t\t\"failed to read tree block %llu from get_old_root\", logical);\n\t\t} else {\n\t\t\teb = btrfs_clone_extent_buffer(old);\n\t\t\tfree_extent_buffer(old);\n\t\t}\n\t} else if (old_root) {\n\t\tbtrfs_tree_read_unlock(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t\teb = alloc_dummy_extent_buffer(root->fs_info, logical);\n\t} else {\n\t\tbtrfs_set_lock_blocking_rw(eb_root, BTRFS_READ_LOCK);\n\t\teb = btrfs_clone_extent_buffer(eb_root);\n\t\tbtrfs_tree_read_unlock_blocking(eb_root);\n\t\tfree_extent_buffer(eb_root);\n\t}\n\n\tif (!eb)\n\t\treturn NULL;\n\textent_buffer_get(eb);\n\tbtrfs_tree_read_lock(eb);\n\tif (old_root) {\n\t\tbtrfs_set_header_bytenr(eb, eb->start);\n\t\tbtrfs_set_header_backref_rev(eb, BTRFS_MIXED_BACKREF_REV);\n\t\tbtrfs_set_header_owner(eb, btrfs_header_owner(eb_root));\n\t\tbtrfs_set_header_level(eb, old_root->level);\n\t\tbtrfs_set_header_generation(eb, old_generation);\n\t}\n\tif (tm)\n\t\t__tree_mod_log_rewind(root->fs_info, eb, time_seq, tm);\n\telse\n\t\tWARN_ON(btrfs_header_level(eb) != 0);\n\tWARN_ON(btrfs_header_nritems(eb) > BTRFS_NODEPTRS_PER_BLOCK(root));\n\n\treturn eb;\n}"
  },
  {
    "function_name": "tree_mod_log_rewind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1352-1405",
    "snippet": "static struct extent_buffer *\ntree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct btrfs_path *path,\n\t\t    struct extent_buffer *eb, u64 time_seq)\n{\n\tstruct extent_buffer *eb_rewin;\n\tstruct tree_mod_elem *tm;\n\n\tif (!time_seq)\n\t\treturn eb;\n\n\tif (btrfs_header_level(eb) == 0)\n\t\treturn eb;\n\n\ttm = tree_mod_log_search(fs_info, eb->start, time_seq);\n\tif (!tm)\n\t\treturn eb;\n\n\tbtrfs_set_path_blocking(path);\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\n\tif (tm->op == MOD_LOG_KEY_REMOVE_WHILE_FREEING) {\n\t\tBUG_ON(tm->slot != 0);\n\t\teb_rewin = alloc_dummy_extent_buffer(fs_info, eb->start);\n\t\tif (!eb_rewin) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn NULL;\n\t\t}\n\t\tbtrfs_set_header_bytenr(eb_rewin, eb->start);\n\t\tbtrfs_set_header_backref_rev(eb_rewin,\n\t\t\t\t\t     btrfs_header_backref_rev(eb));\n\t\tbtrfs_set_header_owner(eb_rewin, btrfs_header_owner(eb));\n\t\tbtrfs_set_header_level(eb_rewin, btrfs_header_level(eb));\n\t} else {\n\t\teb_rewin = btrfs_clone_extent_buffer(eb);\n\t\tif (!eb_rewin) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tbtrfs_clear_path_blocking(path, NULL, BTRFS_READ_LOCK);\n\tbtrfs_tree_read_unlock_blocking(eb);\n\tfree_extent_buffer(eb);\n\n\textent_buffer_get(eb_rewin);\n\tbtrfs_tree_read_lock(eb_rewin);\n\t__tree_mod_log_rewind(fs_info, eb_rewin, time_seq, tm);\n\tWARN_ON(btrfs_header_nritems(eb_rewin) >\n\t\tBTRFS_NODEPTRS_PER_BLOCK(fs_info->tree_root));\n\n\treturn eb_rewin;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_nritems(eb_rewin) >\n\t\tBTRFS_NODEPTRS_PER_BLOCK(fs_info->tree_root)"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BTRFS_NODEPTRS_PER_BLOCK",
          "args": [
            "fs_info->tree_root"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb_rewin"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__tree_mod_log_rewind",
          "args": [
            "fs_info",
            "eb_rewin",
            "time_seq",
            "tm"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_rewind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1274-1343",
          "snippet": "static void\n__tree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct extent_buffer *eb,\n\t\t      u64 time_seq, struct tree_mod_elem *first_tm)\n{\n\tu32 n;\n\tstruct rb_node *next;\n\tstruct tree_mod_elem *tm = first_tm;\n\tunsigned long o_dst;\n\tunsigned long o_src;\n\tunsigned long p_size = sizeof(struct btrfs_key_ptr);\n\n\tn = btrfs_header_nritems(eb);\n\ttree_mod_log_read_lock(fs_info);\n\twhile (tm && tm->seq >= time_seq) {\n\t\t/*\n\t\t * all the operations are recorded with the operator used for\n\t\t * the modification. as we're going backwards, we do the\n\t\t * opposite of each operation here.\n\t\t */\n\t\tswitch (tm->op) {\n\t\tcase MOD_LOG_KEY_REMOVE_WHILE_FREEING:\n\t\t\tBUG_ON(tm->slot < n);\n\t\t\t/* Fallthrough */\n\t\tcase MOD_LOG_KEY_REMOVE_WHILE_MOVING:\n\t\tcase MOD_LOG_KEY_REMOVE:\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tn++;\n\t\t\tbreak;\n\t\tcase MOD_LOG_KEY_REPLACE:\n\t\t\tBUG_ON(tm->slot >= n);\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tbreak;\n\t\tcase MOD_LOG_KEY_ADD:\n\t\t\t/* if a move operation is needed it's in the log */\n\t\t\tn--;\n\t\t\tbreak;\n\t\tcase MOD_LOG_MOVE_KEYS:\n\t\t\to_dst = btrfs_node_key_ptr_offset(tm->slot);\n\t\t\to_src = btrfs_node_key_ptr_offset(tm->move.dst_slot);\n\t\t\tmemmove_extent_buffer(eb, o_dst, o_src,\n\t\t\t\t\t      tm->move.nr_items * p_size);\n\t\t\tbreak;\n\t\tcase MOD_LOG_ROOT_REPLACE:\n\t\t\t/*\n\t\t\t * this operation is special. for roots, this must be\n\t\t\t * handled explicitly before rewinding.\n\t\t\t * for non-roots, this operation may exist if the node\n\t\t\t * was a root: root A -> child B; then A gets empty and\n\t\t\t * B is promoted to the new root. in the mod log, we'll\n\t\t\t * have a root-replace operation for B, a tree block\n\t\t\t * that is no root. we simply ignore that operation.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tnext = rb_next(&tm->node);\n\t\tif (!next)\n\t\t\tbreak;\n\t\ttm = container_of(next, struct tree_mod_elem, node);\n\t\tif (tm->index != first_tm->index)\n\t\t\tbreak;\n\t}\n\ttree_mod_log_read_unlock(fs_info);\n\tbtrfs_set_header_nritems(eb, n);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic void\n__tree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct extent_buffer *eb,\n\t\t      u64 time_seq, struct tree_mod_elem *first_tm)\n{\n\tu32 n;\n\tstruct rb_node *next;\n\tstruct tree_mod_elem *tm = first_tm;\n\tunsigned long o_dst;\n\tunsigned long o_src;\n\tunsigned long p_size = sizeof(struct btrfs_key_ptr);\n\n\tn = btrfs_header_nritems(eb);\n\ttree_mod_log_read_lock(fs_info);\n\twhile (tm && tm->seq >= time_seq) {\n\t\t/*\n\t\t * all the operations are recorded with the operator used for\n\t\t * the modification. as we're going backwards, we do the\n\t\t * opposite of each operation here.\n\t\t */\n\t\tswitch (tm->op) {\n\t\tcase MOD_LOG_KEY_REMOVE_WHILE_FREEING:\n\t\t\tBUG_ON(tm->slot < n);\n\t\t\t/* Fallthrough */\n\t\tcase MOD_LOG_KEY_REMOVE_WHILE_MOVING:\n\t\tcase MOD_LOG_KEY_REMOVE:\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tn++;\n\t\t\tbreak;\n\t\tcase MOD_LOG_KEY_REPLACE:\n\t\t\tBUG_ON(tm->slot >= n);\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tbreak;\n\t\tcase MOD_LOG_KEY_ADD:\n\t\t\t/* if a move operation is needed it's in the log */\n\t\t\tn--;\n\t\t\tbreak;\n\t\tcase MOD_LOG_MOVE_KEYS:\n\t\t\to_dst = btrfs_node_key_ptr_offset(tm->slot);\n\t\t\to_src = btrfs_node_key_ptr_offset(tm->move.dst_slot);\n\t\t\tmemmove_extent_buffer(eb, o_dst, o_src,\n\t\t\t\t\t      tm->move.nr_items * p_size);\n\t\t\tbreak;\n\t\tcase MOD_LOG_ROOT_REPLACE:\n\t\t\t/*\n\t\t\t * this operation is special. for roots, this must be\n\t\t\t * handled explicitly before rewinding.\n\t\t\t * for non-roots, this operation may exist if the node\n\t\t\t * was a root: root A -> child B; then A gets empty and\n\t\t\t * B is promoted to the new root. in the mod log, we'll\n\t\t\t * have a root-replace operation for B, a tree block\n\t\t\t * that is no root. we simply ignore that operation.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tnext = rb_next(&tm->node);\n\t\tif (!next)\n\t\t\tbreak;\n\t\ttm = container_of(next, struct tree_mod_elem, node);\n\t\tif (tm->index != first_tm->index)\n\t\t\tbreak;\n\t}\n\ttree_mod_log_read_unlock(fs_info);\n\tbtrfs_set_header_nritems(eb, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_lock",
          "args": [
            "eb_rewin"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_lock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "135-148",
          "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "eb_rewin"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_unlock_blocking",
          "args": [
            "eb"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clear_path_blocking",
          "args": [
            "path",
            "NULL",
            "BTRFS_READ_LOCK"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "78-104",
          "snippet": "noinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clone_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clone_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4642-4670",
          "snippet": "struct extent_buffer *btrfs_clone_extent_buffer(struct extent_buffer *src)\n{\n\tunsigned long i;\n\tstruct page *p;\n\tstruct extent_buffer *new;\n\tunsigned long num_pages = num_extent_pages(src->start, src->len);\n\n\tnew = __alloc_extent_buffer(src->fs_info, src->start, src->len);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tp = alloc_page(GFP_NOFS);\n\t\tif (!p) {\n\t\t\tbtrfs_release_extent_buffer(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tattach_extent_buffer_page(new, p);\n\t\tWARN_ON(PageDirty(p));\n\t\tSetPageUptodate(p);\n\t\tnew->pages[i] = p;\n\t}\n\n\tcopy_extent_buffer(new, src, 0, 0, src->len);\n\tset_bit(EXTENT_BUFFER_UPTODATE, &new->bflags);\n\tset_bit(EXTENT_BUFFER_DUMMY, &new->bflags);\n\n\treturn new;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *btrfs_clone_extent_buffer(struct extent_buffer *src)\n{\n\tunsigned long i;\n\tstruct page *p;\n\tstruct extent_buffer *new;\n\tunsigned long num_pages = num_extent_pages(src->start, src->len);\n\n\tnew = __alloc_extent_buffer(src->fs_info, src->start, src->len);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tp = alloc_page(GFP_NOFS);\n\t\tif (!p) {\n\t\t\tbtrfs_release_extent_buffer(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tattach_extent_buffer_page(new, p);\n\t\tWARN_ON(PageDirty(p));\n\t\tSetPageUptodate(p);\n\t\tnew->pages[i] = p;\n\t}\n\n\tcopy_extent_buffer(new, src, 0, 0, src->len);\n\tset_bit(EXTENT_BUFFER_UPTODATE, &new->bflags);\n\tset_bit(EXTENT_BUFFER_DUMMY, &new->bflags);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_level",
          "args": [
            "eb_rewin",
            "btrfs_header_level(eb)"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_owner",
          "args": [
            "eb_rewin",
            "btrfs_header_owner(eb)"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_owner",
          "args": [
            "eb"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_backref_rev",
          "args": [
            "eb_rewin",
            "btrfs_header_backref_rev(eb)"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2823-2830",
          "snippet": "static inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)",
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_backref_rev",
          "args": [
            "eb"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2817-2821",
          "snippet": "static inline int btrfs_header_backref_rev(struct extent_buffer *eb)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\treturn flags >> BTRFS_BACKREF_REV_SHIFT;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline int btrfs_header_backref_rev(struct extent_buffer *eb)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\treturn flags >> BTRFS_BACKREF_REV_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_bytenr",
          "args": [
            "eb_rewin",
            "eb->start"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_dummy_extent_buffer",
          "args": [
            "fs_info",
            "eb->start"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_dummy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4672-4710",
          "snippet": "struct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *alloc_dummy_extent_buffer(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tu64 start)\n{\n\tstruct extent_buffer *eb;\n\tunsigned long len;\n\tunsigned long num_pages;\n\tunsigned long i;\n\n\tif (!fs_info) {\n\t\t/*\n\t\t * Called only from tests that don't always have a fs_info\n\t\t * available, but we know that nodesize is 4096\n\t\t */\n\t\tlen = 4096;\n\t} else {\n\t\tlen = fs_info->tree_root->nodesize;\n\t}\n\tnum_pages = num_extent_pages(0, len);\n\n\teb = __alloc_extent_buffer(fs_info, start, len);\n\tif (!eb)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\teb->pages[i] = alloc_page(GFP_NOFS);\n\t\tif (!eb->pages[i])\n\t\t\tgoto err;\n\t}\n\tset_extent_buffer_uptodate(eb);\n\tbtrfs_set_header_nritems(eb, 0);\n\tset_bit(EXTENT_BUFFER_DUMMY, &eb->bflags);\n\n\treturn eb;\nerr:\n\tfor (; i > 0; i--)\n\t\t__free_page(eb->pages[i - 1]);\n\t__free_extent_buffer(eb);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tm->slot != 0"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking_rw",
          "args": [
            "eb",
            "BTRFS_READ_LOCK"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "34-60",
          "snippet": "void btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "path"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_log_search",
          "args": [
            "fs_info",
            "eb->start",
            "time_seq"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "794-798",
          "snippet": "static struct tree_mod_elem *\ntree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq)\n{\n\treturn __tree_mod_log_search(fs_info, start, min_seq, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\ntree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq)\n{\n\treturn __tree_mod_log_search(fs_info, start, min_seq, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic struct extent_buffer *\ntree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct btrfs_path *path,\n\t\t    struct extent_buffer *eb, u64 time_seq)\n{\n\tstruct extent_buffer *eb_rewin;\n\tstruct tree_mod_elem *tm;\n\n\tif (!time_seq)\n\t\treturn eb;\n\n\tif (btrfs_header_level(eb) == 0)\n\t\treturn eb;\n\n\ttm = tree_mod_log_search(fs_info, eb->start, time_seq);\n\tif (!tm)\n\t\treturn eb;\n\n\tbtrfs_set_path_blocking(path);\n\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\n\tif (tm->op == MOD_LOG_KEY_REMOVE_WHILE_FREEING) {\n\t\tBUG_ON(tm->slot != 0);\n\t\teb_rewin = alloc_dummy_extent_buffer(fs_info, eb->start);\n\t\tif (!eb_rewin) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn NULL;\n\t\t}\n\t\tbtrfs_set_header_bytenr(eb_rewin, eb->start);\n\t\tbtrfs_set_header_backref_rev(eb_rewin,\n\t\t\t\t\t     btrfs_header_backref_rev(eb));\n\t\tbtrfs_set_header_owner(eb_rewin, btrfs_header_owner(eb));\n\t\tbtrfs_set_header_level(eb_rewin, btrfs_header_level(eb));\n\t} else {\n\t\teb_rewin = btrfs_clone_extent_buffer(eb);\n\t\tif (!eb_rewin) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tbtrfs_clear_path_blocking(path, NULL, BTRFS_READ_LOCK);\n\tbtrfs_tree_read_unlock_blocking(eb);\n\tfree_extent_buffer(eb);\n\n\textent_buffer_get(eb_rewin);\n\tbtrfs_tree_read_lock(eb_rewin);\n\t__tree_mod_log_rewind(fs_info, eb_rewin, time_seq, tm);\n\tWARN_ON(btrfs_header_nritems(eb_rewin) >\n\t\tBTRFS_NODEPTRS_PER_BLOCK(fs_info->tree_root));\n\n\treturn eb_rewin;\n}"
  },
  {
    "function_name": "__tree_mod_log_rewind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1274-1343",
    "snippet": "static void\n__tree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct extent_buffer *eb,\n\t\t      u64 time_seq, struct tree_mod_elem *first_tm)\n{\n\tu32 n;\n\tstruct rb_node *next;\n\tstruct tree_mod_elem *tm = first_tm;\n\tunsigned long o_dst;\n\tunsigned long o_src;\n\tunsigned long p_size = sizeof(struct btrfs_key_ptr);\n\n\tn = btrfs_header_nritems(eb);\n\ttree_mod_log_read_lock(fs_info);\n\twhile (tm && tm->seq >= time_seq) {\n\t\t/*\n\t\t * all the operations are recorded with the operator used for\n\t\t * the modification. as we're going backwards, we do the\n\t\t * opposite of each operation here.\n\t\t */\n\t\tswitch (tm->op) {\n\t\tcase MOD_LOG_KEY_REMOVE_WHILE_FREEING:\n\t\t\tBUG_ON(tm->slot < n);\n\t\t\t/* Fallthrough */\n\t\tcase MOD_LOG_KEY_REMOVE_WHILE_MOVING:\n\t\tcase MOD_LOG_KEY_REMOVE:\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tn++;\n\t\t\tbreak;\n\t\tcase MOD_LOG_KEY_REPLACE:\n\t\t\tBUG_ON(tm->slot >= n);\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tbreak;\n\t\tcase MOD_LOG_KEY_ADD:\n\t\t\t/* if a move operation is needed it's in the log */\n\t\t\tn--;\n\t\t\tbreak;\n\t\tcase MOD_LOG_MOVE_KEYS:\n\t\t\to_dst = btrfs_node_key_ptr_offset(tm->slot);\n\t\t\to_src = btrfs_node_key_ptr_offset(tm->move.dst_slot);\n\t\t\tmemmove_extent_buffer(eb, o_dst, o_src,\n\t\t\t\t\t      tm->move.nr_items * p_size);\n\t\t\tbreak;\n\t\tcase MOD_LOG_ROOT_REPLACE:\n\t\t\t/*\n\t\t\t * this operation is special. for roots, this must be\n\t\t\t * handled explicitly before rewinding.\n\t\t\t * for non-roots, this operation may exist if the node\n\t\t\t * was a root: root A -> child B; then A gets empty and\n\t\t\t * B is promoted to the new root. in the mod log, we'll\n\t\t\t * have a root-replace operation for B, a tree block\n\t\t\t * that is no root. we simply ignore that operation.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tnext = rb_next(&tm->node);\n\t\tif (!next)\n\t\t\tbreak;\n\t\ttm = container_of(next, struct tree_mod_elem, node);\n\t\tif (tm->index != first_tm->index)\n\t\t\tbreak;\n\t}\n\ttree_mod_log_read_unlock(fs_info);\n\tbtrfs_set_header_nritems(eb, n);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);",
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_set_header_nritems",
          "args": [
            "eb",
            "n"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_read_unlock",
          "args": [
            "fs_info"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "next",
            "structtree_mod_elem",
            "node"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&tm->node"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove_extent_buffer",
          "args": [
            "eb",
            "o_dst",
            "o_src",
            "tm->move.nr_items * p_size"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "memmove_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5521-5566",
          "snippet": "void memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid memmove_extent_buffer(struct extent_buffer *dst, unsigned long dst_offset,\n\t\t\t   unsigned long src_offset, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t dst_off_in_page;\n\tsize_t src_off_in_page;\n\tunsigned long dst_end = dst_offset + len - 1;\n\tunsigned long src_end = src_offset + len - 1;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long dst_i;\n\tunsigned long src_i;\n\n\tif (src_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus src_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", src_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset + len > dst->len) {\n\t\tprintk(KERN_ERR \"BTRFS: memmove bogus dst_offset %lu move \"\n\t\t       \"len %lu len %lu\\n\", dst_offset, len, dst->len);\n\t\tBUG_ON(1);\n\t}\n\tif (dst_offset < src_offset) {\n\t\tmemcpy_extent_buffer(dst, dst_offset, src_offset, len);\n\t\treturn;\n\t}\n\twhile (len > 0) {\n\t\tdst_i = (start_offset + dst_end) >> PAGE_CACHE_SHIFT;\n\t\tsrc_i = (start_offset + src_end) >> PAGE_CACHE_SHIFT;\n\n\t\tdst_off_in_page = (start_offset + dst_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\t\tsrc_off_in_page = (start_offset + src_end) &\n\t\t\t(PAGE_CACHE_SIZE - 1);\n\n\t\tcur = min_t(unsigned long, len, src_off_in_page + 1);\n\t\tcur = min(cur, dst_off_in_page + 1);\n\t\tcopy_pages(dst->pages[dst_i], dst->pages[src_i],\n\t\t\t   dst_off_in_page - cur + 1,\n\t\t\t   src_off_in_page - cur + 1, cur);\n\n\t\tdst_end -= cur;\n\t\tsrc_end -= cur;\n\t\tlen -= cur;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_ptr_offset",
          "args": [
            "tm->move.dst_slot"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_ptr_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2598-2602",
          "snippet": "static inline unsigned long btrfs_node_key_ptr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_node_key_ptr_offset(int nr)\n{\n\treturn offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_ptr_generation",
          "args": [
            "eb",
            "tm->slot",
            "tm->generation"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2589-2596",
          "snippet": "static inline void btrfs_set_node_ptr_generation(struct extent_buffer *eb,\n\t\t\t\t\t\t int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_generation(eb, (struct btrfs_key_ptr *)ptr, val);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_ptr_generation(struct extent_buffer *eb,\n\t\t\t\t\t\t int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_generation(eb, (struct btrfs_key_ptr *)ptr, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_blockptr",
          "args": [
            "eb",
            "tm->slot",
            "tm->blockptr"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2572-2579",
          "snippet": "static inline void btrfs_set_node_blockptr(struct extent_buffer *eb,\n\t\t\t\t\t   int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_blockptr(eb, (struct btrfs_key_ptr *)ptr, val);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_blockptr(struct extent_buffer *eb,\n\t\t\t\t\t   int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_blockptr(eb, (struct btrfs_key_ptr *)ptr, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_key",
          "args": [
            "eb",
            "&tm->key",
            "tm->slot"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2607-2614",
          "snippet": "static inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_key(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_disk_key *disk_key, int nr)\n{\n\tunsigned long ptr;\n\tptr = btrfs_node_key_ptr_offset(nr);\n\twrite_eb_member(eb, (struct btrfs_key_ptr *)ptr,\n\t\t       struct btrfs_key_ptr, key, disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tm->slot >= n"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tm->slot < n"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_read_lock",
          "args": [
            "fs_info"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int push_node_left(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *dst,\n\t\t\t  struct extent_buffer *src, int empty);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic void\n__tree_mod_log_rewind(struct btrfs_fs_info *fs_info, struct extent_buffer *eb,\n\t\t      u64 time_seq, struct tree_mod_elem *first_tm)\n{\n\tu32 n;\n\tstruct rb_node *next;\n\tstruct tree_mod_elem *tm = first_tm;\n\tunsigned long o_dst;\n\tunsigned long o_src;\n\tunsigned long p_size = sizeof(struct btrfs_key_ptr);\n\n\tn = btrfs_header_nritems(eb);\n\ttree_mod_log_read_lock(fs_info);\n\twhile (tm && tm->seq >= time_seq) {\n\t\t/*\n\t\t * all the operations are recorded with the operator used for\n\t\t * the modification. as we're going backwards, we do the\n\t\t * opposite of each operation here.\n\t\t */\n\t\tswitch (tm->op) {\n\t\tcase MOD_LOG_KEY_REMOVE_WHILE_FREEING:\n\t\t\tBUG_ON(tm->slot < n);\n\t\t\t/* Fallthrough */\n\t\tcase MOD_LOG_KEY_REMOVE_WHILE_MOVING:\n\t\tcase MOD_LOG_KEY_REMOVE:\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tn++;\n\t\t\tbreak;\n\t\tcase MOD_LOG_KEY_REPLACE:\n\t\t\tBUG_ON(tm->slot >= n);\n\t\t\tbtrfs_set_node_key(eb, &tm->key, tm->slot);\n\t\t\tbtrfs_set_node_blockptr(eb, tm->slot, tm->blockptr);\n\t\t\tbtrfs_set_node_ptr_generation(eb, tm->slot,\n\t\t\t\t\t\t      tm->generation);\n\t\t\tbreak;\n\t\tcase MOD_LOG_KEY_ADD:\n\t\t\t/* if a move operation is needed it's in the log */\n\t\t\tn--;\n\t\t\tbreak;\n\t\tcase MOD_LOG_MOVE_KEYS:\n\t\t\to_dst = btrfs_node_key_ptr_offset(tm->slot);\n\t\t\to_src = btrfs_node_key_ptr_offset(tm->move.dst_slot);\n\t\t\tmemmove_extent_buffer(eb, o_dst, o_src,\n\t\t\t\t\t      tm->move.nr_items * p_size);\n\t\t\tbreak;\n\t\tcase MOD_LOG_ROOT_REPLACE:\n\t\t\t/*\n\t\t\t * this operation is special. for roots, this must be\n\t\t\t * handled explicitly before rewinding.\n\t\t\t * for non-roots, this operation may exist if the node\n\t\t\t * was a root: root A -> child B; then A gets empty and\n\t\t\t * B is promoted to the new root. in the mod log, we'll\n\t\t\t * have a root-replace operation for B, a tree block\n\t\t\t * that is no root. we simply ignore that operation.\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t\tnext = rb_next(&tm->node);\n\t\tif (!next)\n\t\t\tbreak;\n\t\ttm = container_of(next, struct tree_mod_elem, node);\n\t\tif (tm->index != first_tm->index)\n\t\t\tbreak;\n\t}\n\ttree_mod_log_read_unlock(fs_info);\n\tbtrfs_set_header_nritems(eb, n);\n}"
  },
  {
    "function_name": "__tree_mod_log_oldest_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1219-1267",
    "snippet": "static struct tree_mod_elem *\n__tree_mod_log_oldest_root(struct btrfs_fs_info *fs_info,\n\t\t\t   struct extent_buffer *eb_root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 root_logical = eb_root->start;\n\tint looped = 0;\n\n\tif (!time_seq)\n\t\treturn NULL;\n\n\t/*\n\t * the very last operation that's logged for a root is the replacement\n\t * operation (if it is replaced at all). this has the index of the *new*\n\t * root, making it the very first operation that's logged for this root.\n\t */\n\twhile (1) {\n\t\ttm = tree_mod_log_search_oldest(fs_info, root_logical,\n\t\t\t\t\t\ttime_seq);\n\t\tif (!looped && !tm)\n\t\t\treturn NULL;\n\t\t/*\n\t\t * if there are no tree operation for the oldest root, we simply\n\t\t * return it. this should only happen if that (old) root is at\n\t\t * level 0.\n\t\t */\n\t\tif (!tm)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if there's an operation that's not a root replacement, we\n\t\t * found the oldest version of our root. normally, we'll find a\n\t\t * MOD_LOG_KEY_REMOVE_WHILE_FREEING operation here.\n\t\t */\n\t\tif (tm->op != MOD_LOG_ROOT_REPLACE)\n\t\t\tbreak;\n\n\t\tfound = tm;\n\t\troot_logical = tm->old_root.logical;\n\t\tlooped = 1;\n\t}\n\n\t/* if there's no old root to return, return what we found instead */\n\tif (!found)\n\t\tfound = tm;\n\n\treturn found;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_mod_log_search_oldest",
          "args": [
            "fs_info",
            "root_logical",
            "time_seq"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_search_oldest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "782-787",
          "snippet": "static struct tree_mod_elem *\ntree_mod_log_search_oldest(struct btrfs_fs_info *fs_info, u64 start,\n\t\t\t   u64 min_seq)\n{\n\treturn __tree_mod_log_search(fs_info, start, min_seq, 1);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\ntree_mod_log_search_oldest(struct btrfs_fs_info *fs_info, u64 start,\n\t\t\t   u64 min_seq)\n{\n\treturn __tree_mod_log_search(fs_info, start, min_seq, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\n__tree_mod_log_oldest_root(struct btrfs_fs_info *fs_info,\n\t\t\t   struct extent_buffer *eb_root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 root_logical = eb_root->start;\n\tint looped = 0;\n\n\tif (!time_seq)\n\t\treturn NULL;\n\n\t/*\n\t * the very last operation that's logged for a root is the replacement\n\t * operation (if it is replaced at all). this has the index of the *new*\n\t * root, making it the very first operation that's logged for this root.\n\t */\n\twhile (1) {\n\t\ttm = tree_mod_log_search_oldest(fs_info, root_logical,\n\t\t\t\t\t\ttime_seq);\n\t\tif (!looped && !tm)\n\t\t\treturn NULL;\n\t\t/*\n\t\t * if there are no tree operation for the oldest root, we simply\n\t\t * return it. this should only happen if that (old) root is at\n\t\t * level 0.\n\t\t */\n\t\tif (!tm)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if there's an operation that's not a root replacement, we\n\t\t * found the oldest version of our root. normally, we'll find a\n\t\t * MOD_LOG_KEY_REMOVE_WHILE_FREEING operation here.\n\t\t */\n\t\tif (tm->op != MOD_LOG_ROOT_REPLACE)\n\t\t\tbreak;\n\n\t\tfound = tm;\n\t\troot_logical = tm->old_root.logical;\n\t\tlooped = 1;\n\t}\n\n\t/* if there's no old root to return, return what we found instead */\n\tif (!found)\n\t\tfound = tm;\n\n\treturn found;\n}"
  },
  {
    "function_name": "__btrfs_cow_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "1094-1213",
    "snippet": "static noinline int __btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct extent_buffer *buf,\n\t\t\t     struct extent_buffer *parent, int parent_slot,\n\t\t\t     struct extent_buffer **cow_ret,\n\t\t\t     u64 search_start, u64 empty_size)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *cow;\n\tint level, ret;\n\tint last_ref = 0;\n\tint unlock_orig = 0;\n\tu64 parent_start;\n\n\tif (*cow_ret == buf)\n\t\tunlock_orig = 1;\n\n\tbtrfs_assert_tree_locked(buf);\n\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent)\n\t\t\tparent_start = parent->start;\n\t\telse\n\t\t\tparent_start = 0;\n\t} else\n\t\tparent_start = 0;\n\n\tcow = btrfs_alloc_tree_block(trans, root, parent_start,\n\t\t\troot->root_key.objectid, &disk_key, level,\n\t\t\tsearch_start, empty_size);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\t/* cow is set to blocking by btrfs_init_new_buffer */\n\n\tcopy_extent_buffer(cow, buf, 0, 0, cow->len);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, root->root_key.objectid);\n\n\twrite_extent_buffer(cow, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\tret = update_ref_for_cow(trans, root, buf, cow, &last_ref);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\tret = btrfs_reloc_cow_block(trans, root, buf, cow);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (buf == root->node) {\n\t\tWARN_ON(parent && parent != buf);\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\t\tparent_start = buf->start;\n\t\telse\n\t\t\tparent_start = 0;\n\n\t\textent_buffer_get(cow);\n\t\ttree_mod_log_set_root_pointer(root, cow, 1);\n\t\trcu_assign_pointer(root->node, cow);\n\n\t\tbtrfs_free_tree_block(trans, root, buf, parent_start,\n\t\t\t\t      last_ref);\n\t\tfree_extent_buffer(buf);\n\t\tadd_root_to_dirty_list(root);\n\t} else {\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\t\tparent_start = parent->start;\n\t\telse\n\t\t\tparent_start = 0;\n\n\t\tWARN_ON(trans->transid != btrfs_header_generation(parent));\n\t\ttree_mod_log_insert_key(root->fs_info, parent, parent_slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE, GFP_NOFS);\n\t\tbtrfs_set_node_blockptr(parent, parent_slot,\n\t\t\t\t\tcow->start);\n\t\tbtrfs_set_node_ptr_generation(parent, parent_slot,\n\t\t\t\t\t      trans->transid);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\t\tif (last_ref) {\n\t\t\tret = tree_mod_log_free_eb(root->fs_info, buf);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbtrfs_free_tree_block(trans, root, buf, parent_start,\n\t\t\t\t      last_ref);\n\t}\n\tif (unlock_orig)\n\t\tbtrfs_tree_unlock(buf);\n\tfree_extent_buffer_stale(buf);\n\tbtrfs_mark_buffer_dirty(cow);\n\t*cow_ret = cow;\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "cow"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer_stale",
          "args": [
            "buf"
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "buf"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_tree_block",
          "args": [
            "trans",
            "root",
            "buf",
            "parent_start",
            "last_ref"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "6190-6246",
          "snippet": "void btrfs_free_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct extent_buffer *buf,\n\t\t\t   u64 parent, int last_ref)\n{\n\tint pin = 1;\n\tint ret;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tbuf->start, buf->len,\n\t\t\t\t\tparent, root->root_key.objectid,\n\t\t\t\t\tbtrfs_header_level(buf),\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tif (!last_ref)\n\t\treturn;\n\n\tif (btrfs_header_generation(buf) == trans->transid) {\n\t\tstruct btrfs_block_group_cache *cache;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\t\tret = check_ref_cleanup(trans, root, buf->start);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcache = btrfs_lookup_block_group(root->fs_info, buf->start);\n\n\t\tif (btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN)) {\n\t\t\tpin_down_extent(root, cache, buf->start, buf->len, 1);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto out;\n\t\t}\n\n\t\tWARN_ON(test_bit(EXTENT_BUFFER_DIRTY, &buf->bflags));\n\n\t\tbtrfs_add_free_space(cache, buf->start, buf->len);\n\t\tbtrfs_update_reserved_bytes(cache, buf->len, RESERVE_FREE, 0);\n\t\tbtrfs_put_block_group(cache);\n\t\ttrace_btrfs_reserved_extent_free(root, buf->start, buf->len);\n\t\tpin = 0;\n\t}\nout:\n\tif (pin)\n\t\tadd_pinned_bytes(root->fs_info, buf->len,\n\t\t\t\t btrfs_header_level(buf),\n\t\t\t\t root->root_key.objectid);\n\n\t/*\n\t * Deleting the buffer, clear the corrupt flag since it doesn't matter\n\t * anymore.\n\t */\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &buf->bflags);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t   struct btrfs_root *root,\n\t\t\t   struct extent_buffer *buf,\n\t\t\t   u64 parent, int last_ref)\n{\n\tint pin = 1;\n\tint ret;\n\n\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tbuf->start, buf->len,\n\t\t\t\t\tparent, root->root_key.objectid,\n\t\t\t\t\tbtrfs_header_level(buf),\n\t\t\t\t\tBTRFS_DROP_DELAYED_REF, NULL, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\n\tif (!last_ref)\n\t\treturn;\n\n\tif (btrfs_header_generation(buf) == trans->transid) {\n\t\tstruct btrfs_block_group_cache *cache;\n\n\t\tif (root->root_key.objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\t\tret = check_ref_cleanup(trans, root, buf->start);\n\t\t\tif (!ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcache = btrfs_lookup_block_group(root->fs_info, buf->start);\n\n\t\tif (btrfs_header_flag(buf, BTRFS_HEADER_FLAG_WRITTEN)) {\n\t\t\tpin_down_extent(root, cache, buf->start, buf->len, 1);\n\t\t\tbtrfs_put_block_group(cache);\n\t\t\tgoto out;\n\t\t}\n\n\t\tWARN_ON(test_bit(EXTENT_BUFFER_DIRTY, &buf->bflags));\n\n\t\tbtrfs_add_free_space(cache, buf->start, buf->len);\n\t\tbtrfs_update_reserved_bytes(cache, buf->len, RESERVE_FREE, 0);\n\t\tbtrfs_put_block_group(cache);\n\t\ttrace_btrfs_reserved_extent_free(root, buf->start, buf->len);\n\t\tpin = 0;\n\t}\nout:\n\tif (pin)\n\t\tadd_pinned_bytes(root->fs_info, buf->len,\n\t\t\t\t btrfs_header_level(buf),\n\t\t\t\t root->root_key.objectid);\n\n\t/*\n\t * Deleting the buffer, clear the corrupt flag since it doesn't matter\n\t * anymore.\n\t */\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &buf->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_free_eb",
          "args": [
            "root->fs_info",
            "buf"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_free_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "893-939",
          "snippet": "static noinline int\ntree_mod_log_free_eb(struct btrfs_fs_info *fs_info, struct extent_buffer *eb)\n{\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint nritems = 0;\n\tint i;\n\tint ret = 0;\n\n\tif (btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tnritems = btrfs_header_nritems(eb);\n\ttm_list = kzalloc(nritems * sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nritems; i++) {\n\t\ttm_list[i] = alloc_tree_mod_elem(eb, i,\n\t\t    MOD_LOG_KEY_REMOVE_WHILE_FREEING, GFP_NOFS);\n\t\tif (!tm_list[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, eb))\n\t\tgoto free_tms;\n\n\tret = __tree_mod_log_free_eb(fs_info, tm_list, nritems);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tgoto free_tms;\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tfor (i = 0; i < nritems; i++)\n\t\tkfree(tm_list[i]);\n\tkfree(tm_list);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_free_eb(struct btrfs_fs_info *fs_info, struct extent_buffer *eb)\n{\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint nritems = 0;\n\tint i;\n\tint ret = 0;\n\n\tif (btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tnritems = btrfs_header_nritems(eb);\n\ttm_list = kzalloc(nritems * sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nritems; i++) {\n\t\ttm_list[i] = alloc_tree_mod_elem(eb, i,\n\t\t    MOD_LOG_KEY_REMOVE_WHILE_FREEING, GFP_NOFS);\n\t\tif (!tm_list[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, eb))\n\t\tgoto free_tms;\n\n\tret = __tree_mod_log_free_eb(fs_info, tm_list, nritems);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tgoto free_tms;\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tfor (i = 0; i < nritems; i++)\n\t\tkfree(tm_list[i]);\n\tkfree(tm_list);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_ptr_generation",
          "args": [
            "parent",
            "parent_slot",
            "trans->transid"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2589-2596",
          "snippet": "static inline void btrfs_set_node_ptr_generation(struct extent_buffer *eb,\n\t\t\t\t\t\t int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_generation(eb, (struct btrfs_key_ptr *)ptr, val);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_ptr_generation(struct extent_buffer *eb,\n\t\t\t\t\t\t int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_generation(eb, (struct btrfs_key_ptr *)ptr, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_node_blockptr",
          "args": [
            "parent",
            "parent_slot",
            "cow->start"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2572-2579",
          "snippet": "static inline void btrfs_set_node_blockptr(struct extent_buffer *eb,\n\t\t\t\t\t   int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_blockptr(eb, (struct btrfs_key_ptr *)ptr, val);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_set_node_blockptr(struct extent_buffer *eb,\n\t\t\t\t\t   int nr, u64 val)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\tbtrfs_set_key_blockptr(eb, (struct btrfs_key_ptr *)ptr, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_log_insert_key",
          "args": [
            "root->fs_info",
            "parent",
            "parent_slot",
            "MOD_LOG_KEY_REPLACE",
            "GFP_NOFS"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_insert_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "539-565",
          "snippet": "static noinline int\ntree_mod_log_insert_key(struct btrfs_fs_info *fs_info,\n\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\tenum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\tint ret;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm = alloc_tree_mod_elem(eb, slot, op, flags);\n\tif (!tm)\n\t\treturn -ENOMEM;\n\n\tif (tree_mod_dont_log(fs_info, eb)) {\n\t\tkfree(tm);\n\t\treturn 0;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tkfree(tm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_insert_key(struct btrfs_fs_info *fs_info,\n\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\tenum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\tint ret;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm = alloc_tree_mod_elem(eb, slot, op, flags);\n\tif (!tm)\n\t\treturn -ENOMEM;\n\n\tif (tree_mod_dont_log(fs_info, eb)) {\n\t\tkfree(tm);\n\t\treturn 0;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tkfree(tm);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "trans->transid != btrfs_header_generation(parent)"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "parent"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_root_to_dirty_list",
          "args": [
            "root"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "add_root_to_dirty_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "214-231",
          "snippet": "static void add_root_to_dirty_list(struct btrfs_root *root)\n{\n\tif (test_bit(BTRFS_ROOT_DIRTY, &root->state) ||\n\t    !test_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state))\n\t\treturn;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (!test_and_set_bit(BTRFS_ROOT_DIRTY, &root->state)) {\n\t\t/* Want the extent tree to be the last on the list */\n\t\tif (root->objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\t\tlist_move_tail(&root->dirty_list,\n\t\t\t\t       &root->fs_info->dirty_cowonly_roots);\n\t\telse\n\t\t\tlist_move(&root->dirty_list,\n\t\t\t\t  &root->fs_info->dirty_cowonly_roots);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void add_root_to_dirty_list(struct btrfs_root *root)\n{\n\tif (test_bit(BTRFS_ROOT_DIRTY, &root->state) ||\n\t    !test_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state))\n\t\treturn;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (!test_and_set_bit(BTRFS_ROOT_DIRTY, &root->state)) {\n\t\t/* Want the extent tree to be the last on the list */\n\t\tif (root->objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\t\tlist_move_tail(&root->dirty_list,\n\t\t\t\t       &root->fs_info->dirty_cowonly_roots);\n\t\telse\n\t\t\tlist_move(&root->dirty_list,\n\t\t\t\t  &root->fs_info->dirty_cowonly_roots);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "root->node",
            "cow"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_set_root_pointer",
          "args": [
            "root",
            "cow",
            "1"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_set_root_pointer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "941-950",
          "snippet": "static noinline void\ntree_mod_log_set_root_pointer(struct btrfs_root *root,\n\t\t\t      struct extent_buffer *new_root_node,\n\t\t\t      int log_removal)\n{\n\tint ret;\n\tret = tree_mod_log_insert_root(root->fs_info, root->node,\n\t\t\t\t       new_root_node, GFP_NOFS, log_removal);\n\tBUG_ON(ret < 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline void\ntree_mod_log_set_root_pointer(struct btrfs_root *root,\n\t\t\t      struct extent_buffer *new_root_node,\n\t\t\t      int log_removal)\n{\n\tint ret;\n\tret = tree_mod_log_insert_root(root->fs_info, root->node,\n\t\t\t\t       new_root_node, GFP_NOFS, log_removal);\n\tBUG_ON(ret < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "cow"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_backref_rev",
          "args": [
            "buf"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2817-2821",
          "snippet": "static inline int btrfs_header_backref_rev(struct extent_buffer *eb)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\treturn flags >> BTRFS_BACKREF_REV_SHIFT;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline int btrfs_header_backref_rev(struct extent_buffer *eb)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\treturn flags >> BTRFS_BACKREF_REV_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "parent && parent != buf"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_reloc_cow_block",
          "args": [
            "trans",
            "root",
            "buf",
            "cow"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_reloc_cow_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "4523-4579",
          "snippet": "int btrfs_reloc_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *buf,\n\t\t\t  struct extent_buffer *cow)\n{\n\tstruct reloc_control *rc;\n\tstruct backref_node *node;\n\tint first_cow = 0;\n\tint level;\n\tint ret = 0;\n\n\trc = root->fs_info->reloc_ctl;\n\tif (!rc)\n\t\treturn 0;\n\n\tBUG_ON(rc->stage == UPDATE_DATA_PTRS &&\n\t       root->root_key.objectid == BTRFS_DATA_RELOC_TREE_OBJECTID);\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (buf == root->node)\n\t\t\t__update_reloc_root(root, cow->start);\n\t}\n\n\tlevel = btrfs_header_level(buf);\n\tif (btrfs_header_generation(buf) <=\n\t    btrfs_root_last_snapshot(&root->root_item))\n\t\tfirst_cow = 1;\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID &&\n\t    rc->create_reloc_tree) {\n\t\tWARN_ON(!first_cow && level == 0);\n\n\t\tnode = rc->backref_cache.path[level];\n\t\tBUG_ON(node->bytenr != buf->start &&\n\t\t       node->new_bytenr != buf->start);\n\n\t\tdrop_node_buffer(node);\n\t\textent_buffer_get(cow);\n\t\tnode->eb = cow;\n\t\tnode->new_bytenr = cow->start;\n\n\t\tif (!node->pending) {\n\t\t\tlist_move_tail(&node->list,\n\t\t\t\t       &rc->backref_cache.pending[level]);\n\t\t\tnode->pending = 1;\n\t\t}\n\n\t\tif (first_cow)\n\t\t\t__mark_block_processed(rc, node);\n\n\t\tif (first_cow && level > 0)\n\t\t\trc->nodes_relocated += buf->len;\n\t}\n\n\tif (level == 0 && first_cow && rc->stage == UPDATE_DATA_PTRS)\n\t\tret = replace_file_extents(trans, rc, root, cow);\n\treturn ret;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define UPDATE_DATA_PTRS\t1"
          ],
          "globals_used": [
            "static void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);",
            "static void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define UPDATE_DATA_PTRS\t1\n\nstatic void remove_backref_node(struct backref_cache *cache,\n\t\t\t\tstruct backref_node *node);\nstatic void __mark_block_processed(struct reloc_control *rc,\n\t\t\t\t   struct backref_node *node);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_reloc_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t  struct btrfs_root *root, struct extent_buffer *buf,\n\t\t\t  struct extent_buffer *cow)\n{\n\tstruct reloc_control *rc;\n\tstruct backref_node *node;\n\tint first_cow = 0;\n\tint level;\n\tint ret = 0;\n\n\trc = root->fs_info->reloc_ctl;\n\tif (!rc)\n\t\treturn 0;\n\n\tBUG_ON(rc->stage == UPDATE_DATA_PTRS &&\n\t       root->root_key.objectid == BTRFS_DATA_RELOC_TREE_OBJECTID);\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (buf == root->node)\n\t\t\t__update_reloc_root(root, cow->start);\n\t}\n\n\tlevel = btrfs_header_level(buf);\n\tif (btrfs_header_generation(buf) <=\n\t    btrfs_root_last_snapshot(&root->root_item))\n\t\tfirst_cow = 1;\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID &&\n\t    rc->create_reloc_tree) {\n\t\tWARN_ON(!first_cow && level == 0);\n\n\t\tnode = rc->backref_cache.path[level];\n\t\tBUG_ON(node->bytenr != buf->start &&\n\t\t       node->new_bytenr != buf->start);\n\n\t\tdrop_node_buffer(node);\n\t\textent_buffer_get(cow);\n\t\tnode->eb = cow;\n\t\tnode->new_bytenr = cow->start;\n\n\t\tif (!node->pending) {\n\t\t\tlist_move_tail(&node->list,\n\t\t\t\t       &rc->backref_cache.pending[level]);\n\t\t\tnode->pending = 1;\n\t\t}\n\n\t\tif (first_cow)\n\t\t\t__mark_block_processed(rc, node);\n\n\t\tif (first_cow && level > 0)\n\t\t\trc->nodes_relocated += buf->len;\n\t}\n\n\tif (level == 0 && first_cow && rc->stage == UPDATE_DATA_PTRS)\n\t\tret = replace_file_extents(trans, rc, root, cow);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_abort_transaction",
          "args": [
            "trans",
            "root",
            "ret"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_ref_for_cow",
          "args": [
            "trans",
            "root",
            "buf",
            "cow",
            "&last_ref"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "update_ref_for_cow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "978-1080",
          "snippet": "static noinline int update_ref_for_cow(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct extent_buffer *buf,\n\t\t\t\t       struct extent_buffer *cow,\n\t\t\t\t       int *last_ref)\n{\n\tu64 refs;\n\tu64 owner;\n\tu64 flags;\n\tu64 new_flags = 0;\n\tint ret;\n\n\t/*\n\t * Backrefs update rules:\n\t *\n\t * Always use full backrefs for extent pointers in tree block\n\t * allocated by tree relocation.\n\t *\n\t * If a shared tree block is no longer referenced by its owner\n\t * tree (btrfs_header_owner(buf) == root->root_key.objectid),\n\t * use full backrefs for extent pointers in tree block.\n\t *\n\t * If a tree block is been relocating\n\t * (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID),\n\t * use full backrefs for extent pointers in tree block.\n\t * The reason for this is some operations (such as drop tree)\n\t * are only allowed for blocks use full backrefs.\n\t */\n\n\tif (btrfs_block_can_be_shared(root, buf)) {\n\t\tret = btrfs_lookup_extent_info(trans, root, buf->start,\n\t\t\t\t\t       btrfs_header_level(buf), 1,\n\t\t\t\t\t       &refs, &flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (refs == 0) {\n\t\t\tret = -EROFS;\n\t\t\tbtrfs_std_error(root->fs_info, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\trefs = 1;\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\t\tflags = BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t\telse\n\t\t\tflags = 0;\n\t}\n\n\towner = btrfs_header_owner(buf);\n\tBUG_ON(owner == BTRFS_TREE_RELOC_OBJECTID &&\n\t       !(flags & BTRFS_BLOCK_FLAG_FULL_BACKREF));\n\n\tif (refs > 1) {\n\t\tif ((owner == root->root_key.objectid ||\n\t\t     root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) &&\n\t\t    !(flags & BTRFS_BLOCK_FLAG_FULL_BACKREF)) {\n\t\t\tret = btrfs_inc_ref(trans, root, buf, 1);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\t\tret = btrfs_dec_ref(trans, root, buf, 0);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tnew_flags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t\t} else {\n\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID)\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\telse\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t}\n\t\tif (new_flags != 0) {\n\t\t\tint level = btrfs_header_level(buf);\n\n\t\t\tret = btrfs_set_disk_extent_flags(trans, root,\n\t\t\t\t\t\t\t  buf->start,\n\t\t\t\t\t\t\t  buf->len,\n\t\t\t\t\t\t\t  new_flags, level, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF) {\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID)\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\telse\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\tret = btrfs_dec_ref(trans, root, buf, 1);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t}\n\t\tclean_tree_block(trans, root, buf);\n\t\t*last_ref = 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline int update_ref_for_cow(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct extent_buffer *buf,\n\t\t\t\t       struct extent_buffer *cow,\n\t\t\t\t       int *last_ref)\n{\n\tu64 refs;\n\tu64 owner;\n\tu64 flags;\n\tu64 new_flags = 0;\n\tint ret;\n\n\t/*\n\t * Backrefs update rules:\n\t *\n\t * Always use full backrefs for extent pointers in tree block\n\t * allocated by tree relocation.\n\t *\n\t * If a shared tree block is no longer referenced by its owner\n\t * tree (btrfs_header_owner(buf) == root->root_key.objectid),\n\t * use full backrefs for extent pointers in tree block.\n\t *\n\t * If a tree block is been relocating\n\t * (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID),\n\t * use full backrefs for extent pointers in tree block.\n\t * The reason for this is some operations (such as drop tree)\n\t * are only allowed for blocks use full backrefs.\n\t */\n\n\tif (btrfs_block_can_be_shared(root, buf)) {\n\t\tret = btrfs_lookup_extent_info(trans, root, buf->start,\n\t\t\t\t\t       btrfs_header_level(buf), 1,\n\t\t\t\t\t       &refs, &flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (refs == 0) {\n\t\t\tret = -EROFS;\n\t\t\tbtrfs_std_error(root->fs_info, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\trefs = 1;\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\t\tflags = BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t\telse\n\t\t\tflags = 0;\n\t}\n\n\towner = btrfs_header_owner(buf);\n\tBUG_ON(owner == BTRFS_TREE_RELOC_OBJECTID &&\n\t       !(flags & BTRFS_BLOCK_FLAG_FULL_BACKREF));\n\n\tif (refs > 1) {\n\t\tif ((owner == root->root_key.objectid ||\n\t\t     root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) &&\n\t\t    !(flags & BTRFS_BLOCK_FLAG_FULL_BACKREF)) {\n\t\t\tret = btrfs_inc_ref(trans, root, buf, 1);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\t\tret = btrfs_dec_ref(trans, root, buf, 0);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tnew_flags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t\t} else {\n\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID)\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\telse\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t}\n\t\tif (new_flags != 0) {\n\t\t\tint level = btrfs_header_level(buf);\n\n\t\t\tret = btrfs_set_disk_extent_flags(trans, root,\n\t\t\t\t\t\t\t  buf->start,\n\t\t\t\t\t\t\t  buf->len,\n\t\t\t\t\t\t\t  new_flags, level, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF) {\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID)\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\telse\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\tret = btrfs_dec_ref(trans, root, buf, 1);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t}\n\t\tclean_tree_block(trans, root, buf);\n\t\t*last_ref = 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "cow",
            "root->fs_info->fsid",
            "btrfs_header_fsid()",
            "BTRFS_FSID_SIZE"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_fsid",
          "args": [],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2832-2835",
          "snippet": "static inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_owner",
          "args": [
            "cow",
            "root->root_key.objectid"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_flag",
          "args": [
            "cow",
            "BTRFS_HEADER_FLAG_RELOC"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2803-2808",
          "snippet": "static inline int btrfs_set_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tbtrfs_set_header_flags(eb, flags | flag);\n\treturn (flags & flag) == flag;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_set_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tbtrfs_set_header_flags(eb, flags | flag);\n\treturn (flags & flag) == flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clear_header_flag",
          "args": [
            "cow",
            "BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_header_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2810-2815",
          "snippet": "static inline int btrfs_clear_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tbtrfs_set_header_flags(eb, flags & ~flag);\n\treturn (flags & flag) == flag;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_clear_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tbtrfs_set_header_flags(eb, flags & ~flag);\n\treturn (flags & flag) == flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_backref_rev",
          "args": [
            "cow",
            "BTRFS_MIXED_BACKREF_REV"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2823-2830",
          "snippet": "static inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)",
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_generation",
          "args": [
            "cow",
            "trans->transid"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_bytenr",
          "args": [
            "cow",
            "cow->start"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_extent_buffer",
          "args": [
            "cow",
            "buf",
            "0",
            "0",
            "cow->len"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "copy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5416-5447",
          "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cow"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cow"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_tree_block",
          "args": [
            "trans",
            "root",
            "parent_start",
            "root->root_key.objectid",
            "&disk_key",
            "level",
            "search_start",
            "empty_size"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "7316-7385",
          "snippet": "struct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key",
          "args": [
            "buf",
            "&disk_key",
            "0"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key",
          "args": [
            "buf",
            "&disk_key",
            "0"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "buf"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_assert_tree_locked",
          "args": [
            "buf"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_assert_tree_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "292-295",
          "snippet": "void btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_assert_tree_locked(struct extent_buffer *eb)\n{\n\tBUG_ON(!atomic_read(&eb->write_locks));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline int __btrfs_cow_block(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root,\n\t\t\t     struct extent_buffer *buf,\n\t\t\t     struct extent_buffer *parent, int parent_slot,\n\t\t\t     struct extent_buffer **cow_ret,\n\t\t\t     u64 search_start, u64 empty_size)\n{\n\tstruct btrfs_disk_key disk_key;\n\tstruct extent_buffer *cow;\n\tint level, ret;\n\tint last_ref = 0;\n\tint unlock_orig = 0;\n\tu64 parent_start;\n\n\tif (*cow_ret == buf)\n\t\tunlock_orig = 1;\n\n\tbtrfs_assert_tree_locked(buf);\n\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent)\n\t\t\tparent_start = parent->start;\n\t\telse\n\t\t\tparent_start = 0;\n\t} else\n\t\tparent_start = 0;\n\n\tcow = btrfs_alloc_tree_block(trans, root, parent_start,\n\t\t\troot->root_key.objectid, &disk_key, level,\n\t\t\tsearch_start, empty_size);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\t/* cow is set to blocking by btrfs_init_new_buffer */\n\n\tcopy_extent_buffer(cow, buf, 0, 0, cow->len);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, root->root_key.objectid);\n\n\twrite_extent_buffer(cow, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\tret = update_ref_for_cow(trans, root, buf, cow, &last_ref);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state)) {\n\t\tret = btrfs_reloc_cow_block(trans, root, buf, cow);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (buf == root->node) {\n\t\tWARN_ON(parent && parent != buf);\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\t\tparent_start = buf->start;\n\t\telse\n\t\t\tparent_start = 0;\n\n\t\textent_buffer_get(cow);\n\t\ttree_mod_log_set_root_pointer(root, cow, 1);\n\t\trcu_assign_pointer(root->node, cow);\n\n\t\tbtrfs_free_tree_block(trans, root, buf, parent_start,\n\t\t\t\t      last_ref);\n\t\tfree_extent_buffer(buf);\n\t\tadd_root_to_dirty_list(root);\n\t} else {\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\t\tparent_start = parent->start;\n\t\telse\n\t\t\tparent_start = 0;\n\n\t\tWARN_ON(trans->transid != btrfs_header_generation(parent));\n\t\ttree_mod_log_insert_key(root->fs_info, parent, parent_slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE, GFP_NOFS);\n\t\tbtrfs_set_node_blockptr(parent, parent_slot,\n\t\t\t\t\tcow->start);\n\t\tbtrfs_set_node_ptr_generation(parent, parent_slot,\n\t\t\t\t\t      trans->transid);\n\t\tbtrfs_mark_buffer_dirty(parent);\n\t\tif (last_ref) {\n\t\t\tret = tree_mod_log_free_eb(root->fs_info, buf);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_abort_transaction(trans, root, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tbtrfs_free_tree_block(trans, root, buf, parent_start,\n\t\t\t\t      last_ref);\n\t}\n\tif (unlock_orig)\n\t\tbtrfs_tree_unlock(buf);\n\tfree_extent_buffer_stale(buf);\n\tbtrfs_mark_buffer_dirty(cow);\n\t*cow_ret = cow;\n\treturn 0;\n}"
  },
  {
    "function_name": "update_ref_for_cow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "978-1080",
    "snippet": "static noinline int update_ref_for_cow(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct extent_buffer *buf,\n\t\t\t\t       struct extent_buffer *cow,\n\t\t\t\t       int *last_ref)\n{\n\tu64 refs;\n\tu64 owner;\n\tu64 flags;\n\tu64 new_flags = 0;\n\tint ret;\n\n\t/*\n\t * Backrefs update rules:\n\t *\n\t * Always use full backrefs for extent pointers in tree block\n\t * allocated by tree relocation.\n\t *\n\t * If a shared tree block is no longer referenced by its owner\n\t * tree (btrfs_header_owner(buf) == root->root_key.objectid),\n\t * use full backrefs for extent pointers in tree block.\n\t *\n\t * If a tree block is been relocating\n\t * (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID),\n\t * use full backrefs for extent pointers in tree block.\n\t * The reason for this is some operations (such as drop tree)\n\t * are only allowed for blocks use full backrefs.\n\t */\n\n\tif (btrfs_block_can_be_shared(root, buf)) {\n\t\tret = btrfs_lookup_extent_info(trans, root, buf->start,\n\t\t\t\t\t       btrfs_header_level(buf), 1,\n\t\t\t\t\t       &refs, &flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (refs == 0) {\n\t\t\tret = -EROFS;\n\t\t\tbtrfs_std_error(root->fs_info, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\trefs = 1;\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\t\tflags = BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t\telse\n\t\t\tflags = 0;\n\t}\n\n\towner = btrfs_header_owner(buf);\n\tBUG_ON(owner == BTRFS_TREE_RELOC_OBJECTID &&\n\t       !(flags & BTRFS_BLOCK_FLAG_FULL_BACKREF));\n\n\tif (refs > 1) {\n\t\tif ((owner == root->root_key.objectid ||\n\t\t     root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) &&\n\t\t    !(flags & BTRFS_BLOCK_FLAG_FULL_BACKREF)) {\n\t\t\tret = btrfs_inc_ref(trans, root, buf, 1);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\t\tret = btrfs_dec_ref(trans, root, buf, 0);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tnew_flags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t\t} else {\n\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID)\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\telse\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t}\n\t\tif (new_flags != 0) {\n\t\t\tint level = btrfs_header_level(buf);\n\n\t\t\tret = btrfs_set_disk_extent_flags(trans, root,\n\t\t\t\t\t\t\t  buf->start,\n\t\t\t\t\t\t\t  buf->len,\n\t\t\t\t\t\t\t  new_flags, level, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF) {\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID)\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\telse\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\tret = btrfs_dec_ref(trans, root, buf, 1);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t}\n\t\tclean_tree_block(trans, root, buf);\n\t\t*last_ref = 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clean_tree_block",
          "args": [
            "trans",
            "root",
            "buf"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "clean_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1168-1186",
          "snippet": "void clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid clean_tree_block(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t      struct extent_buffer *buf)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\n\tif (btrfs_header_generation(buf) ==\n\t    fs_info->running_transaction->transid) {\n\t\tbtrfs_assert_tree_locked(buf);\n\n\t\tif (test_and_clear_bit(EXTENT_BUFFER_DIRTY, &buf->bflags)) {\n\t\t\t__percpu_counter_add(&fs_info->dirty_metadata_bytes,\n\t\t\t\t\t     -buf->len,\n\t\t\t\t\t     fs_info->dirty_metadata_batch);\n\t\t\t/* ugh, clear_extent_buffer_dirty needs to lock the page */\n\t\t\tbtrfs_set_lock_blocking(buf);\n\t\t\tclear_extent_buffer_dirty(buf);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dec_ref",
          "args": [
            "trans",
            "root",
            "buf",
            "1"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dec_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3123-3127",
          "snippet": "int btrfs_dec_ref(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t  struct extent_buffer *buf, int full_backref)\n{\n\treturn __btrfs_mod_ref(trans, root, buf, full_backref, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_dec_ref(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t  struct extent_buffer *buf, int full_backref)\n{\n\treturn __btrfs_mod_ref(trans, root, buf, full_backref, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inc_ref",
          "args": [
            "trans",
            "root",
            "cow",
            "0"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inc_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3117-3121",
          "snippet": "int btrfs_inc_ref(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t  struct extent_buffer *buf, int full_backref)\n{\n\treturn __btrfs_mod_ref(trans, root, buf, full_backref, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_inc_ref(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t  struct extent_buffer *buf, int full_backref)\n{\n\treturn __btrfs_mod_ref(trans, root, buf, full_backref, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_disk_extent_flags",
          "args": [
            "trans",
            "root",
            "buf->start",
            "buf->len",
            "new_flags",
            "level",
            "0"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_disk_extent_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "2843-2866",
          "snippet": "int btrfs_set_disk_extent_flags(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 flags,\n\t\t\t\tint level, int is_data)\n{\n\tstruct btrfs_delayed_extent_op *extent_op;\n\tint ret;\n\n\textent_op = btrfs_alloc_delayed_extent_op();\n\tif (!extent_op)\n\t\treturn -ENOMEM;\n\n\textent_op->flags_to_set = flags;\n\textent_op->update_flags = 1;\n\textent_op->update_key = 0;\n\textent_op->is_data = is_data ? 1 : 0;\n\textent_op->level = level;\n\n\tret = btrfs_add_delayed_extent_op(root->fs_info, trans, bytenr,\n\t\t\t\t\t  num_bytes, extent_op);\n\tif (ret)\n\t\tbtrfs_free_delayed_extent_op(extent_op);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int block_rsv_use_bytes(struct btrfs_block_rsv *block_rsv,\n\t\t\t       u64 num_bytes);\nstatic noinline struct;\n\nint btrfs_set_disk_extent_flags(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tu64 bytenr, u64 num_bytes, u64 flags,\n\t\t\t\tint level, int is_data)\n{\n\tstruct btrfs_delayed_extent_op *extent_op;\n\tint ret;\n\n\textent_op = btrfs_alloc_delayed_extent_op();\n\tif (!extent_op)\n\t\treturn -ENOMEM;\n\n\textent_op->flags_to_set = flags;\n\textent_op->update_flags = 1;\n\textent_op->update_key = 0;\n\textent_op->is_data = is_data ? 1 : 0;\n\textent_op->level = level;\n\n\tret = btrfs_add_delayed_extent_op(root->fs_info, trans, bytenr,\n\t\t\t\t\t  num_bytes, extent_op);\n\tif (ret)\n\t\tbtrfs_free_delayed_extent_op(extent_op);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "buf"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "owner == BTRFS_TREE_RELOC_OBJECTID &&\n\t       !(flags & BTRFS_BLOCK_FLAG_FULL_BACKREF)"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_owner",
          "args": [
            "buf"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_backref_rev",
          "args": [
            "buf"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2817-2821",
          "snippet": "static inline int btrfs_header_backref_rev(struct extent_buffer *eb)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\treturn flags >> BTRFS_BACKREF_REV_SHIFT;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline int btrfs_header_backref_rev(struct extent_buffer *eb)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\treturn flags >> BTRFS_BACKREF_REV_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_std_error",
          "args": [
            "root->fs_info",
            "ret"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_extent_info",
          "args": [
            "trans",
            "root",
            "buf->start",
            "btrfs_header_level(buf)",
            "1",
            "&refs",
            "&flags"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_extent_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "743-871",
          "snippet": "int btrfs_lookup_extent_info(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root, u64 bytenr,\n\t\t\t     u64 offset, int metadata, u64 *refs, u64 *flags)\n{\n\tstruct btrfs_delayed_ref_head *head;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_path *path;\n\tstruct btrfs_extent_item *ei;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tu32 item_size;\n\tu64 num_refs;\n\tu64 extent_flags;\n\tint ret;\n\n\t/*\n\t * If we don't have skinny metadata, don't bother doing anything\n\t * different\n\t */\n\tif (metadata && !btrfs_fs_incompat(root->fs_info, SKINNY_METADATA)) {\n\t\toffset = root->nodesize;\n\t\tmetadata = 0;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (!trans) {\n\t\tpath->skip_locking = 1;\n\t\tpath->search_commit_root = 1;\n\t}\n\nsearch_again:\n\tkey.objectid = bytenr;\n\tkey.offset = offset;\n\tif (metadata)\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\n\tret = btrfs_search_slot(trans, root->fs_info->extent_root,\n\t\t\t\t&key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tif (ret > 0 && metadata && key.type == BTRFS_METADATA_ITEM_KEY) {\n\t\tif (path->slots[0]) {\n\t\t\tpath->slots[0]--;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key.objectid == bytenr &&\n\t\t\t    key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t    key.offset == root->nodesize)\n\t\t\t\tret = 0;\n\t\t}\n\t}\n\n\tif (ret == 0) {\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tif (item_size >= sizeof(*ei)) {\n\t\t\tei = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_extent_item);\n\t\t\tnum_refs = btrfs_extent_refs(leaf, ei);\n\t\t\textent_flags = btrfs_extent_flags(leaf, ei);\n\t\t} else {\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tstruct btrfs_extent_item_v0 *ei0;\n\t\t\tBUG_ON(item_size != sizeof(*ei0));\n\t\t\tei0 = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t     struct btrfs_extent_item_v0);\n\t\t\tnum_refs = btrfs_extent_refs_v0(leaf, ei0);\n\t\t\t/* FIXME: this isn't correct for data */\n\t\t\textent_flags = BTRFS_BLOCK_FLAG_FULL_BACKREF;\n#else\n\t\t\tBUG();\n#endif\n\t\t}\n\t\tBUG_ON(num_refs == 0);\n\t} else {\n\t\tnum_refs = 0;\n\t\textent_flags = 0;\n\t\tret = 0;\n\t}\n\n\tif (!trans)\n\t\tgoto out;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tspin_lock(&delayed_refs->lock);\n\thead = btrfs_find_delayed_ref_head(trans, bytenr);\n\tif (head) {\n\t\tif (!mutex_trylock(&head->mutex)) {\n\t\t\tatomic_inc(&head->node.refs);\n\t\t\tspin_unlock(&delayed_refs->lock);\n\n\t\t\tbtrfs_release_path(path);\n\n\t\t\t/*\n\t\t\t * Mutex was contended, block until it's released and try\n\t\t\t * again\n\t\t\t */\n\t\t\tmutex_lock(&head->mutex);\n\t\t\tmutex_unlock(&head->mutex);\n\t\t\tbtrfs_put_delayed_ref(&head->node);\n\t\t\tgoto search_again;\n\t\t}\n\t\tspin_lock(&head->lock);\n\t\tif (head->extent_op && head->extent_op->update_flags)\n\t\t\textent_flags |= head->extent_op->flags_to_set;\n\t\telse\n\t\t\tBUG_ON(num_refs == 0);\n\n\t\tnum_refs += head->node.ref_mod;\n\t\tspin_unlock(&head->lock);\n\t\tmutex_unlock(&head->mutex);\n\t}\n\tspin_unlock(&delayed_refs->lock);\nout:\n\tWARN_ON(num_refs == 0);\n\tif (refs)\n\t\t*refs = num_refs;\n\tif (flags)\n\t\t*flags = extent_flags;\nout_free:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __run_delayed_extent_op(struct btrfs_delayed_extent_op *extent_op,\n\t\t\t\t    struct extent_buffer *leaf,\n\t\t\t\t    struct btrfs_extent_item *ei);",
            "static int alloc_reserved_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      u64 parent, u64 root_objectid,\n\t\t\t\t      u64 flags, u64 owner, u64 offset,\n\t\t\t\t      struct btrfs_key *ins, int ref_mod);",
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void __run_delayed_extent_op(struct btrfs_delayed_extent_op *extent_op,\n\t\t\t\t    struct extent_buffer *leaf,\n\t\t\t\t    struct btrfs_extent_item *ei);\nstatic int alloc_reserved_file_extent(struct btrfs_trans_handle *trans,\n\t\t\t\t      struct btrfs_root *root,\n\t\t\t\t      u64 parent, u64 root_objectid,\n\t\t\t\t      u64 flags, u64 owner, u64 offset,\n\t\t\t\t      struct btrfs_key *ins, int ref_mod);\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nint btrfs_lookup_extent_info(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root, u64 bytenr,\n\t\t\t     u64 offset, int metadata, u64 *refs, u64 *flags)\n{\n\tstruct btrfs_delayed_ref_head *head;\n\tstruct btrfs_delayed_ref_root *delayed_refs;\n\tstruct btrfs_path *path;\n\tstruct btrfs_extent_item *ei;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tu32 item_size;\n\tu64 num_refs;\n\tu64 extent_flags;\n\tint ret;\n\n\t/*\n\t * If we don't have skinny metadata, don't bother doing anything\n\t * different\n\t */\n\tif (metadata && !btrfs_fs_incompat(root->fs_info, SKINNY_METADATA)) {\n\t\toffset = root->nodesize;\n\t\tmetadata = 0;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\n\tif (!trans) {\n\t\tpath->skip_locking = 1;\n\t\tpath->search_commit_root = 1;\n\t}\n\nsearch_again:\n\tkey.objectid = bytenr;\n\tkey.offset = offset;\n\tif (metadata)\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\n\tret = btrfs_search_slot(trans, root->fs_info->extent_root,\n\t\t\t\t&key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tif (ret > 0 && metadata && key.type == BTRFS_METADATA_ITEM_KEY) {\n\t\tif (path->slots[0]) {\n\t\t\tpath->slots[0]--;\n\t\t\tbtrfs_item_key_to_cpu(path->nodes[0], &key,\n\t\t\t\t\t      path->slots[0]);\n\t\t\tif (key.objectid == bytenr &&\n\t\t\t    key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t\t\t    key.offset == root->nodesize)\n\t\t\t\tret = 0;\n\t\t}\n\t}\n\n\tif (ret == 0) {\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, path->slots[0]);\n\t\tif (item_size >= sizeof(*ei)) {\n\t\t\tei = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t    struct btrfs_extent_item);\n\t\t\tnum_refs = btrfs_extent_refs(leaf, ei);\n\t\t\textent_flags = btrfs_extent_flags(leaf, ei);\n\t\t} else {\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\t\t\tstruct btrfs_extent_item_v0 *ei0;\n\t\t\tBUG_ON(item_size != sizeof(*ei0));\n\t\t\tei0 = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t\t     struct btrfs_extent_item_v0);\n\t\t\tnum_refs = btrfs_extent_refs_v0(leaf, ei0);\n\t\t\t/* FIXME: this isn't correct for data */\n\t\t\textent_flags = BTRFS_BLOCK_FLAG_FULL_BACKREF;\n#else\n\t\t\tBUG();\n#endif\n\t\t}\n\t\tBUG_ON(num_refs == 0);\n\t} else {\n\t\tnum_refs = 0;\n\t\textent_flags = 0;\n\t\tret = 0;\n\t}\n\n\tif (!trans)\n\t\tgoto out;\n\n\tdelayed_refs = &trans->transaction->delayed_refs;\n\tspin_lock(&delayed_refs->lock);\n\thead = btrfs_find_delayed_ref_head(trans, bytenr);\n\tif (head) {\n\t\tif (!mutex_trylock(&head->mutex)) {\n\t\t\tatomic_inc(&head->node.refs);\n\t\t\tspin_unlock(&delayed_refs->lock);\n\n\t\t\tbtrfs_release_path(path);\n\n\t\t\t/*\n\t\t\t * Mutex was contended, block until it's released and try\n\t\t\t * again\n\t\t\t */\n\t\t\tmutex_lock(&head->mutex);\n\t\t\tmutex_unlock(&head->mutex);\n\t\t\tbtrfs_put_delayed_ref(&head->node);\n\t\t\tgoto search_again;\n\t\t}\n\t\tspin_lock(&head->lock);\n\t\tif (head->extent_op && head->extent_op->update_flags)\n\t\t\textent_flags |= head->extent_op->flags_to_set;\n\t\telse\n\t\t\tBUG_ON(num_refs == 0);\n\n\t\tnum_refs += head->node.ref_mod;\n\t\tspin_unlock(&head->lock);\n\t\tmutex_unlock(&head->mutex);\n\t}\n\tspin_unlock(&delayed_refs->lock);\nout:\n\tWARN_ON(num_refs == 0);\n\tif (refs)\n\t\t*refs = num_refs;\n\tif (flags)\n\t\t*flags = extent_flags;\nout_free:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "buf"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_block_can_be_shared",
          "args": [
            "root",
            "buf"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_block_can_be_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "955-976",
          "snippet": "int btrfs_block_can_be_shared(struct btrfs_root *root,\n\t\t\t      struct extent_buffer *buf)\n{\n\t/*\n\t * Tree blocks not in refernece counted trees and tree roots\n\t * are never shared. If a block was allocated after the last\n\t * snapshot and the block was not allocated by tree relocation,\n\t * we know the block is not shared.\n\t */\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t    buf != root->node && buf != root->commit_root &&\n\t    (btrfs_header_generation(buf) <=\n\t     btrfs_root_last_snapshot(&root->root_item) ||\n\t     btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)))\n\t\treturn 1;\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_block_can_be_shared(struct btrfs_root *root,\n\t\t\t      struct extent_buffer *buf)\n{\n\t/*\n\t * Tree blocks not in refernece counted trees and tree roots\n\t * are never shared. If a block was allocated after the last\n\t * snapshot and the block was not allocated by tree relocation,\n\t * we know the block is not shared.\n\t */\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t    buf != root->node && buf != root->commit_root &&\n\t    (btrfs_header_generation(buf) <=\n\t     btrfs_root_last_snapshot(&root->root_item) ||\n\t     btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)))\n\t\treturn 1;\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline int update_ref_for_cow(struct btrfs_trans_handle *trans,\n\t\t\t\t       struct btrfs_root *root,\n\t\t\t\t       struct extent_buffer *buf,\n\t\t\t\t       struct extent_buffer *cow,\n\t\t\t\t       int *last_ref)\n{\n\tu64 refs;\n\tu64 owner;\n\tu64 flags;\n\tu64 new_flags = 0;\n\tint ret;\n\n\t/*\n\t * Backrefs update rules:\n\t *\n\t * Always use full backrefs for extent pointers in tree block\n\t * allocated by tree relocation.\n\t *\n\t * If a shared tree block is no longer referenced by its owner\n\t * tree (btrfs_header_owner(buf) == root->root_key.objectid),\n\t * use full backrefs for extent pointers in tree block.\n\t *\n\t * If a tree block is been relocating\n\t * (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID),\n\t * use full backrefs for extent pointers in tree block.\n\t * The reason for this is some operations (such as drop tree)\n\t * are only allowed for blocks use full backrefs.\n\t */\n\n\tif (btrfs_block_can_be_shared(root, buf)) {\n\t\tret = btrfs_lookup_extent_info(trans, root, buf->start,\n\t\t\t\t\t       btrfs_header_level(buf), 1,\n\t\t\t\t\t       &refs, &flags);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (refs == 0) {\n\t\t\tret = -EROFS;\n\t\t\tbtrfs_std_error(root->fs_info, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\trefs = 1;\n\t\tif (root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\t\tflags = BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t\telse\n\t\t\tflags = 0;\n\t}\n\n\towner = btrfs_header_owner(buf);\n\tBUG_ON(owner == BTRFS_TREE_RELOC_OBJECTID &&\n\t       !(flags & BTRFS_BLOCK_FLAG_FULL_BACKREF));\n\n\tif (refs > 1) {\n\t\tif ((owner == root->root_key.objectid ||\n\t\t     root->root_key.objectid == BTRFS_TREE_RELOC_OBJECTID) &&\n\t\t    !(flags & BTRFS_BLOCK_FLAG_FULL_BACKREF)) {\n\t\t\tret = btrfs_inc_ref(trans, root, buf, 1);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID) {\n\t\t\t\tret = btrfs_dec_ref(trans, root, buf, 0);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\t}\n\t\t\tnew_flags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t\t} else {\n\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID)\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\telse\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t}\n\t\tif (new_flags != 0) {\n\t\t\tint level = btrfs_header_level(buf);\n\n\t\t\tret = btrfs_set_disk_extent_flags(trans, root,\n\t\t\t\t\t\t\t  buf->start,\n\t\t\t\t\t\t\t  buf->len,\n\t\t\t\t\t\t\t  new_flags, level, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tif (flags & BTRFS_BLOCK_FLAG_FULL_BACKREF) {\n\t\t\tif (root->root_key.objectid ==\n\t\t\t    BTRFS_TREE_RELOC_OBJECTID)\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\t\t\telse\n\t\t\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t\tret = btrfs_dec_ref(trans, root, buf, 1);\n\t\t\tBUG_ON(ret); /* -ENOMEM */\n\t\t}\n\t\tclean_tree_block(trans, root, buf);\n\t\t*last_ref = 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_block_can_be_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "955-976",
    "snippet": "int btrfs_block_can_be_shared(struct btrfs_root *root,\n\t\t\t      struct extent_buffer *buf)\n{\n\t/*\n\t * Tree blocks not in refernece counted trees and tree roots\n\t * are never shared. If a block was allocated after the last\n\t * snapshot and the block was not allocated by tree relocation,\n\t * we know the block is not shared.\n\t */\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t    buf != root->node && buf != root->commit_root &&\n\t    (btrfs_header_generation(buf) <=\n\t     btrfs_root_last_snapshot(&root->root_item) ||\n\t     btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)))\n\t\treturn 1;\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\treturn 1;\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_header_backref_rev",
          "args": [
            "buf"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2817-2821",
          "snippet": "static inline int btrfs_header_backref_rev(struct extent_buffer *eb)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\treturn flags >> BTRFS_BACKREF_REV_SHIFT;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline int btrfs_header_backref_rev(struct extent_buffer *eb)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\treturn flags >> BTRFS_BACKREF_REV_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_flag",
          "args": [
            "buf",
            "BTRFS_HEADER_FLAG_RELOC"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2798-2801",
          "snippet": "static inline int btrfs_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\treturn (btrfs_header_flags(eb) & flag) == flag;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\treturn (btrfs_header_flags(eb) & flag) == flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_last_snapshot",
          "args": [
            "&root->root_item"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "buf"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_block_can_be_shared(struct btrfs_root *root,\n\t\t\t      struct extent_buffer *buf)\n{\n\t/*\n\t * Tree blocks not in refernece counted trees and tree roots\n\t * are never shared. If a block was allocated after the last\n\t * snapshot and the block was not allocated by tree relocation,\n\t * we know the block is not shared.\n\t */\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t    buf != root->node && buf != root->commit_root &&\n\t    (btrfs_header_generation(buf) <=\n\t     btrfs_root_last_snapshot(&root->root_item) ||\n\t     btrfs_header_flag(buf, BTRFS_HEADER_FLAG_RELOC)))\n\t\treturn 1;\n#ifdef BTRFS_COMPAT_EXTENT_TREE_V0\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t    btrfs_header_backref_rev(buf) < BTRFS_MIXED_BACKREF_REV)\n\t\treturn 1;\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "tree_mod_log_set_root_pointer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "941-950",
    "snippet": "static noinline void\ntree_mod_log_set_root_pointer(struct btrfs_root *root,\n\t\t\t      struct extent_buffer *new_root_node,\n\t\t\t      int log_removal)\n{\n\tint ret;\n\tret = tree_mod_log_insert_root(root->fs_info, root->node,\n\t\t\t\t       new_root_node, GFP_NOFS, log_removal);\n\tBUG_ON(ret < 0);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_insert_root",
          "args": [
            "root->fs_info",
            "root->node",
            "new_root_node",
            "GFP_NOFS",
            "log_removal"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_insert_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "663-732",
          "snippet": "static noinline int\ntree_mod_log_insert_root(struct btrfs_fs_info *fs_info,\n\t\t\t struct extent_buffer *old_root,\n\t\t\t struct extent_buffer *new_root, gfp_t flags,\n\t\t\t int log_removal)\n{\n\tstruct tree_mod_elem *tm = NULL;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint nritems = 0;\n\tint ret = 0;\n\tint i;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (log_removal && btrfs_header_level(old_root) > 0) {\n\t\tnritems = btrfs_header_nritems(old_root);\n\t\ttm_list = kzalloc(nritems * sizeof(struct tree_mod_elem *),\n\t\t\t\t  flags);\n\t\tif (!tm_list) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t\tfor (i = 0; i < nritems; i++) {\n\t\t\ttm_list[i] = alloc_tree_mod_elem(old_root, i,\n\t\t\t    MOD_LOG_KEY_REMOVE_WHILE_FREEING, flags);\n\t\t\tif (!tm_list[i]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_tms;\n\t\t\t}\n\t\t}\n\t}\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm) {\n\t\tret = -ENOMEM;\n\t\tgoto free_tms;\n\t}\n\n\ttm->index = new_root->start >> PAGE_CACHE_SHIFT;\n\ttm->old_root.logical = old_root->start;\n\ttm->old_root.level = btrfs_header_level(old_root);\n\ttm->generation = btrfs_header_generation(old_root);\n\ttm->op = MOD_LOG_ROOT_REPLACE;\n\n\tif (tree_mod_dont_log(fs_info, NULL))\n\t\tgoto free_tms;\n\n\tif (tm_list)\n\t\tret = __tree_mod_log_free_eb(fs_info, tm_list, nritems);\n\tif (!ret)\n\t\tret = __tree_mod_log_insert(fs_info, tm);\n\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tgoto free_tms;\n\tkfree(tm_list);\n\n\treturn ret;\n\nfree_tms:\n\tif (tm_list) {\n\t\tfor (i = 0; i < nritems; i++)\n\t\t\tkfree(tm_list[i]);\n\t\tkfree(tm_list);\n\t}\n\tkfree(tm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_insert_root(struct btrfs_fs_info *fs_info,\n\t\t\t struct extent_buffer *old_root,\n\t\t\t struct extent_buffer *new_root, gfp_t flags,\n\t\t\t int log_removal)\n{\n\tstruct tree_mod_elem *tm = NULL;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint nritems = 0;\n\tint ret = 0;\n\tint i;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (log_removal && btrfs_header_level(old_root) > 0) {\n\t\tnritems = btrfs_header_nritems(old_root);\n\t\ttm_list = kzalloc(nritems * sizeof(struct tree_mod_elem *),\n\t\t\t\t  flags);\n\t\tif (!tm_list) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t\tfor (i = 0; i < nritems; i++) {\n\t\t\ttm_list[i] = alloc_tree_mod_elem(old_root, i,\n\t\t\t    MOD_LOG_KEY_REMOVE_WHILE_FREEING, flags);\n\t\t\tif (!tm_list[i]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_tms;\n\t\t\t}\n\t\t}\n\t}\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm) {\n\t\tret = -ENOMEM;\n\t\tgoto free_tms;\n\t}\n\n\ttm->index = new_root->start >> PAGE_CACHE_SHIFT;\n\ttm->old_root.logical = old_root->start;\n\ttm->old_root.level = btrfs_header_level(old_root);\n\ttm->generation = btrfs_header_generation(old_root);\n\ttm->op = MOD_LOG_ROOT_REPLACE;\n\n\tif (tree_mod_dont_log(fs_info, NULL))\n\t\tgoto free_tms;\n\n\tif (tm_list)\n\t\tret = __tree_mod_log_free_eb(fs_info, tm_list, nritems);\n\tif (!ret)\n\t\tret = __tree_mod_log_insert(fs_info, tm);\n\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tgoto free_tms;\n\tkfree(tm_list);\n\n\treturn ret;\n\nfree_tms:\n\tif (tm_list) {\n\t\tfor (i = 0; i < nritems; i++)\n\t\t\tkfree(tm_list[i]);\n\t\tkfree(tm_list);\n\t}\n\tkfree(tm);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline void\ntree_mod_log_set_root_pointer(struct btrfs_root *root,\n\t\t\t      struct extent_buffer *new_root_node,\n\t\t\t      int log_removal)\n{\n\tint ret;\n\tret = tree_mod_log_insert_root(root->fs_info, root->node,\n\t\t\t\t       new_root_node, GFP_NOFS, log_removal);\n\tBUG_ON(ret < 0);\n}"
  },
  {
    "function_name": "tree_mod_log_free_eb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "893-939",
    "snippet": "static noinline int\ntree_mod_log_free_eb(struct btrfs_fs_info *fs_info, struct extent_buffer *eb)\n{\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint nritems = 0;\n\tint i;\n\tint ret = 0;\n\n\tif (btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tnritems = btrfs_header_nritems(eb);\n\ttm_list = kzalloc(nritems * sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nritems; i++) {\n\t\ttm_list[i] = alloc_tree_mod_elem(eb, i,\n\t\t    MOD_LOG_KEY_REMOVE_WHILE_FREEING, GFP_NOFS);\n\t\tif (!tm_list[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, eb))\n\t\tgoto free_tms;\n\n\tret = __tree_mod_log_free_eb(fs_info, tm_list, nritems);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tgoto free_tms;\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tfor (i = 0; i < nritems; i++)\n\t\tkfree(tm_list[i]);\n\tkfree(tm_list);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm_list"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm_list[i]"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm_list"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_write_unlock",
          "args": [
            "fs_info"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__tree_mod_log_free_eb",
          "args": [
            "fs_info",
            "tm_list",
            "nritems"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_free_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "642-661",
          "snippet": "static inline int\n__tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t       struct tree_mod_elem **tm_list,\n\t\t       int nritems)\n{\n\tint i, j;\n\tint ret;\n\n\tfor (i = nritems - 1; i >= 0; i--) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list[i]);\n\t\tif (ret) {\n\t\t\tfor (j = nritems - 1; j > i; j--)\n\t\t\t\trb_erase(&tm_list[j]->node,\n\t\t\t\t\t &fs_info->tree_mod_log);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline int\n__tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t       struct tree_mod_elem **tm_list,\n\t\t       int nritems)\n{\n\tint i, j;\n\tint ret;\n\n\tfor (i = nritems - 1; i >= 0; i--) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list[i]);\n\t\tif (ret) {\n\t\t\tfor (j = nritems - 1; j > i; j--)\n\t\t\t\trb_erase(&tm_list[j]->node,\n\t\t\t\t\t &fs_info->tree_mod_log);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_dont_log",
          "args": [
            "fs_info",
            "eb"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_dont_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "486-501",
          "snippet": "static inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb) {\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 1;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 1;\n\n\ttree_mod_log_write_lock(fs_info);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\ttree_mod_log_write_unlock(fs_info);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb) {\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 1;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 1;\n\n\ttree_mod_log_write_lock(fs_info);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\ttree_mod_log_write_unlock(fs_info);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_tree_mod_elem",
          "args": [
            "eb",
            "i",
            "MOD_LOG_KEY_REMOVE_WHILE_FREEING",
            "GFP_NOFS"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_tree_mod_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "516-537",
          "snippet": "static struct tree_mod_elem *\nalloc_tree_mod_elem(struct extent_buffer *eb, int slot,\n\t\t    enum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\tif (op != MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\nalloc_tree_mod_elem(struct extent_buffer *eb, int slot,\n\t\t    enum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\tif (op != MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "nritems * sizeof(struct tree_mod_elem *)",
            "GFP_NOFS"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_need_log",
          "args": [
            "fs_info",
            "NULL"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_need_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "504-514",
          "snippet": "static inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 0;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 0;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_free_eb(struct btrfs_fs_info *fs_info, struct extent_buffer *eb)\n{\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint nritems = 0;\n\tint i;\n\tint ret = 0;\n\n\tif (btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tnritems = btrfs_header_nritems(eb);\n\ttm_list = kzalloc(nritems * sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nritems; i++) {\n\t\ttm_list[i] = alloc_tree_mod_elem(eb, i,\n\t\t    MOD_LOG_KEY_REMOVE_WHILE_FREEING, GFP_NOFS);\n\t\tif (!tm_list[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, eb))\n\t\tgoto free_tms;\n\n\tret = __tree_mod_log_free_eb(fs_info, tm_list, nritems);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tgoto free_tms;\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tfor (i = 0; i < nritems; i++)\n\t\tkfree(tm_list[i]);\n\tkfree(tm_list);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tree_mod_log_set_node_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "881-891",
    "snippet": "static noinline void\ntree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_buffer *eb, int slot, int atomic)\n{\n\tint ret;\n\n\tret = tree_mod_log_insert_key(fs_info, eb, slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE,\n\t\t\t\t\tatomic ? GFP_ATOMIC : GFP_NOFS);\n\tBUG_ON(ret < 0);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_insert_key",
          "args": [
            "fs_info",
            "eb",
            "slot",
            "MOD_LOG_KEY_REPLACE",
            "atomic ? GFP_ATOMIC : GFP_NOFS"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_insert_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "539-565",
          "snippet": "static noinline int\ntree_mod_log_insert_key(struct btrfs_fs_info *fs_info,\n\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\tenum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\tint ret;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm = alloc_tree_mod_elem(eb, slot, op, flags);\n\tif (!tm)\n\t\treturn -ENOMEM;\n\n\tif (tree_mod_dont_log(fs_info, eb)) {\n\t\tkfree(tm);\n\t\treturn 0;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tkfree(tm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_insert_key(struct btrfs_fs_info *fs_info,\n\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\tenum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\tint ret;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm = alloc_tree_mod_elem(eb, slot, op, flags);\n\tif (!tm)\n\t\treturn -ENOMEM;\n\n\tif (tree_mod_dont_log(fs_info, eb)) {\n\t\tkfree(tm);\n\t\treturn 0;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tkfree(tm);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline void\ntree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,\n\t\t\t  struct extent_buffer *eb, int slot, int atomic)\n{\n\tint ret;\n\n\tret = tree_mod_log_insert_key(fs_info, eb, slot,\n\t\t\t\t\tMOD_LOG_KEY_REPLACE,\n\t\t\t\t\tatomic ? GFP_ATOMIC : GFP_NOFS);\n\tBUG_ON(ret < 0);\n}"
  },
  {
    "function_name": "tree_mod_log_eb_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "871-879",
    "snippet": "static inline void\ntree_mod_log_eb_move(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     int dst_offset, int src_offset, int nr_items)\n{\n\tint ret;\n\tret = tree_mod_log_insert_move(fs_info, dst, dst_offset, src_offset,\n\t\t\t\t       nr_items, GFP_NOFS);\n\tBUG_ON(ret < 0);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret < 0"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_insert_move",
          "args": [
            "fs_info",
            "dst",
            "dst_offset",
            "src_offset",
            "nr_items",
            "GFP_NOFS"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_insert_move",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "567-640",
          "snippet": "static noinline int\ntree_mod_log_insert_move(struct btrfs_fs_info *fs_info,\n\t\t\t struct extent_buffer *eb, int dst_slot, int src_slot,\n\t\t\t int nr_items, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm = NULL;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint ret = 0;\n\tint i;\n\tint locked = 0;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm_list = kzalloc(nr_items * sizeof(struct tree_mod_elem *), flags);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm) {\n\t\tret = -ENOMEM;\n\t\tgoto free_tms;\n\t}\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\ttm->slot = src_slot;\n\ttm->move.dst_slot = dst_slot;\n\ttm->move.nr_items = nr_items;\n\ttm->op = MOD_LOG_MOVE_KEYS;\n\n\tfor (i = 0; i + dst_slot < src_slot && i < nr_items; i++) {\n\t\ttm_list[i] = alloc_tree_mod_elem(eb, i + dst_slot,\n\t\t    MOD_LOG_KEY_REMOVE_WHILE_MOVING, flags);\n\t\tif (!tm_list[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, eb))\n\t\tgoto free_tms;\n\tlocked = 1;\n\n\t/*\n\t * When we override something during the move, we log these removals.\n\t * This can only happen when we move towards the beginning of the\n\t * buffer, i.e. dst_slot < src_slot.\n\t */\n\tfor (i = 0; i + dst_slot < src_slot && i < nr_items; i++) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\tif (ret)\n\t\tgoto free_tms;\n\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn 0;\nfree_tms:\n\tfor (i = 0; i < nr_items; i++) {\n\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\tkfree(tm_list[i]);\n\t}\n\tif (locked)\n\t\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\tkfree(tm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_insert_move(struct btrfs_fs_info *fs_info,\n\t\t\t struct extent_buffer *eb, int dst_slot, int src_slot,\n\t\t\t int nr_items, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm = NULL;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint ret = 0;\n\tint i;\n\tint locked = 0;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm_list = kzalloc(nr_items * sizeof(struct tree_mod_elem *), flags);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm) {\n\t\tret = -ENOMEM;\n\t\tgoto free_tms;\n\t}\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\ttm->slot = src_slot;\n\ttm->move.dst_slot = dst_slot;\n\ttm->move.nr_items = nr_items;\n\ttm->op = MOD_LOG_MOVE_KEYS;\n\n\tfor (i = 0; i + dst_slot < src_slot && i < nr_items; i++) {\n\t\ttm_list[i] = alloc_tree_mod_elem(eb, i + dst_slot,\n\t\t    MOD_LOG_KEY_REMOVE_WHILE_MOVING, flags);\n\t\tif (!tm_list[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, eb))\n\t\tgoto free_tms;\n\tlocked = 1;\n\n\t/*\n\t * When we override something during the move, we log these removals.\n\t * This can only happen when we move towards the beginning of the\n\t * buffer, i.e. dst_slot < src_slot.\n\t */\n\tfor (i = 0; i + dst_slot < src_slot && i < nr_items; i++) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\tif (ret)\n\t\tgoto free_tms;\n\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn 0;\nfree_tms:\n\tfor (i = 0; i < nr_items; i++) {\n\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\tkfree(tm_list[i]);\n\t}\n\tif (locked)\n\t\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\tkfree(tm);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void\ntree_mod_log_eb_move(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     int dst_offset, int src_offset, int nr_items)\n{\n\tint ret;\n\tret = tree_mod_log_insert_move(fs_info, dst, dst_offset, src_offset,\n\t\t\t\t       nr_items, GFP_NOFS);\n\tBUG_ON(ret < 0);\n}"
  },
  {
    "function_name": "tree_mod_log_eb_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "800-869",
    "snippet": "static noinline int\ntree_mod_log_eb_copy(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     struct extent_buffer *src, unsigned long dst_offset,\n\t\t     unsigned long src_offset, int nr_items)\n{\n\tint ret = 0;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tstruct tree_mod_elem **tm_list_add, **tm_list_rem;\n\tint i;\n\tint locked = 0;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (btrfs_header_level(dst) == 0 && btrfs_header_level(src) == 0)\n\t\treturn 0;\n\n\ttm_list = kzalloc(nr_items * 2 * sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\ttm_list_add = tm_list;\n\ttm_list_rem = tm_list + nr_items;\n\tfor (i = 0; i < nr_items; i++) {\n\t\ttm_list_rem[i] = alloc_tree_mod_elem(src, i + src_offset,\n\t\t    MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tif (!tm_list_rem[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\n\t\ttm_list_add[i] = alloc_tree_mod_elem(dst, i + dst_offset,\n\t\t    MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tif (!tm_list_add[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, NULL))\n\t\tgoto free_tms;\n\tlocked = 1;\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_rem[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_add[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tfor (i = 0; i < nr_items * 2; i++) {\n\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\tkfree(tm_list[i]);\n\t}\n\tif (locked)\n\t\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm_list"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_write_unlock",
          "args": [
            "fs_info"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm_list[i]"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&tm_list[i]->node",
            "&fs_info->tree_mod_log"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&tm_list[i]->node"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm_list"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__tree_mod_log_insert",
          "args": [
            "fs_info",
            "tm_list_add[i]"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "446-478",
          "snippet": "static noinline int\n__tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tBUG_ON(!tm);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = container_of(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->index < tm->index)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->index > tm->index)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int\n__tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tBUG_ON(!tm);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = container_of(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->index < tm->index)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->index > tm->index)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_dont_log",
          "args": [
            "fs_info",
            "NULL"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_dont_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "486-501",
          "snippet": "static inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb) {\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 1;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 1;\n\n\ttree_mod_log_write_lock(fs_info);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\ttree_mod_log_write_unlock(fs_info);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb) {\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 1;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 1;\n\n\ttree_mod_log_write_lock(fs_info);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\ttree_mod_log_write_unlock(fs_info);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_tree_mod_elem",
          "args": [
            "dst",
            "i + dst_offset",
            "MOD_LOG_KEY_ADD",
            "GFP_NOFS"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_tree_mod_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "516-537",
          "snippet": "static struct tree_mod_elem *\nalloc_tree_mod_elem(struct extent_buffer *eb, int slot,\n\t\t    enum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\tif (op != MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\nalloc_tree_mod_elem(struct extent_buffer *eb, int slot,\n\t\t    enum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\tif (op != MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "nr_items * 2 * sizeof(struct tree_mod_elem *)",
            "GFP_NOFS"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "src"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "dst"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_need_log",
          "args": [
            "fs_info",
            "NULL"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_need_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "504-514",
          "snippet": "static inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 0;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 0;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_eb_copy(struct btrfs_fs_info *fs_info, struct extent_buffer *dst,\n\t\t     struct extent_buffer *src, unsigned long dst_offset,\n\t\t     unsigned long src_offset, int nr_items)\n{\n\tint ret = 0;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tstruct tree_mod_elem **tm_list_add, **tm_list_rem;\n\tint i;\n\tint locked = 0;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (btrfs_header_level(dst) == 0 && btrfs_header_level(src) == 0)\n\t\treturn 0;\n\n\ttm_list = kzalloc(nr_items * 2 * sizeof(struct tree_mod_elem *),\n\t\t\t  GFP_NOFS);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\ttm_list_add = tm_list;\n\ttm_list_rem = tm_list + nr_items;\n\tfor (i = 0; i < nr_items; i++) {\n\t\ttm_list_rem[i] = alloc_tree_mod_elem(src, i + src_offset,\n\t\t    MOD_LOG_KEY_REMOVE, GFP_NOFS);\n\t\tif (!tm_list_rem[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\n\t\ttm_list_add[i] = alloc_tree_mod_elem(dst, i + dst_offset,\n\t\t    MOD_LOG_KEY_ADD, GFP_NOFS);\n\t\tif (!tm_list_add[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, NULL))\n\t\tgoto free_tms;\n\tlocked = 1;\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_rem[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t\tret = __tree_mod_log_insert(fs_info, tm_list_add[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn 0;\n\nfree_tms:\n\tfor (i = 0; i < nr_items * 2; i++) {\n\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\tkfree(tm_list[i]);\n\t}\n\tif (locked)\n\t\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tree_mod_log_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "794-798",
    "snippet": "static struct tree_mod_elem *\ntree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq)\n{\n\treturn __tree_mod_log_search(fs_info, start, min_seq, 0);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tree_mod_log_search",
          "args": [
            "fs_info",
            "start",
            "min_seq",
            "0"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "734-775",
          "snippet": "static struct tree_mod_elem *\n__tree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq,\n\t\t      int smallest)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct tree_mod_elem *cur = NULL;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 index = start >> PAGE_CACHE_SHIFT;\n\n\ttree_mod_log_read_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tnode = tm_root->rb_node;\n\twhile (node) {\n\t\tcur = container_of(node, struct tree_mod_elem, node);\n\t\tif (cur->index < index) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->index > index) {\n\t\t\tnode = node->rb_right;\n\t\t} else if (cur->seq < min_seq) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (!smallest) {\n\t\t\t/* we want the node with the highest seq */\n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq > cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->seq > min_seq) {\n\t\t\t/* we want the node with the smallest seq */\n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq < cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_right;\n\t\t} else {\n\t\t\tfound = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttree_mod_log_read_unlock(fs_info);\n\n\treturn found;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\n__tree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq,\n\t\t      int smallest)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct tree_mod_elem *cur = NULL;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 index = start >> PAGE_CACHE_SHIFT;\n\n\ttree_mod_log_read_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tnode = tm_root->rb_node;\n\twhile (node) {\n\t\tcur = container_of(node, struct tree_mod_elem, node);\n\t\tif (cur->index < index) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->index > index) {\n\t\t\tnode = node->rb_right;\n\t\t} else if (cur->seq < min_seq) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (!smallest) {\n\t\t\t/* we want the node with the highest seq */\n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq > cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->seq > min_seq) {\n\t\t\t/* we want the node with the smallest seq */\n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq < cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_right;\n\t\t} else {\n\t\t\tfound = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttree_mod_log_read_unlock(fs_info);\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\ntree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq)\n{\n\treturn __tree_mod_log_search(fs_info, start, min_seq, 0);\n}"
  },
  {
    "function_name": "tree_mod_log_search_oldest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "782-787",
    "snippet": "static struct tree_mod_elem *\ntree_mod_log_search_oldest(struct btrfs_fs_info *fs_info, u64 start,\n\t\t\t   u64 min_seq)\n{\n\treturn __tree_mod_log_search(fs_info, start, min_seq, 1);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__tree_mod_log_search",
          "args": [
            "fs_info",
            "start",
            "min_seq",
            "1"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "734-775",
          "snippet": "static struct tree_mod_elem *\n__tree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq,\n\t\t      int smallest)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct tree_mod_elem *cur = NULL;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 index = start >> PAGE_CACHE_SHIFT;\n\n\ttree_mod_log_read_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tnode = tm_root->rb_node;\n\twhile (node) {\n\t\tcur = container_of(node, struct tree_mod_elem, node);\n\t\tif (cur->index < index) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->index > index) {\n\t\t\tnode = node->rb_right;\n\t\t} else if (cur->seq < min_seq) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (!smallest) {\n\t\t\t/* we want the node with the highest seq */\n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq > cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->seq > min_seq) {\n\t\t\t/* we want the node with the smallest seq */\n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq < cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_right;\n\t\t} else {\n\t\t\tfound = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttree_mod_log_read_unlock(fs_info);\n\n\treturn found;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\n__tree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq,\n\t\t      int smallest)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct tree_mod_elem *cur = NULL;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 index = start >> PAGE_CACHE_SHIFT;\n\n\ttree_mod_log_read_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tnode = tm_root->rb_node;\n\twhile (node) {\n\t\tcur = container_of(node, struct tree_mod_elem, node);\n\t\tif (cur->index < index) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->index > index) {\n\t\t\tnode = node->rb_right;\n\t\t} else if (cur->seq < min_seq) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (!smallest) {\n\t\t\t/* we want the node with the highest seq */\n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq > cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->seq > min_seq) {\n\t\t\t/* we want the node with the smallest seq */\n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq < cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_right;\n\t\t} else {\n\t\t\tfound = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttree_mod_log_read_unlock(fs_info);\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\ntree_mod_log_search_oldest(struct btrfs_fs_info *fs_info, u64 start,\n\t\t\t   u64 min_seq)\n{\n\treturn __tree_mod_log_search(fs_info, start, min_seq, 1);\n}"
  },
  {
    "function_name": "__tree_mod_log_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "734-775",
    "snippet": "static struct tree_mod_elem *\n__tree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq,\n\t\t      int smallest)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct tree_mod_elem *cur = NULL;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 index = start >> PAGE_CACHE_SHIFT;\n\n\ttree_mod_log_read_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tnode = tm_root->rb_node;\n\twhile (node) {\n\t\tcur = container_of(node, struct tree_mod_elem, node);\n\t\tif (cur->index < index) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->index > index) {\n\t\t\tnode = node->rb_right;\n\t\t} else if (cur->seq < min_seq) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (!smallest) {\n\t\t\t/* we want the node with the highest seq */\n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq > cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->seq > min_seq) {\n\t\t\t/* we want the node with the smallest seq */\n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq < cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_right;\n\t\t} else {\n\t\t\tfound = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttree_mod_log_read_unlock(fs_info);\n\n\treturn found;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_mod_log_read_unlock",
          "args": [
            "fs_info"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "found->seq < cur->seq"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "found->seq > cur->seq"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structtree_mod_elem",
            "node"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_read_lock",
          "args": [
            "fs_info"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\n__tree_mod_log_search(struct btrfs_fs_info *fs_info, u64 start, u64 min_seq,\n\t\t      int smallest)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct tree_mod_elem *cur = NULL;\n\tstruct tree_mod_elem *found = NULL;\n\tu64 index = start >> PAGE_CACHE_SHIFT;\n\n\ttree_mod_log_read_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tnode = tm_root->rb_node;\n\twhile (node) {\n\t\tcur = container_of(node, struct tree_mod_elem, node);\n\t\tif (cur->index < index) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->index > index) {\n\t\t\tnode = node->rb_right;\n\t\t} else if (cur->seq < min_seq) {\n\t\t\tnode = node->rb_left;\n\t\t} else if (!smallest) {\n\t\t\t/* we want the node with the highest seq */\n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq > cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_left;\n\t\t} else if (cur->seq > min_seq) {\n\t\t\t/* we want the node with the smallest seq */\n\t\t\tif (found)\n\t\t\t\tBUG_ON(found->seq < cur->seq);\n\t\t\tfound = cur;\n\t\t\tnode = node->rb_right;\n\t\t} else {\n\t\t\tfound = cur;\n\t\t\tbreak;\n\t\t}\n\t}\n\ttree_mod_log_read_unlock(fs_info);\n\n\treturn found;\n}"
  },
  {
    "function_name": "tree_mod_log_insert_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "663-732",
    "snippet": "static noinline int\ntree_mod_log_insert_root(struct btrfs_fs_info *fs_info,\n\t\t\t struct extent_buffer *old_root,\n\t\t\t struct extent_buffer *new_root, gfp_t flags,\n\t\t\t int log_removal)\n{\n\tstruct tree_mod_elem *tm = NULL;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint nritems = 0;\n\tint ret = 0;\n\tint i;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (log_removal && btrfs_header_level(old_root) > 0) {\n\t\tnritems = btrfs_header_nritems(old_root);\n\t\ttm_list = kzalloc(nritems * sizeof(struct tree_mod_elem *),\n\t\t\t\t  flags);\n\t\tif (!tm_list) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t\tfor (i = 0; i < nritems; i++) {\n\t\t\ttm_list[i] = alloc_tree_mod_elem(old_root, i,\n\t\t\t    MOD_LOG_KEY_REMOVE_WHILE_FREEING, flags);\n\t\t\tif (!tm_list[i]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_tms;\n\t\t\t}\n\t\t}\n\t}\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm) {\n\t\tret = -ENOMEM;\n\t\tgoto free_tms;\n\t}\n\n\ttm->index = new_root->start >> PAGE_CACHE_SHIFT;\n\ttm->old_root.logical = old_root->start;\n\ttm->old_root.level = btrfs_header_level(old_root);\n\ttm->generation = btrfs_header_generation(old_root);\n\ttm->op = MOD_LOG_ROOT_REPLACE;\n\n\tif (tree_mod_dont_log(fs_info, NULL))\n\t\tgoto free_tms;\n\n\tif (tm_list)\n\t\tret = __tree_mod_log_free_eb(fs_info, tm_list, nritems);\n\tif (!ret)\n\t\tret = __tree_mod_log_insert(fs_info, tm);\n\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tgoto free_tms;\n\tkfree(tm_list);\n\n\treturn ret;\n\nfree_tms:\n\tif (tm_list) {\n\t\tfor (i = 0; i < nritems; i++)\n\t\t\tkfree(tm_list[i]);\n\t\tkfree(tm_list);\n\t}\n\tkfree(tm);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm_list"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm_list[i]"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm_list"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_write_unlock",
          "args": [
            "fs_info"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__tree_mod_log_insert",
          "args": [
            "fs_info",
            "tm"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "446-478",
          "snippet": "static noinline int\n__tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tBUG_ON(!tm);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = container_of(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->index < tm->index)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->index > tm->index)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int\n__tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tBUG_ON(!tm);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = container_of(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->index < tm->index)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->index > tm->index)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__tree_mod_log_free_eb",
          "args": [
            "fs_info",
            "tm_list",
            "nritems"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_free_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "642-661",
          "snippet": "static inline int\n__tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t       struct tree_mod_elem **tm_list,\n\t\t       int nritems)\n{\n\tint i, j;\n\tint ret;\n\n\tfor (i = nritems - 1; i >= 0; i--) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list[i]);\n\t\tif (ret) {\n\t\t\tfor (j = nritems - 1; j > i; j--)\n\t\t\t\trb_erase(&tm_list[j]->node,\n\t\t\t\t\t &fs_info->tree_mod_log);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline int\n__tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t       struct tree_mod_elem **tm_list,\n\t\t       int nritems)\n{\n\tint i, j;\n\tint ret;\n\n\tfor (i = nritems - 1; i >= 0; i--) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list[i]);\n\t\tif (ret) {\n\t\t\tfor (j = nritems - 1; j > i; j--)\n\t\t\t\trb_erase(&tm_list[j]->node,\n\t\t\t\t\t &fs_info->tree_mod_log);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_dont_log",
          "args": [
            "fs_info",
            "NULL"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_dont_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "486-501",
          "snippet": "static inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb) {\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 1;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 1;\n\n\ttree_mod_log_write_lock(fs_info);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\ttree_mod_log_write_unlock(fs_info);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb) {\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 1;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 1;\n\n\ttree_mod_log_write_lock(fs_info);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\ttree_mod_log_write_unlock(fs_info);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "old_root"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "old_root"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tm)",
            "flags"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_tree_mod_elem",
          "args": [
            "old_root",
            "i",
            "MOD_LOG_KEY_REMOVE_WHILE_FREEING",
            "flags"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_tree_mod_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "516-537",
          "snippet": "static struct tree_mod_elem *\nalloc_tree_mod_elem(struct extent_buffer *eb, int slot,\n\t\t    enum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\tif (op != MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\nalloc_tree_mod_elem(struct extent_buffer *eb, int slot,\n\t\t    enum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\tif (op != MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "nritems * sizeof(struct tree_mod_elem *)",
            "flags"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "old_root"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "old_root"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_need_log",
          "args": [
            "fs_info",
            "NULL"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_need_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "504-514",
          "snippet": "static inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 0;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 0;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_insert_root(struct btrfs_fs_info *fs_info,\n\t\t\t struct extent_buffer *old_root,\n\t\t\t struct extent_buffer *new_root, gfp_t flags,\n\t\t\t int log_removal)\n{\n\tstruct tree_mod_elem *tm = NULL;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint nritems = 0;\n\tint ret = 0;\n\tint i;\n\n\tif (!tree_mod_need_log(fs_info, NULL))\n\t\treturn 0;\n\n\tif (log_removal && btrfs_header_level(old_root) > 0) {\n\t\tnritems = btrfs_header_nritems(old_root);\n\t\ttm_list = kzalloc(nritems * sizeof(struct tree_mod_elem *),\n\t\t\t\t  flags);\n\t\tif (!tm_list) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t\tfor (i = 0; i < nritems; i++) {\n\t\t\ttm_list[i] = alloc_tree_mod_elem(old_root, i,\n\t\t\t    MOD_LOG_KEY_REMOVE_WHILE_FREEING, flags);\n\t\t\tif (!tm_list[i]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_tms;\n\t\t\t}\n\t\t}\n\t}\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm) {\n\t\tret = -ENOMEM;\n\t\tgoto free_tms;\n\t}\n\n\ttm->index = new_root->start >> PAGE_CACHE_SHIFT;\n\ttm->old_root.logical = old_root->start;\n\ttm->old_root.level = btrfs_header_level(old_root);\n\ttm->generation = btrfs_header_generation(old_root);\n\ttm->op = MOD_LOG_ROOT_REPLACE;\n\n\tif (tree_mod_dont_log(fs_info, NULL))\n\t\tgoto free_tms;\n\n\tif (tm_list)\n\t\tret = __tree_mod_log_free_eb(fs_info, tm_list, nritems);\n\tif (!ret)\n\t\tret = __tree_mod_log_insert(fs_info, tm);\n\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tgoto free_tms;\n\tkfree(tm_list);\n\n\treturn ret;\n\nfree_tms:\n\tif (tm_list) {\n\t\tfor (i = 0; i < nritems; i++)\n\t\t\tkfree(tm_list[i]);\n\t\tkfree(tm_list);\n\t}\n\tkfree(tm);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__tree_mod_log_free_eb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "642-661",
    "snippet": "static inline int\n__tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t       struct tree_mod_elem **tm_list,\n\t\t       int nritems)\n{\n\tint i, j;\n\tint ret;\n\n\tfor (i = nritems - 1; i >= 0; i--) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list[i]);\n\t\tif (ret) {\n\t\t\tfor (j = nritems - 1; j > i; j--)\n\t\t\t\trb_erase(&tm_list[j]->node,\n\t\t\t\t\t &fs_info->tree_mod_log);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&tm_list[j]->node",
            "&fs_info->tree_mod_log"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__tree_mod_log_insert",
          "args": [
            "fs_info",
            "tm_list[i]"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "446-478",
          "snippet": "static noinline int\n__tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tBUG_ON(!tm);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = container_of(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->index < tm->index)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->index > tm->index)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int\n__tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tBUG_ON(!tm);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = container_of(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->index < tm->index)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->index > tm->index)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline int\n__tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t       struct tree_mod_elem **tm_list,\n\t\t       int nritems)\n{\n\tint i, j;\n\tint ret;\n\n\tfor (i = nritems - 1; i >= 0; i--) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list[i]);\n\t\tif (ret) {\n\t\t\tfor (j = nritems - 1; j > i; j--)\n\t\t\t\trb_erase(&tm_list[j]->node,\n\t\t\t\t\t &fs_info->tree_mod_log);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "tree_mod_log_insert_move",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "567-640",
    "snippet": "static noinline int\ntree_mod_log_insert_move(struct btrfs_fs_info *fs_info,\n\t\t\t struct extent_buffer *eb, int dst_slot, int src_slot,\n\t\t\t int nr_items, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm = NULL;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint ret = 0;\n\tint i;\n\tint locked = 0;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm_list = kzalloc(nr_items * sizeof(struct tree_mod_elem *), flags);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm) {\n\t\tret = -ENOMEM;\n\t\tgoto free_tms;\n\t}\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\ttm->slot = src_slot;\n\ttm->move.dst_slot = dst_slot;\n\ttm->move.nr_items = nr_items;\n\ttm->op = MOD_LOG_MOVE_KEYS;\n\n\tfor (i = 0; i + dst_slot < src_slot && i < nr_items; i++) {\n\t\ttm_list[i] = alloc_tree_mod_elem(eb, i + dst_slot,\n\t\t    MOD_LOG_KEY_REMOVE_WHILE_MOVING, flags);\n\t\tif (!tm_list[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, eb))\n\t\tgoto free_tms;\n\tlocked = 1;\n\n\t/*\n\t * When we override something during the move, we log these removals.\n\t * This can only happen when we move towards the beginning of the\n\t * buffer, i.e. dst_slot < src_slot.\n\t */\n\tfor (i = 0; i + dst_slot < src_slot && i < nr_items; i++) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\tif (ret)\n\t\tgoto free_tms;\n\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn 0;\nfree_tms:\n\tfor (i = 0; i < nr_items; i++) {\n\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\tkfree(tm_list[i]);\n\t}\n\tif (locked)\n\t\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\tkfree(tm);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm_list"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_write_unlock",
          "args": [
            "fs_info"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm_list[i]"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&tm_list[i]->node",
            "&fs_info->tree_mod_log"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&tm_list[i]->node"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm_list"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__tree_mod_log_insert",
          "args": [
            "fs_info",
            "tm"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "446-478",
          "snippet": "static noinline int\n__tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tBUG_ON(!tm);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = container_of(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->index < tm->index)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->index > tm->index)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int\n__tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tBUG_ON(!tm);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = container_of(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->index < tm->index)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->index > tm->index)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_dont_log",
          "args": [
            "fs_info",
            "eb"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_dont_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "486-501",
          "snippet": "static inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb) {\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 1;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 1;\n\n\ttree_mod_log_write_lock(fs_info);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\ttree_mod_log_write_unlock(fs_info);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb) {\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 1;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 1;\n\n\ttree_mod_log_write_lock(fs_info);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\ttree_mod_log_write_unlock(fs_info);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_tree_mod_elem",
          "args": [
            "eb",
            "i + dst_slot",
            "MOD_LOG_KEY_REMOVE_WHILE_MOVING",
            "flags"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_tree_mod_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "516-537",
          "snippet": "static struct tree_mod_elem *\nalloc_tree_mod_elem(struct extent_buffer *eb, int slot,\n\t\t    enum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\tif (op != MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\nalloc_tree_mod_elem(struct extent_buffer *eb, int slot,\n\t\t    enum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\tif (op != MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tm)",
            "flags"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "nr_items * sizeof(struct tree_mod_elem *)",
            "flags"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_need_log",
          "args": [
            "fs_info",
            "eb"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_need_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "504-514",
          "snippet": "static inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 0;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 0;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_insert_move(struct btrfs_fs_info *fs_info,\n\t\t\t struct extent_buffer *eb, int dst_slot, int src_slot,\n\t\t\t int nr_items, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm = NULL;\n\tstruct tree_mod_elem **tm_list = NULL;\n\tint ret = 0;\n\tint i;\n\tint locked = 0;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm_list = kzalloc(nr_items * sizeof(struct tree_mod_elem *), flags);\n\tif (!tm_list)\n\t\treturn -ENOMEM;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm) {\n\t\tret = -ENOMEM;\n\t\tgoto free_tms;\n\t}\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\ttm->slot = src_slot;\n\ttm->move.dst_slot = dst_slot;\n\ttm->move.nr_items = nr_items;\n\ttm->op = MOD_LOG_MOVE_KEYS;\n\n\tfor (i = 0; i + dst_slot < src_slot && i < nr_items; i++) {\n\t\ttm_list[i] = alloc_tree_mod_elem(eb, i + dst_slot,\n\t\t    MOD_LOG_KEY_REMOVE_WHILE_MOVING, flags);\n\t\tif (!tm_list[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_tms;\n\t\t}\n\t}\n\n\tif (tree_mod_dont_log(fs_info, eb))\n\t\tgoto free_tms;\n\tlocked = 1;\n\n\t/*\n\t * When we override something during the move, we log these removals.\n\t * This can only happen when we move towards the beginning of the\n\t * buffer, i.e. dst_slot < src_slot.\n\t */\n\tfor (i = 0; i + dst_slot < src_slot && i < nr_items; i++) {\n\t\tret = __tree_mod_log_insert(fs_info, tm_list[i]);\n\t\tif (ret)\n\t\t\tgoto free_tms;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\tif (ret)\n\t\tgoto free_tms;\n\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\n\treturn 0;\nfree_tms:\n\tfor (i = 0; i < nr_items; i++) {\n\t\tif (tm_list[i] && !RB_EMPTY_NODE(&tm_list[i]->node))\n\t\t\trb_erase(&tm_list[i]->node, &fs_info->tree_mod_log);\n\t\tkfree(tm_list[i]);\n\t}\n\tif (locked)\n\t\ttree_mod_log_write_unlock(fs_info);\n\tkfree(tm_list);\n\tkfree(tm);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tree_mod_log_insert_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "539-565",
    "snippet": "static noinline int\ntree_mod_log_insert_key(struct btrfs_fs_info *fs_info,\n\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\tenum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\tint ret;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm = alloc_tree_mod_elem(eb, slot, op, flags);\n\tif (!tm)\n\t\treturn -ENOMEM;\n\n\tif (tree_mod_dont_log(fs_info, eb)) {\n\t\tkfree(tm);\n\t\treturn 0;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tkfree(tm);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_write_unlock",
          "args": [
            "fs_info"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__tree_mod_log_insert",
          "args": [
            "fs_info",
            "tm"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "__tree_mod_log_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "446-478",
          "snippet": "static noinline int\n__tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tBUG_ON(!tm);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = container_of(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->index < tm->index)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->index > tm->index)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int\n__tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tBUG_ON(!tm);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = container_of(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->index < tm->index)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->index > tm->index)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_dont_log",
          "args": [
            "fs_info",
            "eb"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_dont_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "486-501",
          "snippet": "static inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb) {\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 1;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 1;\n\n\ttree_mod_log_write_lock(fs_info);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\ttree_mod_log_write_unlock(fs_info);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb) {\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 1;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 1;\n\n\ttree_mod_log_write_lock(fs_info);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\ttree_mod_log_write_unlock(fs_info);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_tree_mod_elem",
          "args": [
            "eb",
            "slot",
            "op",
            "flags"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_tree_mod_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "516-537",
          "snippet": "static struct tree_mod_elem *\nalloc_tree_mod_elem(struct extent_buffer *eb, int slot,\n\t\t    enum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\tif (op != MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\nalloc_tree_mod_elem(struct extent_buffer *eb, int slot,\n\t\t    enum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\tif (op != MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_need_log",
          "args": [
            "fs_info",
            "eb"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_need_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "504-514",
          "snippet": "static inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 0;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 0;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic noinline int\ntree_mod_log_insert_key(struct btrfs_fs_info *fs_info,\n\t\t\tstruct extent_buffer *eb, int slot,\n\t\t\tenum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\tint ret;\n\n\tif (!tree_mod_need_log(fs_info, eb))\n\t\treturn 0;\n\n\ttm = alloc_tree_mod_elem(eb, slot, op, flags);\n\tif (!tm)\n\t\treturn -ENOMEM;\n\n\tif (tree_mod_dont_log(fs_info, eb)) {\n\t\tkfree(tm);\n\t\treturn 0;\n\t}\n\n\tret = __tree_mod_log_insert(fs_info, tm);\n\ttree_mod_log_write_unlock(fs_info);\n\tif (ret)\n\t\tkfree(tm);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "alloc_tree_mod_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "516-537",
    "snippet": "static struct tree_mod_elem *\nalloc_tree_mod_elem(struct extent_buffer *eb, int slot,\n\t\t    enum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\tif (op != MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&tm->node"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "eb",
            "slot"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "eb",
            "slot"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key",
          "args": [
            "eb",
            "&tm->key",
            "slot"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tm)",
            "flags"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic struct tree_mod_elem *\nalloc_tree_mod_elem(struct extent_buffer *eb, int slot,\n\t\t    enum mod_log_op op, gfp_t flags)\n{\n\tstruct tree_mod_elem *tm;\n\n\ttm = kzalloc(sizeof(*tm), flags);\n\tif (!tm)\n\t\treturn NULL;\n\n\ttm->index = eb->start >> PAGE_CACHE_SHIFT;\n\tif (op != MOD_LOG_KEY_ADD) {\n\t\tbtrfs_node_key(eb, &tm->key, slot);\n\t\ttm->blockptr = btrfs_node_blockptr(eb, slot);\n\t}\n\ttm->op = op;\n\ttm->slot = slot;\n\ttm->generation = btrfs_node_ptr_generation(eb, slot);\n\tRB_CLEAR_NODE(&tm->node);\n\n\treturn tm;\n}"
  },
  {
    "function_name": "tree_mod_need_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "504-514",
    "snippet": "static inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 0;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&(fs_info)->tree_mod_seq_list"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline int tree_mod_need_log(const struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb)\n{\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 0;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "tree_mod_dont_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "486-501",
    "snippet": "static inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb) {\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 1;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 1;\n\n\ttree_mod_log_write_lock(fs_info);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\ttree_mod_log_write_unlock(fs_info);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_mod_log_write_unlock",
          "args": [
            "fs_info"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&(fs_info)->tree_mod_seq_list"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_log_write_lock",
          "args": [
            "fs_info"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic inline int tree_mod_dont_log(struct btrfs_fs_info *fs_info,\n\t\t\t\t    struct extent_buffer *eb) {\n\tsmp_mb();\n\tif (list_empty(&(fs_info)->tree_mod_seq_list))\n\t\treturn 1;\n\tif (eb && btrfs_header_level(eb) == 0)\n\t\treturn 1;\n\n\ttree_mod_log_write_lock(fs_info);\n\tif (list_empty(&(fs_info)->tree_mod_seq_list)) {\n\t\ttree_mod_log_write_unlock(fs_info);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__tree_mod_log_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "446-478",
    "snippet": "static noinline int\n__tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tBUG_ON(!tm);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = container_of(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->index < tm->index)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->index > tm->index)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&tm->node",
            "tm_root"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&tm->node",
            "parent",
            "new"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "*new",
            "structtree_mod_elem",
            "node"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inc_tree_mod_seq",
          "args": [
            "fs_info"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inc_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "358-361",
          "snippet": "static inline u64 btrfs_inc_tree_mod_seq(struct btrfs_fs_info *fs_info)\n{\n\treturn atomic64_inc_return(&fs_info->tree_mod_seq);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline u64 btrfs_inc_tree_mod_seq(struct btrfs_fs_info *fs_info)\n{\n\treturn atomic64_inc_return(&fs_info->tree_mod_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tm"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic noinline int\n__tree_mod_log_insert(struct btrfs_fs_info *fs_info, struct tree_mod_elem *tm)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node **new;\n\tstruct rb_node *parent = NULL;\n\tstruct tree_mod_elem *cur;\n\n\tBUG_ON(!tm);\n\n\ttm->seq = btrfs_inc_tree_mod_seq(fs_info);\n\n\ttm_root = &fs_info->tree_mod_log;\n\tnew = &tm_root->rb_node;\n\twhile (*new) {\n\t\tcur = container_of(*new, struct tree_mod_elem, node);\n\t\tparent = *new;\n\t\tif (cur->index < tm->index)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->index > tm->index)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse if (cur->seq < tm->seq)\n\t\t\tnew = &((*new)->rb_left);\n\t\telse if (cur->seq > tm->seq)\n\t\t\tnew = &((*new)->rb_right);\n\t\telse\n\t\t\treturn -EEXIST;\n\t}\n\n\trb_link_node(&tm->node, parent, new);\n\trb_insert_color(&tm->node, tm_root);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_put_tree_mod_seq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "386-434",
    "snippet": "void btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_mod_log_write_unlock",
          "args": [
            "fs_info"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tm"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "node",
            "tm_root"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "node",
            "structtree_mod_elem",
            "node"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "node"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "tm_root"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree_mod_log_write_lock",
          "args": [
            "fs_info"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->tree_mod_seq_lock"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur_elem",
            "&fs_info->tree_mod_seq_list",
            "list"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&elem->list"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->tree_mod_seq_lock"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}"
  },
  {
    "function_name": "btrfs_get_tree_mod_seq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "371-384",
    "snippet": "u64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tree_mod_log_write_unlock",
          "args": [
            "fs_info"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->tree_mod_seq_lock"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&elem->list",
            "&fs_info->tree_mod_seq_list"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inc_tree_mod_seq",
          "args": [
            "fs_info"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inc_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "358-361",
          "snippet": "static inline u64 btrfs_inc_tree_mod_seq(struct btrfs_fs_info *fs_info)\n{\n\treturn atomic64_inc_return(&fs_info->tree_mod_seq);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline u64 btrfs_inc_tree_mod_seq(struct btrfs_fs_info *fs_info)\n{\n\treturn atomic64_inc_return(&fs_info->tree_mod_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->tree_mod_seq_lock"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree_mod_log_write_lock",
          "args": [
            "fs_info"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nu64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}"
  },
  {
    "function_name": "btrfs_inc_tree_mod_seq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "358-361",
    "snippet": "static inline u64 btrfs_inc_tree_mod_seq(struct btrfs_fs_info *fs_info)\n{\n\treturn atomic64_inc_return(&fs_info->tree_mod_seq);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_inc_return",
          "args": [
            "&fs_info->tree_mod_seq"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline u64 btrfs_inc_tree_mod_seq(struct btrfs_fs_info *fs_info)\n{\n\treturn atomic64_inc_return(&fs_info->tree_mod_seq);\n}"
  },
  {
    "function_name": "tree_mod_log_write_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "350-353",
    "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&fs_info->tree_mod_log_lock"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "350-353",
          "snippet": "static inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_unlock(struct btrfs_fs_info *fs_info)\n{\n\twrite_unlock(&fs_info->tree_mod_log_lock);\n}"
  },
  {
    "function_name": "tree_mod_log_write_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "345-348",
    "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&fs_info->tree_mod_log_lock"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "345-348",
          "snippet": "static inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_write_lock(struct btrfs_fs_info *fs_info)\n{\n\twrite_lock(&fs_info->tree_mod_log_lock);\n}"
  },
  {
    "function_name": "tree_mod_log_read_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "340-343",
    "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&fs_info->tree_mod_log_lock"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
  },
  {
    "function_name": "tree_mod_log_read_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "335-338",
    "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&fs_info->tree_mod_log_lock"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "335-338",
          "snippet": "static inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_lock(struct btrfs_fs_info *fs_info)\n{\n\tread_lock(&fs_info->tree_mod_log_lock);\n}"
  },
  {
    "function_name": "btrfs_copy_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "238-290",
    "snippet": "int btrfs_copy_root(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root,\n\t\t      struct extent_buffer *buf,\n\t\t      struct extent_buffer **cow_ret, u64 new_root_objectid)\n{\n\tstruct extent_buffer *cow;\n\tint ret = 0;\n\tint level;\n\tstruct btrfs_disk_key disk_key;\n\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tcow = btrfs_alloc_tree_block(trans, root, 0, new_root_objectid,\n\t\t\t&disk_key, level, buf->start, 0);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\tcopy_extent_buffer(cow, buf, 0, 0, cow->len);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, new_root_objectid);\n\n\twrite_extent_buffer(cow, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\tWARN_ON(btrfs_header_generation(buf) > trans->transid);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\telse\n\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_mark_buffer_dirty(cow);\n\t*cow_ret = cow;\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_mark_buffer_dirty",
          "args": [
            "cow"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3763-3795",
          "snippet": "void btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid btrfs_mark_buffer_dirty(struct extent_buffer *buf)\n{\n\tstruct btrfs_root *root;\n\tu64 transid = btrfs_header_generation(buf);\n\tint was_dirty;\n\n#ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS\n\t/*\n\t * This is a fast path so only do this check if we have sanity tests\n\t * enabled.  Normal people shouldn't be marking dummy buffers as dirty\n\t * outside of the sanity tests.\n\t */\n\tif (unlikely(test_bit(EXTENT_BUFFER_DUMMY, &buf->bflags)))\n\t\treturn;\n#endif\n\troot = BTRFS_I(buf->pages[0]->mapping->host)->root;\n\tbtrfs_assert_tree_locked(buf);\n\tif (transid != root->fs_info->generation)\n\t\tWARN(1, KERN_CRIT \"btrfs transid mismatch buffer %llu, \"\n\t\t       \"found %llu running %llu\\n\",\n\t\t\tbuf->start, transid, root->fs_info->generation);\n\twas_dirty = set_extent_buffer_dirty(buf);\n\tif (!was_dirty)\n\t\t__percpu_counter_add(&root->fs_info->dirty_metadata_bytes,\n\t\t\t\t     buf->len,\n\t\t\t\t     root->fs_info->dirty_metadata_batch);\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_header_level(buf) == 0 && check_leaf(root, buf)) {\n\t\tbtrfs_print_leaf(root, buf);\n\t\tASSERT(0);\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inc_ref",
          "args": [
            "trans",
            "root",
            "cow",
            "0"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_inc_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3117-3121",
          "snippet": "int btrfs_inc_ref(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t  struct extent_buffer *buf, int full_backref)\n{\n\treturn __btrfs_mod_ref(trans, root, buf, full_backref, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_inc_ref(struct btrfs_trans_handle *trans, struct btrfs_root *root,\n\t\t  struct extent_buffer *buf, int full_backref)\n{\n\treturn __btrfs_mod_ref(trans, root, buf, full_backref, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "btrfs_header_generation(buf) > trans->transid"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "buf"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_extent_buffer",
          "args": [
            "cow",
            "root->fs_info->fsid",
            "btrfs_header_fsid()",
            "BTRFS_FSID_SIZE"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "write_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5356-5385",
          "snippet": "void write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid write_extent_buffer(struct extent_buffer *eb, const void *srcv,\n\t\t\t unsigned long start, unsigned long len)\n{\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tchar *src = (char *)srcv;\n\tsize_t start_offset = eb->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + start) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(start > eb->len);\n\tWARN_ON(start + len > eb->start + eb->len);\n\n\toffset = (start_offset + start) & (PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = eb->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, PAGE_CACHE_SIZE - offset);\n\t\tkaddr = page_address(page);\n\t\tmemcpy(kaddr + offset, src, cur);\n\n\t\tsrc += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_fsid",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_header_fsid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2832-2835",
          "snippet": "static inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline unsigned long btrfs_header_fsid(void)\n{\n\treturn offsetof(struct btrfs_header, fsid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_owner",
          "args": [
            "cow",
            "new_root_objectid"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_flag",
          "args": [
            "cow",
            "BTRFS_HEADER_FLAG_RELOC"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2803-2808",
          "snippet": "static inline int btrfs_set_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tbtrfs_set_header_flags(eb, flags | flag);\n\treturn (flags & flag) == flag;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_set_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tbtrfs_set_header_flags(eb, flags | flag);\n\treturn (flags & flag) == flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clear_header_flag",
          "args": [
            "cow",
            "BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_header_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2810-2815",
          "snippet": "static inline int btrfs_clear_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tbtrfs_set_header_flags(eb, flags & ~flag);\n\treturn (flags & flag) == flag;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_clear_header_flag(struct extent_buffer *eb, u64 flag)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tbtrfs_set_header_flags(eb, flags & ~flag);\n\treturn (flags & flag) == flag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_backref_rev",
          "args": [
            "cow",
            "BTRFS_MIXED_BACKREF_REV"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_header_backref_rev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2823-2830",
          "snippet": "static inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)",
            "#define BTRFS_BACKREF_REV_SHIFT\t\t56"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_BACKREF_REV_MASK\t\t(((u64)BTRFS_BACKREF_REV_MAX - 1) << \\\n\t\t\t\t\t BTRFS_BACKREF_REV_SHIFT)\n#define BTRFS_BACKREF_REV_SHIFT\t\t56\n\nstatic inline void btrfs_set_header_backref_rev(struct extent_buffer *eb,\n\t\t\t\t\t\tint rev)\n{\n\tu64 flags = btrfs_header_flags(eb);\n\tflags &= ~BTRFS_BACKREF_REV_MASK;\n\tflags |= (u64)rev << BTRFS_BACKREF_REV_SHIFT;\n\tbtrfs_set_header_flags(eb, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_generation",
          "args": [
            "cow",
            "trans->transid"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_header_bytenr",
          "args": [
            "cow",
            "cow->start"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_extent_buffer",
          "args": [
            "cow",
            "buf",
            "0",
            "0",
            "cow->len"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "copy_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5416-5447",
          "snippet": "void copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid copy_extent_buffer(struct extent_buffer *dst, struct extent_buffer *src,\n\t\t\tunsigned long dst_offset, unsigned long src_offset,\n\t\t\tunsigned long len)\n{\n\tu64 dst_len = dst->len;\n\tsize_t cur;\n\tsize_t offset;\n\tstruct page *page;\n\tchar *kaddr;\n\tsize_t start_offset = dst->start & ((u64)PAGE_CACHE_SIZE - 1);\n\tunsigned long i = (start_offset + dst_offset) >> PAGE_CACHE_SHIFT;\n\n\tWARN_ON(src->len != dst_len);\n\n\toffset = (start_offset + dst_offset) &\n\t\t(PAGE_CACHE_SIZE - 1);\n\n\twhile (len > 0) {\n\t\tpage = dst->pages[i];\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\tcur = min(len, (unsigned long)(PAGE_CACHE_SIZE - offset));\n\n\t\tkaddr = page_address(page);\n\t\tread_extent_buffer(src, kaddr + offset, src_offset, cur);\n\n\t\tsrc_offset += cur;\n\t\tlen -= cur;\n\t\toffset = 0;\n\t\ti++;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cow"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cow"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_tree_block",
          "args": [
            "trans",
            "root",
            "0",
            "new_root_objectid",
            "&disk_key",
            "level",
            "buf->start",
            "0"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "7316-7385",
          "snippet": "struct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_alloc_tree_block(struct btrfs_trans_handle *trans,\n\t\t\t\t\tstruct btrfs_root *root,\n\t\t\t\t\tu64 parent, u64 root_objectid,\n\t\t\t\t\tstruct btrfs_disk_key *key, int level,\n\t\t\t\t\tu64 hint, u64 empty_size)\n{\n\tstruct btrfs_key ins;\n\tstruct btrfs_block_rsv *block_rsv;\n\tstruct extent_buffer *buf;\n\tu64 flags = 0;\n\tint ret;\n\tu32 blocksize = root->nodesize;\n\tbool skinny_metadata = btrfs_fs_incompat(root->fs_info,\n\t\t\t\t\t\t SKINNY_METADATA);\n\n\tif (btrfs_test_is_dummy_root(root)) {\n\t\tbuf = btrfs_init_new_buffer(trans, root, root->alloc_bytenr,\n\t\t\t\t\t    level);\n\t\tif (!IS_ERR(buf))\n\t\t\troot->alloc_bytenr += blocksize;\n\t\treturn buf;\n\t}\n\n\tblock_rsv = use_block_rsv(trans, root, blocksize);\n\tif (IS_ERR(block_rsv))\n\t\treturn ERR_CAST(block_rsv);\n\n\tret = btrfs_reserve_extent(root, blocksize, blocksize,\n\t\t\t\t   empty_size, hint, &ins, 0, 0);\n\tif (ret) {\n\t\tunuse_block_rsv(root->fs_info, block_rsv, blocksize);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tbuf = btrfs_init_new_buffer(trans, root, ins.objectid, level);\n\tBUG_ON(IS_ERR(buf)); /* -ENOMEM */\n\n\tif (root_objectid == BTRFS_TREE_RELOC_OBJECTID) {\n\t\tif (parent == 0)\n\t\t\tparent = ins.objectid;\n\t\tflags |= BTRFS_BLOCK_FLAG_FULL_BACKREF;\n\t} else\n\t\tBUG_ON(parent > 0);\n\n\tif (root_objectid != BTRFS_TREE_LOG_OBJECTID) {\n\t\tstruct btrfs_delayed_extent_op *extent_op;\n\t\textent_op = btrfs_alloc_delayed_extent_op();\n\t\tBUG_ON(!extent_op); /* -ENOMEM */\n\t\tif (key)\n\t\t\tmemcpy(&extent_op->key, key, sizeof(extent_op->key));\n\t\telse\n\t\t\tmemset(&extent_op->key, 0, sizeof(extent_op->key));\n\t\textent_op->flags_to_set = flags;\n\t\tif (skinny_metadata)\n\t\t\textent_op->update_key = 0;\n\t\telse\n\t\t\textent_op->update_key = 1;\n\t\textent_op->update_flags = 1;\n\t\textent_op->is_data = 0;\n\t\textent_op->level = level;\n\n\t\tret = btrfs_add_delayed_tree_ref(root->fs_info, trans,\n\t\t\t\t\tins.objectid,\n\t\t\t\t\tins.offset, parent, root_objectid,\n\t\t\t\t\tlevel, BTRFS_ADD_DELAYED_EXTENT,\n\t\t\t\t\textent_op, 0);\n\t\tBUG_ON(ret); /* -ENOMEM */\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key",
          "args": [
            "buf",
            "&disk_key",
            "0"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key",
          "args": [
            "buf",
            "&disk_key",
            "0"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "buf"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_REF_COWS",
            "&root->state"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nint btrfs_copy_root(struct btrfs_trans_handle *trans,\n\t\t      struct btrfs_root *root,\n\t\t      struct extent_buffer *buf,\n\t\t      struct extent_buffer **cow_ret, u64 new_root_objectid)\n{\n\tstruct extent_buffer *cow;\n\tint ret = 0;\n\tint level;\n\tstruct btrfs_disk_key disk_key;\n\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->fs_info->running_transaction->transid);\n\tWARN_ON(test_bit(BTRFS_ROOT_REF_COWS, &root->state) &&\n\t\ttrans->transid != root->last_trans);\n\n\tlevel = btrfs_header_level(buf);\n\tif (level == 0)\n\t\tbtrfs_item_key(buf, &disk_key, 0);\n\telse\n\t\tbtrfs_node_key(buf, &disk_key, 0);\n\n\tcow = btrfs_alloc_tree_block(trans, root, 0, new_root_objectid,\n\t\t\t&disk_key, level, buf->start, 0);\n\tif (IS_ERR(cow))\n\t\treturn PTR_ERR(cow);\n\n\tcopy_extent_buffer(cow, buf, 0, 0, cow->len);\n\tbtrfs_set_header_bytenr(cow, cow->start);\n\tbtrfs_set_header_generation(cow, trans->transid);\n\tbtrfs_set_header_backref_rev(cow, BTRFS_MIXED_BACKREF_REV);\n\tbtrfs_clear_header_flag(cow, BTRFS_HEADER_FLAG_WRITTEN |\n\t\t\t\t     BTRFS_HEADER_FLAG_RELOC);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tbtrfs_set_header_flag(cow, BTRFS_HEADER_FLAG_RELOC);\n\telse\n\t\tbtrfs_set_header_owner(cow, new_root_objectid);\n\n\twrite_extent_buffer(cow, root->fs_info->fsid, btrfs_header_fsid(),\n\t\t\t    BTRFS_FSID_SIZE);\n\n\tWARN_ON(btrfs_header_generation(buf) > trans->transid);\n\tif (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)\n\t\tret = btrfs_inc_ref(trans, root, cow, 1);\n\telse\n\t\tret = btrfs_inc_ref(trans, root, cow, 0);\n\n\tif (ret)\n\t\treturn ret;\n\n\tbtrfs_mark_buffer_dirty(cow);\n\t*cow_ret = cow;\n\treturn 0;\n}"
  },
  {
    "function_name": "add_root_to_dirty_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "214-231",
    "snippet": "static void add_root_to_dirty_list(struct btrfs_root *root)\n{\n\tif (test_bit(BTRFS_ROOT_DIRTY, &root->state) ||\n\t    !test_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state))\n\t\treturn;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (!test_and_set_bit(BTRFS_ROOT_DIRTY, &root->state)) {\n\t\t/* Want the extent tree to be the last on the list */\n\t\tif (root->objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\t\tlist_move_tail(&root->dirty_list,\n\t\t\t\t       &root->fs_info->dirty_cowonly_roots);\n\t\telse\n\t\t\tlist_move(&root->dirty_list,\n\t\t\t\t  &root->fs_info->dirty_cowonly_roots);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&root->dirty_list",
            "&root->fs_info->dirty_cowonly_roots"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&root->dirty_list",
            "&root->fs_info->dirty_cowonly_roots"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "BTRFS_ROOT_DIRTY",
            "&root->state"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&root->fs_info->trans_lock"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_ROOT_TRACK_DIRTY",
            "&root->state"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic void add_root_to_dirty_list(struct btrfs_root *root)\n{\n\tif (test_bit(BTRFS_ROOT_DIRTY, &root->state) ||\n\t    !test_bit(BTRFS_ROOT_TRACK_DIRTY, &root->state))\n\t\treturn;\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tif (!test_and_set_bit(BTRFS_ROOT_DIRTY, &root->state)) {\n\t\t/* Want the extent tree to be the last on the list */\n\t\tif (root->objectid == BTRFS_EXTENT_TREE_OBJECTID)\n\t\t\tlist_move_tail(&root->dirty_list,\n\t\t\t\t       &root->fs_info->dirty_cowonly_roots);\n\t\telse\n\t\t\tlist_move(&root->dirty_list,\n\t\t\t\t  &root->fs_info->dirty_cowonly_roots);\n\t}\n\tspin_unlock(&root->fs_info->trans_lock);\n}"
  },
  {
    "function_name": "btrfs_read_lock_root_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "195-208",
    "snippet": "static struct extent_buffer *btrfs_read_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_read_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_read_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_unlock",
          "args": [
            "eb"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_lock",
          "args": [
            "eb"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_lock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "135-148",
          "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_node",
          "args": [
            "root"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "148-170",
          "snippet": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstatic struct extent_buffer *btrfs_read_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_read_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_read_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}"
  },
  {
    "function_name": "btrfs_lock_root_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "176-189",
    "snippet": "struct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock",
          "args": [
            "eb"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "269-290",
          "snippet": "void btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_unlock(struct extent_buffer *eb)\n{\n\tint blockers = atomic_read(&eb->blocking_writers);\n\n\tBUG_ON(blockers > 1);\n\n\tbtrfs_assert_tree_locked(eb);\n\teb->lock_owner = 0;\n\tatomic_dec(&eb->write_locks);\n\n\tif (blockers) {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_dec(&eb->blocking_writers);\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else {\n\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\tatomic_dec(&eb->spinning_writers);\n\t\twrite_unlock(&eb->lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_lock",
          "args": [
            "eb"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "242-264",
          "snippet": "void btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_lock(struct extent_buffer *eb)\n{\nagain:\n\twait_event(eb->read_lock_wq, atomic_read(&eb->blocking_readers) == 0);\n\twait_event(eb->write_lock_wq, atomic_read(&eb->blocking_writers) == 0);\n\twrite_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_readers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->read_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_readers) == 0);\n\t\tgoto again;\n\t}\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\twrite_unlock(&eb->lock);\n\t\twait_event(eb->write_lock_wq,\n\t\t\t   atomic_read(&eb->blocking_writers) == 0);\n\t\tgoto again;\n\t}\n\tWARN_ON(atomic_read(&eb->spinning_writers));\n\tatomic_inc(&eb->spinning_writers);\n\tatomic_inc(&eb->write_locks);\n\teb->lock_owner = current->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_node",
          "args": [
            "root"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "148-170",
          "snippet": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_lock_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\teb = btrfs_root_node(root);\n\t\tbtrfs_tree_lock(eb);\n\t\tif (eb == root->node)\n\t\t\tbreak;\n\t\tbtrfs_tree_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn eb;\n}"
  },
  {
    "function_name": "btrfs_root_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "148-170",
    "snippet": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&eb->refs"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "root->node"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}"
  },
  {
    "function_name": "btrfs_release_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "121-136",
    "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "p->nodes[i]"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_unlock_rw",
          "args": [
            "p->nodes[i]",
            "p->locks[i]"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_unlock_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.h",
          "lines": "41-51",
          "snippet": "static inline void btrfs_tree_unlock_rw(struct extent_buffer *eb, int rw)\n{\n\tif (rw == BTRFS_WRITE_LOCK || rw == BTRFS_WRITE_LOCK_BLOCKING)\n\t\tbtrfs_tree_unlock(eb);\n\telse if (rw == BTRFS_READ_LOCK_BLOCKING)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\telse if (rw == BTRFS_READ_LOCK)\n\t\tbtrfs_tree_read_unlock(eb);\n\telse\n\t\tBUG();\n}",
          "includes": [],
          "macros_used": [
            "#define BTRFS_READ_LOCK_BLOCKING 4",
            "#define BTRFS_WRITE_LOCK_BLOCKING 3",
            "#define BTRFS_READ_LOCK 2",
            "#define BTRFS_WRITE_LOCK 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define BTRFS_READ_LOCK_BLOCKING 4\n#define BTRFS_WRITE_LOCK_BLOCKING 3\n#define BTRFS_READ_LOCK 2\n#define BTRFS_WRITE_LOCK 1\n\nstatic inline void btrfs_tree_unlock_rw(struct extent_buffer *eb, int rw)\n{\n\tif (rw == BTRFS_WRITE_LOCK || rw == BTRFS_WRITE_LOCK_BLOCKING)\n\t\tbtrfs_tree_unlock(eb);\n\telse if (rw == BTRFS_READ_LOCK_BLOCKING)\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\telse if (rw == BTRFS_READ_LOCK)\n\t\tbtrfs_tree_read_unlock(eb);\n\telse\n\t\tBUG();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "btrfs_free_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "107-113",
    "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_path_cachep",
            "p"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "p"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
  },
  {
    "function_name": "btrfs_clear_path_blocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "78-104",
    "snippet": "noinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_clear_lock_blocking_rw",
          "args": [
            "held",
            "held_rw"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clear_lock_blocking_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "66-94",
          "snippet": "void btrfs_clear_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\n\tif (rw == BTRFS_WRITE_LOCK_BLOCKING) {\n\t\tBUG_ON(atomic_read(&eb->blocking_writers) != 1);\n\t\twrite_lock(&eb->lock);\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_inc(&eb->spinning_writers);\n\t\tif (atomic_dec_and_test(&eb->blocking_writers) &&\n\t\t    waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else if (rw == BTRFS_READ_LOCK_BLOCKING) {\n\t\tBUG_ON(atomic_read(&eb->blocking_readers) == 0);\n\t\tread_lock(&eb->lock);\n\t\tatomic_inc(&eb->spinning_readers);\n\t\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t\t    waitqueue_active(&eb->read_lock_wq))\n\t\t\twake_up(&eb->read_lock_wq);\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_clear_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\n\tif (rw == BTRFS_WRITE_LOCK_BLOCKING) {\n\t\tBUG_ON(atomic_read(&eb->blocking_writers) != 1);\n\t\twrite_lock(&eb->lock);\n\t\tWARN_ON(atomic_read(&eb->spinning_writers));\n\t\tatomic_inc(&eb->spinning_writers);\n\t\tif (atomic_dec_and_test(&eb->blocking_writers) &&\n\t\t    waitqueue_active(&eb->write_lock_wq))\n\t\t\twake_up(&eb->write_lock_wq);\n\t} else if (rw == BTRFS_READ_LOCK_BLOCKING) {\n\t\tBUG_ON(atomic_read(&eb->blocking_readers) == 0);\n\t\tread_lock(&eb->lock);\n\t\tatomic_inc(&eb->spinning_readers);\n\t\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t\t    waitqueue_active(&eb->read_lock_wq))\n\t\t\twake_up(&eb->read_lock_wq);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_path_blocking",
          "args": [
            "p"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_path_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "56-68",
          "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking_rw",
          "args": [
            "held",
            "held_rw"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "34-60",
          "snippet": "void btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_clear_path_blocking(struct btrfs_path *p,\n\t\t\t\t\tstruct extent_buffer *held, int held_rw)\n{\n\tint i;\n\n\tif (held) {\n\t\tbtrfs_set_lock_blocking_rw(held, held_rw);\n\t\tif (held_rw == BTRFS_WRITE_LOCK)\n\t\t\theld_rw = BTRFS_WRITE_LOCK_BLOCKING;\n\t\telse if (held_rw == BTRFS_READ_LOCK)\n\t\t\theld_rw = BTRFS_READ_LOCK_BLOCKING;\n\t}\n\tbtrfs_set_path_blocking(p);\n\n\tfor (i = BTRFS_MAX_LEVEL - 1; i >= 0; i--) {\n\t\tif (p->nodes[i] && p->locks[i]) {\n\t\t\tbtrfs_clear_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\t\tif (p->locks[i] == BTRFS_WRITE_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_WRITE_LOCK;\n\t\t\telse if (p->locks[i] == BTRFS_READ_LOCK_BLOCKING)\n\t\t\t\tp->locks[i] = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\n\tif (held)\n\t\tbtrfs_clear_lock_blocking_rw(held, held_rw);\n}"
  },
  {
    "function_name": "btrfs_set_path_blocking",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "56-68",
    "snippet": "noinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking_rw",
          "args": [
            "p->nodes[i]",
            "p->locks[i]"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "34-60",
          "snippet": "void btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_set_path_blocking(struct btrfs_path *p)\n{\n\tint i;\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tif (!p->nodes[i] || !p->locks[i])\n\t\t\tcontinue;\n\t\tbtrfs_set_lock_blocking_rw(p->nodes[i], p->locks[i]);\n\t\tif (p->locks[i] == BTRFS_READ_LOCK)\n\t\t\tp->locks[i] = BTRFS_READ_LOCK_BLOCKING;\n\t\telse if (p->locks[i] == BTRFS_WRITE_LOCK)\n\t\t\tp->locks[i] = BTRFS_WRITE_LOCK_BLOCKING;\n\t}\n}"
  },
  {
    "function_name": "btrfs_alloc_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
    "lines": "45-50",
    "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"print-tree.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/rbtree.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static noinline struct"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "btrfs_path_cachep",
            "GFP_NOFS"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
  }
]