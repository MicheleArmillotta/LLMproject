[
  {
    "function_name": "v9fs_refresh_inode_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "945-974",
    "snippet": "int v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode)\n{\n\tloff_t i_size;\n\tstruct p9_stat_dotl *st;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tif ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))\n\t\tgoto out;\n\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\ti_size = inode->i_size;\n\tv9fs_stat2inode_dotl(st, inode);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode->i_size = i_size;\n\tspin_unlock(&inode->i_lock);\nout:\n\tkfree(st);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "st"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_stat2inode_dotl",
          "args": [
            "st",
            "inode"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_stat2inode_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "613-676",
          "snippet": "void\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\ti_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tinode->i_mode = stat->st_mode;\n\t\t\tif ((S_ISBLK(inode->i_mode)) ||\n\t\t\t\t\t\t(S_ISCHR(inode->i_mode)))\n\t\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t\t\t\tinode->i_rdev);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_RDEV)\n\t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n\t\tif (stat->st_result_mask & P9_STATS_SIZE)\n\t\t\ti_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t/* Currently we don't support P9_STATS_BTIME and P9_STATS_DATA_VERSION\n\t * because the inode structure does not have fields for them.\n\t */\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\ti_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tinode->i_mode = stat->st_mode;\n\t\t\tif ((S_ISBLK(inode->i_mode)) ||\n\t\t\t\t\t\t(S_ISCHR(inode->i_mode)))\n\t\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t\t\t\tinode->i_rdev);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_RDEV)\n\t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n\t\tif (stat->st_result_mask & P9_STATS_SIZE)\n\t\t\ti_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t/* Currently we don't support P9_STATS_BTIME and P9_STATS_DATA_VERSION\n\t * because the inode structure does not have fields for them.\n\t */\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&inode->i_lock"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "st"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "st"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_getattr_dotl",
          "args": [
            "fid",
            "P9_STATS_ALL"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "inode"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode)\n{\n\tloff_t i_size;\n\tstruct p9_stat_dotl *st;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tif ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))\n\t\tgoto out;\n\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\ti_size = inode->i_size;\n\tv9fs_stat2inode_dotl(st, inode);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode->i_size = i_size;\n\tspin_unlock(&inode->i_lock);\nout:\n\tkfree(st);\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_vfs_follow_link_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "912-943",
    "snippet": "static void *\nv9fs_vfs_follow_link_dotl(struct dentry *dentry, struct nameidata *nd)\n{\n\tint retval;\n\tstruct p9_fid *fid;\n\tchar *link = __getname();\n\tchar *target;\n\n\tp9_debug(P9_DEBUG_VFS, \"%pd\\n\", dentry);\n\n\tif (!link) {\n\t\tlink = ERR_PTR(-ENOMEM);\n\t\tgoto ndset;\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid)) {\n\t\t__putname(link);\n\t\tlink = ERR_CAST(fid);\n\t\tgoto ndset;\n\t}\n\tretval = p9_client_readlink(fid, &target);\n\tif (!retval) {\n\t\tstrcpy(link, target);\n\t\tkfree(target);\n\t\tgoto ndset;\n\t}\n\t__putname(link);\n\tlink = ERR_PTR(retval);\nndset:\n\tnd_set_link(nd, link);\n\treturn NULL;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nd_set_link",
          "args": [
            "nd",
            "link"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "nd_set_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "717-720",
          "snippet": "void nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_set_link(struct nameidata *nd, char *path)\n{\n\tnd->saved_names[nd->depth] = path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "link"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "target"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "link",
            "target"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_readlink",
          "args": [
            "fid",
            "&target"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "fid"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__putname",
          "args": [
            "link"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"%pd\\n\"",
            "dentry"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getname",
          "args": [],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic void *\nv9fs_vfs_follow_link_dotl(struct dentry *dentry, struct nameidata *nd)\n{\n\tint retval;\n\tstruct p9_fid *fid;\n\tchar *link = __getname();\n\tchar *target;\n\n\tp9_debug(P9_DEBUG_VFS, \"%pd\\n\", dentry);\n\n\tif (!link) {\n\t\tlink = ERR_PTR(-ENOMEM);\n\t\tgoto ndset;\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid)) {\n\t\t__putname(link);\n\t\tlink = ERR_CAST(fid);\n\t\tgoto ndset;\n\t}\n\tretval = p9_client_readlink(fid, &target);\n\tif (!retval) {\n\t\tstrcpy(link, target);\n\t\tkfree(target);\n\t\tgoto ndset;\n\t}\n\t__putname(link);\n\tlink = ERR_PTR(retval);\nndset:\n\tnd_set_link(nd, link);\n\treturn NULL;\n}"
  },
  {
    "function_name": "v9fs_vfs_mknod_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "814-903",
    "snippet": "static int\nv9fs_vfs_mknod_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,\n\t\tdev_t rdev)\n{\n\tint err;\n\tkgid_t gid;\n\tchar *name;\n\tumode_t mode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid = NULL, *dfid = NULL;\n\tstruct inode *inode;\n\tstruct p9_qid qid;\n\tstruct dentry *dir_dentry;\n\tstruct posix_acl *dacl = NULL, *pacl = NULL;\n\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd mode: %hx MAJOR: %u MINOR: %u\\n\",\n\t\t dir->i_ino, dentry, omode,\n\t\t MAJOR(rdev), MINOR(rdev));\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tdir_dentry = dentry->d_parent;\n\tdfid = v9fs_fid_lookup(dir_dentry);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\tdfid = NULL;\n\t\tgoto error;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\tmode = omode;\n\t/* Update mode based on ACL value */\n\terr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_VFS, \"Failed to get acl values in mknod %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\tname = (char *) dentry->d_name.name;\n\n\terr = p9_client_mknod_dotl(dfid, name, mode, rdev, gid, &qid);\n\tif (err < 0)\n\t\tgoto error;\n\n\tv9fs_invalidate_inode_attr(dir);\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\",\n\t\t\t err);\n\t\tfid = NULL;\n\t\tgoto error;\n\t}\n\n\t/* instantiate inode and assign the unopened fid to the dentry */\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t\tfid = NULL;\n\t\terr = 0;\n\t} else {\n\t\t/*\n\t\t * Not in cached mode. No need to populate inode with stat.\n\t\t * socket syscall returns a fd, so we need instantiate\n\t\t */\n\t\tinode = v9fs_get_inode(dir->i_sb, mode, rdev);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\td_instantiate(dentry, inode);\n\t}\nerror:\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\tv9fs_put_acl(dacl, pacl);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nv9fs_vfs_mknod_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,\n\t\t    dev_t rdev);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_put_acl",
          "args": [
            "dacl",
            "pacl"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_put_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "179-184",
          "snippet": "void v9fs_put_acl(struct posix_acl *dacl,\n\t\t  struct posix_acl *acl)\n{\n\tposix_acl_release(dacl);\n\tposix_acl_release(acl);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid v9fs_put_acl(struct posix_acl *dacl,\n\t\t  struct posix_acl *acl)\n{\n\tposix_acl_release(dacl);\n\tposix_acl_release(acl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_set_create_acl",
          "args": [
            "inode",
            "fid",
            "dacl",
            "pacl"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_set_create_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "169-177",
          "snippet": "int v9fs_set_create_acl(struct inode *inode, struct p9_fid *fid,\n\t\t\tstruct posix_acl *dacl, struct posix_acl *acl)\n{\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\tv9fs_set_acl(fid, ACL_TYPE_DEFAULT, dacl);\n\tv9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\treturn 0;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_set_create_acl(struct inode *inode, struct p9_fid *fid,\n\t\t\tstruct posix_acl *dacl, struct posix_acl *acl)\n{\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\tv9fs_set_acl(fid, ACL_TYPE_DEFAULT, dacl);\n\tv9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_inode",
          "args": [
            "dir->i_sb",
            "mode",
            "rdev"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "370-390",
          "snippet": "struct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \"super block: %p mode: %ho\\n\", sb, mode);\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_warn(\"%s (%d): Problem allocating inode\\n\",\n\t\t\t__func__, task_pid_nr(current));\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\terr = v9fs_init_inode(v9ses, inode, mode, rdev);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \"super block: %p mode: %ho\\n\", sb, mode);\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_warn(\"%s (%d): Problem allocating inode\\n\",\n\t\t\t__func__, task_pid_nr(current));\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\terr = v9fs_init_inode(v9ses, inode, mode, rdev);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_fid_add",
          "args": [
            "dentry",
            "fid"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"inode creation failed %d\\n\"",
            "err"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_new_inode_from_fid",
          "args": [
            "v9ses",
            "fid",
            "dir->i_sb"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_new_inode_from_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "218-226",
          "snippet": "static inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"p9_client_walk failed %d\\n\"",
            "err"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_walk",
          "args": [
            "dfid",
            "1",
            "&name",
            "1"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "dir"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_client_mknod_dotl",
          "args": [
            "dfid",
            "name",
            "mode",
            "rdev",
            "gid",
            "&qid"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"Failed to get acl values in mknod %d\\n\"",
            "err"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_acl_mode",
          "args": [
            "dir",
            "&mode",
            "&dacl",
            "&pacl"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_acl_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "186-213",
          "snippet": "int v9fs_acl_mode(struct inode *dir, umode_t *modep,\n\t\t  struct posix_acl **dpacl, struct posix_acl **pacl)\n{\n\tint retval = 0;\n\tumode_t mode = *modep;\n\tstruct posix_acl *acl = NULL;\n\n\tif (!S_ISLNK(mode)) {\n\t\tacl = v9fs_get_cached_acl(dir, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\tif (!acl)\n\t\t\tmode &= ~current_umask();\n\t}\n\tif (acl) {\n\t\tif (S_ISDIR(mode))\n\t\t\t*dpacl = posix_acl_dup(acl);\n\t\tretval = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval > 0)\n\t\t\t*pacl = acl;\n\t\telse\n\t\t\tposix_acl_release(acl);\n\t}\n\t*modep  = mode;\n\treturn 0;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_acl_mode(struct inode *dir, umode_t *modep,\n\t\t  struct posix_acl **dpacl, struct posix_acl **pacl)\n{\n\tint retval = 0;\n\tumode_t mode = *modep;\n\tstruct posix_acl *acl = NULL;\n\n\tif (!S_ISLNK(mode)) {\n\t\tacl = v9fs_get_cached_acl(dir, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\tif (!acl)\n\t\t\tmode &= ~current_umask();\n\t}\n\tif (acl) {\n\t\tif (S_ISDIR(mode))\n\t\t\t*dpacl = posix_acl_dup(acl);\n\t\tretval = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval > 0)\n\t\t\t*pacl = acl;\n\t\telse\n\t\t\tposix_acl_release(acl);\n\t}\n\t*modep  = mode;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_get_fsgid_for_create",
          "args": [
            "dir"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_fsgid_for_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "60-69",
          "snippet": "static kgid_t v9fs_get_fsgid_for_create(struct inode *dir_inode)\n{\n\tBUG_ON(dir_inode == NULL);\n\n\tif (dir_inode->i_mode & S_ISGID) {\n\t\t/* set_gid bit is set.*/\n\t\treturn dir_inode->i_gid;\n\t}\n\treturn current_fsgid();\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic kgid_t v9fs_get_fsgid_for_create(struct inode *dir_inode)\n{\n\tBUG_ON(dir_inode == NULL);\n\n\tif (dir_inode->i_mode & S_ISGID) {\n\t\t/* set_gid bit is set.*/\n\t\treturn dir_inode->i_gid;\n\t}\n\treturn current_fsgid();\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"fid lookup failed %d\\n\"",
            "err"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dfid"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dfid"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dir_dentry"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "dir"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_valid_dev",
          "args": [
            "rdev"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\" %lu,%pd mode: %hx MAJOR: %u MINOR: %u\\n\"",
            "dir->i_ino",
            "dentry",
            "omode",
            "MAJOR(rdev)",
            "MINOR(rdev)"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "rdev"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "rdev"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_mknod_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,\n\t\t    dev_t rdev);\n\nstatic int\nv9fs_vfs_mknod_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,\n\t\tdev_t rdev)\n{\n\tint err;\n\tkgid_t gid;\n\tchar *name;\n\tumode_t mode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid = NULL, *dfid = NULL;\n\tstruct inode *inode;\n\tstruct p9_qid qid;\n\tstruct dentry *dir_dentry;\n\tstruct posix_acl *dacl = NULL, *pacl = NULL;\n\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd mode: %hx MAJOR: %u MINOR: %u\\n\",\n\t\t dir->i_ino, dentry, omode,\n\t\t MAJOR(rdev), MINOR(rdev));\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tdir_dentry = dentry->d_parent;\n\tdfid = v9fs_fid_lookup(dir_dentry);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\tdfid = NULL;\n\t\tgoto error;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\tmode = omode;\n\t/* Update mode based on ACL value */\n\terr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_VFS, \"Failed to get acl values in mknod %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\tname = (char *) dentry->d_name.name;\n\n\terr = p9_client_mknod_dotl(dfid, name, mode, rdev, gid, &qid);\n\tif (err < 0)\n\t\tgoto error;\n\n\tv9fs_invalidate_inode_attr(dir);\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\",\n\t\t\t err);\n\t\tfid = NULL;\n\t\tgoto error;\n\t}\n\n\t/* instantiate inode and assign the unopened fid to the dentry */\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t\tfid = NULL;\n\t\terr = 0;\n\t} else {\n\t\t/*\n\t\t * Not in cached mode. No need to populate inode with stat.\n\t\t * socket syscall returns a fd, so we need instantiate\n\t\t */\n\t\tinode = v9fs_get_inode(dir->i_sb, mode, rdev);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\td_instantiate(dentry, inode);\n\t}\nerror:\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\tv9fs_put_acl(dacl, pacl);\n\treturn err;\n}"
  },
  {
    "function_name": "v9fs_vfs_link_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "761-804",
    "snippet": "static int\nv9fs_vfs_link_dotl(struct dentry *old_dentry, struct inode *dir,\n\t\tstruct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *dir_dentry;\n\tstruct p9_fid *dfid, *oldfid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"dir ino: %lu, old_name: %pd, new_name: %pd\\n\",\n\t\t dir->i_ino, old_dentry, dentry);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tdir_dentry = dentry->d_parent;\n\tdfid = v9fs_fid_lookup(dir_dentry);\n\tif (IS_ERR(dfid))\n\t\treturn PTR_ERR(dfid);\n\n\toldfid = v9fs_fid_lookup(old_dentry);\n\tif (IS_ERR(oldfid))\n\t\treturn PTR_ERR(oldfid);\n\n\terr = p9_client_link(dfid, oldfid, (char *)dentry->d_name.name);\n\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_link failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tv9fs_invalidate_inode_attr(dir);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\t/* Get the latest stat info from server. */\n\t\tstruct p9_fid *fid;\n\t\tfid = v9fs_fid_lookup(old_dentry);\n\t\tif (IS_ERR(fid))\n\t\t\treturn PTR_ERR(fid);\n\n\t\tv9fs_refresh_inode_dotl(fid, old_dentry->d_inode);\n\t}\n\tihold(old_dentry->d_inode);\n\td_instantiate(dentry, old_dentry->d_inode);\n\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "old_dentry->d_inode"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "old_dentry->d_inode"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_refresh_inode_dotl",
          "args": [
            "fid",
            "old_dentry->d_inode"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_refresh_inode_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "945-974",
          "snippet": "int v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode)\n{\n\tloff_t i_size;\n\tstruct p9_stat_dotl *st;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tif ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))\n\t\tgoto out;\n\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\ti_size = inode->i_size;\n\tv9fs_stat2inode_dotl(st, inode);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode->i_size = i_size;\n\tspin_unlock(&inode->i_lock);\nout:\n\tkfree(st);\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode)\n{\n\tloff_t i_size;\n\tstruct p9_stat_dotl *st;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\t/*\n\t * Don't update inode if the file type is different\n\t */\n\tif ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))\n\t\tgoto out;\n\n\tspin_lock(&inode->i_lock);\n\t/*\n\t * We don't want to refresh inode->i_size,\n\t * because we may have cached data\n\t */\n\ti_size = inode->i_size;\n\tv9fs_stat2inode_dotl(st, inode);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode->i_size = i_size;\n\tspin_unlock(&inode->i_lock);\nout:\n\tkfree(st);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "old_dentry"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "dir"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"p9_client_link failed %d\\n\"",
            "err"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_link",
          "args": [
            "dfid",
            "oldfid",
            "(char *)dentry->d_name.name"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "oldfid"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "oldfid"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dfid"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dfid"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "dir"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"dir ino: %lu, old_name: %pd, new_name: %pd\\n\"",
            "dir->i_ino",
            "old_dentry",
            "dentry"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_link_dotl(struct dentry *old_dentry, struct inode *dir,\n\t\tstruct dentry *dentry)\n{\n\tint err;\n\tstruct dentry *dir_dentry;\n\tstruct p9_fid *dfid, *oldfid;\n\tstruct v9fs_session_info *v9ses;\n\n\tp9_debug(P9_DEBUG_VFS, \"dir ino: %lu, old_name: %pd, new_name: %pd\\n\",\n\t\t dir->i_ino, old_dentry, dentry);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tdir_dentry = dentry->d_parent;\n\tdfid = v9fs_fid_lookup(dir_dentry);\n\tif (IS_ERR(dfid))\n\t\treturn PTR_ERR(dfid);\n\n\toldfid = v9fs_fid_lookup(old_dentry);\n\tif (IS_ERR(oldfid))\n\t\treturn PTR_ERR(oldfid);\n\n\terr = p9_client_link(dfid, oldfid, (char *)dentry->d_name.name);\n\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_link failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tv9fs_invalidate_inode_attr(dir);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\t/* Get the latest stat info from server. */\n\t\tstruct p9_fid *fid;\n\t\tfid = v9fs_fid_lookup(old_dentry);\n\t\tif (IS_ERR(fid))\n\t\t\treturn PTR_ERR(fid);\n\n\t\tv9fs_refresh_inode_dotl(fid, old_dentry->d_inode);\n\t}\n\tihold(old_dentry->d_inode);\n\td_instantiate(dentry, old_dentry->d_inode);\n\n\treturn err;\n}"
  },
  {
    "function_name": "v9fs_vfs_symlink_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "678-751",
    "snippet": "static int\nv9fs_vfs_symlink_dotl(struct inode *dir, struct dentry *dentry,\n\t\tconst char *symname)\n{\n\tint err;\n\tkgid_t gid;\n\tchar *name;\n\tstruct p9_qid qid;\n\tstruct inode *inode;\n\tstruct p9_fid *dfid;\n\tstruct p9_fid *fid = NULL;\n\tstruct v9fs_session_info *v9ses;\n\n\tname = (char *) dentry->d_name.name;\n\tp9_debug(P9_DEBUG_VFS, \"%lu,%s,%s\\n\", dir->i_ino, name, symname);\n\tv9ses = v9fs_inode2v9ses(dir);\n\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\n\t/* Server doesn't alter fid on TSYMLINK. Hence no need to clone it. */\n\terr = p9_client_symlink(dfid, name, (char *)symname, gid, &qid);\n\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_symlink failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tv9fs_invalidate_inode_attr(dir);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\t/* Now walk from the parent so we can get an unopened fid. */\n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\",\n\t\t\t\t err);\n\t\t\tfid = NULL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* instantiate inode and assign the unopened fid to dentry */\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t\tfid = NULL;\n\t\terr = 0;\n\t} else {\n\t\t/* Not in cached mode. No need to populate inode with stat */\n\t\tinode = v9fs_get_inode(dir->i_sb, S_IFLNK, 0);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto error;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t}\n\nerror:\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_inode",
          "args": [
            "dir->i_sb",
            "S_IFLNK",
            "0"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "370-390",
          "snippet": "struct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \"super block: %p mode: %ho\\n\", sb, mode);\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_warn(\"%s (%d): Problem allocating inode\\n\",\n\t\t\t__func__, task_pid_nr(current));\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\terr = v9fs_init_inode(v9ses, inode, mode, rdev);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \"super block: %p mode: %ho\\n\", sb, mode);\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_warn(\"%s (%d): Problem allocating inode\\n\",\n\t\t\t__func__, task_pid_nr(current));\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\terr = v9fs_init_inode(v9ses, inode, mode, rdev);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_fid_add",
          "args": [
            "dentry",
            "fid"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"inode creation failed %d\\n\"",
            "err"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_new_inode_from_fid",
          "args": [
            "v9ses",
            "fid",
            "dir->i_sb"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_new_inode_from_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "218-226",
          "snippet": "static inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"p9_client_walk failed %d\\n\"",
            "err"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_walk",
          "args": [
            "dfid",
            "1",
            "&name",
            "1"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "dir"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"p9_client_symlink failed %d\\n\"",
            "err"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_symlink",
          "args": [
            "dfid",
            "name",
            "(char *)symname",
            "gid",
            "&qid"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_fsgid_for_create",
          "args": [
            "dir"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_fsgid_for_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "60-69",
          "snippet": "static kgid_t v9fs_get_fsgid_for_create(struct inode *dir_inode)\n{\n\tBUG_ON(dir_inode == NULL);\n\n\tif (dir_inode->i_mode & S_ISGID) {\n\t\t/* set_gid bit is set.*/\n\t\treturn dir_inode->i_gid;\n\t}\n\treturn current_fsgid();\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic kgid_t v9fs_get_fsgid_for_create(struct inode *dir_inode)\n{\n\tBUG_ON(dir_inode == NULL);\n\n\tif (dir_inode->i_mode & S_ISGID) {\n\t\t/* set_gid bit is set.*/\n\t\treturn dir_inode->i_gid;\n\t}\n\treturn current_fsgid();\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"fid lookup failed %d\\n\"",
            "err"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dfid"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dfid"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry->d_parent"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "dir"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"%lu,%s,%s\\n\"",
            "dir->i_ino",
            "name",
            "symname"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_symlink_dotl(struct inode *dir, struct dentry *dentry,\n\t\tconst char *symname)\n{\n\tint err;\n\tkgid_t gid;\n\tchar *name;\n\tstruct p9_qid qid;\n\tstruct inode *inode;\n\tstruct p9_fid *dfid;\n\tstruct p9_fid *fid = NULL;\n\tstruct v9fs_session_info *v9ses;\n\n\tname = (char *) dentry->d_name.name;\n\tp9_debug(P9_DEBUG_VFS, \"%lu,%s,%s\\n\", dir->i_ino, name, symname);\n\tv9ses = v9fs_inode2v9ses(dir);\n\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\n\t/* Server doesn't alter fid on TSYMLINK. Hence no need to clone it. */\n\terr = p9_client_symlink(dfid, name, (char *)symname, gid, &qid);\n\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_symlink failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tv9fs_invalidate_inode_attr(dir);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\t/* Now walk from the parent so we can get an unopened fid. */\n\t\tfid = p9_client_walk(dfid, 1, &name, 1);\n\t\tif (IS_ERR(fid)) {\n\t\t\terr = PTR_ERR(fid);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\",\n\t\t\t\t err);\n\t\t\tfid = NULL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* instantiate inode and assign the unopened fid to dentry */\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t\tfid = NULL;\n\t\terr = 0;\n\t} else {\n\t\t/* Not in cached mode. No need to populate inode with stat */\n\t\tinode = v9fs_get_inode(dir->i_sb, S_IFLNK, 0);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto error;\n\t\t}\n\t\td_instantiate(dentry, inode);\n\t}\n\nerror:\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\n\treturn err;\n}"
  },
  {
    "function_name": "v9fs_stat2inode_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "613-676",
    "snippet": "void\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\ti_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tinode->i_mode = stat->st_mode;\n\t\t\tif ((S_ISBLK(inode->i_mode)) ||\n\t\t\t\t\t\t(S_ISCHR(inode->i_mode)))\n\t\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t\t\t\tinode->i_rdev);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_RDEV)\n\t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n\t\tif (stat->st_result_mask & P9_STATS_SIZE)\n\t\t\ti_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t/* Currently we don't support P9_STATS_BTIME and P9_STATS_DATA_VERSION\n\t * because the inode structure does not have fields for them.\n\t */\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "inode",
            "stat->st_size"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "stat->st_rdev"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "inode->i_rdev"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "stat->st_nlink"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\ti_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tinode->i_mode = stat->st_mode;\n\t\t\tif ((S_ISBLK(inode->i_mode)) ||\n\t\t\t\t\t\t(S_ISCHR(inode->i_mode)))\n\t\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t\t\t\tinode->i_rdev);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_RDEV)\n\t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n\t\tif (stat->st_result_mask & P9_STATS_SIZE)\n\t\t\ti_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t/* Currently we don't support P9_STATS_BTIME and P9_STATS_DATA_VERSION\n\t * because the inode structure does not have fields for them.\n\t */\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}"
  },
  {
    "function_name": "v9fs_vfs_setattr_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "555-604",
    "snippet": "int v9fs_vfs_setattr_dotl(struct dentry *dentry, struct iattr *iattr)\n{\n\tint retval;\n\tstruct p9_fid *fid;\n\tstruct p9_iattr_dotl p9attr;\n\tstruct inode *inode = dentry->d_inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tretval = inode_change_ok(inode, iattr);\n\tif (retval)\n\t\treturn retval;\n\n\tp9attr.valid = v9fs_mapped_iattr_valid(iattr->ia_valid);\n\tp9attr.mode = iattr->ia_mode;\n\tp9attr.uid = iattr->ia_uid;\n\tp9attr.gid = iattr->ia_gid;\n\tp9attr.size = iattr->ia_size;\n\tp9attr.atime_sec = iattr->ia_atime.tv_sec;\n\tp9attr.atime_nsec = iattr->ia_atime.tv_nsec;\n\tp9attr.mtime_sec = iattr->ia_mtime.tv_sec;\n\tp9attr.mtime_nsec = iattr->ia_mtime.tv_nsec;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\t/* Write all dirty data */\n\tif (S_ISREG(inode->i_mode))\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\tretval = p9_client_setattr(fid, &p9attr);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t    iattr->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\n\tv9fs_invalidate_inode_attr(inode);\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\tif (iattr->ia_valid & ATTR_MODE) {\n\t\t/* We also want to update ACL when we update mode bits */\n\t\tretval = v9fs_acl_chmod(inode, fid);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_acl_chmod",
          "args": [
            "inode",
            "fid"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_acl_chmod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "150-167",
          "snippet": "int v9fs_acl_chmod(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *acl;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tacl = v9fs_get_cached_acl(inode, ACL_TYPE_ACCESS);\n\tif (acl) {\n\t\tretval = __posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\tretval = v9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_acl_chmod(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *acl;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tacl = v9fs_get_cached_acl(inode, ACL_TYPE_ACCESS);\n\tif (acl) {\n\t\tretval = __posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\t\tretval = v9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\t\tposix_acl_release(acl);\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "inode"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_setsize",
          "args": [
            "inode",
            "iattr->ia_size"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_setattr",
          "args": [
            "fid",
            "&p9attr"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_mapped_iattr_valid",
          "args": [
            "iattr->ia_valid"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_mapped_iattr_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "526-546",
          "snippet": "static int v9fs_mapped_iattr_valid(int iattr_valid)\n{\n\tint i;\n\tint p9_iattr_valid = 0;\n\tstruct dotl_iattr_map dotl_iattr_map[] = {\n\t\t{ ATTR_MODE,\t\tP9_ATTR_MODE },\n\t\t{ ATTR_UID,\t\tP9_ATTR_UID },\n\t\t{ ATTR_GID,\t\tP9_ATTR_GID },\n\t\t{ ATTR_SIZE,\t\tP9_ATTR_SIZE },\n\t\t{ ATTR_ATIME,\t\tP9_ATTR_ATIME },\n\t\t{ ATTR_MTIME,\t\tP9_ATTR_MTIME },\n\t\t{ ATTR_CTIME,\t\tP9_ATTR_CTIME },\n\t\t{ ATTR_ATIME_SET,\tP9_ATTR_ATIME_SET },\n\t\t{ ATTR_MTIME_SET,\tP9_ATTR_MTIME_SET },\n\t};\n\tfor (i = 0; i < ARRAY_SIZE(dotl_iattr_map); i++) {\n\t\tif (iattr_valid & dotl_iattr_map[i].iattr_valid)\n\t\t\tp9_iattr_valid |= dotl_iattr_map[i].p9_iattr_valid;\n\t}\n\treturn p9_iattr_valid;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define P9_ATTR_MTIME_SET\t(1 << 8)",
            "#define P9_ATTR_ATIME_SET\t(1 << 7)",
            "#define P9_ATTR_CTIME\t\t(1 << 6)",
            "#define P9_ATTR_MTIME\t\t(1 << 5)",
            "#define P9_ATTR_ATIME\t\t(1 << 4)",
            "#define P9_ATTR_SIZE\t\t(1 << 3)",
            "#define P9_ATTR_GID\t\t(1 << 2)",
            "#define P9_ATTR_UID\t\t(1 << 1)",
            "#define P9_ATTR_MODE\t\t(1 << 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\n#define P9_ATTR_MTIME_SET\t(1 << 8)\n#define P9_ATTR_ATIME_SET\t(1 << 7)\n#define P9_ATTR_CTIME\t\t(1 << 6)\n#define P9_ATTR_MTIME\t\t(1 << 5)\n#define P9_ATTR_ATIME\t\t(1 << 4)\n#define P9_ATTR_SIZE\t\t(1 << 3)\n#define P9_ATTR_GID\t\t(1 << 2)\n#define P9_ATTR_UID\t\t(1 << 1)\n#define P9_ATTR_MODE\t\t(1 << 0)\n\nstatic int v9fs_mapped_iattr_valid(int iattr_valid)\n{\n\tint i;\n\tint p9_iattr_valid = 0;\n\tstruct dotl_iattr_map dotl_iattr_map[] = {\n\t\t{ ATTR_MODE,\t\tP9_ATTR_MODE },\n\t\t{ ATTR_UID,\t\tP9_ATTR_UID },\n\t\t{ ATTR_GID,\t\tP9_ATTR_GID },\n\t\t{ ATTR_SIZE,\t\tP9_ATTR_SIZE },\n\t\t{ ATTR_ATIME,\t\tP9_ATTR_ATIME },\n\t\t{ ATTR_MTIME,\t\tP9_ATTR_MTIME },\n\t\t{ ATTR_CTIME,\t\tP9_ATTR_CTIME },\n\t\t{ ATTR_ATIME_SET,\tP9_ATTR_ATIME_SET },\n\t\t{ ATTR_MTIME_SET,\tP9_ATTR_MTIME_SET },\n\t};\n\tfor (i = 0; i < ARRAY_SIZE(dotl_iattr_map); i++) {\n\t\tif (iattr_valid & dotl_iattr_map[i].iattr_valid)\n\t\t\tp9_iattr_valid |= dotl_iattr_map[i].p9_iattr_valid;\n\t}\n\treturn p9_iattr_valid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "iattr"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"\\n\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_vfs_setattr_dotl(struct dentry *dentry, struct iattr *iattr)\n{\n\tint retval;\n\tstruct p9_fid *fid;\n\tstruct p9_iattr_dotl p9attr;\n\tstruct inode *inode = dentry->d_inode;\n\n\tp9_debug(P9_DEBUG_VFS, \"\\n\");\n\n\tretval = inode_change_ok(inode, iattr);\n\tif (retval)\n\t\treturn retval;\n\n\tp9attr.valid = v9fs_mapped_iattr_valid(iattr->ia_valid);\n\tp9attr.mode = iattr->ia_mode;\n\tp9attr.uid = iattr->ia_uid;\n\tp9attr.gid = iattr->ia_gid;\n\tp9attr.size = iattr->ia_size;\n\tp9attr.atime_sec = iattr->ia_atime.tv_sec;\n\tp9attr.atime_nsec = iattr->ia_atime.tv_nsec;\n\tp9attr.mtime_sec = iattr->ia_mtime.tv_sec;\n\tp9attr.mtime_nsec = iattr->ia_mtime.tv_nsec;\n\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\t/* Write all dirty data */\n\tif (S_ISREG(inode->i_mode))\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\n\tretval = p9_client_setattr(fid, &p9attr);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tif ((iattr->ia_valid & ATTR_SIZE) &&\n\t    iattr->ia_size != i_size_read(inode))\n\t\ttruncate_setsize(inode, iattr->ia_size);\n\n\tv9fs_invalidate_inode_attr(inode);\n\tsetattr_copy(inode, iattr);\n\tmark_inode_dirty(inode);\n\tif (iattr->ia_valid & ATTR_MODE) {\n\t\t/* We also want to update ACL when we update mode bits */\n\t\tretval = v9fs_acl_chmod(inode, fid);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_mapped_iattr_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "526-546",
    "snippet": "static int v9fs_mapped_iattr_valid(int iattr_valid)\n{\n\tint i;\n\tint p9_iattr_valid = 0;\n\tstruct dotl_iattr_map dotl_iattr_map[] = {\n\t\t{ ATTR_MODE,\t\tP9_ATTR_MODE },\n\t\t{ ATTR_UID,\t\tP9_ATTR_UID },\n\t\t{ ATTR_GID,\t\tP9_ATTR_GID },\n\t\t{ ATTR_SIZE,\t\tP9_ATTR_SIZE },\n\t\t{ ATTR_ATIME,\t\tP9_ATTR_ATIME },\n\t\t{ ATTR_MTIME,\t\tP9_ATTR_MTIME },\n\t\t{ ATTR_CTIME,\t\tP9_ATTR_CTIME },\n\t\t{ ATTR_ATIME_SET,\tP9_ATTR_ATIME_SET },\n\t\t{ ATTR_MTIME_SET,\tP9_ATTR_MTIME_SET },\n\t};\n\tfor (i = 0; i < ARRAY_SIZE(dotl_iattr_map); i++) {\n\t\tif (iattr_valid & dotl_iattr_map[i].iattr_valid)\n\t\t\tp9_iattr_valid |= dotl_iattr_map[i].p9_iattr_valid;\n\t}\n\treturn p9_iattr_valid;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define P9_ATTR_MTIME_SET\t(1 << 8)",
      "#define P9_ATTR_ATIME_SET\t(1 << 7)",
      "#define P9_ATTR_CTIME\t\t(1 << 6)",
      "#define P9_ATTR_MTIME\t\t(1 << 5)",
      "#define P9_ATTR_ATIME\t\t(1 << 4)",
      "#define P9_ATTR_SIZE\t\t(1 << 3)",
      "#define P9_ATTR_GID\t\t(1 << 2)",
      "#define P9_ATTR_UID\t\t(1 << 1)",
      "#define P9_ATTR_MODE\t\t(1 << 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "dotl_iattr_map"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\n#define P9_ATTR_MTIME_SET\t(1 << 8)\n#define P9_ATTR_ATIME_SET\t(1 << 7)\n#define P9_ATTR_CTIME\t\t(1 << 6)\n#define P9_ATTR_MTIME\t\t(1 << 5)\n#define P9_ATTR_ATIME\t\t(1 << 4)\n#define P9_ATTR_SIZE\t\t(1 << 3)\n#define P9_ATTR_GID\t\t(1 << 2)\n#define P9_ATTR_UID\t\t(1 << 1)\n#define P9_ATTR_MODE\t\t(1 << 0)\n\nstatic int v9fs_mapped_iattr_valid(int iattr_valid)\n{\n\tint i;\n\tint p9_iattr_valid = 0;\n\tstruct dotl_iattr_map dotl_iattr_map[] = {\n\t\t{ ATTR_MODE,\t\tP9_ATTR_MODE },\n\t\t{ ATTR_UID,\t\tP9_ATTR_UID },\n\t\t{ ATTR_GID,\t\tP9_ATTR_GID },\n\t\t{ ATTR_SIZE,\t\tP9_ATTR_SIZE },\n\t\t{ ATTR_ATIME,\t\tP9_ATTR_ATIME },\n\t\t{ ATTR_MTIME,\t\tP9_ATTR_MTIME },\n\t\t{ ATTR_CTIME,\t\tP9_ATTR_CTIME },\n\t\t{ ATTR_ATIME_SET,\tP9_ATTR_ATIME_SET },\n\t\t{ ATTR_MTIME_SET,\tP9_ATTR_MTIME_SET },\n\t};\n\tfor (i = 0; i < ARRAY_SIZE(dotl_iattr_map); i++) {\n\t\tif (iattr_valid & dotl_iattr_map[i].iattr_valid)\n\t\t\tp9_iattr_valid |= dotl_iattr_map[i].p9_iattr_valid;\n\t}\n\treturn p9_iattr_valid;\n}"
  },
  {
    "function_name": "v9fs_vfs_getattr_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "473-506",
    "snippet": "static int\nv9fs_vfs_getattr_dotl(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_stat_dotl *st;\n\n\tp9_debug(P9_DEBUG_VFS, \"dentry: %p\\n\", dentry);\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tgeneric_fillattr(dentry->d_inode, stat);\n\t\treturn 0;\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\t/* Ask for all the fields in stat structure. Server will return\n\t * whatever it supports\n\t */\n\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tv9fs_stat2inode_dotl(st, dentry->d_inode);\n\tgeneric_fillattr(dentry->d_inode, stat);\n\t/* Change block size to what the server returned */\n\tstat->blksize = st->st_blksize;\n\n\tkfree(st);\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "st"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "dentry->d_inode",
            "stat"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_stat2inode_dotl",
          "args": [
            "st",
            "dentry->d_inode"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_stat2inode_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "613-676",
          "snippet": "void\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\ti_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tinode->i_mode = stat->st_mode;\n\t\t\tif ((S_ISBLK(inode->i_mode)) ||\n\t\t\t\t\t\t(S_ISCHR(inode->i_mode)))\n\t\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t\t\t\tinode->i_rdev);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_RDEV)\n\t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n\t\tif (stat->st_result_mask & P9_STATS_SIZE)\n\t\t\ti_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t/* Currently we don't support P9_STATS_BTIME and P9_STATS_DATA_VERSION\n\t * because the inode structure does not have fields for them.\n\t */\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\ti_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tinode->i_mode = stat->st_mode;\n\t\t\tif ((S_ISBLK(inode->i_mode)) ||\n\t\t\t\t\t\t(S_ISCHR(inode->i_mode)))\n\t\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t\t\t\tinode->i_rdev);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_RDEV)\n\t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n\t\tif (stat->st_result_mask & P9_STATS_SIZE)\n\t\t\ti_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t/* Currently we don't support P9_STATS_BTIME and P9_STATS_DATA_VERSION\n\t * because the inode structure does not have fields for them.\n\t */\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "st"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "st"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_getattr_dotl",
          "args": [
            "fid",
            "P9_STATS_ALL"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_dentry2v9ses",
          "args": [
            "dentry"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_dentry2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "177-180",
          "snippet": "static inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_dentry2v9ses(struct dentry *dentry)\n{\n\treturn dentry->d_sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"dentry: %p\\n\"",
            "dentry"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_getattr_dotl(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid;\n\tstruct p9_stat_dotl *st;\n\n\tp9_debug(P9_DEBUG_VFS, \"dentry: %p\\n\", dentry);\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tgeneric_fillattr(dentry->d_inode, stat);\n\t\treturn 0;\n\t}\n\tfid = v9fs_fid_lookup(dentry);\n\tif (IS_ERR(fid))\n\t\treturn PTR_ERR(fid);\n\n\t/* Ask for all the fields in stat structure. Server will return\n\t * whatever it supports\n\t */\n\n\tst = p9_client_getattr_dotl(fid, P9_STATS_ALL);\n\tif (IS_ERR(st))\n\t\treturn PTR_ERR(st);\n\n\tv9fs_stat2inode_dotl(st, dentry->d_inode);\n\tgeneric_fillattr(dentry->d_inode, stat);\n\t/* Change block size to what the server returned */\n\tstat->blksize = st->st_blksize;\n\n\tkfree(st);\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_vfs_mkdir_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "382-471",
    "snippet": "static int v9fs_vfs_mkdir_dotl(struct inode *dir,\n\t\t\t       struct dentry *dentry, umode_t omode)\n{\n\tint err;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid = NULL, *dfid = NULL;\n\tkgid_t gid;\n\tchar *name;\n\tumode_t mode;\n\tstruct inode *inode;\n\tstruct p9_qid qid;\n\tstruct dentry *dir_dentry;\n\tstruct posix_acl *dacl = NULL, *pacl = NULL;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\terr = 0;\n\tv9ses = v9fs_inode2v9ses(dir);\n\n\tomode |= S_IFDIR;\n\tif (dir->i_mode & S_ISGID)\n\t\tomode |= S_ISGID;\n\n\tdir_dentry = dentry->d_parent;\n\tdfid = v9fs_fid_lookup(dir_dentry);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\tdfid = NULL;\n\t\tgoto error;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\tmode = omode;\n\t/* Update mode based on ACL value */\n\terr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_VFS, \"Failed to get acl values in mkdir %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\tname = (char *) dentry->d_name.name;\n\terr = p9_client_mkdir_dotl(dfid, name, mode, gid, &qid);\n\tif (err < 0)\n\t\tgoto error;\n\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\",\n\t\t\t err);\n\t\tfid = NULL;\n\t\tgoto error;\n\t}\n\n\t/* instantiate inode and assign the unopened fid to the dentry */\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\td_instantiate(dentry, inode);\n\t\tfid = NULL;\n\t\terr = 0;\n\t} else {\n\t\t/*\n\t\t * Not in cached mode. No need to populate\n\t\t * inode with stat. We need to get an inode\n\t\t * so that we can set the acl with dentry\n\t\t */\n\t\tinode = v9fs_get_inode(dir->i_sb, mode, 0);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\td_instantiate(dentry, inode);\n\t}\n\tinc_nlink(dir);\n\tv9fs_invalidate_inode_attr(dir);\nerror:\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\tv9fs_put_acl(dacl, pacl);\n\treturn err;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_put_acl",
          "args": [
            "dacl",
            "pacl"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_put_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "179-184",
          "snippet": "void v9fs_put_acl(struct posix_acl *dacl,\n\t\t  struct posix_acl *acl)\n{\n\tposix_acl_release(dacl);\n\tposix_acl_release(acl);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid v9fs_put_acl(struct posix_acl *dacl,\n\t\t  struct posix_acl *acl)\n{\n\tposix_acl_release(dacl);\n\tposix_acl_release(acl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "dir"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_set_create_acl",
          "args": [
            "inode",
            "fid",
            "dacl",
            "pacl"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_set_create_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "169-177",
          "snippet": "int v9fs_set_create_acl(struct inode *inode, struct p9_fid *fid,\n\t\t\tstruct posix_acl *dacl, struct posix_acl *acl)\n{\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\tv9fs_set_acl(fid, ACL_TYPE_DEFAULT, dacl);\n\tv9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\treturn 0;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_set_create_acl(struct inode *inode, struct p9_fid *fid,\n\t\t\tstruct posix_acl *dacl, struct posix_acl *acl)\n{\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\tv9fs_set_acl(fid, ACL_TYPE_DEFAULT, dacl);\n\tv9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_inode",
          "args": [
            "dir->i_sb",
            "mode",
            "0"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "370-390",
          "snippet": "struct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \"super block: %p mode: %ho\\n\", sb, mode);\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_warn(\"%s (%d): Problem allocating inode\\n\",\n\t\t\t__func__, task_pid_nr(current));\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\terr = v9fs_init_inode(v9ses, inode, mode, rdev);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct inode *v9fs_get_inode(struct super_block *sb, umode_t mode, dev_t rdev)\n{\n\tint err;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\n\tp9_debug(P9_DEBUG_VFS, \"super block: %p mode: %ho\\n\", sb, mode);\n\n\tinode = new_inode(sb);\n\tif (!inode) {\n\t\tpr_warn(\"%s (%d): Problem allocating inode\\n\",\n\t\t\t__func__, task_pid_nr(current));\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\terr = v9fs_init_inode(v9ses, inode, mode, rdev);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_fid_add",
          "args": [
            "dentry",
            "fid"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"inode creation failed %d\\n\"",
            "err"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_new_inode_from_fid",
          "args": [
            "v9ses",
            "fid",
            "dir->i_sb"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_new_inode_from_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "218-226",
          "snippet": "static inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"p9_client_walk failed %d\\n\"",
            "err"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_walk",
          "args": [
            "dfid",
            "1",
            "&name",
            "1"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_mkdir_dotl",
          "args": [
            "dfid",
            "name",
            "mode",
            "gid",
            "&qid"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"Failed to get acl values in mkdir %d\\n\"",
            "err"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_acl_mode",
          "args": [
            "dir",
            "&mode",
            "&dacl",
            "&pacl"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_acl_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "186-213",
          "snippet": "int v9fs_acl_mode(struct inode *dir, umode_t *modep,\n\t\t  struct posix_acl **dpacl, struct posix_acl **pacl)\n{\n\tint retval = 0;\n\tumode_t mode = *modep;\n\tstruct posix_acl *acl = NULL;\n\n\tif (!S_ISLNK(mode)) {\n\t\tacl = v9fs_get_cached_acl(dir, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\tif (!acl)\n\t\t\tmode &= ~current_umask();\n\t}\n\tif (acl) {\n\t\tif (S_ISDIR(mode))\n\t\t\t*dpacl = posix_acl_dup(acl);\n\t\tretval = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval > 0)\n\t\t\t*pacl = acl;\n\t\telse\n\t\t\tposix_acl_release(acl);\n\t}\n\t*modep  = mode;\n\treturn 0;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_acl_mode(struct inode *dir, umode_t *modep,\n\t\t  struct posix_acl **dpacl, struct posix_acl **pacl)\n{\n\tint retval = 0;\n\tumode_t mode = *modep;\n\tstruct posix_acl *acl = NULL;\n\n\tif (!S_ISLNK(mode)) {\n\t\tacl = v9fs_get_cached_acl(dir, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\tif (!acl)\n\t\t\tmode &= ~current_umask();\n\t}\n\tif (acl) {\n\t\tif (S_ISDIR(mode))\n\t\t\t*dpacl = posix_acl_dup(acl);\n\t\tretval = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval > 0)\n\t\t\t*pacl = acl;\n\t\telse\n\t\t\tposix_acl_release(acl);\n\t}\n\t*modep  = mode;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_get_fsgid_for_create",
          "args": [
            "dir"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_fsgid_for_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "60-69",
          "snippet": "static kgid_t v9fs_get_fsgid_for_create(struct inode *dir_inode)\n{\n\tBUG_ON(dir_inode == NULL);\n\n\tif (dir_inode->i_mode & S_ISGID) {\n\t\t/* set_gid bit is set.*/\n\t\treturn dir_inode->i_gid;\n\t}\n\treturn current_fsgid();\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic kgid_t v9fs_get_fsgid_for_create(struct inode *dir_inode)\n{\n\tBUG_ON(dir_inode == NULL);\n\n\tif (dir_inode->i_mode & S_ISGID) {\n\t\t/* set_gid bit is set.*/\n\t\treturn dir_inode->i_gid;\n\t}\n\treturn current_fsgid();\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"fid lookup failed %d\\n\"",
            "err"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dfid"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dfid"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dir_dentry"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "dir"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"name %pd\\n\"",
            "dentry"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_vfs_mkdir_dotl(struct inode *dir,\n\t\t\t       struct dentry *dentry, umode_t omode)\n{\n\tint err;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid = NULL, *dfid = NULL;\n\tkgid_t gid;\n\tchar *name;\n\tumode_t mode;\n\tstruct inode *inode;\n\tstruct p9_qid qid;\n\tstruct dentry *dir_dentry;\n\tstruct posix_acl *dacl = NULL, *pacl = NULL;\n\n\tp9_debug(P9_DEBUG_VFS, \"name %pd\\n\", dentry);\n\terr = 0;\n\tv9ses = v9fs_inode2v9ses(dir);\n\n\tomode |= S_IFDIR;\n\tif (dir->i_mode & S_ISGID)\n\t\tomode |= S_ISGID;\n\n\tdir_dentry = dentry->d_parent;\n\tdfid = v9fs_fid_lookup(dir_dentry);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\tdfid = NULL;\n\t\tgoto error;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\tmode = omode;\n\t/* Update mode based on ACL value */\n\terr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_VFS, \"Failed to get acl values in mkdir %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\tname = (char *) dentry->d_name.name;\n\terr = p9_client_mkdir_dotl(dfid, name, mode, gid, &qid);\n\tif (err < 0)\n\t\tgoto error;\n\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\",\n\t\t\t err);\n\t\tfid = NULL;\n\t\tgoto error;\n\t}\n\n\t/* instantiate inode and assign the unopened fid to the dentry */\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_fid_add(dentry, fid);\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\td_instantiate(dentry, inode);\n\t\tfid = NULL;\n\t\terr = 0;\n\t} else {\n\t\t/*\n\t\t * Not in cached mode. No need to populate\n\t\t * inode with stat. We need to get an inode\n\t\t * so that we can set the acl with dentry\n\t\t */\n\t\tinode = v9fs_get_inode(dir->i_sb, mode, 0);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\td_instantiate(dentry, inode);\n\t}\n\tinc_nlink(dir);\n\tv9fs_invalidate_inode_attr(dir);\nerror:\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\tv9fs_put_acl(dacl, pacl);\n\treturn err;\n}"
  },
  {
    "function_name": "v9fs_vfs_atomic_open_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "240-372",
    "snippet": "static int\nv9fs_vfs_atomic_open_dotl(struct inode *dir, struct dentry *dentry,\n\t\t\t  struct file *file, unsigned flags, umode_t omode,\n\t\t\t  int *opened)\n{\n\tint err = 0;\n\tkgid_t gid;\n\tumode_t mode;\n\tchar *name = NULL;\n\tstruct p9_qid qid;\n\tstruct inode *inode;\n\tstruct p9_fid *fid = NULL;\n\tstruct v9fs_inode *v9inode;\n\tstruct p9_fid *dfid, *ofid, *inode_fid;\n\tstruct v9fs_session_info *v9ses;\n\tstruct posix_acl *pacl = NULL, *dacl = NULL;\n\tstruct dentry *res = NULL;\n\n\tif (d_unhashed(dentry)) {\n\t\tres = v9fs_vfs_lookup(dir, dentry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\tif (res)\n\t\t\tdentry = res;\n\t}\n\n\t/* Only creates */\n\tif (!(flags & O_CREAT) || dentry->d_inode)\n\t\treturn\tfinish_no_open(file, res);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\n\tname = (char *) dentry->d_name.name;\n\tp9_debug(P9_DEBUG_VFS, \"name:%s flags:0x%x mode:0x%hx\\n\",\n\t\t name, flags, omode);\n\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* clone a fid to use for creation */\n\tofid = p9_client_walk(dfid, 0, NULL, 1);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\n\tmode = omode;\n\t/* Update mode based on ACL value */\n\terr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_VFS, \"Failed to get acl values in creat %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\terr = p9_client_create_dotl(ofid, name, v9fs_open_to_dotl_flags(flags),\n\t\t\t\t    mode, gid, &qid);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_open_dotl failed in creat %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\tv9fs_invalidate_inode_attr(dir);\n\n\t/* instantiate inode and assign the unopened fid to the dentry */\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\tfid = NULL;\n\t\tgoto error;\n\t}\n\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\t/* Now set the ACL based on the default value */\n\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\n\tv9fs_fid_add(dentry, fid);\n\td_instantiate(dentry, inode);\n\n\tv9inode = V9FS_I(inode);\n\tmutex_lock(&v9inode->v_mutex);\n\tif ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&\n\t    !v9inode->writeback_fid &&\n\t    ((flags & O_ACCMODE) != O_RDONLY)) {\n\t\t/*\n\t\t * clone a fid and add it to writeback_fid\n\t\t * we do it during open time instead of\n\t\t * page dirty time via write_begin/page_mkwrite\n\t\t * because we want write after unlink usecase\n\t\t * to work.\n\t\t */\n\t\tinode_fid = v9fs_writeback_fid(dentry);\n\t\tif (IS_ERR(inode_fid)) {\n\t\t\terr = PTR_ERR(inode_fid);\n\t\t\tmutex_unlock(&v9inode->v_mutex);\n\t\t\tgoto err_clunk_old_fid;\n\t\t}\n\t\tv9inode->writeback_fid = (void *) inode_fid;\n\t}\n\tmutex_unlock(&v9inode->v_mutex);\n\t/* Since we are opening a file, assign the open fid to the file */\n\terr = finish_open(file, dentry, generic_file_open, opened);\n\tif (err)\n\t\tgoto err_clunk_old_fid;\n\tfile->private_data = ofid;\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tv9fs_cache_inode_set_cookie(inode, file);\n\t*opened |= FILE_CREATED;\nout:\n\tv9fs_put_acl(dacl, pacl);\n\tdput(res);\n\treturn err;\n\nerror:\n\tif (fid)\n\t\tp9_client_clunk(fid);\nerr_clunk_old_fid:\n\tif (ofid)\n\t\tp9_client_clunk(ofid);\n\tgoto out;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "ofid"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_clunk",
          "args": [
            "fid"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "res"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_put_acl",
          "args": [
            "dacl",
            "pacl"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_put_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "179-184",
          "snippet": "void v9fs_put_acl(struct posix_acl *dacl,\n\t\t  struct posix_acl *acl)\n{\n\tposix_acl_release(dacl);\n\tposix_acl_release(acl);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid v9fs_put_acl(struct posix_acl *dacl,\n\t\t  struct posix_acl *acl)\n{\n\tposix_acl_release(dacl);\n\tposix_acl_release(acl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_cache_inode_set_cookie",
          "args": [
            "inode",
            "file"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_cache_inode_set_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "239-254",
          "snippet": "void v9fs_cache_inode_set_cookie(struct inode *inode, struct file *filp)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif (!v9inode->fscache)\n\t\treturn;\n\n\tspin_lock(&v9inode->fscache_lock);\n\n\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\tv9fs_cache_inode_flush_cookie(inode);\n\telse\n\t\tv9fs_cache_inode_get_cookie(inode);\n\n\tspin_unlock(&v9inode->fscache_lock);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nvoid v9fs_cache_inode_set_cookie(struct inode *inode, struct file *filp)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif (!v9inode->fscache)\n\t\treturn;\n\n\tspin_lock(&v9inode->fscache_lock);\n\n\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\tv9fs_cache_inode_flush_cookie(inode);\n\telse\n\t\tv9fs_cache_inode_get_cookie(inode);\n\n\tspin_unlock(&v9inode->fscache_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_open",
          "args": [
            "file",
            "dentry",
            "generic_file_open",
            "opened"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "finish_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "784-797",
          "snippet": "int finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); /* once it's opened, it's opened */\n\n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode_fid"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode_fid"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_writeback_fid",
          "args": [
            "dentry"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_writeback_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "284-306",
          "snippet": "struct p9_fid *v9fs_writeback_fid(struct dentry *dentry)\n{\n\tint err;\n\tstruct p9_fid *fid;\n\n\tfid = v9fs_fid_clone_with_uid(dentry, GLOBAL_ROOT_UID);\n\tif (IS_ERR(fid))\n\t\tgoto error_out;\n\t/*\n\t * writeback fid will only be used to write back the\n\t * dirty pages. We always request for the open fid in read-write\n\t * mode so that a partial page write which result in page\n\t * read can work.\n\t */\n\terr = p9_client_open(fid, O_RDWR);\n\tif (err < 0) {\n\t\tp9_client_clunk(fid);\n\t\tfid = ERR_PTR(err);\n\t\tgoto error_out;\n\t}\nerror_out:\n\treturn fid;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_writeback_fid(struct dentry *dentry)\n{\n\tint err;\n\tstruct p9_fid *fid;\n\n\tfid = v9fs_fid_clone_with_uid(dentry, GLOBAL_ROOT_UID);\n\tif (IS_ERR(fid))\n\t\tgoto error_out;\n\t/*\n\t * writeback fid will only be used to write back the\n\t * dirty pages. We always request for the open fid in read-write\n\t * mode so that a partial page write which result in page\n\t * read can work.\n\t */\n\terr = p9_client_open(fid, O_RDWR);\n\tif (err < 0) {\n\t\tp9_client_clunk(fid);\n\t\tfid = ERR_PTR(err);\n\t\tgoto error_out;\n\t}\nerror_out:\n\treturn fid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&v9inode->v_mutex"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_fid_add",
          "args": [
            "dentry",
            "fid"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_set_create_acl",
          "args": [
            "inode",
            "fid",
            "dacl",
            "pacl"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_set_create_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "169-177",
          "snippet": "int v9fs_set_create_acl(struct inode *inode, struct p9_fid *fid,\n\t\t\tstruct posix_acl *dacl, struct posix_acl *acl)\n{\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\tv9fs_set_acl(fid, ACL_TYPE_DEFAULT, dacl);\n\tv9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\treturn 0;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_set_create_acl(struct inode *inode, struct p9_fid *fid,\n\t\t\tstruct posix_acl *dacl, struct posix_acl *acl)\n{\n\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\tset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\n\tv9fs_set_acl(fid, ACL_TYPE_DEFAULT, dacl);\n\tv9fs_set_acl(fid, ACL_TYPE_ACCESS, acl);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"inode creation failed %d\\n\"",
            "err"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_get_new_inode_from_fid",
          "args": [
            "v9ses",
            "fid",
            "dir->i_sb"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_new_inode_from_fid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "218-226",
          "snippet": "static inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct inode *\nv9fs_get_new_inode_from_fid(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t    struct super_block *sb)\n{\n\tif (v9fs_proto_dotl(v9ses))\n\t\treturn v9fs_inode_from_fid_dotl(v9ses, fid, sb, 1);\n\telse\n\t\treturn v9fs_inode_from_fid(v9ses, fid, sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"p9_client_walk failed %d\\n\"",
            "err"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_walk",
          "args": [
            "dfid",
            "1",
            "&name",
            "1"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_invalidate_inode_attr",
          "args": [
            "dir"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_invalidate_inode_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs_vfs.h",
          "lines": "81-87",
          "snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void v9fs_invalidate_inode_attr(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tv9inode = V9FS_I(inode);\n\tv9inode->cache_validity |= V9FS_INO_INVALID_ATTR;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"p9_client_open_dotl failed in creat %d\\n\"",
            "err"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_create_dotl",
          "args": [
            "ofid",
            "name",
            "v9fs_open_to_dotl_flags(flags)",
            "mode",
            "gid",
            "&qid"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_open_to_dotl_flags",
          "args": [
            "flags"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_open_to_dotl_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "211-223",
          "snippet": "int v9fs_open_to_dotl_flags(int flags)\n{\n\tint rflags = 0;\n\n\t/*\n\t * We have same bits for P9_DOTL_READONLY, P9_DOTL_WRONLY\n\t * and P9_DOTL_NOACCESS\n\t */\n\trflags |= flags & O_ACCMODE;\n\trflags |= v9fs_mapped_dotl_flags(flags);\n\n\treturn rflags;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_open_to_dotl_flags(int flags)\n{\n\tint rflags = 0;\n\n\t/*\n\t * We have same bits for P9_DOTL_READONLY, P9_DOTL_WRONLY\n\t * and P9_DOTL_NOACCESS\n\t */\n\trflags |= flags & O_ACCMODE;\n\trflags |= v9fs_mapped_dotl_flags(flags);\n\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"Failed to get acl values in creat %d\\n\"",
            "err"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_acl_mode",
          "args": [
            "dir",
            "&mode",
            "&dacl",
            "&pacl"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_acl_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "186-213",
          "snippet": "int v9fs_acl_mode(struct inode *dir, umode_t *modep,\n\t\t  struct posix_acl **dpacl, struct posix_acl **pacl)\n{\n\tint retval = 0;\n\tumode_t mode = *modep;\n\tstruct posix_acl *acl = NULL;\n\n\tif (!S_ISLNK(mode)) {\n\t\tacl = v9fs_get_cached_acl(dir, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\tif (!acl)\n\t\t\tmode &= ~current_umask();\n\t}\n\tif (acl) {\n\t\tif (S_ISDIR(mode))\n\t\t\t*dpacl = posix_acl_dup(acl);\n\t\tretval = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval > 0)\n\t\t\t*pacl = acl;\n\t\telse\n\t\t\tposix_acl_release(acl);\n\t}\n\t*modep  = mode;\n\treturn 0;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_acl_mode(struct inode *dir, umode_t *modep,\n\t\t  struct posix_acl **dpacl, struct posix_acl **pacl)\n{\n\tint retval = 0;\n\tumode_t mode = *modep;\n\tstruct posix_acl *acl = NULL;\n\n\tif (!S_ISLNK(mode)) {\n\t\tacl = v9fs_get_cached_acl(dir, ACL_TYPE_DEFAULT);\n\t\tif (IS_ERR(acl))\n\t\t\treturn PTR_ERR(acl);\n\t\tif (!acl)\n\t\t\tmode &= ~current_umask();\n\t}\n\tif (acl) {\n\t\tif (S_ISDIR(mode))\n\t\t\t*dpacl = posix_acl_dup(acl);\n\t\tretval = __posix_acl_create(&acl, GFP_NOFS, &mode);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tif (retval > 0)\n\t\t\t*pacl = acl;\n\t\telse\n\t\t\tposix_acl_release(acl);\n\t}\n\t*modep  = mode;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_get_fsgid_for_create",
          "args": [
            "dir"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_fsgid_for_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "60-69",
          "snippet": "static kgid_t v9fs_get_fsgid_for_create(struct inode *dir_inode)\n{\n\tBUG_ON(dir_inode == NULL);\n\n\tif (dir_inode->i_mode & S_ISGID) {\n\t\t/* set_gid bit is set.*/\n\t\treturn dir_inode->i_gid;\n\t}\n\treturn current_fsgid();\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic kgid_t v9fs_get_fsgid_for_create(struct inode *dir_inode)\n{\n\tBUG_ON(dir_inode == NULL);\n\n\tif (dir_inode->i_mode & S_ISGID) {\n\t\t/* set_gid bit is set.*/\n\t\treturn dir_inode->i_gid;\n\t}\n\treturn current_fsgid();\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"p9_client_walk failed %d\\n\"",
            "err"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ofid"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ofid"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_walk",
          "args": [
            "dfid",
            "0",
            "NULL",
            "1"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"fid lookup failed %d\\n\"",
            "err"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dfid"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dfid"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_fid_lookup",
          "args": [
            "dentry->d_parent"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "231-258",
          "snippet": "struct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct p9_fid *v9fs_fid_lookup(struct dentry *dentry)\n{\n\tkuid_t uid;\n\tint  any, access;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_dentry2v9ses(dentry);\n\taccess = v9ses->flags & V9FS_ACCESS_MASK;\n\tswitch (access) {\n\tcase V9FS_ACCESS_SINGLE:\n\tcase V9FS_ACCESS_USER:\n\tcase V9FS_ACCESS_CLIENT:\n\t\tuid = current_fsuid();\n\t\tany = 0;\n\t\tbreak;\n\n\tcase V9FS_ACCESS_ANY:\n\t\tuid = v9ses->uid;\n\t\tany = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tuid = INVALID_UID;\n\t\tany = 0;\n\t\tbreak;\n\t}\n\treturn v9fs_fid_lookup_with_uid(dentry, uid, any);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_VFS",
            "\"name:%s flags:0x%x mode:0x%hx\\n\"",
            "name",
            "flags",
            "omode"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_inode2v9ses",
          "args": [
            "dir"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode2v9ses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "172-175",
          "snippet": "static inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_session_info *v9fs_inode2v9ses(struct inode *inode)\n{\n\treturn (inode->i_sb->s_fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_no_open",
          "args": [
            "file",
            "res"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "finish_no_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "814-818",
          "snippet": "int finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint finish_no_open(struct file *file, struct dentry *dentry)\n{\n\tfile->f_path.dentry = dentry;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "res"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "res"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_vfs_lookup",
          "args": [
            "dir",
            "dentry",
            "0"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_vfs_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "785-843",
          "snippet": "struct dentry *v9fs_vfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct dentry *res;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *dfid, *fid;\n\tstruct inode *inode;\n\tchar *name;\n\n\tp9_debug(P9_DEBUG_VFS, \"dir: %p dentry: (%pd) %p flags: %x\\n\",\n\t\t dir, dentry, dentry, flags);\n\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\t/* We can walk d_parent because we hold the dir->i_mutex */\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid))\n\t\treturn ERR_CAST(dfid);\n\n\tname = (char *) dentry->d_name.name;\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\tif (fid == ERR_PTR(-ENOENT)) {\n\t\t\td_add(dentry, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ERR_CAST(fid);\n\t}\n\t/*\n\t * Make sure we don't use a wrong inode due to parallel\n\t * unlink. For cached mode create calls request for new\n\t * inode. But with cache disabled, lookup should do this.\n\t */\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode = v9fs_get_inode_from_fid(v9ses, fid, dir->i_sb);\n\telse\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tp9_client_clunk(fid);\n\t\treturn ERR_CAST(inode);\n\t}\n\t/*\n\t * If we had a rename on the server and a parallel lookup\n\t * for the new name, then make sure we instantiate with\n\t * the new name. ie look up for a/b, while on server somebody\n\t * moved b under k and client parallely did a lookup for\n\t * k/b.\n\t */\n\tres = d_splice_alias(inode, dentry);\n\tif (!res)\n\t\tv9fs_fid_add(dentry, fid);\n\telse if (!IS_ERR(res))\n\t\tv9fs_fid_add(res, fid);\n\telse\n\t\tp9_client_clunk(fid);\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct dentry *v9fs_vfs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t      unsigned int flags)\n{\n\tstruct dentry *res;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *dfid, *fid;\n\tstruct inode *inode;\n\tchar *name;\n\n\tp9_debug(P9_DEBUG_VFS, \"dir: %p dentry: (%pd) %p flags: %x\\n\",\n\t\t dir, dentry, dentry, flags);\n\n\tif (dentry->d_name.len > NAME_MAX)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\t/* We can walk d_parent because we hold the dir->i_mutex */\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid))\n\t\treturn ERR_CAST(dfid);\n\n\tname = (char *) dentry->d_name.name;\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\tif (fid == ERR_PTR(-ENOENT)) {\n\t\t\td_add(dentry, NULL);\n\t\t\treturn NULL;\n\t\t}\n\t\treturn ERR_CAST(fid);\n\t}\n\t/*\n\t * Make sure we don't use a wrong inode due to parallel\n\t * unlink. For cached mode create calls request for new\n\t * inode. But with cache disabled, lookup should do this.\n\t */\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tinode = v9fs_get_inode_from_fid(v9ses, fid, dir->i_sb);\n\telse\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\tp9_client_clunk(fid);\n\t\treturn ERR_CAST(inode);\n\t}\n\t/*\n\t * If we had a rename on the server and a parallel lookup\n\t * for the new name, then make sure we instantiate with\n\t * the new name. ie look up for a/b, while on server somebody\n\t * moved b under k and client parallely did a lookup for\n\t * k/b.\n\t */\n\tres = d_splice_alias(inode, dentry);\n\tif (!res)\n\t\tv9fs_fid_add(dentry, fid);\n\telse if (!IS_ERR(res))\n\t\tv9fs_fid_add(res, fid);\n\telse\n\t\tp9_client_clunk(fid);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_atomic_open_dotl(struct inode *dir, struct dentry *dentry,\n\t\t\t  struct file *file, unsigned flags, umode_t omode,\n\t\t\t  int *opened)\n{\n\tint err = 0;\n\tkgid_t gid;\n\tumode_t mode;\n\tchar *name = NULL;\n\tstruct p9_qid qid;\n\tstruct inode *inode;\n\tstruct p9_fid *fid = NULL;\n\tstruct v9fs_inode *v9inode;\n\tstruct p9_fid *dfid, *ofid, *inode_fid;\n\tstruct v9fs_session_info *v9ses;\n\tstruct posix_acl *pacl = NULL, *dacl = NULL;\n\tstruct dentry *res = NULL;\n\n\tif (d_unhashed(dentry)) {\n\t\tres = v9fs_vfs_lookup(dir, dentry, 0);\n\t\tif (IS_ERR(res))\n\t\t\treturn PTR_ERR(res);\n\n\t\tif (res)\n\t\t\tdentry = res;\n\t}\n\n\t/* Only creates */\n\tif (!(flags & O_CREAT) || dentry->d_inode)\n\t\treturn\tfinish_no_open(file, res);\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\n\tname = (char *) dentry->d_name.name;\n\tp9_debug(P9_DEBUG_VFS, \"name:%s flags:0x%x mode:0x%hx\\n\",\n\t\t name, flags, omode);\n\n\tdfid = v9fs_fid_lookup(dentry->d_parent);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t/* clone a fid to use for creation */\n\tofid = p9_client_walk(dfid, 0, NULL, 1);\n\tif (IS_ERR(ofid)) {\n\t\terr = PTR_ERR(ofid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\n\tmode = omode;\n\t/* Update mode based on ACL value */\n\terr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_VFS, \"Failed to get acl values in creat %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\terr = p9_client_create_dotl(ofid, name, v9fs_open_to_dotl_flags(flags),\n\t\t\t\t    mode, gid, &qid);\n\tif (err < 0) {\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_open_dotl failed in creat %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\tv9fs_invalidate_inode_attr(dir);\n\n\t/* instantiate inode and assign the unopened fid to the dentry */\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\", err);\n\t\tfid = NULL;\n\t\tgoto error;\n\t}\n\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\", err);\n\t\tgoto error;\n\t}\n\t/* Now set the ACL based on the default value */\n\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\n\tv9fs_fid_add(dentry, fid);\n\td_instantiate(dentry, inode);\n\n\tv9inode = V9FS_I(inode);\n\tmutex_lock(&v9inode->v_mutex);\n\tif ((v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) &&\n\t    !v9inode->writeback_fid &&\n\t    ((flags & O_ACCMODE) != O_RDONLY)) {\n\t\t/*\n\t\t * clone a fid and add it to writeback_fid\n\t\t * we do it during open time instead of\n\t\t * page dirty time via write_begin/page_mkwrite\n\t\t * because we want write after unlink usecase\n\t\t * to work.\n\t\t */\n\t\tinode_fid = v9fs_writeback_fid(dentry);\n\t\tif (IS_ERR(inode_fid)) {\n\t\t\terr = PTR_ERR(inode_fid);\n\t\t\tmutex_unlock(&v9inode->v_mutex);\n\t\t\tgoto err_clunk_old_fid;\n\t\t}\n\t\tv9inode->writeback_fid = (void *) inode_fid;\n\t}\n\tmutex_unlock(&v9inode->v_mutex);\n\t/* Since we are opening a file, assign the open fid to the file */\n\terr = finish_open(file, dentry, generic_file_open, opened);\n\tif (err)\n\t\tgoto err_clunk_old_fid;\n\tfile->private_data = ofid;\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE)\n\t\tv9fs_cache_inode_set_cookie(inode, file);\n\t*opened |= FILE_CREATED;\nout:\n\tv9fs_put_acl(dacl, pacl);\n\tdput(res);\n\treturn err;\n\nerror:\n\tif (fid)\n\t\tp9_client_clunk(fid);\nerr_clunk_old_fid:\n\tif (ofid)\n\t\tp9_client_clunk(ofid);\n\tgoto out;\n}"
  },
  {
    "function_name": "v9fs_vfs_create_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "233-238",
    "snippet": "static int\nv9fs_vfs_create_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,\n\t\tbool excl)\n{\n\treturn v9fs_vfs_mknod_dotl(dir, dentry, omode, 0);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_vfs_mknod_dotl",
          "args": [
            "dir",
            "dentry",
            "omode",
            "0"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_vfs_mknod_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "814-903",
          "snippet": "static int\nv9fs_vfs_mknod_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,\n\t\tdev_t rdev)\n{\n\tint err;\n\tkgid_t gid;\n\tchar *name;\n\tumode_t mode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid = NULL, *dfid = NULL;\n\tstruct inode *inode;\n\tstruct p9_qid qid;\n\tstruct dentry *dir_dentry;\n\tstruct posix_acl *dacl = NULL, *pacl = NULL;\n\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd mode: %hx MAJOR: %u MINOR: %u\\n\",\n\t\t dir->i_ino, dentry, omode,\n\t\t MAJOR(rdev), MINOR(rdev));\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tdir_dentry = dentry->d_parent;\n\tdfid = v9fs_fid_lookup(dir_dentry);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\tdfid = NULL;\n\t\tgoto error;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\tmode = omode;\n\t/* Update mode based on ACL value */\n\terr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_VFS, \"Failed to get acl values in mknod %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\tname = (char *) dentry->d_name.name;\n\n\terr = p9_client_mknod_dotl(dfid, name, mode, rdev, gid, &qid);\n\tif (err < 0)\n\t\tgoto error;\n\n\tv9fs_invalidate_inode_attr(dir);\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\",\n\t\t\t err);\n\t\tfid = NULL;\n\t\tgoto error;\n\t}\n\n\t/* instantiate inode and assign the unopened fid to the dentry */\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t\tfid = NULL;\n\t\terr = 0;\n\t} else {\n\t\t/*\n\t\t * Not in cached mode. No need to populate inode with stat.\n\t\t * socket syscall returns a fd, so we need instantiate\n\t\t */\n\t\tinode = v9fs_get_inode(dir->i_sb, mode, rdev);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\td_instantiate(dentry, inode);\n\t}\nerror:\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\tv9fs_put_acl(dacl, pacl);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nv9fs_vfs_mknod_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,\n\t\t    dev_t rdev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_mknod_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,\n\t\t    dev_t rdev);\n\nstatic int\nv9fs_vfs_mknod_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,\n\t\tdev_t rdev)\n{\n\tint err;\n\tkgid_t gid;\n\tchar *name;\n\tumode_t mode;\n\tstruct v9fs_session_info *v9ses;\n\tstruct p9_fid *fid = NULL, *dfid = NULL;\n\tstruct inode *inode;\n\tstruct p9_qid qid;\n\tstruct dentry *dir_dentry;\n\tstruct posix_acl *dacl = NULL, *pacl = NULL;\n\n\tp9_debug(P9_DEBUG_VFS, \" %lu,%pd mode: %hx MAJOR: %u MINOR: %u\\n\",\n\t\t dir->i_ino, dentry, omode,\n\t\t MAJOR(rdev), MINOR(rdev));\n\n\tif (!new_valid_dev(rdev))\n\t\treturn -EINVAL;\n\n\tv9ses = v9fs_inode2v9ses(dir);\n\tdir_dentry = dentry->d_parent;\n\tdfid = v9fs_fid_lookup(dir_dentry);\n\tif (IS_ERR(dfid)) {\n\t\terr = PTR_ERR(dfid);\n\t\tp9_debug(P9_DEBUG_VFS, \"fid lookup failed %d\\n\", err);\n\t\tdfid = NULL;\n\t\tgoto error;\n\t}\n\n\tgid = v9fs_get_fsgid_for_create(dir);\n\tmode = omode;\n\t/* Update mode based on ACL value */\n\terr = v9fs_acl_mode(dir, &mode, &dacl, &pacl);\n\tif (err) {\n\t\tp9_debug(P9_DEBUG_VFS, \"Failed to get acl values in mknod %d\\n\",\n\t\t\t err);\n\t\tgoto error;\n\t}\n\tname = (char *) dentry->d_name.name;\n\n\terr = p9_client_mknod_dotl(dfid, name, mode, rdev, gid, &qid);\n\tif (err < 0)\n\t\tgoto error;\n\n\tv9fs_invalidate_inode_attr(dir);\n\tfid = p9_client_walk(dfid, 1, &name, 1);\n\tif (IS_ERR(fid)) {\n\t\terr = PTR_ERR(fid);\n\t\tp9_debug(P9_DEBUG_VFS, \"p9_client_walk failed %d\\n\",\n\t\t\t err);\n\t\tfid = NULL;\n\t\tgoto error;\n\t}\n\n\t/* instantiate inode and assign the unopened fid to the dentry */\n\tif (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) {\n\t\tinode = v9fs_get_new_inode_from_fid(v9ses, fid, dir->i_sb);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tp9_debug(P9_DEBUG_VFS, \"inode creation failed %d\\n\",\n\t\t\t\t err);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\tv9fs_fid_add(dentry, fid);\n\t\td_instantiate(dentry, inode);\n\t\tfid = NULL;\n\t\terr = 0;\n\t} else {\n\t\t/*\n\t\t * Not in cached mode. No need to populate inode with stat.\n\t\t * socket syscall returns a fd, so we need instantiate\n\t\t */\n\t\tinode = v9fs_get_inode(dir->i_sb, mode, rdev);\n\t\tif (IS_ERR(inode)) {\n\t\t\terr = PTR_ERR(inode);\n\t\t\tgoto error;\n\t\t}\n\t\tv9fs_set_create_acl(inode, fid, dacl, pacl);\n\t\td_instantiate(dentry, inode);\n\t}\nerror:\n\tif (fid)\n\t\tp9_client_clunk(fid);\n\tv9fs_put_acl(dacl, pacl);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int\nv9fs_vfs_create_dotl(struct inode *dir, struct dentry *dentry, umode_t omode,\n\t\tbool excl)\n{\n\treturn v9fs_vfs_mknod_dotl(dir, dentry, omode, 0);\n}"
  },
  {
    "function_name": "v9fs_open_to_dotl_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "211-223",
    "snippet": "int v9fs_open_to_dotl_flags(int flags)\n{\n\tint rflags = 0;\n\n\t/*\n\t * We have same bits for P9_DOTL_READONLY, P9_DOTL_WRONLY\n\t * and P9_DOTL_NOACCESS\n\t */\n\trflags |= flags & O_ACCMODE;\n\trflags |= v9fs_mapped_dotl_flags(flags);\n\n\treturn rflags;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_mapped_dotl_flags",
          "args": [
            "flags"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_mapped_dotl_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "179-204",
          "snippet": "static int v9fs_mapped_dotl_flags(int flags)\n{\n\tint i;\n\tint rflags = 0;\n\tstruct dotl_openflag_map dotl_oflag_map[] = {\n\t\t{ O_CREAT,\tP9_DOTL_CREATE },\n\t\t{ O_EXCL,\tP9_DOTL_EXCL },\n\t\t{ O_NOCTTY,\tP9_DOTL_NOCTTY },\n\t\t{ O_APPEND,\tP9_DOTL_APPEND },\n\t\t{ O_NONBLOCK,\tP9_DOTL_NONBLOCK },\n\t\t{ O_DSYNC,\tP9_DOTL_DSYNC },\n\t\t{ FASYNC,\tP9_DOTL_FASYNC },\n\t\t{ O_DIRECT,\tP9_DOTL_DIRECT },\n\t\t{ O_LARGEFILE,\tP9_DOTL_LARGEFILE },\n\t\t{ O_DIRECTORY,\tP9_DOTL_DIRECTORY },\n\t\t{ O_NOFOLLOW,\tP9_DOTL_NOFOLLOW },\n\t\t{ O_NOATIME,\tP9_DOTL_NOATIME },\n\t\t{ O_CLOEXEC,\tP9_DOTL_CLOEXEC },\n\t\t{ O_SYNC,\tP9_DOTL_SYNC},\n\t};\n\tfor (i = 0; i < ARRAY_SIZE(dotl_oflag_map); i++) {\n\t\tif (flags & dotl_oflag_map[i].open_flag)\n\t\t\trflags |= dotl_oflag_map[i].dotl_flag;\n\t}\n\treturn rflags;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_mapped_dotl_flags(int flags)\n{\n\tint i;\n\tint rflags = 0;\n\tstruct dotl_openflag_map dotl_oflag_map[] = {\n\t\t{ O_CREAT,\tP9_DOTL_CREATE },\n\t\t{ O_EXCL,\tP9_DOTL_EXCL },\n\t\t{ O_NOCTTY,\tP9_DOTL_NOCTTY },\n\t\t{ O_APPEND,\tP9_DOTL_APPEND },\n\t\t{ O_NONBLOCK,\tP9_DOTL_NONBLOCK },\n\t\t{ O_DSYNC,\tP9_DOTL_DSYNC },\n\t\t{ FASYNC,\tP9_DOTL_FASYNC },\n\t\t{ O_DIRECT,\tP9_DOTL_DIRECT },\n\t\t{ O_LARGEFILE,\tP9_DOTL_LARGEFILE },\n\t\t{ O_DIRECTORY,\tP9_DOTL_DIRECTORY },\n\t\t{ O_NOFOLLOW,\tP9_DOTL_NOFOLLOW },\n\t\t{ O_NOATIME,\tP9_DOTL_NOATIME },\n\t\t{ O_CLOEXEC,\tP9_DOTL_CLOEXEC },\n\t\t{ O_SYNC,\tP9_DOTL_SYNC},\n\t};\n\tfor (i = 0; i < ARRAY_SIZE(dotl_oflag_map); i++) {\n\t\tif (flags & dotl_oflag_map[i].open_flag)\n\t\t\trflags |= dotl_oflag_map[i].dotl_flag;\n\t}\n\treturn rflags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nint v9fs_open_to_dotl_flags(int flags)\n{\n\tint rflags = 0;\n\n\t/*\n\t * We have same bits for P9_DOTL_READONLY, P9_DOTL_WRONLY\n\t * and P9_DOTL_NOACCESS\n\t */\n\trflags |= flags & O_ACCMODE;\n\trflags |= v9fs_mapped_dotl_flags(flags);\n\n\treturn rflags;\n}"
  },
  {
    "function_name": "v9fs_mapped_dotl_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "179-204",
    "snippet": "static int v9fs_mapped_dotl_flags(int flags)\n{\n\tint i;\n\tint rflags = 0;\n\tstruct dotl_openflag_map dotl_oflag_map[] = {\n\t\t{ O_CREAT,\tP9_DOTL_CREATE },\n\t\t{ O_EXCL,\tP9_DOTL_EXCL },\n\t\t{ O_NOCTTY,\tP9_DOTL_NOCTTY },\n\t\t{ O_APPEND,\tP9_DOTL_APPEND },\n\t\t{ O_NONBLOCK,\tP9_DOTL_NONBLOCK },\n\t\t{ O_DSYNC,\tP9_DOTL_DSYNC },\n\t\t{ FASYNC,\tP9_DOTL_FASYNC },\n\t\t{ O_DIRECT,\tP9_DOTL_DIRECT },\n\t\t{ O_LARGEFILE,\tP9_DOTL_LARGEFILE },\n\t\t{ O_DIRECTORY,\tP9_DOTL_DIRECTORY },\n\t\t{ O_NOFOLLOW,\tP9_DOTL_NOFOLLOW },\n\t\t{ O_NOATIME,\tP9_DOTL_NOATIME },\n\t\t{ O_CLOEXEC,\tP9_DOTL_CLOEXEC },\n\t\t{ O_SYNC,\tP9_DOTL_SYNC},\n\t};\n\tfor (i = 0; i < ARRAY_SIZE(dotl_oflag_map); i++) {\n\t\tif (flags & dotl_oflag_map[i].open_flag)\n\t\t\trflags |= dotl_oflag_map[i].dotl_flag;\n\t}\n\treturn rflags;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "dotl_oflag_map"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_mapped_dotl_flags(int flags)\n{\n\tint i;\n\tint rflags = 0;\n\tstruct dotl_openflag_map dotl_oflag_map[] = {\n\t\t{ O_CREAT,\tP9_DOTL_CREATE },\n\t\t{ O_EXCL,\tP9_DOTL_EXCL },\n\t\t{ O_NOCTTY,\tP9_DOTL_NOCTTY },\n\t\t{ O_APPEND,\tP9_DOTL_APPEND },\n\t\t{ O_NONBLOCK,\tP9_DOTL_NONBLOCK },\n\t\t{ O_DSYNC,\tP9_DOTL_DSYNC },\n\t\t{ FASYNC,\tP9_DOTL_FASYNC },\n\t\t{ O_DIRECT,\tP9_DOTL_DIRECT },\n\t\t{ O_LARGEFILE,\tP9_DOTL_LARGEFILE },\n\t\t{ O_DIRECTORY,\tP9_DOTL_DIRECTORY },\n\t\t{ O_NOFOLLOW,\tP9_DOTL_NOFOLLOW },\n\t\t{ O_NOATIME,\tP9_DOTL_NOATIME },\n\t\t{ O_CLOEXEC,\tP9_DOTL_CLOEXEC },\n\t\t{ O_SYNC,\tP9_DOTL_SYNC},\n\t};\n\tfor (i = 0; i < ARRAY_SIZE(dotl_oflag_map); i++) {\n\t\tif (flags & dotl_oflag_map[i].open_flag)\n\t\t\trflags |= dotl_oflag_map[i].dotl_flag;\n\t}\n\treturn rflags;\n}"
  },
  {
    "function_name": "v9fs_inode_from_fid_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "158-172",
    "snippet": "struct inode *\nv9fs_inode_from_fid_dotl(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t struct super_block *sb, int new)\n{\n\tstruct p9_stat_dotl *st;\n\tstruct inode *inode = NULL;\n\n\tst = p9_client_getattr_dotl(fid, P9_STATS_BASIC | P9_STATS_GEN);\n\tif (IS_ERR(st))\n\t\treturn ERR_CAST(st);\n\n\tinode = v9fs_qid_iget_dotl(sb, &st->qid, fid, st, new);\n\tkfree(st);\n\treturn inode;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "st"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_qid_iget_dotl",
          "args": [
            "sb",
            "&st->qid",
            "fid",
            "st",
            "new"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_qid_iget_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "109-156",
          "snippet": "static struct inode *v9fs_qid_iget_dotl(struct super_block *sb,\n\t\t\t\t\tstruct p9_qid *qid,\n\t\t\t\t\tstruct p9_fid *fid,\n\t\t\t\t\tstruct p9_stat_dotl *st,\n\t\t\t\t\tint new)\n{\n\tint retval;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *, void *);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode_dotl;\n\telse\n\t\ttest = v9fs_test_inode_dotl;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode_dotl, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t/*\n\t * initialize the inode with the stat info\n\t * FIXME!! we may need support for stale inodes\n\t * later.\n\t */\n\tinode->i_ino = i_ino;\n\tretval = v9fs_init_inode(v9ses, inode,\n\t\t\t\t st->st_mode, new_decode_dev(st->st_rdev));\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode_dotl(st, inode);\n\tv9fs_cache_inode_get_cookie(inode);\n\tretval = v9fs_get_acl(inode, fid);\n\tif (retval)\n\t\tgoto error;\n\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(retval);\n\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct inode *v9fs_qid_iget_dotl(struct super_block *sb,\n\t\t\t\t\tstruct p9_qid *qid,\n\t\t\t\t\tstruct p9_fid *fid,\n\t\t\t\t\tstruct p9_stat_dotl *st,\n\t\t\t\t\tint new)\n{\n\tint retval;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *, void *);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode_dotl;\n\telse\n\t\ttest = v9fs_test_inode_dotl;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode_dotl, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t/*\n\t * initialize the inode with the stat info\n\t * FIXME!! we may need support for stale inodes\n\t * later.\n\t */\n\tinode->i_ino = i_ino;\n\tretval = v9fs_init_inode(v9ses, inode,\n\t\t\t\t st->st_mode, new_decode_dev(st->st_rdev));\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode_dotl(st, inode);\n\tv9fs_cache_inode_get_cookie(inode);\n\tretval = v9fs_get_acl(inode, fid);\n\tif (retval)\n\t\tgoto error;\n\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(retval);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "st"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "st"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_getattr_dotl",
          "args": [
            "fid",
            "P9_STATS_BASIC | P9_STATS_GEN"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct inode *\nv9fs_inode_from_fid_dotl(struct v9fs_session_info *v9ses, struct p9_fid *fid,\n\t\t\t struct super_block *sb, int new)\n{\n\tstruct p9_stat_dotl *st;\n\tstruct inode *inode = NULL;\n\n\tst = p9_client_getattr_dotl(fid, P9_STATS_BASIC | P9_STATS_GEN);\n\tif (IS_ERR(st))\n\t\treturn ERR_CAST(st);\n\n\tinode = v9fs_qid_iget_dotl(sb, &st->qid, fid, st, new);\n\tkfree(st);\n\treturn inode;\n}"
  },
  {
    "function_name": "v9fs_qid_iget_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "109-156",
    "snippet": "static struct inode *v9fs_qid_iget_dotl(struct super_block *sb,\n\t\t\t\t\tstruct p9_qid *qid,\n\t\t\t\t\tstruct p9_fid *fid,\n\t\t\t\t\tstruct p9_stat_dotl *st,\n\t\t\t\t\tint new)\n{\n\tint retval;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *, void *);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode_dotl;\n\telse\n\t\ttest = v9fs_test_inode_dotl;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode_dotl, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t/*\n\t * initialize the inode with the stat info\n\t * FIXME!! we may need support for stale inodes\n\t * later.\n\t */\n\tinode->i_ino = i_ino;\n\tretval = v9fs_init_inode(v9ses, inode,\n\t\t\t\t st->st_mode, new_decode_dev(st->st_rdev));\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode_dotl(st, inode);\n\tv9fs_cache_inode_get_cookie(inode);\n\tretval = v9fs_get_acl(inode, fid);\n\tif (retval)\n\t\tgoto error;\n\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(retval);\n\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_get_acl",
          "args": [
            "inode",
            "fid"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/acl.c",
          "lines": "56-86",
          "snippet": "int v9fs_get_acl(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *pacl, *dacl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, NULL);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, NULL);\n\t\treturn 0;\n\t}\n\t/* get the default/access acl values and cache them */\n\tdacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_DEFAULT);\n\tpacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_ACCESS);\n\n\tif (!IS_ERR(dacl) && !IS_ERR(pacl)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, pacl);\n\t} else\n\t\tretval = -EIO;\n\n\tif (!IS_ERR(dacl))\n\t\tposix_acl_release(dacl);\n\n\tif (!IS_ERR(pacl))\n\t\tposix_acl_release(pacl);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint v9fs_get_acl(struct inode *inode, struct p9_fid *fid)\n{\n\tint retval = 0;\n\tstruct posix_acl *pacl, *dacl;\n\tstruct v9fs_session_info *v9ses;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tif (((v9ses->flags & V9FS_ACCESS_MASK) != V9FS_ACCESS_CLIENT) ||\n\t\t\t((v9ses->flags & V9FS_ACL_MASK) != V9FS_POSIX_ACL)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, NULL);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, NULL);\n\t\treturn 0;\n\t}\n\t/* get the default/access acl values and cache them */\n\tdacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_DEFAULT);\n\tpacl = __v9fs_get_acl(fid, POSIX_ACL_XATTR_ACCESS);\n\n\tif (!IS_ERR(dacl) && !IS_ERR(pacl)) {\n\t\tset_cached_acl(inode, ACL_TYPE_DEFAULT, dacl);\n\t\tset_cached_acl(inode, ACL_TYPE_ACCESS, pacl);\n\t} else\n\t\tretval = -EIO;\n\n\tif (!IS_ERR(dacl))\n\t\tposix_acl_release(dacl);\n\n\tif (!IS_ERR(pacl))\n\t\tposix_acl_release(pacl);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_cache_inode_get_cookie",
          "args": [
            "inode"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_cache_inode_get_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "192-211",
          "snippet": "void v9fs_cache_inode_get_cookie(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tstruct v9fs_session_info *v9ses;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tv9inode = V9FS_I(inode);\n\tif (v9inode->fscache)\n\t\treturn;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tv9inode->fscache = fscache_acquire_cookie(v9ses->fscache,\n\t\t\t\t\t\t  &v9fs_cache_inode_index_def,\n\t\t\t\t\t\t  v9inode, true);\n\n\tp9_debug(P9_DEBUG_FSC, \"inode %p get cookie %p\\n\",\n\t\t inode, v9inode->fscache);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct fscache_cookie_def v9fs_cache_inode_index_def = {\n\t.name\t\t= \"9p.inode\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_DATAFILE,\n\t.get_key\t= v9fs_cache_inode_get_key,\n\t.get_attr\t= v9fs_cache_inode_get_attr,\n\t.get_aux\t= v9fs_cache_inode_get_aux,\n\t.check_aux\t= v9fs_cache_inode_check_aux,\n\t.now_uncached\t= v9fs_cache_inode_now_uncached,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nconst struct fscache_cookie_def v9fs_cache_inode_index_def = {\n\t.name\t\t= \"9p.inode\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_DATAFILE,\n\t.get_key\t= v9fs_cache_inode_get_key,\n\t.get_attr\t= v9fs_cache_inode_get_attr,\n\t.get_aux\t= v9fs_cache_inode_get_aux,\n\t.check_aux\t= v9fs_cache_inode_check_aux,\n\t.now_uncached\t= v9fs_cache_inode_now_uncached,\n};\n\nvoid v9fs_cache_inode_get_cookie(struct inode *inode)\n{\n\tstruct v9fs_inode *v9inode;\n\tstruct v9fs_session_info *v9ses;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tv9inode = V9FS_I(inode);\n\tif (v9inode->fscache)\n\t\treturn;\n\n\tv9ses = v9fs_inode2v9ses(inode);\n\tv9inode->fscache = fscache_acquire_cookie(v9ses->fscache,\n\t\t\t\t\t\t  &v9fs_cache_inode_index_def,\n\t\t\t\t\t\t  v9inode, true);\n\n\tp9_debug(P9_DEBUG_FSC, \"inode %p get cookie %p\\n\",\n\t\t inode, v9inode->fscache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_stat2inode_dotl",
          "args": [
            "st",
            "inode"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_stat2inode_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
          "lines": "613-676",
          "snippet": "void\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\ti_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tinode->i_mode = stat->st_mode;\n\t\t\tif ((S_ISBLK(inode->i_mode)) ||\n\t\t\t\t\t\t(S_ISCHR(inode->i_mode)))\n\t\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t\t\t\tinode->i_rdev);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_RDEV)\n\t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n\t\tif (stat->st_result_mask & P9_STATS_SIZE)\n\t\t\ti_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t/* Currently we don't support P9_STATS_BTIME and P9_STATS_DATA_VERSION\n\t * because the inode structure does not have fields for them.\n\t */\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid\nv9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode)\n{\n\tumode_t mode;\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\n\tif ((stat->st_result_mask & P9_STATS_BASIC) == P9_STATS_BASIC) {\n\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\tinode->i_uid = stat->st_uid;\n\t\tinode->i_gid = stat->st_gid;\n\t\tset_nlink(inode, stat->st_nlink);\n\n\t\tmode = stat->st_mode & S_IALLUGO;\n\t\tmode |= inode->i_mode & ~S_IALLUGO;\n\t\tinode->i_mode = mode;\n\n\t\ti_size_write(inode, stat->st_size);\n\t\tinode->i_blocks = stat->st_blocks;\n\t} else {\n\t\tif (stat->st_result_mask & P9_STATS_ATIME) {\n\t\t\tinode->i_atime.tv_sec = stat->st_atime_sec;\n\t\t\tinode->i_atime.tv_nsec = stat->st_atime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_MTIME) {\n\t\t\tinode->i_mtime.tv_sec = stat->st_mtime_sec;\n\t\t\tinode->i_mtime.tv_nsec = stat->st_mtime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_CTIME) {\n\t\t\tinode->i_ctime.tv_sec = stat->st_ctime_sec;\n\t\t\tinode->i_ctime.tv_nsec = stat->st_ctime_nsec;\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_UID)\n\t\t\tinode->i_uid = stat->st_uid;\n\t\tif (stat->st_result_mask & P9_STATS_GID)\n\t\t\tinode->i_gid = stat->st_gid;\n\t\tif (stat->st_result_mask & P9_STATS_NLINK)\n\t\t\tset_nlink(inode, stat->st_nlink);\n\t\tif (stat->st_result_mask & P9_STATS_MODE) {\n\t\t\tinode->i_mode = stat->st_mode;\n\t\t\tif ((S_ISBLK(inode->i_mode)) ||\n\t\t\t\t\t\t(S_ISCHR(inode->i_mode)))\n\t\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t\t\t\t\t\tinode->i_rdev);\n\t\t}\n\t\tif (stat->st_result_mask & P9_STATS_RDEV)\n\t\t\tinode->i_rdev = new_decode_dev(stat->st_rdev);\n\t\tif (stat->st_result_mask & P9_STATS_SIZE)\n\t\t\ti_size_write(inode, stat->st_size);\n\t\tif (stat->st_result_mask & P9_STATS_BLOCKS)\n\t\t\tinode->i_blocks = stat->st_blocks;\n\t}\n\tif (stat->st_result_mask & P9_STATS_GEN)\n\t\tinode->i_generation = stat->st_gen;\n\n\t/* Currently we don't support P9_STATS_BTIME and P9_STATS_DATA_VERSION\n\t * because the inode structure does not have fields for them.\n\t */\n\tv9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_init_inode",
          "args": [
            "v9ses",
            "inode",
            "st->st_mode",
            "new_decode_dev(st->st_rdev)"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "271-361",
          "snippet": "int v9fs_init_inode(struct v9fs_session_info *v9ses,\n\t\t    struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tint err = 0;\n\n\tinode_init_owner(inode, NULL, mode);\n\tinode->i_blocks = 0;\n\tinode->i_rdev = rdev;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mapping->a_ops = &v9fs_addr_operations;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t} else if (v9fs_proto_dotu(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t} else {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"special files without extended mode\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations_dotl;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations_dotl;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations_dotl;\n\t\t} else {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations;\n\t\t}\n\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"extended modes used with legacy protocol\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations_dotl;\n\t\telse\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations;\n\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinc_nlink(inode);\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotl;\n\t\telse if (v9fs_proto_dotu(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotu;\n\t\telse\n\t\t\tinode->i_op = &v9fs_dir_inode_operations;\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_fop = &v9fs_dir_operations_dotl;\n\t\telse\n\t\t\tinode->i_fop = &v9fs_dir_operations;\n\n\t\tbreak;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_ERROR, \"BAD mode 0x%hx S_IFMT 0x%x\\n\",\n\t\t\t mode, mode & S_IFMT);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\nerror:\n\treturn err;\n\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations v9fs_dir_inode_operations;",
            "static const struct inode_operations v9fs_dir_inode_operations_dotu;",
            "static const struct inode_operations v9fs_file_inode_operations;",
            "static const struct inode_operations v9fs_symlink_inode_operations;",
            "static const struct inode_operations v9fs_dir_inode_operations_dotu = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.symlink = v9fs_vfs_symlink,\n\t.link = v9fs_vfs_link,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};",
            "static const struct inode_operations v9fs_dir_inode_operations = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};",
            "static const struct inode_operations v9fs_file_inode_operations = {\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};",
            "static const struct inode_operations v9fs_symlink_inode_operations = {\n\t.readlink = generic_readlink,\n\t.follow_link = v9fs_vfs_follow_link,\n\t.put_link = v9fs_vfs_put_link,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic const struct inode_operations v9fs_dir_inode_operations;\nstatic const struct inode_operations v9fs_dir_inode_operations_dotu;\nstatic const struct inode_operations v9fs_file_inode_operations;\nstatic const struct inode_operations v9fs_symlink_inode_operations;\nstatic const struct inode_operations v9fs_dir_inode_operations_dotu = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.symlink = v9fs_vfs_symlink,\n\t.link = v9fs_vfs_link,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\nstatic const struct inode_operations v9fs_dir_inode_operations = {\n\t.create = v9fs_vfs_create,\n\t.lookup = v9fs_vfs_lookup,\n\t.atomic_open = v9fs_vfs_atomic_open,\n\t.unlink = v9fs_vfs_unlink,\n\t.mkdir = v9fs_vfs_mkdir,\n\t.rmdir = v9fs_vfs_rmdir,\n\t.mknod = v9fs_vfs_mknod,\n\t.rename = v9fs_vfs_rename,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\nstatic const struct inode_operations v9fs_file_inode_operations = {\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\nstatic const struct inode_operations v9fs_symlink_inode_operations = {\n\t.readlink = generic_readlink,\n\t.follow_link = v9fs_vfs_follow_link,\n\t.put_link = v9fs_vfs_put_link,\n\t.getattr = v9fs_vfs_getattr,\n\t.setattr = v9fs_vfs_setattr,\n};\n\nint v9fs_init_inode(struct v9fs_session_info *v9ses,\n\t\t    struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tint err = 0;\n\n\tinode_init_owner(inode, NULL, mode);\n\tinode->i_blocks = 0;\n\tinode->i_rdev = rdev;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_mapping->a_ops = &v9fs_addr_operations;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFBLK:\n\tcase S_IFCHR:\n\tcase S_IFSOCK:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t} else if (v9fs_proto_dotu(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t} else {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"special files without extended mode\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tif (v9fs_proto_dotl(v9ses)) {\n\t\t\tinode->i_op = &v9fs_file_inode_operations_dotl;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations_dotl;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations_dotl;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations_dotl;\n\t\t} else {\n\t\t\tinode->i_op = &v9fs_file_inode_operations;\n\t\t\tif (v9ses->cache == CACHE_LOOSE ||\n\t\t\t    v9ses->cache == CACHE_FSCACHE)\n\t\t\t\tinode->i_fop =\n\t\t\t\t\t&v9fs_cached_file_operations;\n\t\t\telse if (v9ses->cache == CACHE_MMAP)\n\t\t\t\tinode->i_fop = &v9fs_mmap_file_operations;\n\t\t\telse\n\t\t\t\tinode->i_fop = &v9fs_file_operations;\n\t\t}\n\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tif (!v9fs_proto_dotu(v9ses) && !v9fs_proto_dotl(v9ses)) {\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"extended modes used with legacy protocol\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations_dotl;\n\t\telse\n\t\t\tinode->i_op = &v9fs_symlink_inode_operations;\n\n\t\tbreak;\n\tcase S_IFDIR:\n\t\tinc_nlink(inode);\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotl;\n\t\telse if (v9fs_proto_dotu(v9ses))\n\t\t\tinode->i_op = &v9fs_dir_inode_operations_dotu;\n\t\telse\n\t\t\tinode->i_op = &v9fs_dir_inode_operations;\n\n\t\tif (v9fs_proto_dotl(v9ses))\n\t\t\tinode->i_fop = &v9fs_dir_operations_dotl;\n\t\telse\n\t\t\tinode->i_fop = &v9fs_dir_operations;\n\n\t\tbreak;\n\tdefault:\n\t\tp9_debug(P9_DEBUG_ERROR, \"BAD mode 0x%hx S_IFMT 0x%x\\n\",\n\t\t\t mode, mode & S_IFMT);\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\nerror:\n\treturn err;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "st->st_rdev"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget5_locked",
          "args": [
            "sb",
            "i_ino",
            "test",
            "v9fs_set_inode_dotl",
            "st"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "iget5_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "991-1047",
          "snippet": "struct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget5_locked(struct super_block *sb, unsigned long hashval,\n\t\tint (*test)(struct inode *, void *),\n\t\tint (*set)(struct inode *, void *), void *data)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, hashval);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode(sb, head, test, data);\n\tspin_unlock(&inode_hash_lock);\n\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode(sb, head, test, data);\n\t\tif (!old) {\n\t\t\tif (set(inode, data))\n\t\t\t\tgoto set_failed;\n\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n\nset_failed:\n\tspin_unlock(&inode_hash_lock);\n\tdestroy_inode(inode);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_qid2ino",
          "args": [
            "qid"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_qid2ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode.c",
          "lines": "1213-1224",
          "snippet": "ino_t v9fs_qid2ino(struct p9_qid *qid)\n{\n\tu64 path = qid->path + 2;\n\tino_t i = 0;\n\n\tif (sizeof(ino_t) == sizeof(path))\n\t\tmemcpy(&i, &path, sizeof(ino_t));\n\telse\n\t\ti = (ino_t) (path ^ (path >> 32));\n\n\treturn i;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"cache.h\"",
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/idr.h>",
            "#include <linux/namei.h>",
            "#include <linux/inet.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nino_t v9fs_qid2ino(struct p9_qid *qid)\n{\n\tu64 path = qid->path + 2;\n\tino_t i = 0;\n\n\tif (sizeof(ino_t) == sizeof(path))\n\t\tmemcpy(&i, &path, sizeof(ino_t));\n\telse\n\t\ti = (ino_t) (path ^ (path >> 32));\n\n\treturn i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct inode *v9fs_qid_iget_dotl(struct super_block *sb,\n\t\t\t\t\tstruct p9_qid *qid,\n\t\t\t\t\tstruct p9_fid *fid,\n\t\t\t\t\tstruct p9_stat_dotl *st,\n\t\t\t\t\tint new)\n{\n\tint retval;\n\tunsigned long i_ino;\n\tstruct inode *inode;\n\tstruct v9fs_session_info *v9ses = sb->s_fs_info;\n\tint (*test)(struct inode *, void *);\n\n\tif (new)\n\t\ttest = v9fs_test_new_inode_dotl;\n\telse\n\t\ttest = v9fs_test_inode_dotl;\n\n\ti_ino = v9fs_qid2ino(qid);\n\tinode = iget5_locked(sb, i_ino, test, v9fs_set_inode_dotl, st);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\t/*\n\t * initialize the inode with the stat info\n\t * FIXME!! we may need support for stale inodes\n\t * later.\n\t */\n\tinode->i_ino = i_ino;\n\tretval = v9fs_init_inode(v9ses, inode,\n\t\t\t\t st->st_mode, new_decode_dev(st->st_rdev));\n\tif (retval)\n\t\tgoto error;\n\n\tv9fs_stat2inode_dotl(st, inode);\n\tv9fs_cache_inode_get_cookie(inode);\n\tretval = v9fs_get_acl(inode, fid);\n\tif (retval)\n\t\tgoto error;\n\n\tunlock_new_inode(inode);\n\treturn inode;\nerror:\n\tunlock_new_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(retval);\n\n}"
  },
  {
    "function_name": "v9fs_set_inode_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "99-107",
    "snippet": "static int v9fs_set_inode_dotl(struct inode *inode,  void *data)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_stat_dotl *st = (struct p9_stat_dotl *)data;\n\n\tmemcpy(&v9inode->qid, &st->qid, sizeof(st->qid));\n\tinode->i_generation = st->st_gen;\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&v9inode->qid",
            "&st->qid",
            "sizeof(st->qid)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_set_inode_dotl(struct inode *inode,  void *data)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_stat_dotl *st = (struct p9_stat_dotl *)data;\n\n\tmemcpy(&v9inode->qid, &st->qid, sizeof(st->qid));\n\tinode->i_generation = st->st_gen;\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_test_new_inode_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "94-97",
    "snippet": "static int v9fs_test_new_inode_dotl(struct inode *inode, void *data)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_test_new_inode_dotl(struct inode *inode, void *data)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_test_inode_dotl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "71-91",
    "snippet": "static int v9fs_test_inode_dotl(struct inode *inode, void *data)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_stat_dotl *st = (struct p9_stat_dotl *)data;\n\n\t/* don't match inode of different type */\n\tif ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))\n\t\treturn 0;\n\n\tif (inode->i_generation != st->st_gen)\n\t\treturn 0;\n\n\t/* compare qid details */\n\tif (memcmp(&v9inode->qid.version,\n\t\t   &st->qid.version, sizeof(v9inode->qid.version)))\n\t\treturn 0;\n\n\tif (v9inode->qid.type != st->qid.type)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&v9inode->qid.version",
            "&st->qid.version",
            "sizeof(v9inode->qid.version)"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "V9FS_I",
          "args": [
            "inode"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "V9FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "137-140",
          "snippet": "static inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline struct v9fs_inode *V9FS_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct v9fs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_test_inode_dotl(struct inode *inode, void *data)\n{\n\tstruct v9fs_inode *v9inode = V9FS_I(inode);\n\tstruct p9_stat_dotl *st = (struct p9_stat_dotl *)data;\n\n\t/* don't match inode of different type */\n\tif ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT))\n\t\treturn 0;\n\n\tif (inode->i_generation != st->st_gen)\n\t\treturn 0;\n\n\t/* compare qid details */\n\tif (memcmp(&v9inode->qid.version,\n\t\t   &st->qid.version, sizeof(v9inode->qid.version)))\n\t\treturn 0;\n\n\tif (v9inode->qid.type != st->qid.type)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "v9fs_get_fsgid_for_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/vfs_inode_dotl.c",
    "lines": "60-69",
    "snippet": "static kgid_t v9fs_get_fsgid_for_create(struct inode *dir_inode)\n{\n\tBUG_ON(dir_inode == NULL);\n\n\tif (dir_inode->i_mode & S_ISGID) {\n\t\t/* set_gid bit is set.*/\n\t\treturn dir_inode->i_gid;\n\t}\n\treturn current_fsgid();\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"cache.h\"",
      "#include \"fid.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/posix_acl.h>",
      "#include <linux/xattr.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/idr.h>",
      "#include <linux/namei.h>",
      "#include <linux/inet.h>",
      "#include <linux/string.h>",
      "#include <linux/stat.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dir_inode == NULL"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"cache.h\"\n#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/idr.h>\n#include <linux/namei.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic kgid_t v9fs_get_fsgid_for_create(struct inode *dir_inode)\n{\n\tBUG_ON(dir_inode == NULL);\n\n\tif (dir_inode->i_mode & S_ISGID) {\n\t\t/* set_gid bit is set.*/\n\t\treturn dir_inode->i_gid;\n\t}\n\treturn current_fsgid();\n}"
  }
]