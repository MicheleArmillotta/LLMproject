[
  {
    "function_name": "coda_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/file.c",
    "lines": "204-230",
    "snippet": "int coda_fsync(struct file *coda_file, loff_t start, loff_t end, int datasync)\n{\n\tstruct file *host_file;\n\tstruct inode *coda_inode = file_inode(coda_file);\n\tstruct coda_file_info *cfi;\n\tint err;\n\n\tif (!(S_ISREG(coda_inode->i_mode) || S_ISDIR(coda_inode->i_mode) ||\n\t      S_ISLNK(coda_inode->i_mode)))\n\t\treturn -EINVAL;\n\n\terr = filemap_write_and_wait_range(coda_inode->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&coda_inode->i_mutex);\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\terr = vfs_fsync(host_file, datasync);\n\tif (!err && !datasync)\n\t\terr = venus_fsync(coda_inode->i_sb, coda_i2f(coda_inode));\n\tmutex_unlock(&coda_inode->i_mutex);\n\n\treturn err;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&coda_inode->i_mutex"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "venus_fsync",
          "args": [
            "coda_inode->i_sb",
            "coda_i2f(coda_inode)"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "venus_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "439-454",
          "snippet": "int venus_fsync(struct super_block *sb, struct CodaFid *fid)\n{\n        union inputArgs *inp;\n        union outputArgs *outp; \n\tint insize, outsize, error;\n\t\n\tinsize=SIZE(fsync);\n\tUPARG(CODA_FSYNC);\n\n\tinp->coda_fsync.VFid = *fid;\n\terror = coda_upcall(coda_vcp(sb), sizeof(union inputArgs),\n\t\t\t    &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_fsync(struct super_block *sb, struct CodaFid *fid)\n{\n        union inputArgs *inp;\n        union outputArgs *outp; \n\tint insize, outsize, error;\n\t\n\tinsize=SIZE(fsync);\n\tUPARG(CODA_FSYNC);\n\n\tinp->coda_fsync.VFid = *fid;\n\terror = coda_upcall(coda_vcp(sb), sizeof(union inputArgs),\n\t\t\t    &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_i2f",
          "args": [
            "coda_inode"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "85-88",
          "snippet": "static __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "host_file",
            "datasync"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "202-205",
          "snippet": "int vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cfi || cfi->cfi_magic != CODA_MAGIC"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_FTOC",
          "args": [
            "coda_file"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&coda_inode->i_mutex"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "coda_inode->i_mapping",
            "start",
            "end"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "coda_inode->i_mode"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "coda_inode->i_mode"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "coda_inode->i_mode"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "coda_file"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint coda_fsync(struct file *coda_file, loff_t start, loff_t end, int datasync)\n{\n\tstruct file *host_file;\n\tstruct inode *coda_inode = file_inode(coda_file);\n\tstruct coda_file_info *cfi;\n\tint err;\n\n\tif (!(S_ISREG(coda_inode->i_mode) || S_ISDIR(coda_inode->i_mode) ||\n\t      S_ISLNK(coda_inode->i_mode)))\n\t\treturn -EINVAL;\n\n\terr = filemap_write_and_wait_range(coda_inode->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&coda_inode->i_mutex);\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\terr = vfs_fsync(host_file, datasync);\n\tif (!err && !datasync)\n\t\terr = venus_fsync(coda_inode->i_sb, coda_i2f(coda_inode));\n\tmutex_unlock(&coda_inode->i_mutex);\n\n\treturn err;\n}"
  },
  {
    "function_name": "coda_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/file.c",
    "lines": "168-202",
    "snippet": "int coda_release(struct inode *coda_inode, struct file *coda_file)\n{\n\tunsigned short flags = (coda_file->f_flags) & (~O_EXCL);\n\tunsigned short coda_flags = coda_flags_to_cflags(flags);\n\tstruct coda_file_info *cfi;\n\tstruct coda_inode_info *cii;\n\tstruct inode *host_inode;\n\tint err;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\n\terr = venus_close(coda_inode->i_sb, coda_i2f(coda_inode),\n\t\t\t  coda_flags, coda_file->f_cred->fsuid);\n\n\thost_inode = file_inode(cfi->cfi_container);\n\tcii = ITOC(coda_inode);\n\n\t/* did we mmap this file? */\n\tspin_lock(&cii->c_lock);\n\tif (coda_inode->i_mapping == &host_inode->i_data) {\n\t\tcii->c_mapcount -= cfi->cfi_mapcount;\n\t\tif (!cii->c_mapcount)\n\t\t\tcoda_inode->i_mapping = &coda_inode->i_data;\n\t}\n\tspin_unlock(&cii->c_lock);\n\n\tfput(cfi->cfi_container);\n\tkfree(coda_file->private_data);\n\tcoda_file->private_data = NULL;\n\n\t/* VFS fput ignores the return value from file_operations->release, so\n\t * there is no use returning an error here */\n\treturn 0;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "coda_file->private_data"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "cfi->cfi_container"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cii->c_lock"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cii->c_lock"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITOC",
          "args": [
            "coda_inode"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "ITOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "80-83",
          "snippet": "static inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "cfi->cfi_container"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "venus_close",
          "args": [
            "coda_inode->i_sb",
            "coda_i2f(coda_inode)",
            "coda_flags",
            "coda_file->f_cred->fsuid"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "venus_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "159-177",
          "snippet": "int venus_close(struct super_block *sb, struct CodaFid *fid, int flags,\n\t\tkuid_t uid)\n{\n\tunion inputArgs *inp;\n\tunion outputArgs *outp;\n\tint insize, outsize, error;\n\t\n\tinsize = SIZE(release);\n\tUPARG(CODA_CLOSE);\n\t\n\tinp->ih.uid = from_kuid(&init_user_ns, uid);\n        inp->coda_close.VFid = *fid;\n        inp->coda_close.flags = flags;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n        return error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_close(struct super_block *sb, struct CodaFid *fid, int flags,\n\t\tkuid_t uid)\n{\n\tunion inputArgs *inp;\n\tunion outputArgs *outp;\n\tint insize, outsize, error;\n\t\n\tinsize = SIZE(release);\n\tUPARG(CODA_CLOSE);\n\t\n\tinp->ih.uid = from_kuid(&init_user_ns, uid);\n        inp->coda_close.VFid = *fid;\n        inp->coda_close.flags = flags;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\n\tCODA_FREE(inp, insize);\n        return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_i2f",
          "args": [
            "coda_inode"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "85-88",
          "snippet": "static __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cfi || cfi->cfi_magic != CODA_MAGIC"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_FTOC",
          "args": [
            "coda_file"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "coda_flags_to_cflags",
          "args": [
            "flags"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "coda_flags_to_cflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
          "lines": "43-66",
          "snippet": "unsigned short coda_flags_to_cflags(unsigned short flags)\n{\n\tunsigned short coda_flags = 0;\n\t\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tcoda_flags |= C_O_READ;\n\n\tif ((flags & O_ACCMODE) == O_RDWR)\n\t\tcoda_flags |= C_O_READ | C_O_WRITE;\n\n\tif ((flags & O_ACCMODE) == O_WRONLY)\n\t\tcoda_flags |= C_O_WRITE;\n\n\tif (flags & O_TRUNC)\n\t\tcoda_flags |= C_O_TRUNC;\n\n\tif (flags & O_CREAT)\n\t\tcoda_flags |= C_O_CREAT;\n\n\tif (flags & O_EXCL)\n\t\tcoda_flags |= C_O_EXCL;\n\n\treturn coda_flags;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nunsigned short coda_flags_to_cflags(unsigned short flags)\n{\n\tunsigned short coda_flags = 0;\n\t\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tcoda_flags |= C_O_READ;\n\n\tif ((flags & O_ACCMODE) == O_RDWR)\n\t\tcoda_flags |= C_O_READ | C_O_WRITE;\n\n\tif ((flags & O_ACCMODE) == O_WRONLY)\n\t\tcoda_flags |= C_O_WRITE;\n\n\tif (flags & O_TRUNC)\n\t\tcoda_flags |= C_O_TRUNC;\n\n\tif (flags & O_CREAT)\n\t\tcoda_flags |= C_O_CREAT;\n\n\tif (flags & O_EXCL)\n\t\tcoda_flags |= C_O_EXCL;\n\n\treturn coda_flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint coda_release(struct inode *coda_inode, struct file *coda_file)\n{\n\tunsigned short flags = (coda_file->f_flags) & (~O_EXCL);\n\tunsigned short coda_flags = coda_flags_to_cflags(flags);\n\tstruct coda_file_info *cfi;\n\tstruct coda_inode_info *cii;\n\tstruct inode *host_inode;\n\tint err;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\n\terr = venus_close(coda_inode->i_sb, coda_i2f(coda_inode),\n\t\t\t  coda_flags, coda_file->f_cred->fsuid);\n\n\thost_inode = file_inode(cfi->cfi_container);\n\tcii = ITOC(coda_inode);\n\n\t/* did we mmap this file? */\n\tspin_lock(&cii->c_lock);\n\tif (coda_inode->i_mapping == &host_inode->i_data) {\n\t\tcii->c_mapcount -= cfi->cfi_mapcount;\n\t\tif (!cii->c_mapcount)\n\t\t\tcoda_inode->i_mapping = &coda_inode->i_data;\n\t}\n\tspin_unlock(&cii->c_lock);\n\n\tfput(cfi->cfi_container);\n\tkfree(coda_file->private_data);\n\tcoda_file->private_data = NULL;\n\n\t/* VFS fput ignores the return value from file_operations->release, so\n\t * there is no use returning an error here */\n\treturn 0;\n}"
  },
  {
    "function_name": "coda_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/file.c",
    "lines": "135-166",
    "snippet": "int coda_open(struct inode *coda_inode, struct file *coda_file)\n{\n\tstruct file *host_file = NULL;\n\tint error;\n\tunsigned short flags = coda_file->f_flags & (~O_EXCL);\n\tunsigned short coda_flags = coda_flags_to_cflags(flags);\n\tstruct coda_file_info *cfi;\n\n\tcfi = kmalloc(sizeof(struct coda_file_info), GFP_KERNEL);\n\tif (!cfi)\n\t\treturn -ENOMEM;\n\n\terror = venus_open(coda_inode->i_sb, coda_i2f(coda_inode), coda_flags,\n\t\t\t   &host_file);\n\tif (!host_file)\n\t\terror = -EIO;\n\n\tif (error) {\n\t\tkfree(cfi);\n\t\treturn error;\n\t}\n\n\thost_file->f_flags |= coda_file->f_flags & (O_APPEND | O_SYNC);\n\n\tcfi->cfi_magic = CODA_MAGIC;\n\tcfi->cfi_mapcount = 0;\n\tcfi->cfi_container = host_file;\n\n\tBUG_ON(coda_file->private_data != NULL);\n\tcoda_file->private_data = cfi;\n\treturn 0;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "coda_file->private_data != NULL"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cfi"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "venus_open",
          "args": [
            "coda_inode->i_sb",
            "coda_i2f(coda_inode)",
            "coda_flags",
            "&host_file"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "venus_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/upcall.c",
          "lines": "179-198",
          "snippet": "int venus_open(struct super_block *sb, struct CodaFid *fid,\n\t\t  int flags, struct file **fh)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n       \n\tinsize = SIZE(open_by_fd);\n\tUPARG(CODA_OPEN_BY_FD);\n\n\tinp->coda_open_by_fd.VFid = *fid;\n\tinp->coda_open_by_fd.flags = flags;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*fh = outp->coda_open_by_fd.fh;\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}",
          "includes": [
            "#include \"coda_int.h\"",
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/vfs.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/vfs.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/signal.h>\n\nint venus_open(struct super_block *sb, struct CodaFid *fid,\n\t\t  int flags, struct file **fh)\n{\n        union inputArgs *inp;\n        union outputArgs *outp;\n        int insize, outsize, error;\n       \n\tinsize = SIZE(open_by_fd);\n\tUPARG(CODA_OPEN_BY_FD);\n\n\tinp->coda_open_by_fd.VFid = *fid;\n\tinp->coda_open_by_fd.flags = flags;\n\n\terror = coda_upcall(coda_vcp(sb), insize, &outsize, inp);\n\tif (!error)\n\t\t*fh = outp->coda_open_by_fd.fh;\n\n\tCODA_FREE(inp, insize);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_i2f",
          "args": [
            "coda_inode"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "coda_i2f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "85-88",
          "snippet": "static __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic __inline__ struct CodaFid *coda_i2f(struct inode *inode)\n{\n\treturn &(ITOC(inode)->c_fid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct coda_file_info)",
            "GFP_KERNEL"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "coda_flags_to_cflags",
          "args": [
            "flags"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "coda_flags_to_cflags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.c",
          "lines": "43-66",
          "snippet": "unsigned short coda_flags_to_cflags(unsigned short flags)\n{\n\tunsigned short coda_flags = 0;\n\t\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tcoda_flags |= C_O_READ;\n\n\tif ((flags & O_ACCMODE) == O_RDWR)\n\t\tcoda_flags |= C_O_READ | C_O_WRITE;\n\n\tif ((flags & O_ACCMODE) == O_WRONLY)\n\t\tcoda_flags |= C_O_WRITE;\n\n\tif (flags & O_TRUNC)\n\t\tcoda_flags |= C_O_TRUNC;\n\n\tif (flags & O_CREAT)\n\t\tcoda_flags |= C_O_CREAT;\n\n\tif (flags & O_EXCL)\n\t\tcoda_flags |= C_O_EXCL;\n\n\treturn coda_flags;\n}",
          "includes": [
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nunsigned short coda_flags_to_cflags(unsigned short flags)\n{\n\tunsigned short coda_flags = 0;\n\t\n\tif ((flags & O_ACCMODE) == O_RDONLY)\n\t\tcoda_flags |= C_O_READ;\n\n\tif ((flags & O_ACCMODE) == O_RDWR)\n\t\tcoda_flags |= C_O_READ | C_O_WRITE;\n\n\tif ((flags & O_ACCMODE) == O_WRONLY)\n\t\tcoda_flags |= C_O_WRITE;\n\n\tif (flags & O_TRUNC)\n\t\tcoda_flags |= C_O_TRUNC;\n\n\tif (flags & O_CREAT)\n\t\tcoda_flags |= C_O_CREAT;\n\n\tif (flags & O_EXCL)\n\t\tcoda_flags |= C_O_EXCL;\n\n\treturn coda_flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint coda_open(struct inode *coda_inode, struct file *coda_file)\n{\n\tstruct file *host_file = NULL;\n\tint error;\n\tunsigned short flags = coda_file->f_flags & (~O_EXCL);\n\tunsigned short coda_flags = coda_flags_to_cflags(flags);\n\tstruct coda_file_info *cfi;\n\n\tcfi = kmalloc(sizeof(struct coda_file_info), GFP_KERNEL);\n\tif (!cfi)\n\t\treturn -ENOMEM;\n\n\terror = venus_open(coda_inode->i_sb, coda_i2f(coda_inode), coda_flags,\n\t\t\t   &host_file);\n\tif (!host_file)\n\t\terror = -EIO;\n\n\tif (error) {\n\t\tkfree(cfi);\n\t\treturn error;\n\t}\n\n\thost_file->f_flags |= coda_file->f_flags & (O_APPEND | O_SYNC);\n\n\tcfi->cfi_magic = CODA_MAGIC;\n\tcfi->cfi_mapcount = 0;\n\tcfi->cfi_container = host_file;\n\n\tBUG_ON(coda_file->private_data != NULL);\n\tcoda_file->private_data = cfi;\n\treturn 0;\n}"
  },
  {
    "function_name": "coda_file_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/file.c",
    "lines": "96-133",
    "snippet": "static int\ncoda_file_mmap(struct file *coda_file, struct vm_area_struct *vma)\n{\n\tstruct coda_file_info *cfi;\n\tstruct coda_inode_info *cii;\n\tstruct file *host_file;\n\tstruct inode *coda_inode, *host_inode;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tif (!host_file->f_op->mmap)\n\t\treturn -ENODEV;\n\n\tcoda_inode = file_inode(coda_file);\n\thost_inode = file_inode(host_file);\n\n\tcii = ITOC(coda_inode);\n\tspin_lock(&cii->c_lock);\n\tcoda_file->f_mapping = host_file->f_mapping;\n\tif (coda_inode->i_mapping == &coda_inode->i_data)\n\t\tcoda_inode->i_mapping = host_inode->i_mapping;\n\n\t/* only allow additional mmaps as long as userspace isn't changing\n\t * the container file on us! */\n\telse if (coda_inode->i_mapping != host_inode->i_mapping) {\n\t\tspin_unlock(&cii->c_lock);\n\t\treturn -EBUSY;\n\t}\n\n\t/* keep track of how often the coda_inode/host_file has been mmapped */\n\tcii->c_mapcount++;\n\tcfi->cfi_mapcount++;\n\tspin_unlock(&cii->c_lock);\n\n\treturn host_file->f_op->mmap(host_file, vma);\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "host_file->f_op->mmap",
          "args": [
            "host_file",
            "vma"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cii->c_lock"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cii->c_lock"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ITOC",
          "args": [
            "coda_inode"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ITOC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/coda_linux.h",
          "lines": "80-83",
          "snippet": "static inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"coda_fs_i.h\"",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/wait.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/param.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_fs_i.h\"\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/param.h>\n#include <linux/kernel.h>\n\nstatic inline struct coda_inode_info *ITOC(struct inode *inode)\n{\n\treturn list_entry(inode, struct coda_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "host_file"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cfi || cfi->cfi_magic != CODA_MAGIC"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_FTOC",
          "args": [
            "coda_file"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic int\ncoda_file_mmap(struct file *coda_file, struct vm_area_struct *vma)\n{\n\tstruct coda_file_info *cfi;\n\tstruct coda_inode_info *cii;\n\tstruct file *host_file;\n\tstruct inode *coda_inode, *host_inode;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tif (!host_file->f_op->mmap)\n\t\treturn -ENODEV;\n\n\tcoda_inode = file_inode(coda_file);\n\thost_inode = file_inode(host_file);\n\n\tcii = ITOC(coda_inode);\n\tspin_lock(&cii->c_lock);\n\tcoda_file->f_mapping = host_file->f_mapping;\n\tif (coda_inode->i_mapping == &coda_inode->i_data)\n\t\tcoda_inode->i_mapping = host_inode->i_mapping;\n\n\t/* only allow additional mmaps as long as userspace isn't changing\n\t * the container file on us! */\n\telse if (coda_inode->i_mapping != host_inode->i_mapping) {\n\t\tspin_unlock(&cii->c_lock);\n\t\treturn -EBUSY;\n\t}\n\n\t/* keep track of how often the coda_inode/host_file has been mmapped */\n\tcii->c_mapcount++;\n\tcfi->cfi_mapcount++;\n\tspin_unlock(&cii->c_lock);\n\n\treturn host_file->f_op->mmap(host_file, vma);\n}"
  },
  {
    "function_name": "coda_file_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/file.c",
    "lines": "66-94",
    "snippet": "static ssize_t\ncoda_file_write(struct file *coda_file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *host_inode, *coda_inode = file_inode(coda_file);\n\tstruct coda_file_info *cfi;\n\tstruct file *host_file;\n\tssize_t ret;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tif (!host_file->f_op->write)\n\t\treturn -EINVAL;\n\n\thost_inode = file_inode(host_file);\n\tfile_start_write(host_file);\n\tmutex_lock(&coda_inode->i_mutex);\n\n\tret = host_file->f_op->write(host_file, buf, count, ppos);\n\n\tcoda_inode->i_size = host_inode->i_size;\n\tcoda_inode->i_blocks = (coda_inode->i_size + 511) >> 9;\n\tcoda_inode->i_mtime = coda_inode->i_ctime = CURRENT_TIME_SEC;\n\tmutex_unlock(&coda_inode->i_mutex);\n\tfile_end_write(host_file);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "host_file"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&coda_inode->i_mutex"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "host_file->f_op->write",
          "args": [
            "host_file",
            "buf",
            "count",
            "ppos"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&coda_inode->i_mutex"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "host_file"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "host_file"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cfi || cfi->cfi_magic != CODA_MAGIC"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_FTOC",
          "args": [
            "coda_file"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic ssize_t\ncoda_file_write(struct file *coda_file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct inode *host_inode, *coda_inode = file_inode(coda_file);\n\tstruct coda_file_info *cfi;\n\tstruct file *host_file;\n\tssize_t ret;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tif (!host_file->f_op->write)\n\t\treturn -EINVAL;\n\n\thost_inode = file_inode(host_file);\n\tfile_start_write(host_file);\n\tmutex_lock(&coda_inode->i_mutex);\n\n\tret = host_file->f_op->write(host_file, buf, count, ppos);\n\n\tcoda_inode->i_size = host_inode->i_size;\n\tcoda_inode->i_blocks = (coda_inode->i_size + 511) >> 9;\n\tcoda_inode->i_mtime = coda_inode->i_ctime = CURRENT_TIME_SEC;\n\tmutex_unlock(&coda_inode->i_mutex);\n\tfile_end_write(host_file);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "coda_file_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/file.c",
    "lines": "45-64",
    "snippet": "static ssize_t\ncoda_file_splice_read(struct file *coda_file, loff_t *ppos,\n\t\t      struct pipe_inode_info *pipe, size_t count,\n\t\t      unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tstruct coda_file_info *cfi;\n\tstruct file *host_file;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tsplice_read = host_file->f_op->splice_read;\n\tif (!splice_read)\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(host_file, ppos, pipe, count, flags);\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_read",
          "args": [
            "host_file",
            "ppos",
            "pipe",
            "count",
            "flags"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "coda_file_splice_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/file.c",
          "lines": "45-64",
          "snippet": "static ssize_t\ncoda_file_splice_read(struct file *coda_file, loff_t *ppos,\n\t\t      struct pipe_inode_info *pipe, size_t count,\n\t\t      unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tstruct coda_file_info *cfi;\n\tstruct file *host_file;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tsplice_read = host_file->f_op->splice_read;\n\tif (!splice_read)\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(host_file, ppos, pipe, count, flags);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cfi || cfi->cfi_magic != CODA_MAGIC"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_FTOC",
          "args": [
            "coda_file"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic ssize_t\ncoda_file_splice_read(struct file *coda_file, loff_t *ppos,\n\t\t      struct pipe_inode_info *pipe, size_t count,\n\t\t      unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tstruct coda_file_info *cfi;\n\tstruct file *host_file;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tsplice_read = host_file->f_op->splice_read;\n\tif (!splice_read)\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(host_file, ppos, pipe, count, flags);\n}"
  },
  {
    "function_name": "coda_file_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/file.c",
    "lines": "29-43",
    "snippet": "static ssize_t\ncoda_file_read(struct file *coda_file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct coda_file_info *cfi;\n\tstruct file *host_file;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tif (!host_file->f_op->read)\n\t\treturn -EINVAL;\n\n\treturn host_file->f_op->read(host_file, buf, count, ppos);\n}",
    "includes": [
      "#include \"coda_int.h\"",
      "#include \"coda_linux.h\"",
      "#include <linux/coda_psdev.h>",
      "#include <linux/coda.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>",
      "#include <linux/string.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/errno.h>",
      "#include <linux/cred.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/time.h>",
      "#include <linux/kernel.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "host_file->f_op->read",
          "args": [
            "host_file",
            "buf",
            "count",
            "ppos"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cfi || cfi->cfi_magic != CODA_MAGIC"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CODA_FTOC",
          "args": [
            "coda_file"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"coda_int.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic ssize_t\ncoda_file_read(struct file *coda_file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct coda_file_info *cfi;\n\tstruct file *host_file;\n\n\tcfi = CODA_FTOC(coda_file);\n\tBUG_ON(!cfi || cfi->cfi_magic != CODA_MAGIC);\n\thost_file = cfi->cfi_container;\n\n\tif (!host_file->f_op->read)\n\t\treturn -EINVAL;\n\n\treturn host_file->f_op->read(host_file, buf, count, ppos);\n}"
  }
]