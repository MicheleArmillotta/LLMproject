[
  {
    "function_name": "squashfs_read_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/inode.c",
    "lines": "112-422",
    "snippet": "int squashfs_read_inode(struct inode *inode, long long ino)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 block = SQUASHFS_INODE_BLK(ino) + msblk->inode_table;\n\tint err, type, offset = SQUASHFS_INODE_OFFSET(ino);\n\tunion squashfs_inode squashfs_ino;\n\tstruct squashfs_base_inode *sqshb_ino = &squashfs_ino.base;\n\tint xattr_id = SQUASHFS_INVALID_XATTR;\n\n\tTRACE(\"Entered squashfs_read_inode\\n\");\n\n\t/*\n\t * Read inode base common to all inode types.\n\t */\n\terr = squashfs_read_metadata(sb, sqshb_ino, &block,\n\t\t\t\t&offset, sizeof(*sqshb_ino));\n\tif (err < 0)\n\t\tgoto failed_read;\n\n\terr = squashfs_new_inode(sb, inode, sqshb_ino);\n\tif (err)\n\t\tgoto failed_read;\n\n\tblock = SQUASHFS_INODE_BLK(ino) + msblk->inode_table;\n\toffset = SQUASHFS_INODE_OFFSET(ino);\n\n\ttype = le16_to_cpu(sqshb_ino->inode_type);\n\tswitch (type) {\n\tcase SQUASHFS_REG_TYPE: {\n\t\tunsigned int frag_offset, frag;\n\t\tint frag_size;\n\t\tu64 frag_blk;\n\t\tstruct squashfs_reg_inode *sqsh_ino = &squashfs_ino.reg;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tfrag = le32_to_cpu(sqsh_ino->fragment);\n\t\tif (frag != SQUASHFS_INVALID_FRAG) {\n\t\t\tfrag_offset = le32_to_cpu(sqsh_ino->offset);\n\t\t\tfrag_size = squashfs_frag_lookup(sb, frag, &frag_blk);\n\t\t\tif (frag_size < 0) {\n\t\t\t\terr = frag_size;\n\t\t\t\tgoto failed_read;\n\t\t\t}\n\t\t} else {\n\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n\t\t\tfrag_size = 0;\n\t\t\tfrag_offset = 0;\n\t\t}\n\n\t\tset_nlink(inode, 1);\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_blocks = ((inode->i_size - 1) >> 9) + 1;\n\t\tsquashfs_i(inode)->fragment_block = frag_blk;\n\t\tsquashfs_i(inode)->fragment_size = frag_size;\n\t\tsquashfs_i(inode)->fragment_offset = frag_offset;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->block_list_start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\t\tinode->i_data.a_ops = &squashfs_aops;\n\n\t\tTRACE(\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\", SQUASHFS_INODE_BLK(ino),\n\t\t\toffset, squashfs_i(inode)->start, block, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LREG_TYPE: {\n\t\tunsigned int frag_offset, frag;\n\t\tint frag_size;\n\t\tu64 frag_blk;\n\t\tstruct squashfs_lreg_inode *sqsh_ino = &squashfs_ino.lreg;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tfrag = le32_to_cpu(sqsh_ino->fragment);\n\t\tif (frag != SQUASHFS_INVALID_FRAG) {\n\t\t\tfrag_offset = le32_to_cpu(sqsh_ino->offset);\n\t\t\tfrag_size = squashfs_frag_lookup(sb, frag, &frag_blk);\n\t\t\tif (frag_size < 0) {\n\t\t\t\terr = frag_size;\n\t\t\t\tgoto failed_read;\n\t\t\t}\n\t\t} else {\n\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n\t\t\tfrag_size = 0;\n\t\t\tfrag_offset = 0;\n\t\t}\n\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le64_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_blocks = (inode->i_size -\n\t\t\t\tle64_to_cpu(sqsh_ino->sparse) + 511) >> 9;\n\n\t\tsquashfs_i(inode)->fragment_block = frag_blk;\n\t\tsquashfs_i(inode)->fragment_size = frag_size;\n\t\tsquashfs_i(inode)->fragment_offset = frag_offset;\n\t\tsquashfs_i(inode)->start = le64_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->block_list_start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\t\tinode->i_data.a_ops = &squashfs_aops;\n\n\t\tTRACE(\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\", SQUASHFS_INODE_BLK(ino),\n\t\t\toffset, squashfs_i(inode)->start, block, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_DIR_TYPE: {\n\t\tstruct squashfs_dir_inode *sqsh_ino = &squashfs_ino.dir;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le16_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_dir_inode_ops;\n\t\tinode->i_fop = &squashfs_dir_ops;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->offset = le16_to_cpu(sqsh_ino->offset);\n\t\tsquashfs_i(inode)->dir_idx_cnt = 0;\n\t\tsquashfs_i(inode)->parent = le32_to_cpu(sqsh_ino->parent_inode);\n\n\t\tTRACE(\"Directory inode %x:%x, start_block %llx, offset %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tle16_to_cpu(sqsh_ino->offset));\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LDIR_TYPE: {\n\t\tstruct squashfs_ldir_inode *sqsh_ino = &squashfs_ino.ldir;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_dir_inode_ops;\n\t\tinode->i_fop = &squashfs_dir_ops;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->offset = le16_to_cpu(sqsh_ino->offset);\n\t\tsquashfs_i(inode)->dir_idx_start = block;\n\t\tsquashfs_i(inode)->dir_idx_offset = offset;\n\t\tsquashfs_i(inode)->dir_idx_cnt = le16_to_cpu(sqsh_ino->i_count);\n\t\tsquashfs_i(inode)->parent = le32_to_cpu(sqsh_ino->parent_inode);\n\n\t\tTRACE(\"Long directory inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\", SQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tle16_to_cpu(sqsh_ino->offset));\n\t\tbreak;\n\t}\n\tcase SQUASHFS_SYMLINK_TYPE:\n\tcase SQUASHFS_LSYMLINK_TYPE: {\n\t\tstruct squashfs_symlink_inode *sqsh_ino = &squashfs_ino.symlink;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->symlink_size);\n\t\tinode->i_op = &squashfs_symlink_inode_ops;\n\t\tinode->i_data.a_ops = &squashfs_symlink_aops;\n\t\tinode->i_mode |= S_IFLNK;\n\t\tsquashfs_i(inode)->start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\n\t\tif (type == SQUASHFS_LSYMLINK_TYPE) {\n\t\t\t__le32 xattr;\n\n\t\t\terr = squashfs_read_metadata(sb, NULL, &block,\n\t\t\t\t\t\t&offset, inode->i_size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\t\t\terr = squashfs_read_metadata(sb, &xattr, &block,\n\t\t\t\t\t\t&offset, sizeof(xattr));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\t\t\txattr_id = le32_to_cpu(xattr);\n\t\t}\n\n\t\tTRACE(\"Symbolic link inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\", SQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tblock, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_BLKDEV_TYPE:\n\tcase SQUASHFS_CHRDEV_TYPE: {\n\t\tstruct squashfs_dev_inode *sqsh_ino = &squashfs_ino.dev;\n\t\tunsigned int rdev;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_CHRDEV_TYPE)\n\t\t\tinode->i_mode |= S_IFCHR;\n\t\telse\n\t\t\tinode->i_mode |= S_IFBLK;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\trdev = le32_to_cpu(sqsh_ino->rdev);\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\n\t\tTRACE(\"Device inode %x:%x, rdev %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset, rdev);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LBLKDEV_TYPE:\n\tcase SQUASHFS_LCHRDEV_TYPE: {\n\t\tstruct squashfs_ldev_inode *sqsh_ino = &squashfs_ino.ldev;\n\t\tunsigned int rdev;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_LCHRDEV_TYPE)\n\t\t\tinode->i_mode |= S_IFCHR;\n\t\telse\n\t\t\tinode->i_mode |= S_IFBLK;\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\trdev = le32_to_cpu(sqsh_ino->rdev);\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\n\t\tTRACE(\"Device inode %x:%x, rdev %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset, rdev);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_FIFO_TYPE:\n\tcase SQUASHFS_SOCKET_TYPE: {\n\t\tstruct squashfs_ipc_inode *sqsh_ino = &squashfs_ino.ipc;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_FIFO_TYPE)\n\t\t\tinode->i_mode |= S_IFIFO;\n\t\telse\n\t\t\tinode->i_mode |= S_IFSOCK;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LFIFO_TYPE:\n\tcase SQUASHFS_LSOCKET_TYPE: {\n\t\tstruct squashfs_lipc_inode *sqsh_ino = &squashfs_ino.lipc;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_LFIFO_TYPE)\n\t\t\tinode->i_mode |= S_IFIFO;\n\t\telse\n\t\t\tinode->i_mode |= S_IFSOCK;\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tERROR(\"Unknown inode type %d in squashfs_iget!\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (xattr_id != SQUASHFS_INVALID_XATTR && msblk->xattr_id_table) {\n\t\terr = squashfs_xattr_lookup(sb, xattr_id,\n\t\t\t\t\t&squashfs_i(inode)->xattr_count,\n\t\t\t\t\t&squashfs_i(inode)->xattr_size,\n\t\t\t\t\t&squashfs_i(inode)->xattr);\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\t\tinode->i_blocks += ((squashfs_i(inode)->xattr_size - 1) >> 9)\n\t\t\t\t+ 1;\n\t} else\n\t\tsquashfs_i(inode)->xattr_count = 0;\n\n\treturn 0;\n\nfailed_read:\n\tERROR(\"Unable to read inode 0x%llx\\n\", ino);\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations squashfs_inode_ops = {\n\t.getxattr = generic_getxattr,\n\t.listxattr = squashfs_listxattr\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unable to read inode 0x%llx\\n\"",
            "ino"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_i",
          "args": [
            "inode"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/squashfs_fs_i.h",
          "lines": "50-53",
          "snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct squashfs_inode_info *squashfs_i(struct inode *inode)\n{\n\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_xattr_lookup",
          "args": [
            "sb",
            "xattr_id",
            "&squashfs_i(inode)->xattr_count",
            "&squashfs_i(inode)->xattr_size",
            "&squashfs_i(inode)->xattr"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_xattr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/xattr_id.c",
          "lines": "41-60",
          "snippet": "int squashfs_xattr_lookup(struct super_block *sb, unsigned int index,\n\t\tint *count, unsigned int *size, unsigned long long *xattr)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint block = SQUASHFS_XATTR_BLOCK(index);\n\tint offset = SQUASHFS_XATTR_BLOCK_OFFSET(index);\n\tu64 start_block = le64_to_cpu(msblk->xattr_id_table[block]);\n\tstruct squashfs_xattr_id id;\n\tint err;\n\n\terr = squashfs_read_metadata(sb, &id, &start_block, &offset,\n\t\t\t\t\t\t\tsizeof(id));\n\tif (err < 0)\n\t\treturn err;\n\n\t*xattr = le64_to_cpu(id.xattr);\n\t*size = le32_to_cpu(id.size);\n\t*count = le32_to_cpu(id.count);\n\treturn 0;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_xattr_lookup(struct super_block *sb, unsigned int index,\n\t\tint *count, unsigned int *size, unsigned long long *xattr)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint block = SQUASHFS_XATTR_BLOCK(index);\n\tint offset = SQUASHFS_XATTR_BLOCK_OFFSET(index);\n\tu64 start_block = le64_to_cpu(msblk->xattr_id_table[block]);\n\tstruct squashfs_xattr_id id;\n\tint err;\n\n\terr = squashfs_read_metadata(sb, &id, &start_block, &offset,\n\t\t\t\t\t\t\tsizeof(id));\n\tif (err < 0)\n\t\treturn err;\n\n\t*xattr = le64_to_cpu(id.xattr);\n\t*size = le32_to_cpu(id.size);\n\t*count = le32_to_cpu(id.count);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERROR",
          "args": [
            "\"Unknown inode type %d in squashfs_iget!\\n\"",
            "type"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "0"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "le32_to_cpu(sqsh_ino->nlink)"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sqsh_ino->nlink"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_read_metadata",
          "args": [
            "sb",
            "sqsh_ino",
            "&block",
            "&offset",
            "sizeof(*sqsh_ino)"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/cache.c",
          "lines": "344-382",
          "snippet": "int squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"page_actor.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/wait.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"page_actor.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/pagemap.h>\n#include <linux/wait.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_read_metadata(struct super_block *sb, void *buffer,\n\t\tu64 *block, int *offset, int length)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint bytes, res = length;\n\tstruct squashfs_cache_entry *entry;\n\n\tTRACE(\"Entered squashfs_read_metadata [%llx:%x]\\n\", *block, *offset);\n\n\twhile (length) {\n\t\tentry = squashfs_cache_get(sb, msblk->block_cache, *block, 0);\n\t\tif (entry->error) {\n\t\t\tres = entry->error;\n\t\t\tgoto error;\n\t\t} else if (*offset >= entry->length) {\n\t\t\tres = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\tbytes = squashfs_copy_data(buffer, entry, *offset, length);\n\t\tif (buffer)\n\t\t\tbuffer += bytes;\n\t\tlength -= bytes;\n\t\t*offset += bytes;\n\n\t\tif (*offset == entry->length) {\n\t\t\t*block = entry->next_index;\n\t\t\t*offset = 0;\n\t\t}\n\n\t\tsquashfs_cache_put(entry);\n\t}\n\n\treturn res;\n\nerror:\n\tsquashfs_cache_put(entry);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Device inode %x:%x, rdev %x\\n\"",
            "SQUASHFS_INODE_BLK(ino)",
            "offset",
            "rdev"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_INODE_BLK",
          "args": [
            "ino"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "rdev"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Device inode %x:%x, rdev %x\\n\"",
            "SQUASHFS_INODE_BLK(ino)",
            "offset",
            "rdev"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_INODE_BLK",
          "args": [
            "ino"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_decode_dev",
          "args": [
            "rdev"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Symbolic link inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\"",
            "SQUASHFS_INODE_BLK(ino)",
            "offset",
            "block",
            "offset"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_INODE_BLK",
          "args": [
            "ino"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Long directory inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\"",
            "SQUASHFS_INODE_BLK(ino)",
            "offset",
            "squashfs_i(inode)->start",
            "le16_to_cpu(sqsh_ino->offset)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sqsh_ino->offset"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SQUASHFS_INODE_BLK",
          "args": [
            "ino"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Directory inode %x:%x, start_block %llx, offset %x\\n\"",
            "SQUASHFS_INODE_BLK(ino)",
            "offset",
            "squashfs_i(inode)->start",
            "le16_to_cpu(sqsh_ino->offset)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_INODE_BLK",
          "args": [
            "ino"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\"",
            "SQUASHFS_INODE_BLK(ino)",
            "offset",
            "squashfs_i(inode)->start",
            "block",
            "offset"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_INODE_BLK",
          "args": [
            "ino"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "sqsh_ino->start_block"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_frag_lookup",
          "args": [
            "sb",
            "frag",
            "&frag_blk"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_frag_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/fragment.c",
          "lines": "48-67",
          "snippet": "int squashfs_frag_lookup(struct super_block *sb, unsigned int fragment,\n\t\t\t\tu64 *fragment_block)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint block = SQUASHFS_FRAGMENT_INDEX(fragment);\n\tint offset = SQUASHFS_FRAGMENT_INDEX_OFFSET(fragment);\n\tu64 start_block = le64_to_cpu(msblk->fragment_index[block]);\n\tstruct squashfs_fragment_entry fragment_entry;\n\tint size;\n\n\tsize = squashfs_read_metadata(sb, &fragment_entry, &start_block,\n\t\t\t\t\t&offset, sizeof(fragment_entry));\n\tif (size < 0)\n\t\treturn size;\n\n\t*fragment_block = le64_to_cpu(fragment_entry.start_block);\n\tsize = le32_to_cpu(fragment_entry.size);\n\n\treturn size;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_frag_lookup(struct super_block *sb, unsigned int fragment,\n\t\t\t\tu64 *fragment_block)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint block = SQUASHFS_FRAGMENT_INDEX(fragment);\n\tint offset = SQUASHFS_FRAGMENT_INDEX_OFFSET(fragment);\n\tu64 start_block = le64_to_cpu(msblk->fragment_index[block]);\n\tstruct squashfs_fragment_entry fragment_entry;\n\tint size;\n\n\tsize = squashfs_read_metadata(sb, &fragment_entry, &start_block,\n\t\t\t\t\t&offset, sizeof(fragment_entry));\n\tif (size < 0)\n\t\treturn size;\n\n\t*fragment_block = le64_to_cpu(fragment_entry.start_block);\n\tsize = le32_to_cpu(fragment_entry.size);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\"",
            "SQUASHFS_INODE_BLK(ino)",
            "offset",
            "squashfs_i(inode)->start",
            "block",
            "offset"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_INODE_BLK",
          "args": [
            "ino"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_INODE_OFFSET",
          "args": [
            "ino"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_INODE_BLK",
          "args": [
            "ino"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_new_inode",
          "args": [
            "sb",
            "inode",
            "sqshb_ino"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/inode.c",
          "lines": "56-81",
          "snippet": "static int squashfs_new_inode(struct super_block *sb, struct inode *inode,\n\t\t\t\tstruct squashfs_base_inode *sqsh_ino)\n{\n\tuid_t i_uid;\n\tgid_t i_gid;\n\tint err;\n\n\terr = squashfs_get_id(sb, le16_to_cpu(sqsh_ino->uid), &i_uid);\n\tif (err)\n\t\treturn err;\n\n\terr = squashfs_get_id(sb, le16_to_cpu(sqsh_ino->guid), &i_gid);\n\tif (err)\n\t\treturn err;\n\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tinode->i_ino = le32_to_cpu(sqsh_ino->inode_number);\n\tinode->i_mtime.tv_sec = le32_to_cpu(sqsh_ino->mtime);\n\tinode->i_atime.tv_sec = inode->i_mtime.tv_sec;\n\tinode->i_ctime.tv_sec = inode->i_mtime.tv_sec;\n\tinode->i_mode = le16_to_cpu(sqsh_ino->mode);\n\tinode->i_size = 0;\n\n\treturn err;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_new_inode(struct super_block *sb, struct inode *inode,\n\t\t\t\tstruct squashfs_base_inode *sqsh_ino)\n{\n\tuid_t i_uid;\n\tgid_t i_gid;\n\tint err;\n\n\terr = squashfs_get_id(sb, le16_to_cpu(sqsh_ino->uid), &i_uid);\n\tif (err)\n\t\treturn err;\n\n\terr = squashfs_get_id(sb, le16_to_cpu(sqsh_ino->guid), &i_gid);\n\tif (err)\n\t\treturn err;\n\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tinode->i_ino = le32_to_cpu(sqsh_ino->inode_number);\n\tinode->i_mtime.tv_sec = le32_to_cpu(sqsh_ino->mtime);\n\tinode->i_atime.tv_sec = inode->i_mtime.tv_sec;\n\tinode->i_ctime.tv_sec = inode->i_mtime.tv_sec;\n\tinode->i_mode = le16_to_cpu(sqsh_ino->mode);\n\tinode->i_size = 0;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Entered squashfs_read_inode\\n\""
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_INODE_OFFSET",
          "args": [
            "ino"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SQUASHFS_INODE_BLK",
          "args": [
            "ino"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nconst struct inode_operations squashfs_inode_ops = {\n\t.getxattr = generic_getxattr,\n\t.listxattr = squashfs_listxattr\n};\n\nint squashfs_read_inode(struct inode *inode, long long ino)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 block = SQUASHFS_INODE_BLK(ino) + msblk->inode_table;\n\tint err, type, offset = SQUASHFS_INODE_OFFSET(ino);\n\tunion squashfs_inode squashfs_ino;\n\tstruct squashfs_base_inode *sqshb_ino = &squashfs_ino.base;\n\tint xattr_id = SQUASHFS_INVALID_XATTR;\n\n\tTRACE(\"Entered squashfs_read_inode\\n\");\n\n\t/*\n\t * Read inode base common to all inode types.\n\t */\n\terr = squashfs_read_metadata(sb, sqshb_ino, &block,\n\t\t\t\t&offset, sizeof(*sqshb_ino));\n\tif (err < 0)\n\t\tgoto failed_read;\n\n\terr = squashfs_new_inode(sb, inode, sqshb_ino);\n\tif (err)\n\t\tgoto failed_read;\n\n\tblock = SQUASHFS_INODE_BLK(ino) + msblk->inode_table;\n\toffset = SQUASHFS_INODE_OFFSET(ino);\n\n\ttype = le16_to_cpu(sqshb_ino->inode_type);\n\tswitch (type) {\n\tcase SQUASHFS_REG_TYPE: {\n\t\tunsigned int frag_offset, frag;\n\t\tint frag_size;\n\t\tu64 frag_blk;\n\t\tstruct squashfs_reg_inode *sqsh_ino = &squashfs_ino.reg;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tfrag = le32_to_cpu(sqsh_ino->fragment);\n\t\tif (frag != SQUASHFS_INVALID_FRAG) {\n\t\t\tfrag_offset = le32_to_cpu(sqsh_ino->offset);\n\t\t\tfrag_size = squashfs_frag_lookup(sb, frag, &frag_blk);\n\t\t\tif (frag_size < 0) {\n\t\t\t\terr = frag_size;\n\t\t\t\tgoto failed_read;\n\t\t\t}\n\t\t} else {\n\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n\t\t\tfrag_size = 0;\n\t\t\tfrag_offset = 0;\n\t\t}\n\n\t\tset_nlink(inode, 1);\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_blocks = ((inode->i_size - 1) >> 9) + 1;\n\t\tsquashfs_i(inode)->fragment_block = frag_blk;\n\t\tsquashfs_i(inode)->fragment_size = frag_size;\n\t\tsquashfs_i(inode)->fragment_offset = frag_offset;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->block_list_start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\t\tinode->i_data.a_ops = &squashfs_aops;\n\n\t\tTRACE(\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\", SQUASHFS_INODE_BLK(ino),\n\t\t\toffset, squashfs_i(inode)->start, block, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LREG_TYPE: {\n\t\tunsigned int frag_offset, frag;\n\t\tint frag_size;\n\t\tu64 frag_blk;\n\t\tstruct squashfs_lreg_inode *sqsh_ino = &squashfs_ino.lreg;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tfrag = le32_to_cpu(sqsh_ino->fragment);\n\t\tif (frag != SQUASHFS_INVALID_FRAG) {\n\t\t\tfrag_offset = le32_to_cpu(sqsh_ino->offset);\n\t\t\tfrag_size = squashfs_frag_lookup(sb, frag, &frag_blk);\n\t\t\tif (frag_size < 0) {\n\t\t\t\terr = frag_size;\n\t\t\t\tgoto failed_read;\n\t\t\t}\n\t\t} else {\n\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n\t\t\tfrag_size = 0;\n\t\t\tfrag_offset = 0;\n\t\t}\n\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le64_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_blocks = (inode->i_size -\n\t\t\t\tle64_to_cpu(sqsh_ino->sparse) + 511) >> 9;\n\n\t\tsquashfs_i(inode)->fragment_block = frag_blk;\n\t\tsquashfs_i(inode)->fragment_size = frag_size;\n\t\tsquashfs_i(inode)->fragment_offset = frag_offset;\n\t\tsquashfs_i(inode)->start = le64_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->block_list_start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\t\tinode->i_data.a_ops = &squashfs_aops;\n\n\t\tTRACE(\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\", SQUASHFS_INODE_BLK(ino),\n\t\t\toffset, squashfs_i(inode)->start, block, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_DIR_TYPE: {\n\t\tstruct squashfs_dir_inode *sqsh_ino = &squashfs_ino.dir;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le16_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_dir_inode_ops;\n\t\tinode->i_fop = &squashfs_dir_ops;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->offset = le16_to_cpu(sqsh_ino->offset);\n\t\tsquashfs_i(inode)->dir_idx_cnt = 0;\n\t\tsquashfs_i(inode)->parent = le32_to_cpu(sqsh_ino->parent_inode);\n\n\t\tTRACE(\"Directory inode %x:%x, start_block %llx, offset %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tle16_to_cpu(sqsh_ino->offset));\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LDIR_TYPE: {\n\t\tstruct squashfs_ldir_inode *sqsh_ino = &squashfs_ino.ldir;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_dir_inode_ops;\n\t\tinode->i_fop = &squashfs_dir_ops;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->offset = le16_to_cpu(sqsh_ino->offset);\n\t\tsquashfs_i(inode)->dir_idx_start = block;\n\t\tsquashfs_i(inode)->dir_idx_offset = offset;\n\t\tsquashfs_i(inode)->dir_idx_cnt = le16_to_cpu(sqsh_ino->i_count);\n\t\tsquashfs_i(inode)->parent = le32_to_cpu(sqsh_ino->parent_inode);\n\n\t\tTRACE(\"Long directory inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\", SQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tle16_to_cpu(sqsh_ino->offset));\n\t\tbreak;\n\t}\n\tcase SQUASHFS_SYMLINK_TYPE:\n\tcase SQUASHFS_LSYMLINK_TYPE: {\n\t\tstruct squashfs_symlink_inode *sqsh_ino = &squashfs_ino.symlink;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->symlink_size);\n\t\tinode->i_op = &squashfs_symlink_inode_ops;\n\t\tinode->i_data.a_ops = &squashfs_symlink_aops;\n\t\tinode->i_mode |= S_IFLNK;\n\t\tsquashfs_i(inode)->start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\n\t\tif (type == SQUASHFS_LSYMLINK_TYPE) {\n\t\t\t__le32 xattr;\n\n\t\t\terr = squashfs_read_metadata(sb, NULL, &block,\n\t\t\t\t\t\t&offset, inode->i_size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\t\t\terr = squashfs_read_metadata(sb, &xattr, &block,\n\t\t\t\t\t\t&offset, sizeof(xattr));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\t\t\txattr_id = le32_to_cpu(xattr);\n\t\t}\n\n\t\tTRACE(\"Symbolic link inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\", SQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tblock, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_BLKDEV_TYPE:\n\tcase SQUASHFS_CHRDEV_TYPE: {\n\t\tstruct squashfs_dev_inode *sqsh_ino = &squashfs_ino.dev;\n\t\tunsigned int rdev;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_CHRDEV_TYPE)\n\t\t\tinode->i_mode |= S_IFCHR;\n\t\telse\n\t\t\tinode->i_mode |= S_IFBLK;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\trdev = le32_to_cpu(sqsh_ino->rdev);\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\n\t\tTRACE(\"Device inode %x:%x, rdev %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset, rdev);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LBLKDEV_TYPE:\n\tcase SQUASHFS_LCHRDEV_TYPE: {\n\t\tstruct squashfs_ldev_inode *sqsh_ino = &squashfs_ino.ldev;\n\t\tunsigned int rdev;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_LCHRDEV_TYPE)\n\t\t\tinode->i_mode |= S_IFCHR;\n\t\telse\n\t\t\tinode->i_mode |= S_IFBLK;\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\trdev = le32_to_cpu(sqsh_ino->rdev);\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\n\t\tTRACE(\"Device inode %x:%x, rdev %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset, rdev);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_FIFO_TYPE:\n\tcase SQUASHFS_SOCKET_TYPE: {\n\t\tstruct squashfs_ipc_inode *sqsh_ino = &squashfs_ino.ipc;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_FIFO_TYPE)\n\t\t\tinode->i_mode |= S_IFIFO;\n\t\telse\n\t\t\tinode->i_mode |= S_IFSOCK;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LFIFO_TYPE:\n\tcase SQUASHFS_LSOCKET_TYPE: {\n\t\tstruct squashfs_lipc_inode *sqsh_ino = &squashfs_ino.lipc;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_LFIFO_TYPE)\n\t\t\tinode->i_mode |= S_IFIFO;\n\t\telse\n\t\t\tinode->i_mode |= S_IFSOCK;\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tERROR(\"Unknown inode type %d in squashfs_iget!\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (xattr_id != SQUASHFS_INVALID_XATTR && msblk->xattr_id_table) {\n\t\terr = squashfs_xattr_lookup(sb, xattr_id,\n\t\t\t\t\t&squashfs_i(inode)->xattr_count,\n\t\t\t\t\t&squashfs_i(inode)->xattr_size,\n\t\t\t\t\t&squashfs_i(inode)->xattr);\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\t\tinode->i_blocks += ((squashfs_i(inode)->xattr_size - 1) >> 9)\n\t\t\t\t+ 1;\n\t} else\n\t\tsquashfs_i(inode)->xattr_count = 0;\n\n\treturn 0;\n\nfailed_read:\n\tERROR(\"Unable to read inode 0x%llx\\n\", ino);\n\treturn err;\n}"
  },
  {
    "function_name": "squashfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/inode.c",
    "lines": "84-105",
    "snippet": "struct inode *squashfs_iget(struct super_block *sb, long long ino,\n\t\t\t\tunsigned int ino_number)\n{\n\tstruct inode *inode = iget_locked(sb, ino_number);\n\tint err;\n\n\tTRACE(\"Entered squashfs_iget\\n\");\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = squashfs_read_inode(inode, ino);\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "squashfs_read_inode",
          "args": [
            "inode",
            "ino"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/inode.c",
          "lines": "112-422",
          "snippet": "int squashfs_read_inode(struct inode *inode, long long ino)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 block = SQUASHFS_INODE_BLK(ino) + msblk->inode_table;\n\tint err, type, offset = SQUASHFS_INODE_OFFSET(ino);\n\tunion squashfs_inode squashfs_ino;\n\tstruct squashfs_base_inode *sqshb_ino = &squashfs_ino.base;\n\tint xattr_id = SQUASHFS_INVALID_XATTR;\n\n\tTRACE(\"Entered squashfs_read_inode\\n\");\n\n\t/*\n\t * Read inode base common to all inode types.\n\t */\n\terr = squashfs_read_metadata(sb, sqshb_ino, &block,\n\t\t\t\t&offset, sizeof(*sqshb_ino));\n\tif (err < 0)\n\t\tgoto failed_read;\n\n\terr = squashfs_new_inode(sb, inode, sqshb_ino);\n\tif (err)\n\t\tgoto failed_read;\n\n\tblock = SQUASHFS_INODE_BLK(ino) + msblk->inode_table;\n\toffset = SQUASHFS_INODE_OFFSET(ino);\n\n\ttype = le16_to_cpu(sqshb_ino->inode_type);\n\tswitch (type) {\n\tcase SQUASHFS_REG_TYPE: {\n\t\tunsigned int frag_offset, frag;\n\t\tint frag_size;\n\t\tu64 frag_blk;\n\t\tstruct squashfs_reg_inode *sqsh_ino = &squashfs_ino.reg;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tfrag = le32_to_cpu(sqsh_ino->fragment);\n\t\tif (frag != SQUASHFS_INVALID_FRAG) {\n\t\t\tfrag_offset = le32_to_cpu(sqsh_ino->offset);\n\t\t\tfrag_size = squashfs_frag_lookup(sb, frag, &frag_blk);\n\t\t\tif (frag_size < 0) {\n\t\t\t\terr = frag_size;\n\t\t\t\tgoto failed_read;\n\t\t\t}\n\t\t} else {\n\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n\t\t\tfrag_size = 0;\n\t\t\tfrag_offset = 0;\n\t\t}\n\n\t\tset_nlink(inode, 1);\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_blocks = ((inode->i_size - 1) >> 9) + 1;\n\t\tsquashfs_i(inode)->fragment_block = frag_blk;\n\t\tsquashfs_i(inode)->fragment_size = frag_size;\n\t\tsquashfs_i(inode)->fragment_offset = frag_offset;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->block_list_start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\t\tinode->i_data.a_ops = &squashfs_aops;\n\n\t\tTRACE(\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\", SQUASHFS_INODE_BLK(ino),\n\t\t\toffset, squashfs_i(inode)->start, block, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LREG_TYPE: {\n\t\tunsigned int frag_offset, frag;\n\t\tint frag_size;\n\t\tu64 frag_blk;\n\t\tstruct squashfs_lreg_inode *sqsh_ino = &squashfs_ino.lreg;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tfrag = le32_to_cpu(sqsh_ino->fragment);\n\t\tif (frag != SQUASHFS_INVALID_FRAG) {\n\t\t\tfrag_offset = le32_to_cpu(sqsh_ino->offset);\n\t\t\tfrag_size = squashfs_frag_lookup(sb, frag, &frag_blk);\n\t\t\tif (frag_size < 0) {\n\t\t\t\terr = frag_size;\n\t\t\t\tgoto failed_read;\n\t\t\t}\n\t\t} else {\n\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n\t\t\tfrag_size = 0;\n\t\t\tfrag_offset = 0;\n\t\t}\n\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le64_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_blocks = (inode->i_size -\n\t\t\t\tle64_to_cpu(sqsh_ino->sparse) + 511) >> 9;\n\n\t\tsquashfs_i(inode)->fragment_block = frag_blk;\n\t\tsquashfs_i(inode)->fragment_size = frag_size;\n\t\tsquashfs_i(inode)->fragment_offset = frag_offset;\n\t\tsquashfs_i(inode)->start = le64_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->block_list_start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\t\tinode->i_data.a_ops = &squashfs_aops;\n\n\t\tTRACE(\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\", SQUASHFS_INODE_BLK(ino),\n\t\t\toffset, squashfs_i(inode)->start, block, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_DIR_TYPE: {\n\t\tstruct squashfs_dir_inode *sqsh_ino = &squashfs_ino.dir;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le16_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_dir_inode_ops;\n\t\tinode->i_fop = &squashfs_dir_ops;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->offset = le16_to_cpu(sqsh_ino->offset);\n\t\tsquashfs_i(inode)->dir_idx_cnt = 0;\n\t\tsquashfs_i(inode)->parent = le32_to_cpu(sqsh_ino->parent_inode);\n\n\t\tTRACE(\"Directory inode %x:%x, start_block %llx, offset %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tle16_to_cpu(sqsh_ino->offset));\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LDIR_TYPE: {\n\t\tstruct squashfs_ldir_inode *sqsh_ino = &squashfs_ino.ldir;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_dir_inode_ops;\n\t\tinode->i_fop = &squashfs_dir_ops;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->offset = le16_to_cpu(sqsh_ino->offset);\n\t\tsquashfs_i(inode)->dir_idx_start = block;\n\t\tsquashfs_i(inode)->dir_idx_offset = offset;\n\t\tsquashfs_i(inode)->dir_idx_cnt = le16_to_cpu(sqsh_ino->i_count);\n\t\tsquashfs_i(inode)->parent = le32_to_cpu(sqsh_ino->parent_inode);\n\n\t\tTRACE(\"Long directory inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\", SQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tle16_to_cpu(sqsh_ino->offset));\n\t\tbreak;\n\t}\n\tcase SQUASHFS_SYMLINK_TYPE:\n\tcase SQUASHFS_LSYMLINK_TYPE: {\n\t\tstruct squashfs_symlink_inode *sqsh_ino = &squashfs_ino.symlink;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->symlink_size);\n\t\tinode->i_op = &squashfs_symlink_inode_ops;\n\t\tinode->i_data.a_ops = &squashfs_symlink_aops;\n\t\tinode->i_mode |= S_IFLNK;\n\t\tsquashfs_i(inode)->start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\n\t\tif (type == SQUASHFS_LSYMLINK_TYPE) {\n\t\t\t__le32 xattr;\n\n\t\t\terr = squashfs_read_metadata(sb, NULL, &block,\n\t\t\t\t\t\t&offset, inode->i_size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\t\t\terr = squashfs_read_metadata(sb, &xattr, &block,\n\t\t\t\t\t\t&offset, sizeof(xattr));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\t\t\txattr_id = le32_to_cpu(xattr);\n\t\t}\n\n\t\tTRACE(\"Symbolic link inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\", SQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tblock, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_BLKDEV_TYPE:\n\tcase SQUASHFS_CHRDEV_TYPE: {\n\t\tstruct squashfs_dev_inode *sqsh_ino = &squashfs_ino.dev;\n\t\tunsigned int rdev;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_CHRDEV_TYPE)\n\t\t\tinode->i_mode |= S_IFCHR;\n\t\telse\n\t\t\tinode->i_mode |= S_IFBLK;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\trdev = le32_to_cpu(sqsh_ino->rdev);\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\n\t\tTRACE(\"Device inode %x:%x, rdev %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset, rdev);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LBLKDEV_TYPE:\n\tcase SQUASHFS_LCHRDEV_TYPE: {\n\t\tstruct squashfs_ldev_inode *sqsh_ino = &squashfs_ino.ldev;\n\t\tunsigned int rdev;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_LCHRDEV_TYPE)\n\t\t\tinode->i_mode |= S_IFCHR;\n\t\telse\n\t\t\tinode->i_mode |= S_IFBLK;\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\trdev = le32_to_cpu(sqsh_ino->rdev);\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\n\t\tTRACE(\"Device inode %x:%x, rdev %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset, rdev);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_FIFO_TYPE:\n\tcase SQUASHFS_SOCKET_TYPE: {\n\t\tstruct squashfs_ipc_inode *sqsh_ino = &squashfs_ino.ipc;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_FIFO_TYPE)\n\t\t\tinode->i_mode |= S_IFIFO;\n\t\telse\n\t\t\tinode->i_mode |= S_IFSOCK;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LFIFO_TYPE:\n\tcase SQUASHFS_LSOCKET_TYPE: {\n\t\tstruct squashfs_lipc_inode *sqsh_ino = &squashfs_ino.lipc;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_LFIFO_TYPE)\n\t\t\tinode->i_mode |= S_IFIFO;\n\t\telse\n\t\t\tinode->i_mode |= S_IFSOCK;\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tERROR(\"Unknown inode type %d in squashfs_iget!\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (xattr_id != SQUASHFS_INVALID_XATTR && msblk->xattr_id_table) {\n\t\terr = squashfs_xattr_lookup(sb, xattr_id,\n\t\t\t\t\t&squashfs_i(inode)->xattr_count,\n\t\t\t\t\t&squashfs_i(inode)->xattr_size,\n\t\t\t\t\t&squashfs_i(inode)->xattr);\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\t\tinode->i_blocks += ((squashfs_i(inode)->xattr_size - 1) >> 9)\n\t\t\t\t+ 1;\n\t} else\n\t\tsquashfs_i(inode)->xattr_count = 0;\n\n\treturn 0;\n\nfailed_read:\n\tERROR(\"Unable to read inode 0x%llx\\n\", ino);\n\treturn err;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_i.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct inode_operations squashfs_inode_ops = {\n\t.getxattr = generic_getxattr,\n\t.listxattr = squashfs_listxattr\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nconst struct inode_operations squashfs_inode_ops = {\n\t.getxattr = generic_getxattr,\n\t.listxattr = squashfs_listxattr\n};\n\nint squashfs_read_inode(struct inode *inode, long long ino)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tu64 block = SQUASHFS_INODE_BLK(ino) + msblk->inode_table;\n\tint err, type, offset = SQUASHFS_INODE_OFFSET(ino);\n\tunion squashfs_inode squashfs_ino;\n\tstruct squashfs_base_inode *sqshb_ino = &squashfs_ino.base;\n\tint xattr_id = SQUASHFS_INVALID_XATTR;\n\n\tTRACE(\"Entered squashfs_read_inode\\n\");\n\n\t/*\n\t * Read inode base common to all inode types.\n\t */\n\terr = squashfs_read_metadata(sb, sqshb_ino, &block,\n\t\t\t\t&offset, sizeof(*sqshb_ino));\n\tif (err < 0)\n\t\tgoto failed_read;\n\n\terr = squashfs_new_inode(sb, inode, sqshb_ino);\n\tif (err)\n\t\tgoto failed_read;\n\n\tblock = SQUASHFS_INODE_BLK(ino) + msblk->inode_table;\n\toffset = SQUASHFS_INODE_OFFSET(ino);\n\n\ttype = le16_to_cpu(sqshb_ino->inode_type);\n\tswitch (type) {\n\tcase SQUASHFS_REG_TYPE: {\n\t\tunsigned int frag_offset, frag;\n\t\tint frag_size;\n\t\tu64 frag_blk;\n\t\tstruct squashfs_reg_inode *sqsh_ino = &squashfs_ino.reg;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tfrag = le32_to_cpu(sqsh_ino->fragment);\n\t\tif (frag != SQUASHFS_INVALID_FRAG) {\n\t\t\tfrag_offset = le32_to_cpu(sqsh_ino->offset);\n\t\t\tfrag_size = squashfs_frag_lookup(sb, frag, &frag_blk);\n\t\t\tif (frag_size < 0) {\n\t\t\t\terr = frag_size;\n\t\t\t\tgoto failed_read;\n\t\t\t}\n\t\t} else {\n\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n\t\t\tfrag_size = 0;\n\t\t\tfrag_offset = 0;\n\t\t}\n\n\t\tset_nlink(inode, 1);\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_blocks = ((inode->i_size - 1) >> 9) + 1;\n\t\tsquashfs_i(inode)->fragment_block = frag_blk;\n\t\tsquashfs_i(inode)->fragment_size = frag_size;\n\t\tsquashfs_i(inode)->fragment_offset = frag_offset;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->block_list_start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\t\tinode->i_data.a_ops = &squashfs_aops;\n\n\t\tTRACE(\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\", SQUASHFS_INODE_BLK(ino),\n\t\t\toffset, squashfs_i(inode)->start, block, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LREG_TYPE: {\n\t\tunsigned int frag_offset, frag;\n\t\tint frag_size;\n\t\tu64 frag_blk;\n\t\tstruct squashfs_lreg_inode *sqsh_ino = &squashfs_ino.lreg;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tfrag = le32_to_cpu(sqsh_ino->fragment);\n\t\tif (frag != SQUASHFS_INVALID_FRAG) {\n\t\t\tfrag_offset = le32_to_cpu(sqsh_ino->offset);\n\t\t\tfrag_size = squashfs_frag_lookup(sb, frag, &frag_blk);\n\t\t\tif (frag_size < 0) {\n\t\t\t\terr = frag_size;\n\t\t\t\tgoto failed_read;\n\t\t\t}\n\t\t} else {\n\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n\t\t\tfrag_size = 0;\n\t\t\tfrag_offset = 0;\n\t\t}\n\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le64_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tinode->i_fop = &generic_ro_fops;\n\t\tinode->i_mode |= S_IFREG;\n\t\tinode->i_blocks = (inode->i_size -\n\t\t\t\tle64_to_cpu(sqsh_ino->sparse) + 511) >> 9;\n\n\t\tsquashfs_i(inode)->fragment_block = frag_blk;\n\t\tsquashfs_i(inode)->fragment_size = frag_size;\n\t\tsquashfs_i(inode)->fragment_offset = frag_offset;\n\t\tsquashfs_i(inode)->start = le64_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->block_list_start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\t\tinode->i_data.a_ops = &squashfs_aops;\n\n\t\tTRACE(\"File inode %x:%x, start_block %llx, block_list_start \"\n\t\t\t\"%llx, offset %x\\n\", SQUASHFS_INODE_BLK(ino),\n\t\t\toffset, squashfs_i(inode)->start, block, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_DIR_TYPE: {\n\t\tstruct squashfs_dir_inode *sqsh_ino = &squashfs_ino.dir;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le16_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_dir_inode_ops;\n\t\tinode->i_fop = &squashfs_dir_ops;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->offset = le16_to_cpu(sqsh_ino->offset);\n\t\tsquashfs_i(inode)->dir_idx_cnt = 0;\n\t\tsquashfs_i(inode)->parent = le32_to_cpu(sqsh_ino->parent_inode);\n\n\t\tTRACE(\"Directory inode %x:%x, start_block %llx, offset %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tle16_to_cpu(sqsh_ino->offset));\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LDIR_TYPE: {\n\t\tstruct squashfs_ldir_inode *sqsh_ino = &squashfs_ino.ldir;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->file_size);\n\t\tinode->i_op = &squashfs_dir_inode_ops;\n\t\tinode->i_fop = &squashfs_dir_ops;\n\t\tinode->i_mode |= S_IFDIR;\n\t\tsquashfs_i(inode)->start = le32_to_cpu(sqsh_ino->start_block);\n\t\tsquashfs_i(inode)->offset = le16_to_cpu(sqsh_ino->offset);\n\t\tsquashfs_i(inode)->dir_idx_start = block;\n\t\tsquashfs_i(inode)->dir_idx_offset = offset;\n\t\tsquashfs_i(inode)->dir_idx_cnt = le16_to_cpu(sqsh_ino->i_count);\n\t\tsquashfs_i(inode)->parent = le32_to_cpu(sqsh_ino->parent_inode);\n\n\t\tTRACE(\"Long directory inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\", SQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tsquashfs_i(inode)->start,\n\t\t\t\tle16_to_cpu(sqsh_ino->offset));\n\t\tbreak;\n\t}\n\tcase SQUASHFS_SYMLINK_TYPE:\n\tcase SQUASHFS_LSYMLINK_TYPE: {\n\t\tstruct squashfs_symlink_inode *sqsh_ino = &squashfs_ino.symlink;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinode->i_size = le32_to_cpu(sqsh_ino->symlink_size);\n\t\tinode->i_op = &squashfs_symlink_inode_ops;\n\t\tinode->i_data.a_ops = &squashfs_symlink_aops;\n\t\tinode->i_mode |= S_IFLNK;\n\t\tsquashfs_i(inode)->start = block;\n\t\tsquashfs_i(inode)->offset = offset;\n\n\t\tif (type == SQUASHFS_LSYMLINK_TYPE) {\n\t\t\t__le32 xattr;\n\n\t\t\terr = squashfs_read_metadata(sb, NULL, &block,\n\t\t\t\t\t\t&offset, inode->i_size);\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\t\t\terr = squashfs_read_metadata(sb, &xattr, &block,\n\t\t\t\t\t\t&offset, sizeof(xattr));\n\t\t\tif (err < 0)\n\t\t\t\tgoto failed_read;\n\t\t\txattr_id = le32_to_cpu(xattr);\n\t\t}\n\n\t\tTRACE(\"Symbolic link inode %x:%x, start_block %llx, offset \"\n\t\t\t\t\"%x\\n\", SQUASHFS_INODE_BLK(ino), offset,\n\t\t\t\tblock, offset);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_BLKDEV_TYPE:\n\tcase SQUASHFS_CHRDEV_TYPE: {\n\t\tstruct squashfs_dev_inode *sqsh_ino = &squashfs_ino.dev;\n\t\tunsigned int rdev;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_CHRDEV_TYPE)\n\t\t\tinode->i_mode |= S_IFCHR;\n\t\telse\n\t\t\tinode->i_mode |= S_IFBLK;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\trdev = le32_to_cpu(sqsh_ino->rdev);\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\n\t\tTRACE(\"Device inode %x:%x, rdev %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset, rdev);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LBLKDEV_TYPE:\n\tcase SQUASHFS_LCHRDEV_TYPE: {\n\t\tstruct squashfs_ldev_inode *sqsh_ino = &squashfs_ino.ldev;\n\t\tunsigned int rdev;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_LCHRDEV_TYPE)\n\t\t\tinode->i_mode |= S_IFCHR;\n\t\telse\n\t\t\tinode->i_mode |= S_IFBLK;\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\trdev = le32_to_cpu(sqsh_ino->rdev);\n\t\tinit_special_inode(inode, inode->i_mode, new_decode_dev(rdev));\n\n\t\tTRACE(\"Device inode %x:%x, rdev %x\\n\",\n\t\t\t\tSQUASHFS_INODE_BLK(ino), offset, rdev);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_FIFO_TYPE:\n\tcase SQUASHFS_SOCKET_TYPE: {\n\t\tstruct squashfs_ipc_inode *sqsh_ino = &squashfs_ino.ipc;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_FIFO_TYPE)\n\t\t\tinode->i_mode |= S_IFIFO;\n\t\telse\n\t\t\tinode->i_mode |= S_IFSOCK;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tbreak;\n\t}\n\tcase SQUASHFS_LFIFO_TYPE:\n\tcase SQUASHFS_LSOCKET_TYPE: {\n\t\tstruct squashfs_lipc_inode *sqsh_ino = &squashfs_ino.lipc;\n\n\t\terr = squashfs_read_metadata(sb, sqsh_ino, &block, &offset,\n\t\t\t\tsizeof(*sqsh_ino));\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\n\t\tif (type == SQUASHFS_LFIFO_TYPE)\n\t\t\tinode->i_mode |= S_IFIFO;\n\t\telse\n\t\t\tinode->i_mode |= S_IFSOCK;\n\t\txattr_id = le32_to_cpu(sqsh_ino->xattr);\n\t\tinode->i_op = &squashfs_inode_ops;\n\t\tset_nlink(inode, le32_to_cpu(sqsh_ino->nlink));\n\t\tinit_special_inode(inode, inode->i_mode, 0);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tERROR(\"Unknown inode type %d in squashfs_iget!\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (xattr_id != SQUASHFS_INVALID_XATTR && msblk->xattr_id_table) {\n\t\terr = squashfs_xattr_lookup(sb, xattr_id,\n\t\t\t\t\t&squashfs_i(inode)->xattr_count,\n\t\t\t\t\t&squashfs_i(inode)->xattr_size,\n\t\t\t\t\t&squashfs_i(inode)->xattr);\n\t\tif (err < 0)\n\t\t\tgoto failed_read;\n\t\tinode->i_blocks += ((squashfs_i(inode)->xattr_size - 1) >> 9)\n\t\t\t\t+ 1;\n\t} else\n\t\tsquashfs_i(inode)->xattr_count = 0;\n\n\treturn 0;\n\nfailed_read:\n\tERROR(\"Unable to read inode 0x%llx\\n\", ino);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRACE",
          "args": [
            "\"Entered squashfs_iget\\n\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino_number"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstruct inode *squashfs_iget(struct super_block *sb, long long ino,\n\t\t\t\tunsigned int ino_number)\n{\n\tstruct inode *inode = iget_locked(sb, ino_number);\n\tint err;\n\n\tTRACE(\"Entered squashfs_iget\\n\");\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = squashfs_read_inode(inode, ino);\n\tif (err) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "squashfs_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/inode.c",
    "lines": "56-81",
    "snippet": "static int squashfs_new_inode(struct super_block *sb, struct inode *inode,\n\t\t\t\tstruct squashfs_base_inode *sqsh_ino)\n{\n\tuid_t i_uid;\n\tgid_t i_gid;\n\tint err;\n\n\terr = squashfs_get_id(sb, le16_to_cpu(sqsh_ino->uid), &i_uid);\n\tif (err)\n\t\treturn err;\n\n\terr = squashfs_get_id(sb, le16_to_cpu(sqsh_ino->guid), &i_gid);\n\tif (err)\n\t\treturn err;\n\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tinode->i_ino = le32_to_cpu(sqsh_ino->inode_number);\n\tinode->i_mtime.tv_sec = le32_to_cpu(sqsh_ino->mtime);\n\tinode->i_atime.tv_sec = inode->i_mtime.tv_sec;\n\tinode->i_ctime.tv_sec = inode->i_mtime.tv_sec;\n\tinode->i_mode = le16_to_cpu(sqsh_ino->mode);\n\tinode->i_size = 0;\n\n\treturn err;\n}",
    "includes": [
      "#include \"xattr.h\"",
      "#include \"squashfs.h\"",
      "#include \"squashfs_fs_i.h\"",
      "#include \"squashfs_fs_sb.h\"",
      "#include \"squashfs_fs.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sqsh_ino->mode"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sqsh_ino->mtime"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "i_gid"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "i_uid"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "squashfs_get_id",
          "args": [
            "sb",
            "le16_to_cpu(sqsh_ino->guid)",
            "&i_gid"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "squashfs_get_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/squashfs/id.c",
          "lines": "45-62",
          "snippet": "int squashfs_get_id(struct super_block *sb, unsigned int index,\n\t\t\t\t\tunsigned int *id)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint block = SQUASHFS_ID_BLOCK(index);\n\tint offset = SQUASHFS_ID_BLOCK_OFFSET(index);\n\tu64 start_block = le64_to_cpu(msblk->id_table[block]);\n\t__le32 disk_id;\n\tint err;\n\n\terr = squashfs_read_metadata(sb, &disk_id, &start_block, &offset,\n\t\t\t\t\t\t\tsizeof(disk_id));\n\tif (err < 0)\n\t\treturn err;\n\n\t*id = le32_to_cpu(disk_id);\n\treturn 0;\n}",
          "includes": [
            "#include \"squashfs.h\"",
            "#include \"squashfs_fs_sb.h\"",
            "#include \"squashfs_fs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"squashfs.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/slab.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nint squashfs_get_id(struct super_block *sb, unsigned int index,\n\t\t\t\t\tunsigned int *id)\n{\n\tstruct squashfs_sb_info *msblk = sb->s_fs_info;\n\tint block = SQUASHFS_ID_BLOCK(index);\n\tint offset = SQUASHFS_ID_BLOCK_OFFSET(index);\n\tu64 start_block = le64_to_cpu(msblk->id_table[block]);\n\t__le32 disk_id;\n\tint err;\n\n\terr = squashfs_read_metadata(sb, &disk_id, &start_block, &offset,\n\t\t\t\t\t\t\tsizeof(disk_id));\n\tif (err < 0)\n\t\treturn err;\n\n\t*id = le32_to_cpu(disk_id);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xattr.h\"\n#include \"squashfs.h\"\n#include \"squashfs_fs_i.h\"\n#include \"squashfs_fs_sb.h\"\n#include \"squashfs_fs.h\"\n#include <linux/xattr.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n\nstatic int squashfs_new_inode(struct super_block *sb, struct inode *inode,\n\t\t\t\tstruct squashfs_base_inode *sqsh_ino)\n{\n\tuid_t i_uid;\n\tgid_t i_gid;\n\tint err;\n\n\terr = squashfs_get_id(sb, le16_to_cpu(sqsh_ino->uid), &i_uid);\n\tif (err)\n\t\treturn err;\n\n\terr = squashfs_get_id(sb, le16_to_cpu(sqsh_ino->guid), &i_gid);\n\tif (err)\n\t\treturn err;\n\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tinode->i_ino = le32_to_cpu(sqsh_ino->inode_number);\n\tinode->i_mtime.tv_sec = le32_to_cpu(sqsh_ino->mtime);\n\tinode->i_atime.tv_sec = inode->i_mtime.tv_sec;\n\tinode->i_ctime.tv_sec = inode->i_mtime.tv_sec;\n\tinode->i_mode = le16_to_cpu(sqsh_ino->mode);\n\tinode->i_size = 0;\n\n\treturn err;\n}"
  }
]