[
  {
    "function_name": "xfs_inactive_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_symlink.c",
    "lines": "554-598",
    "snippet": "int\nxfs_inactive_symlink(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tpathlen;\n\n\ttrace_xfs_inactive_symlink(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Zero length symlinks _can_ exist.\n\t */\n\tpathlen = (int)ip->i_d.di_size;\n\tif (!pathlen) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\treturn 0;\n\t}\n\n\tif (pathlen < 0 || pathlen > MAXPATHLEN) {\n\t\txfs_alert(mp, \"%s: inode (0x%llx) bad symlink length (%d)\",\n\t\t\t __func__, (unsigned long long)ip->i_ino, pathlen);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(0);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (ip->i_df.if_flags & XFS_IFINLINE) {\n\t\tif (ip->i_df.if_bytes > 0) \n\t\t\txfs_idata_realloc(ip, -(ip->i_df.if_bytes),\n\t\t\t\t\t  XFS_DATA_FORK);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(ip->i_df.if_bytes == 0);\n\t\treturn 0;\n\t}\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/* remove the remote symlink */\n\treturn xfs_inactive_symlink_rmt(ip);\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_inactive_symlink_rmt",
          "args": [
            "ip"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inactive_symlink_rmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_symlink.c",
          "lines": "426-549",
          "snippet": "STATIC int\nxfs_inactive_symlink_rmt(\n\tstruct xfs_inode *ip)\n{\n\txfs_buf_t\t*bp;\n\tint\t\tcommitted;\n\tint\t\tdone;\n\tint\t\terror;\n\txfs_fsblock_t\tfirst_block;\n\txfs_bmap_free_t\tfree_list;\n\tint\t\ti;\n\txfs_mount_t\t*mp;\n\txfs_bmbt_irec_t\tmval[XFS_SYMLINK_MAPS];\n\tint\t\tnmaps;\n\tint\t\tsize;\n\txfs_trans_t\t*tp;\n\n\tmp = ip->i_mount;\n\tASSERT(ip->i_df.if_flags & XFS_IFEXTENTS);\n\t/*\n\t * We're freeing a symlink that has some\n\t * blocks allocated to it.  Free the\n\t * blocks here.  We know that we've got\n\t * either 1 or 2 extents and that we can\n\t * free them all in one bunmapi call.\n\t */\n\tASSERT(ip->i_d.di_nextents > 0 && ip->i_d.di_nextents <= 2);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Lock the inode, fix the size, and join it to the transaction.\n\t * Hold it so in the normal path, we still have it locked for\n\t * the second transaction.  In the error paths we need it\n\t * held so the cancel won't rele it, see below.\n\t */\n\tsize = (int)ip->i_d.di_size;\n\tip->i_d.di_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t/*\n\t * Find the block(s) so we can inval and unmap them.\n\t */\n\tdone = 0;\n\txfs_bmap_init(&free_list, &first_block);\n\tnmaps = ARRAY_SIZE(mval);\n\terror = xfs_bmapi_read(ip, 0, xfs_symlink_blocks(mp, size),\n\t\t\t\tmval, &nmaps, 0);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\t/*\n\t * Invalidate the block(s). No validation is done.\n\t */\n\tfor (i = 0; i < nmaps; i++) {\n\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp,\n\t\t\tXFS_FSB_TO_DADDR(mp, mval[i].br_startblock),\n\t\t\tXFS_FSB_TO_BB(mp, mval[i].br_blockcount), 0);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error_bmap_cancel;\n\t\t}\n\t\txfs_trans_binval(tp, bp);\n\t}\n\t/*\n\t * Unmap the dead block(s) to the free_list.\n\t */\n\terror = xfs_bunmapi(tp, ip, 0, size, XFS_BMAPI_METADATA, nmaps,\n\t\t\t    &first_block, &free_list, &done);\n\tif (error)\n\t\tgoto error_bmap_cancel;\n\tASSERT(done);\n\t/*\n\t * Commit the first transaction.  This logs the EFI and the inode.\n\t */\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto error_bmap_cancel;\n\t/*\n\t * The transaction must have been committed, since there were\n\t * actually extents freed by xfs_bunmapi.  See xfs_bmap_finish.\n\t * The new tp has the extent freeing and EFDs.\n\t */\n\tASSERT(committed);\n\t/*\n\t * The first xact was committed, so add the inode to the new one.\n\t * Mark it dirty so it will be logged and moved forward in the log as\n\t * part of every commit.\n\t */\n\txfs_trans_ijoin(tp, ip, 0);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t/*\n\t * Commit the transaction containing extent freeing and EFDs.\n\t */\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\tgoto error_unlock;\n\t}\n\n\t/*\n\t * Remove the memory for extent descriptions (just bookkeeping).\n\t */\n\tif (ip->i_df.if_bytes)\n\t\txfs_idata_realloc(ip, -ip->i_df.if_bytes, XFS_DATA_FORK);\n\tASSERT(ip->i_df.if_bytes == 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n\nerror_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\nerror_trans_cancel:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\nerror_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_inactive_symlink_rmt(\n\tstruct xfs_inode *ip)\n{\n\txfs_buf_t\t*bp;\n\tint\t\tcommitted;\n\tint\t\tdone;\n\tint\t\terror;\n\txfs_fsblock_t\tfirst_block;\n\txfs_bmap_free_t\tfree_list;\n\tint\t\ti;\n\txfs_mount_t\t*mp;\n\txfs_bmbt_irec_t\tmval[XFS_SYMLINK_MAPS];\n\tint\t\tnmaps;\n\tint\t\tsize;\n\txfs_trans_t\t*tp;\n\n\tmp = ip->i_mount;\n\tASSERT(ip->i_df.if_flags & XFS_IFEXTENTS);\n\t/*\n\t * We're freeing a symlink that has some\n\t * blocks allocated to it.  Free the\n\t * blocks here.  We know that we've got\n\t * either 1 or 2 extents and that we can\n\t * free them all in one bunmapi call.\n\t */\n\tASSERT(ip->i_d.di_nextents > 0 && ip->i_d.di_nextents <= 2);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Lock the inode, fix the size, and join it to the transaction.\n\t * Hold it so in the normal path, we still have it locked for\n\t * the second transaction.  In the error paths we need it\n\t * held so the cancel won't rele it, see below.\n\t */\n\tsize = (int)ip->i_d.di_size;\n\tip->i_d.di_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t/*\n\t * Find the block(s) so we can inval and unmap them.\n\t */\n\tdone = 0;\n\txfs_bmap_init(&free_list, &first_block);\n\tnmaps = ARRAY_SIZE(mval);\n\terror = xfs_bmapi_read(ip, 0, xfs_symlink_blocks(mp, size),\n\t\t\t\tmval, &nmaps, 0);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\t/*\n\t * Invalidate the block(s). No validation is done.\n\t */\n\tfor (i = 0; i < nmaps; i++) {\n\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp,\n\t\t\tXFS_FSB_TO_DADDR(mp, mval[i].br_startblock),\n\t\t\tXFS_FSB_TO_BB(mp, mval[i].br_blockcount), 0);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error_bmap_cancel;\n\t\t}\n\t\txfs_trans_binval(tp, bp);\n\t}\n\t/*\n\t * Unmap the dead block(s) to the free_list.\n\t */\n\terror = xfs_bunmapi(tp, ip, 0, size, XFS_BMAPI_METADATA, nmaps,\n\t\t\t    &first_block, &free_list, &done);\n\tif (error)\n\t\tgoto error_bmap_cancel;\n\tASSERT(done);\n\t/*\n\t * Commit the first transaction.  This logs the EFI and the inode.\n\t */\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto error_bmap_cancel;\n\t/*\n\t * The transaction must have been committed, since there were\n\t * actually extents freed by xfs_bunmapi.  See xfs_bmap_finish.\n\t * The new tp has the extent freeing and EFDs.\n\t */\n\tASSERT(committed);\n\t/*\n\t * The first xact was committed, so add the inode to the new one.\n\t * Mark it dirty so it will be logged and moved forward in the log as\n\t * part of every commit.\n\t */\n\txfs_trans_ijoin(tp, ip, 0);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t/*\n\t * Commit the transaction containing extent freeing and EFDs.\n\t */\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\tgoto error_unlock;\n\t}\n\n\t/*\n\t * Remove the memory for extent descriptions (just bookkeeping).\n\t */\n\tif (ip->i_df.if_bytes)\n\t\txfs_idata_realloc(ip, -ip->i_df.if_bytes, XFS_DATA_FORK);\n\tASSERT(ip->i_df.if_bytes == 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n\nerror_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\nerror_trans_cancel:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\nerror_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_df.if_bytes == 0"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "ip",
            "-(ip->i_df.if_bytes)",
            "XFS_DATA_FORK"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"%s: inode (0x%llx) bad symlink length (%d)\"",
            "__func__",
            "(unsigned long long)ip->i_ino",
            "pathlen"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_inactive_symlink",
          "args": [
            "ip"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nint\nxfs_inactive_symlink(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tpathlen;\n\n\ttrace_xfs_inactive_symlink(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * Zero length symlinks _can_ exist.\n\t */\n\tpathlen = (int)ip->i_d.di_size;\n\tif (!pathlen) {\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\treturn 0;\n\t}\n\n\tif (pathlen < 0 || pathlen > MAXPATHLEN) {\n\t\txfs_alert(mp, \"%s: inode (0x%llx) bad symlink length (%d)\",\n\t\t\t __func__, (unsigned long long)ip->i_ino, pathlen);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(0);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (ip->i_df.if_flags & XFS_IFINLINE) {\n\t\tif (ip->i_df.if_bytes > 0) \n\t\t\txfs_idata_realloc(ip, -(ip->i_df.if_bytes),\n\t\t\t\t\t  XFS_DATA_FORK);\n\t\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\t\tASSERT(ip->i_df.if_bytes == 0);\n\t\treturn 0;\n\t}\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\n\t/* remove the remote symlink */\n\treturn xfs_inactive_symlink_rmt(ip);\n}"
  },
  {
    "function_name": "xfs_inactive_symlink_rmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_symlink.c",
    "lines": "426-549",
    "snippet": "STATIC int\nxfs_inactive_symlink_rmt(\n\tstruct xfs_inode *ip)\n{\n\txfs_buf_t\t*bp;\n\tint\t\tcommitted;\n\tint\t\tdone;\n\tint\t\terror;\n\txfs_fsblock_t\tfirst_block;\n\txfs_bmap_free_t\tfree_list;\n\tint\t\ti;\n\txfs_mount_t\t*mp;\n\txfs_bmbt_irec_t\tmval[XFS_SYMLINK_MAPS];\n\tint\t\tnmaps;\n\tint\t\tsize;\n\txfs_trans_t\t*tp;\n\n\tmp = ip->i_mount;\n\tASSERT(ip->i_df.if_flags & XFS_IFEXTENTS);\n\t/*\n\t * We're freeing a symlink that has some\n\t * blocks allocated to it.  Free the\n\t * blocks here.  We know that we've got\n\t * either 1 or 2 extents and that we can\n\t * free them all in one bunmapi call.\n\t */\n\tASSERT(ip->i_d.di_nextents > 0 && ip->i_d.di_nextents <= 2);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Lock the inode, fix the size, and join it to the transaction.\n\t * Hold it so in the normal path, we still have it locked for\n\t * the second transaction.  In the error paths we need it\n\t * held so the cancel won't rele it, see below.\n\t */\n\tsize = (int)ip->i_d.di_size;\n\tip->i_d.di_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t/*\n\t * Find the block(s) so we can inval and unmap them.\n\t */\n\tdone = 0;\n\txfs_bmap_init(&free_list, &first_block);\n\tnmaps = ARRAY_SIZE(mval);\n\terror = xfs_bmapi_read(ip, 0, xfs_symlink_blocks(mp, size),\n\t\t\t\tmval, &nmaps, 0);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\t/*\n\t * Invalidate the block(s). No validation is done.\n\t */\n\tfor (i = 0; i < nmaps; i++) {\n\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp,\n\t\t\tXFS_FSB_TO_DADDR(mp, mval[i].br_startblock),\n\t\t\tXFS_FSB_TO_BB(mp, mval[i].br_blockcount), 0);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error_bmap_cancel;\n\t\t}\n\t\txfs_trans_binval(tp, bp);\n\t}\n\t/*\n\t * Unmap the dead block(s) to the free_list.\n\t */\n\terror = xfs_bunmapi(tp, ip, 0, size, XFS_BMAPI_METADATA, nmaps,\n\t\t\t    &first_block, &free_list, &done);\n\tif (error)\n\t\tgoto error_bmap_cancel;\n\tASSERT(done);\n\t/*\n\t * Commit the first transaction.  This logs the EFI and the inode.\n\t */\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto error_bmap_cancel;\n\t/*\n\t * The transaction must have been committed, since there were\n\t * actually extents freed by xfs_bunmapi.  See xfs_bmap_finish.\n\t * The new tp has the extent freeing and EFDs.\n\t */\n\tASSERT(committed);\n\t/*\n\t * The first xact was committed, so add the inode to the new one.\n\t * Mark it dirty so it will be logged and moved forward in the log as\n\t * part of every commit.\n\t */\n\txfs_trans_ijoin(tp, ip, 0);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t/*\n\t * Commit the transaction containing extent freeing and EFDs.\n\t */\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\tgoto error_unlock;\n\t}\n\n\t/*\n\t * Remove the memory for extent descriptions (just bookkeeping).\n\t */\n\tif (ip->i_df.if_bytes)\n\t\txfs_idata_realloc(ip, -ip->i_df.if_bytes, XFS_DATA_FORK);\n\tASSERT(ip->i_df.if_bytes == 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n\nerror_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\nerror_trans_cancel:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\nerror_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "&free_list"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_df.if_bytes == 0"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "ip",
            "-ip->i_df.if_bytes",
            "XFS_DATA_FORK"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(mp)"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "XFS_ILOG_CORE"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "0"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "committed"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&free_list",
            "&committed"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "done"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bunmapi",
          "args": [
            "tp",
            "ip",
            "0",
            "size",
            "XFS_BMAPI_METADATA",
            "nmaps",
            "&first_block",
            "&free_list",
            "&done"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bunmapi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "5030-5403",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "tp",
            "bp"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_buf",
          "args": [
            "tp",
            "mp->m_ddev_targp",
            "XFS_FSB_TO_DADDR(mp, mval[i].br_startblock)",
            "XFS_FSB_TO_BB(mp, mval[i].br_blockcount)",
            "0"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "166-176",
          "snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "mval[i].br_blockcount"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "mval[i].br_startblock"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "0",
            "xfs_symlink_blocks(mp, size)",
            "mval",
            "&nmaps",
            "0"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_symlink_blocks",
          "args": [
            "mp",
            "size"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_symlink_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_symlink_remote.c",
          "lines": "40-48",
          "snippet": "int\nxfs_symlink_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tpathlen)\n{\n\tint buflen = XFS_SYMLINK_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\n\treturn (pathlen + buflen - 1) / buflen;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_symlink_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tpathlen)\n{\n\tint buflen = XFS_SYMLINK_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\n\treturn (pathlen + buflen - 1) / buflen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mval"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&free_list",
            "&first_block"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_itruncate",
            "0",
            "0"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_INACTIVE"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_nextents > 0 && ip->i_d.di_nextents <= 2"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_df.if_flags & XFS_IFEXTENTS"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_inactive_symlink_rmt(\n\tstruct xfs_inode *ip)\n{\n\txfs_buf_t\t*bp;\n\tint\t\tcommitted;\n\tint\t\tdone;\n\tint\t\terror;\n\txfs_fsblock_t\tfirst_block;\n\txfs_bmap_free_t\tfree_list;\n\tint\t\ti;\n\txfs_mount_t\t*mp;\n\txfs_bmbt_irec_t\tmval[XFS_SYMLINK_MAPS];\n\tint\t\tnmaps;\n\tint\t\tsize;\n\txfs_trans_t\t*tp;\n\n\tmp = ip->i_mount;\n\tASSERT(ip->i_df.if_flags & XFS_IFEXTENTS);\n\t/*\n\t * We're freeing a symlink that has some\n\t * blocks allocated to it.  Free the\n\t * blocks here.  We know that we've got\n\t * either 1 or 2 extents and that we can\n\t * free them all in one bunmapi call.\n\t */\n\tASSERT(ip->i_d.di_nextents > 0 && ip->i_d.di_nextents <= 2);\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_INACTIVE);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_itruncate, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(tp, ip, 0);\n\n\t/*\n\t * Lock the inode, fix the size, and join it to the transaction.\n\t * Hold it so in the normal path, we still have it locked for\n\t * the second transaction.  In the error paths we need it\n\t * held so the cancel won't rele it, see below.\n\t */\n\tsize = (int)ip->i_d.di_size;\n\tip->i_d.di_size = 0;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t/*\n\t * Find the block(s) so we can inval and unmap them.\n\t */\n\tdone = 0;\n\txfs_bmap_init(&free_list, &first_block);\n\tnmaps = ARRAY_SIZE(mval);\n\terror = xfs_bmapi_read(ip, 0, xfs_symlink_blocks(mp, size),\n\t\t\t\tmval, &nmaps, 0);\n\tif (error)\n\t\tgoto error_trans_cancel;\n\t/*\n\t * Invalidate the block(s). No validation is done.\n\t */\n\tfor (i = 0; i < nmaps; i++) {\n\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp,\n\t\t\tXFS_FSB_TO_DADDR(mp, mval[i].br_startblock),\n\t\t\tXFS_FSB_TO_BB(mp, mval[i].br_blockcount), 0);\n\t\tif (!bp) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto error_bmap_cancel;\n\t\t}\n\t\txfs_trans_binval(tp, bp);\n\t}\n\t/*\n\t * Unmap the dead block(s) to the free_list.\n\t */\n\terror = xfs_bunmapi(tp, ip, 0, size, XFS_BMAPI_METADATA, nmaps,\n\t\t\t    &first_block, &free_list, &done);\n\tif (error)\n\t\tgoto error_bmap_cancel;\n\tASSERT(done);\n\t/*\n\t * Commit the first transaction.  This logs the EFI and the inode.\n\t */\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error)\n\t\tgoto error_bmap_cancel;\n\t/*\n\t * The transaction must have been committed, since there were\n\t * actually extents freed by xfs_bunmapi.  See xfs_bmap_finish.\n\t * The new tp has the extent freeing and EFDs.\n\t */\n\tASSERT(committed);\n\t/*\n\t * The first xact was committed, so add the inode to the new one.\n\t * Mark it dirty so it will be logged and moved forward in the log as\n\t * part of every commit.\n\t */\n\txfs_trans_ijoin(tp, ip, 0);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\t/*\n\t * Commit the transaction containing extent freeing and EFDs.\n\t */\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\tif (error) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\tgoto error_unlock;\n\t}\n\n\t/*\n\t * Remove the memory for extent descriptions (just bookkeeping).\n\t */\n\tif (ip->i_df.if_bytes)\n\t\txfs_idata_realloc(ip, -ip->i_df.if_bytes, XFS_DATA_FORK);\n\tASSERT(ip->i_df.if_bytes == 0);\n\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn 0;\n\nerror_bmap_cancel:\n\txfs_bmap_cancel(&free_list);\nerror_trans_cancel:\n\txfs_trans_cancel(tp, XFS_TRANS_RELEASE_LOG_RES | XFS_TRANS_ABORT);\nerror_unlock:\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_symlink.c",
    "lines": "165-421",
    "snippet": "int\nxfs_symlink(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_name\t\t*link_name,\n\tconst char\t\t*target_path,\n\tumode_t\t\t\tmode,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_trans\t*tp = NULL;\n\tstruct xfs_inode\t*ip = NULL;\n\tint\t\t\terror = 0;\n\tint\t\t\tpathlen;\n\tstruct xfs_bmap_free\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tbool\t\t\tunlock_dp_on_error = false;\n\tuint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\txfs_fileoff_t\t\tfirst_fsb;\n\txfs_filblks_t\t\tfs_blocks;\n\tint\t\t\tnmaps;\n\tstruct xfs_bmbt_irec\tmval[XFS_SYMLINK_MAPS];\n\txfs_daddr_t\t\td;\n\tconst char\t\t*cur_chunk;\n\tint\t\t\tbyte_cnt;\n\tint\t\t\tn;\n\txfs_buf_t\t\t*bp;\n\tprid_t\t\t\tprid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tuint\t\t\tresblks;\n\n\t*ipp = NULL;\n\n\ttrace_xfs_symlink(dp, link_name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\t/*\n\t * Check component lengths of the target path name.\n\t */\n\tpathlen = strlen(target_path);\n\tif (pathlen >= MAXPATHLEN)      /* total string too long */\n\t\treturn -ENAMETOOLONG;\n\n\tudqp = gdqp = NULL;\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp,\n\t\t\txfs_kuid_to_uid(current_fsuid()),\n\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\tgoto std_return;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SYMLINK);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\t/*\n\t * The symlink will fit into the inode data fork?\n\t * There can't be any attributes so we get the whole variable part.\n\t */\n\tif (pathlen <= XFS_LITINO(mp, dp->i_d.di_version))\n\t\tfs_blocks = 0;\n\telse\n\t\tfs_blocks = xfs_symlink_blocks(mp, pathlen);\n\tresblks = XFS_SYMLINK_SPACE_RES(mp, link_name->len, fs_blocks);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_symlink, resblks, 0);\n\tif (error == -ENOSPC && fs_blocks == 0) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_symlink, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto error_return;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\n\tunlock_dp_on_error = true;\n\n\t/*\n\t * Check whether the directory allows new symlinks or not.\n\t */\n\tif (dp->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) {\n\t\terror = -EPERM;\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * Reserve disk quota : blocks and inode.\n\t */\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto error_return;\n\n\t/*\n\t * Check for ability to enter directory entry, if no space reserved.\n\t */\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, dp, link_name);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t}\n\t/*\n\t * Initialize the bmap freelist prior to calling either\n\t * bmapi or the directory create code.\n\t */\n\txfs_bmap_init(&free_list, &first_block);\n\n\t/*\n\t * Allocate an inode for the symlink.\n\t */\n\terror = xfs_dir_ialloc(&tp, dp, S_IFLNK | (mode & ~S_IFMT), 1, 0,\n\t\t\t       prid, resblks > 0, &ip, NULL);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\tgoto error_return;\n\t\tgoto error1;\n\t}\n\n\t/*\n\t * An error after we've joined dp to the transaction will result in the\n\t * transaction cancel unlocking dp so don't do it explicitly in the\n\t * error path.\n\t */\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\tunlock_dp_on_error = false;\n\n\t/*\n\t * Also attach the dquot(s) to it, if applicable.\n\t */\n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\tif (resblks)\n\t\tresblks -= XFS_IALLOC_SPACE_RES(mp);\n\t/*\n\t * If the symlink will fit into the inode, write it inline.\n\t */\n\tif (pathlen <= XFS_IFORK_DSIZE(ip)) {\n\t\txfs_idata_realloc(ip, pathlen, XFS_DATA_FORK);\n\t\tmemcpy(ip->i_df.if_u1.if_data, target_path, pathlen);\n\t\tip->i_d.di_size = pathlen;\n\n\t\t/*\n\t\t * The inode was initially created in extent format.\n\t\t */\n\t\tip->i_df.if_flags &= ~(XFS_IFEXTENTS | XFS_IFBROOT);\n\t\tip->i_df.if_flags |= XFS_IFINLINE;\n\n\t\tip->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_DDATA | XFS_ILOG_CORE);\n\n\t} else {\n\t\tint\toffset;\n\n\t\tfirst_fsb = 0;\n\t\tnmaps = XFS_SYMLINK_MAPS;\n\n\t\terror = xfs_bmapi_write(tp, ip, first_fsb, fs_blocks,\n\t\t\t\t  XFS_BMAPI_METADATA, &first_block, resblks,\n\t\t\t\t  mval, &nmaps, &free_list);\n\t\tif (error)\n\t\t\tgoto error2;\n\n\t\tif (resblks)\n\t\t\tresblks -= fs_blocks;\n\t\tip->i_d.di_size = pathlen;\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\t\tcur_chunk = target_path;\n\t\toffset = 0;\n\t\tfor (n = 0; n < nmaps; n++) {\n\t\t\tchar\t*buf;\n\n\t\t\td = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\n\t\t\tbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\n\t\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\t\t       BTOBB(byte_cnt), 0);\n\t\t\tif (!bp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto error2;\n\t\t\t}\n\t\t\tbp->b_ops = &xfs_symlink_buf_ops;\n\n\t\t\tbyte_cnt = XFS_SYMLINK_BUF_SPACE(mp, byte_cnt);\n\t\t\tbyte_cnt = min(byte_cnt, pathlen);\n\n\t\t\tbuf = bp->b_addr;\n\t\t\tbuf += xfs_symlink_hdr_set(mp, ip->i_ino, offset,\n\t\t\t\t\t\t   byte_cnt, bp);\n\n\t\t\tmemcpy(buf, cur_chunk, byte_cnt);\n\n\t\t\tcur_chunk += byte_cnt;\n\t\t\tpathlen -= byte_cnt;\n\t\t\toffset += byte_cnt;\n\n\t\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SYMLINK_BUF);\n\t\t\txfs_trans_log_buf(tp, bp, 0, (buf + byte_cnt - 1) -\n\t\t\t\t\t\t\t(char *)bp->b_addr);\n\t\t}\n\t\tASSERT(pathlen == 0);\n\t}\n\n\t/*\n\t * Create the directory entry for the symlink.\n\t */\n\terror = xfs_dir_createname(tp, dp, link_name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error)\n\t\tgoto error2;\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * symlink transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\n\t\txfs_trans_set_sync(tp);\n\t}\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error) {\n\t\tgoto error2;\n\t}\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n error2:\n\tIRELE(ip);\n error1:\n\txfs_bmap_cancel(&free_list);\n\tcancel_flags |= XFS_TRANS_ABORT;\n error_return:\n\txfs_trans_cancel(tp, cancel_flags);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\tif (unlock_dp_on_error)\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n std_return:\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "dp",
            "XFS_ILOCK_EXCL"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_dqrele",
          "args": [
            "pdqp"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_dqrele",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_dquot.c",
          "lines": "862-879",
          "snippet": "void\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_dqrele(\n\txfs_dquot_t\t*dqp)\n{\n\tif (!dqp)\n\t\treturn;\n\n\ttrace_xfs_dqrele(dqp);\n\n\txfs_dqlock(dqp);\n\t/*\n\t * We don't care to flush it if the dquot is dirty here.\n\t * That will create stutters that we want to avoid.\n\t * Instead we do a delayed write when we try to reclaim\n\t * a dirty dquot. Also xfs_sync will take part of the burden...\n\t */\n\txfs_qm_dqput(dqp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "cancel_flags"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "&free_list"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IRELE",
          "args": [
            "ip"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&free_list",
            "&committed"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "dp",
            "XFS_ILOG_CORE"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ichgtime",
          "args": [
            "tp",
            "dp",
            "XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ichgtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "64-90",
          "snippet": "void\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ichgtime(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tstruct inode\t\t*inode = VFS_I(ip);\n\tstruct timespec\t\ttv;\n\n\tASSERT(tp);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\ttv = current_fs_time(inode->i_sb);\n\n\tif ((flags & XFS_ICHGTIME_MOD) &&\n\t    !timespec_equal(&inode->i_mtime, &tv)) {\n\t\tinode->i_mtime = tv;\n\t\tip->i_d.di_mtime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_mtime.t_nsec = tv.tv_nsec;\n\t}\n\tif ((flags & XFS_ICHGTIME_CHG) &&\n\t    !timespec_equal(&inode->i_ctime, &tv)) {\n\t\tinode->i_ctime = tv;\n\t\tip->i_d.di_ctime.t_sec = tv.tv_sec;\n\t\tip->i_d.di_ctime.t_nsec = tv.tv_nsec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_createname",
          "args": [
            "tp",
            "dp",
            "link_name",
            "ip->i_ino",
            "&first_block",
            "&free_list",
            "resblks"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_createname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "255-321",
          "snippet": "int\nxfs_dir_createname(\n\txfs_trans_t\t\t*tp,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tinum,\t\t/* new entry inode number */\n\txfs_fsblock_t\t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_createname(\n\txfs_trans_t\t\t*tp,\n\txfs_inode_t\t\t*dp,\n\tstruct xfs_name\t\t*name,\n\txfs_ino_t\t\tinum,\t\t/* new entry inode number */\n\txfs_fsblock_t\t\t*first,\t\t/* bmap's firstblock */\n\txfs_bmap_free_t\t\t*flist,\t\t/* bmap's freeblock list */\n\txfs_extlen_t\t\ttotal)\t\t/* bmap's total block count */\n{\n\tstruct xfs_da_args\t*args;\n\tint\t\t\trval;\n\tint\t\t\tv;\t\t/* type-checking value */\n\n\tASSERT(S_ISDIR(dp->i_d.di_mode));\n\tif (inum) {\n\t\trval = xfs_dir_ino_validate(tp->t_mountp, inum);\n\t\tif (rval)\n\t\t\treturn rval;\n\t\tXFS_STATS_INC(xs_dir_create);\n\t}\n\n\targs = kmem_zalloc(sizeof(*args), KM_SLEEP | KM_NOFS);\n\tif (!args)\n\t\treturn -ENOMEM;\n\n\targs->geo = dp->i_mount->m_dir_geo;\n\targs->name = name->name;\n\targs->namelen = name->len;\n\targs->filetype = name->type;\n\targs->hashval = dp->i_mount->m_dirnameops->hashname(name);\n\targs->inumber = inum;\n\targs->dp = dp;\n\targs->firstblock = first;\n\targs->flist = flist;\n\targs->total = total;\n\targs->whichfork = XFS_DATA_FORK;\n\targs->trans = tp;\n\targs->op_flags = XFS_DA_OP_ADDNAME | XFS_DA_OP_OKNOENT;\n\tif (!inum)\n\t\targs->op_flags |= XFS_DA_OP_JUSTCHECK;\n\n\tif (dp->i_d.di_format == XFS_DINODE_FMT_LOCAL) {\n\t\trval = xfs_dir2_sf_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isblock(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v) {\n\t\trval = xfs_dir2_block_addname(args);\n\t\tgoto out_free;\n\t}\n\n\trval = xfs_dir2_isleaf(args, &v);\n\tif (rval)\n\t\tgoto out_free;\n\tif (v)\n\t\trval = xfs_dir2_leaf_addname(args);\n\telse\n\t\trval = xfs_dir2_node_addname(args);\n\nout_free:\n\tkmem_free(args);\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pathlen == 0"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "0",
            "(buf + byte_cnt - 1) -\n\t\t\t\t\t\t\t(char *)bp->b_addr"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_SYMLINK_BUF"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "cur_chunk",
            "byte_cnt"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_symlink_hdr_set",
          "args": [
            "mp",
            "ip->i_ino",
            "offset",
            "byte_cnt",
            "bp"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_symlink_hdr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_symlink_remote.c",
          "lines": "50-72",
          "snippet": "int\nxfs_symlink_hdr_set(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dsymlink_hdr\t*dsl = bp->b_addr;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn 0;\n\n\tdsl->sl_magic = cpu_to_be32(XFS_SYMLINK_MAGIC);\n\tdsl->sl_offset = cpu_to_be32(offset);\n\tdsl->sl_bytes = cpu_to_be32(size);\n\tuuid_copy(&dsl->sl_uuid, &mp->m_sb.sb_uuid);\n\tdsl->sl_owner = cpu_to_be64(ino);\n\tdsl->sl_blkno = cpu_to_be64(bp->b_bn);\n\tbp->b_ops = &xfs_symlink_buf_ops;\n\n\treturn sizeof(struct xfs_dsymlink_hdr);\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const struct xfs_buf_ops xfs_symlink_buf_ops = {\n\t.verify_read = xfs_symlink_read_verify,\n\t.verify_write = xfs_symlink_write_verify,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nconst struct xfs_buf_ops xfs_symlink_buf_ops = {\n\t.verify_read = xfs_symlink_read_verify,\n\t.verify_write = xfs_symlink_write_verify,\n};\n\nint\nxfs_symlink_hdr_set(\n\tstruct xfs_mount\t*mp,\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dsymlink_hdr\t*dsl = bp->b_addr;\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn 0;\n\n\tdsl->sl_magic = cpu_to_be32(XFS_SYMLINK_MAGIC);\n\tdsl->sl_offset = cpu_to_be32(offset);\n\tdsl->sl_bytes = cpu_to_be32(size);\n\tuuid_copy(&dsl->sl_uuid, &mp->m_sb.sb_uuid);\n\tdsl->sl_owner = cpu_to_be64(ino);\n\tdsl->sl_blkno = cpu_to_be64(bp->b_bn);\n\tbp->b_ops = &xfs_symlink_buf_ops;\n\n\treturn sizeof(struct xfs_dsymlink_hdr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "byte_cnt",
            "pathlen"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_SYMLINK_BUF_SPACE",
          "args": [
            "mp",
            "byte_cnt"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_buf",
          "args": [
            "tp",
            "mp->m_ddev_targp",
            "d",
            "BTOBB(byte_cnt)",
            "0"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_get_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.h",
          "lines": "166-176",
          "snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct xfs_buf *\nxfs_trans_get_buf(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tint\t\t\tnumblks,\n\tuint\t\t\tflags)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_trans_get_buf_map(tp, target, &map, 1, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "byte_cnt"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "mval[n].br_blockcount"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "mval[n].br_startblock"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_write",
          "args": [
            "tp",
            "ip",
            "first_fsb",
            "fs_blocks",
            "XFS_BMAPI_METADATA",
            "&first_block",
            "resblks",
            "mval",
            "&nmaps",
            "&free_list"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4483-4700",
          "snippet": "int\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ip->i_df.if_u1.if_data",
            "target_path",
            "pathlen"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "ip",
            "pathlen",
            "XFS_DATA_FORK"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_DSIZE",
          "args": [
            "ip"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IALLOC_SPACE_RES",
          "args": [
            "mp"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_create_dqattach",
          "args": [
            "tp",
            "ip",
            "udqp",
            "gdqp",
            "pdqp"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_create_dqattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_qm.c",
          "lines": "1897-1933",
          "snippet": "void\nxfs_qm_vop_create_dqattach(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tif (udqp && XFS_IS_UQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_udquot == NULL);\n\t\tASSERT(ip->i_d.di_uid == be32_to_cpu(udqp->q_core.d_id));\n\n\t\tip->i_udquot = xfs_qm_dqhold(udqp);\n\t\txfs_trans_mod_dquot(tp, udqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (gdqp && XFS_IS_GQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_gdquot == NULL);\n\t\tASSERT(ip->i_d.di_gid == be32_to_cpu(gdqp->q_core.d_id));\n\t\tip->i_gdquot = xfs_qm_dqhold(gdqp);\n\t\txfs_trans_mod_dquot(tp, gdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (pdqp && XFS_IS_PQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_pdquot == NULL);\n\t\tASSERT(xfs_get_projid(ip) == be32_to_cpu(pdqp->q_core.d_id));\n\n\t\tip->i_pdquot = xfs_qm_dqhold(pdqp);\n\t\txfs_trans_mod_dquot(tp, pdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_itable.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_itable.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_qm_vop_create_dqattach(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(XFS_IS_QUOTA_RUNNING(mp));\n\n\tif (udqp && XFS_IS_UQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_udquot == NULL);\n\t\tASSERT(ip->i_d.di_uid == be32_to_cpu(udqp->q_core.d_id));\n\n\t\tip->i_udquot = xfs_qm_dqhold(udqp);\n\t\txfs_trans_mod_dquot(tp, udqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (gdqp && XFS_IS_GQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_gdquot == NULL);\n\t\tASSERT(ip->i_d.di_gid == be32_to_cpu(gdqp->q_core.d_id));\n\t\tip->i_gdquot = xfs_qm_dqhold(gdqp);\n\t\txfs_trans_mod_dquot(tp, gdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n\tif (pdqp && XFS_IS_PQUOTA_ON(mp)) {\n\t\tASSERT(ip->i_pdquot == NULL);\n\t\tASSERT(xfs_get_projid(ip) == be32_to_cpu(pdqp->q_core.d_id));\n\n\t\tip->i_pdquot = xfs_qm_dqhold(pdqp);\n\t\txfs_trans_mod_dquot(tp, pdqp, XFS_TRANS_DQ_ICOUNT, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "dp",
            "XFS_ILOCK_EXCL"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_ialloc",
          "args": [
            "&tp",
            "dp",
            "S_IFLNK | (mode & ~S_IFMT)",
            "1",
            "0",
            "prid",
            "resblks > 0",
            "&ip",
            "NULL"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_ialloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "838-1009",
          "snippet": "int\nxfs_dir_ialloc(\n\txfs_trans_t\t**tpp,\t\t/* input: current transaction;\n\t\t\t\t\t   output: may be a new transaction. */\n\txfs_inode_t\t*dp,\t\t/* directory within whose allocate\n\t\t\t\t\t   the inode. */\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\t\t/* project id */\n\tint\t\tokalloc,\t/* ok to allocate new space */\n\txfs_inode_t\t**ipp,\t\t/* pointer to inode; it will be\n\t\t\t\t\t   locked. */\n\tint\t\t*committed)\n\n{\n\txfs_trans_t\t*tp;\n\txfs_trans_t\t*ntp;\n\txfs_inode_t\t*ip;\n\txfs_buf_t\t*ialloc_context = NULL;\n\tint\t\tcode;\n\tvoid\t\t*dqinfo;\n\tuint\t\ttflags;\n\n\ttp = *tpp;\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\t/*\n\t * xfs_ialloc will return a pointer to an incore inode if\n\t * the Space Manager has an available inode on the free\n\t * list. Otherwise, it will do an allocation and replenish\n\t * the freelist.  Since we can only do one allocation per\n\t * transaction without deadlocks, we will need to commit the\n\t * current transaction and start a new one.  We will then\n\t * need to call xfs_ialloc again to get the inode.\n\t *\n\t * If xfs_ialloc did an allocation to replenish the freelist,\n\t * it returns the bp containing the head of the freelist as\n\t * ialloc_context. We will hold a lock on it across the\n\t * transaction commit so that no other process can steal\n\t * the inode(s) that we've just allocated.\n\t */\n\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid, okalloc,\n\t\t\t  &ialloc_context, &ip);\n\n\t/*\n\t * Return an error if we were unable to allocate a new inode.\n\t * This should only happen if we run out of space on disk or\n\t * encounter a disk error.\n\t */\n\tif (code) {\n\t\t*ipp = NULL;\n\t\treturn code;\n\t}\n\tif (!ialloc_context && !ip) {\n\t\t*ipp = NULL;\n\t\treturn -ENOSPC;\n\t}\n\n\t/*\n\t * If the AGI buffer is non-NULL, then we were unable to get an\n\t * inode in one operation.  We need to commit the current\n\t * transaction and call xfs_ialloc() again.  It is guaranteed\n\t * to succeed the second time.\n\t */\n\tif (ialloc_context) {\n\t\tstruct xfs_trans_res tres;\n\n\t\t/*\n\t\t * Normally, xfs_trans_commit releases all the locks.\n\t\t * We call bhold to hang on to the ialloc_context across\n\t\t * the commit.  Holding this buffer prevents any other\n\t\t * processes from doing any allocations in this\n\t\t * allocation group.\n\t\t */\n\t\txfs_trans_bhold(tp, ialloc_context);\n\t\t/*\n\t\t * Save the log reservation so we can use\n\t\t * them in the next transaction.\n\t\t */\n\t\ttres.tr_logres = xfs_trans_get_log_res(tp);\n\t\ttres.tr_logcount = xfs_trans_get_log_count(tp);\n\n\t\t/*\n\t\t * We want the quota changes to be associated with the next\n\t\t * transaction, NOT this one. So, detach the dqinfo from this\n\t\t * and attach it to the next transaction.\n\t\t */\n\t\tdqinfo = NULL;\n\t\ttflags = 0;\n\t\tif (tp->t_dqinfo) {\n\t\t\tdqinfo = (void *)tp->t_dqinfo;\n\t\t\ttp->t_dqinfo = NULL;\n\t\t\ttflags = tp->t_flags & XFS_TRANS_DQ_DIRTY;\n\t\t\ttp->t_flags &= ~(XFS_TRANS_DQ_DIRTY);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\tcode = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\t\tif (committed != NULL) {\n\t\t\t*committed = 1;\n\t\t}\n\t\t/*\n\t\t * If we get an error during the commit processing,\n\t\t * release the buffer that is still held and return\n\t\t * to the caller.\n\t\t */\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\tif (dqinfo) {\n\t\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\t\txfs_trans_free_dqinfo(tp);\n\t\t\t}\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\n\t\t/*\n\t\t * transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\t\tcode = xfs_trans_reserve(tp, &tres, 0, 0);\n\n\t\t/*\n\t\t * Re-attach the quota info that we detached from prev trx.\n\t\t */\n\t\tif (dqinfo) {\n\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\ttp->t_flags |= tflags;\n\t\t}\n\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\txfs_trans_bjoin(tp, ialloc_context);\n\n\t\t/*\n\t\t * Call ialloc again. Since we've locked out all\n\t\t * other allocations in this allocation group,\n\t\t * this call should always succeed.\n\t\t */\n\t\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid,\n\t\t\t\t  okalloc, &ialloc_context, &ip);\n\n\t\t/*\n\t\t * If we get an error at this point, return to the caller\n\t\t * so that the current transaction can be aborted.\n\t\t */\n\t\tif (code) {\n\t\t\t*tpp = tp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\tASSERT(!ialloc_context && ip);\n\n\t} else {\n\t\tif (committed != NULL)\n\t\t\t*committed = 0;\n\t}\n\n\t*ipp = ip;\n\t*tpp = tp;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);",
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iflush_int(xfs_inode_t *, xfs_buf_t *);\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_dir_ialloc(\n\txfs_trans_t\t**tpp,\t\t/* input: current transaction;\n\t\t\t\t\t   output: may be a new transaction. */\n\txfs_inode_t\t*dp,\t\t/* directory within whose allocate\n\t\t\t\t\t   the inode. */\n\tumode_t\t\tmode,\n\txfs_nlink_t\tnlink,\n\txfs_dev_t\trdev,\n\tprid_t\t\tprid,\t\t/* project id */\n\tint\t\tokalloc,\t/* ok to allocate new space */\n\txfs_inode_t\t**ipp,\t\t/* pointer to inode; it will be\n\t\t\t\t\t   locked. */\n\tint\t\t*committed)\n\n{\n\txfs_trans_t\t*tp;\n\txfs_trans_t\t*ntp;\n\txfs_inode_t\t*ip;\n\txfs_buf_t\t*ialloc_context = NULL;\n\tint\t\tcode;\n\tvoid\t\t*dqinfo;\n\tuint\t\ttflags;\n\n\ttp = *tpp;\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\n\t/*\n\t * xfs_ialloc will return a pointer to an incore inode if\n\t * the Space Manager has an available inode on the free\n\t * list. Otherwise, it will do an allocation and replenish\n\t * the freelist.  Since we can only do one allocation per\n\t * transaction without deadlocks, we will need to commit the\n\t * current transaction and start a new one.  We will then\n\t * need to call xfs_ialloc again to get the inode.\n\t *\n\t * If xfs_ialloc did an allocation to replenish the freelist,\n\t * it returns the bp containing the head of the freelist as\n\t * ialloc_context. We will hold a lock on it across the\n\t * transaction commit so that no other process can steal\n\t * the inode(s) that we've just allocated.\n\t */\n\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid, okalloc,\n\t\t\t  &ialloc_context, &ip);\n\n\t/*\n\t * Return an error if we were unable to allocate a new inode.\n\t * This should only happen if we run out of space on disk or\n\t * encounter a disk error.\n\t */\n\tif (code) {\n\t\t*ipp = NULL;\n\t\treturn code;\n\t}\n\tif (!ialloc_context && !ip) {\n\t\t*ipp = NULL;\n\t\treturn -ENOSPC;\n\t}\n\n\t/*\n\t * If the AGI buffer is non-NULL, then we were unable to get an\n\t * inode in one operation.  We need to commit the current\n\t * transaction and call xfs_ialloc() again.  It is guaranteed\n\t * to succeed the second time.\n\t */\n\tif (ialloc_context) {\n\t\tstruct xfs_trans_res tres;\n\n\t\t/*\n\t\t * Normally, xfs_trans_commit releases all the locks.\n\t\t * We call bhold to hang on to the ialloc_context across\n\t\t * the commit.  Holding this buffer prevents any other\n\t\t * processes from doing any allocations in this\n\t\t * allocation group.\n\t\t */\n\t\txfs_trans_bhold(tp, ialloc_context);\n\t\t/*\n\t\t * Save the log reservation so we can use\n\t\t * them in the next transaction.\n\t\t */\n\t\ttres.tr_logres = xfs_trans_get_log_res(tp);\n\t\ttres.tr_logcount = xfs_trans_get_log_count(tp);\n\n\t\t/*\n\t\t * We want the quota changes to be associated with the next\n\t\t * transaction, NOT this one. So, detach the dqinfo from this\n\t\t * and attach it to the next transaction.\n\t\t */\n\t\tdqinfo = NULL;\n\t\ttflags = 0;\n\t\tif (tp->t_dqinfo) {\n\t\t\tdqinfo = (void *)tp->t_dqinfo;\n\t\t\ttp->t_dqinfo = NULL;\n\t\t\ttflags = tp->t_flags & XFS_TRANS_DQ_DIRTY;\n\t\t\ttp->t_flags &= ~(XFS_TRANS_DQ_DIRTY);\n\t\t}\n\n\t\tntp = xfs_trans_dup(tp);\n\t\tcode = xfs_trans_commit(tp, 0);\n\t\ttp = ntp;\n\t\tif (committed != NULL) {\n\t\t\t*committed = 1;\n\t\t}\n\t\t/*\n\t\t * If we get an error during the commit processing,\n\t\t * release the buffer that is still held and return\n\t\t * to the caller.\n\t\t */\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\tif (dqinfo) {\n\t\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\t\txfs_trans_free_dqinfo(tp);\n\t\t\t}\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\n\t\t/*\n\t\t * transaction commit worked ok so we can drop the extra ticket\n\t\t * reference that we gained in xfs_trans_dup()\n\t\t */\n\t\txfs_log_ticket_put(tp->t_ticket);\n\t\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\t\tcode = xfs_trans_reserve(tp, &tres, 0, 0);\n\n\t\t/*\n\t\t * Re-attach the quota info that we detached from prev trx.\n\t\t */\n\t\tif (dqinfo) {\n\t\t\ttp->t_dqinfo = dqinfo;\n\t\t\ttp->t_flags |= tflags;\n\t\t}\n\n\t\tif (code) {\n\t\t\txfs_buf_relse(ialloc_context);\n\t\t\t*tpp = ntp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\txfs_trans_bjoin(tp, ialloc_context);\n\n\t\t/*\n\t\t * Call ialloc again. Since we've locked out all\n\t\t * other allocations in this allocation group,\n\t\t * this call should always succeed.\n\t\t */\n\t\tcode = xfs_ialloc(tp, dp, mode, nlink, rdev, prid,\n\t\t\t\t  okalloc, &ialloc_context, &ip);\n\n\t\t/*\n\t\t * If we get an error at this point, return to the caller\n\t\t * so that the current transaction can be aborted.\n\t\t */\n\t\tif (code) {\n\t\t\t*tpp = tp;\n\t\t\t*ipp = NULL;\n\t\t\treturn code;\n\t\t}\n\t\tASSERT(!ialloc_context && ip);\n\n\t} else {\n\t\tif (committed != NULL)\n\t\t\t*committed = 0;\n\t}\n\n\t*ipp = ip;\n\t*tpp = tp;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&free_list",
            "&first_block"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_dir_canenter",
          "args": [
            "tp",
            "dp",
            "link_name"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir_canenter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2.c",
          "lines": "556-563",
          "snippet": "int\nxfs_dir_canenter(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name)\t\t/* name of entry to add */\n{\n\treturn xfs_dir_createname(tp, dp, name, 0, NULL, NULL, 0);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_dir_canenter(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*dp,\n\tstruct xfs_name\t*name)\t\t/* name of entry to add */\n{\n\treturn xfs_dir_createname(tp, dp, name, 0, NULL, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve_quota",
          "args": [
            "tp",
            "mp",
            "udqp",
            "gdqp",
            "pdqp",
            "resblks",
            "1",
            "0"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve_quota_bydquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "740-794",
          "snippet": "int\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_bydquots(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_dquot\t*udqp,\n\tstruct xfs_dquot\t*gdqp,\n\tstruct xfs_dquot\t*pdqp,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tint\t\terror;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\n\tif (tp && tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tASSERT(flags & XFS_QMOPT_RESBLK_MASK);\n\n\tif (udqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, udqp, nblks, ninos,\n\t\t\t\t\t(flags & ~XFS_QMOPT_ENOSPC));\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (gdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, gdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_usr;\n\t}\n\n\tif (pdqp) {\n\t\terror = xfs_trans_dqresv(tp, mp, pdqp, nblks, ninos, flags);\n\t\tif (error)\n\t\t\tgoto unwind_grp;\n\t}\n\n\t/*\n\t * Didn't change anything critical, so, no need to log\n\t */\n\treturn 0;\n\nunwind_grp:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (gdqp)\n\t\txfs_trans_dqresv(tp, mp, gdqp, -nblks, -ninos, flags);\nunwind_usr:\n\tflags |= XFS_QMOPT_FORCE_RES;\n\tif (udqp)\n\t\txfs_trans_dqresv(tp, mp, udqp, -nblks, -ninos, flags);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "dp",
            "XFS_ILOCK_EXCL | XFS_ILOCK_PARENT"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_symlink",
            "0",
            "0"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_SYMLINK_SPACE_RES",
          "args": [
            "mp",
            "link_name->len",
            "fs_blocks"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_symlink_blocks",
          "args": [
            "mp",
            "pathlen"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_symlink_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_symlink_remote.c",
          "lines": "40-48",
          "snippet": "int\nxfs_symlink_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tpathlen)\n{\n\tint buflen = XFS_SYMLINK_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\n\treturn (pathlen + buflen - 1) / buflen;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_symlink_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tpathlen)\n{\n\tint buflen = XFS_SYMLINK_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\n\treturn (pathlen + buflen - 1) / buflen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_LITINO",
          "args": [
            "mp",
            "dp->i_d.di_version"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_SYMLINK"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_qm_vop_dqalloc",
          "args": [
            "dp",
            "xfs_kuid_to_uid(current_fsuid())",
            "xfs_kgid_to_gid(current_fsgid())",
            "prid",
            "XFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT",
            "&udqp",
            "&gdqp",
            "&pdqp"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_qm_vop_dqalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_quota.h",
          "lines": "105-114",
          "snippet": "static inline int\nxfs_qm_vop_dqalloc(struct xfs_inode *ip, xfs_dqid_t uid, xfs_dqid_t gid,\n\t\tprid_t prid, uint flags, struct xfs_dquot **udqp,\n\t\tstruct xfs_dquot **gdqp, struct xfs_dquot **pdqp)\n{\n\t*udqp = NULL;\n\t*gdqp = NULL;\n\t*pdqp = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_quota_defs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_quota_defs.h\"\n\nstatic inline int\nxfs_qm_vop_dqalloc(struct xfs_inode *ip, xfs_dqid_t uid, xfs_dqid_t gid,\n\t\tprid_t prid, uint flags, struct xfs_dquot **udqp,\n\t\tstruct xfs_dquot **gdqp, struct xfs_dquot **pdqp)\n{\n\t*udqp = NULL;\n\t*gdqp = NULL;\n\t*pdqp = NULL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_kgid_to_gid",
          "args": [
            "current_fsgid()"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_kgid_to_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "213-216",
          "snippet": "static inline __uint32_t xfs_kgid_to_gid(kgid_t gid)\n{\n\treturn from_kgid(&init_user_ns, gid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint32_t xfs_kgid_to_gid(kgid_t gid)\n{\n\treturn from_kgid(&init_user_ns, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_kuid_to_uid",
          "args": [
            "current_fsuid()"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_kuid_to_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "203-206",
          "snippet": "static inline __uint32_t xfs_kuid_to_uid(kuid_t uid)\n{\n\treturn from_kuid(&init_user_ns, uid);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint32_t xfs_kuid_to_uid(kuid_t uid)\n{\n\treturn from_kuid(&init_user_ns, uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_get_initial_prid",
          "args": [
            "dp"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_initial_prid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "195-202",
          "snippet": "static inline prid_t\nxfs_get_initial_prid(struct xfs_inode *dp)\n{\n\tif (dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\treturn xfs_get_projid(dp);\n\n\treturn XFS_PROJID_DEFAULT;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline prid_t\nxfs_get_initial_prid(struct xfs_inode *dp)\n{\n\tif (dp->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)\n\t\treturn xfs_get_projid(dp);\n\n\treturn XFS_PROJID_DEFAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "target_path"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_symlink",
          "args": [
            "dp",
            "link_name"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nint\nxfs_symlink(\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_name\t\t*link_name,\n\tconst char\t\t*target_path,\n\tumode_t\t\t\tmode,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct xfs_mount\t*mp = dp->i_mount;\n\tstruct xfs_trans\t*tp = NULL;\n\tstruct xfs_inode\t*ip = NULL;\n\tint\t\t\terror = 0;\n\tint\t\t\tpathlen;\n\tstruct xfs_bmap_free\tfree_list;\n\txfs_fsblock_t\t\tfirst_block;\n\tbool\t\t\tunlock_dp_on_error = false;\n\tuint\t\t\tcancel_flags;\n\tint\t\t\tcommitted;\n\txfs_fileoff_t\t\tfirst_fsb;\n\txfs_filblks_t\t\tfs_blocks;\n\tint\t\t\tnmaps;\n\tstruct xfs_bmbt_irec\tmval[XFS_SYMLINK_MAPS];\n\txfs_daddr_t\t\td;\n\tconst char\t\t*cur_chunk;\n\tint\t\t\tbyte_cnt;\n\tint\t\t\tn;\n\txfs_buf_t\t\t*bp;\n\tprid_t\t\t\tprid;\n\tstruct xfs_dquot\t*udqp = NULL;\n\tstruct xfs_dquot\t*gdqp = NULL;\n\tstruct xfs_dquot\t*pdqp = NULL;\n\tuint\t\t\tresblks;\n\n\t*ipp = NULL;\n\n\ttrace_xfs_symlink(dp, link_name);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\t/*\n\t * Check component lengths of the target path name.\n\t */\n\tpathlen = strlen(target_path);\n\tif (pathlen >= MAXPATHLEN)      /* total string too long */\n\t\treturn -ENAMETOOLONG;\n\n\tudqp = gdqp = NULL;\n\tprid = xfs_get_initial_prid(dp);\n\n\t/*\n\t * Make sure that we have allocated dquot(s) on disk.\n\t */\n\terror = xfs_qm_vop_dqalloc(dp,\n\t\t\txfs_kuid_to_uid(current_fsuid()),\n\t\t\txfs_kgid_to_gid(current_fsgid()), prid,\n\t\t\tXFS_QMOPT_QUOTALL | XFS_QMOPT_INHERIT,\n\t\t\t&udqp, &gdqp, &pdqp);\n\tif (error)\n\t\tgoto std_return;\n\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_SYMLINK);\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\t/*\n\t * The symlink will fit into the inode data fork?\n\t * There can't be any attributes so we get the whole variable part.\n\t */\n\tif (pathlen <= XFS_LITINO(mp, dp->i_d.di_version))\n\t\tfs_blocks = 0;\n\telse\n\t\tfs_blocks = xfs_symlink_blocks(mp, pathlen);\n\tresblks = XFS_SYMLINK_SPACE_RES(mp, link_name->len, fs_blocks);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_symlink, resblks, 0);\n\tif (error == -ENOSPC && fs_blocks == 0) {\n\t\tresblks = 0;\n\t\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_symlink, 0, 0);\n\t}\n\tif (error) {\n\t\tcancel_flags = 0;\n\t\tgoto error_return;\n\t}\n\n\txfs_ilock(dp, XFS_ILOCK_EXCL | XFS_ILOCK_PARENT);\n\tunlock_dp_on_error = true;\n\n\t/*\n\t * Check whether the directory allows new symlinks or not.\n\t */\n\tif (dp->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) {\n\t\terror = -EPERM;\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * Reserve disk quota : blocks and inode.\n\t */\n\terror = xfs_trans_reserve_quota(tp, mp, udqp, gdqp,\n\t\t\t\t\t\tpdqp, resblks, 1, 0);\n\tif (error)\n\t\tgoto error_return;\n\n\t/*\n\t * Check for ability to enter directory entry, if no space reserved.\n\t */\n\tif (!resblks) {\n\t\terror = xfs_dir_canenter(tp, dp, link_name);\n\t\tif (error)\n\t\t\tgoto error_return;\n\t}\n\t/*\n\t * Initialize the bmap freelist prior to calling either\n\t * bmapi or the directory create code.\n\t */\n\txfs_bmap_init(&free_list, &first_block);\n\n\t/*\n\t * Allocate an inode for the symlink.\n\t */\n\terror = xfs_dir_ialloc(&tp, dp, S_IFLNK | (mode & ~S_IFMT), 1, 0,\n\t\t\t       prid, resblks > 0, &ip, NULL);\n\tif (error) {\n\t\tif (error == -ENOSPC)\n\t\t\tgoto error_return;\n\t\tgoto error1;\n\t}\n\n\t/*\n\t * An error after we've joined dp to the transaction will result in the\n\t * transaction cancel unlocking dp so don't do it explicitly in the\n\t * error path.\n\t */\n\txfs_trans_ijoin(tp, dp, XFS_ILOCK_EXCL);\n\tunlock_dp_on_error = false;\n\n\t/*\n\t * Also attach the dquot(s) to it, if applicable.\n\t */\n\txfs_qm_vop_create_dqattach(tp, ip, udqp, gdqp, pdqp);\n\n\tif (resblks)\n\t\tresblks -= XFS_IALLOC_SPACE_RES(mp);\n\t/*\n\t * If the symlink will fit into the inode, write it inline.\n\t */\n\tif (pathlen <= XFS_IFORK_DSIZE(ip)) {\n\t\txfs_idata_realloc(ip, pathlen, XFS_DATA_FORK);\n\t\tmemcpy(ip->i_df.if_u1.if_data, target_path, pathlen);\n\t\tip->i_d.di_size = pathlen;\n\n\t\t/*\n\t\t * The inode was initially created in extent format.\n\t\t */\n\t\tip->i_df.if_flags &= ~(XFS_IFEXTENTS | XFS_IFBROOT);\n\t\tip->i_df.if_flags |= XFS_IFINLINE;\n\n\t\tip->i_d.di_format = XFS_DINODE_FMT_LOCAL;\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_DDATA | XFS_ILOG_CORE);\n\n\t} else {\n\t\tint\toffset;\n\n\t\tfirst_fsb = 0;\n\t\tnmaps = XFS_SYMLINK_MAPS;\n\n\t\terror = xfs_bmapi_write(tp, ip, first_fsb, fs_blocks,\n\t\t\t\t  XFS_BMAPI_METADATA, &first_block, resblks,\n\t\t\t\t  mval, &nmaps, &free_list);\n\t\tif (error)\n\t\t\tgoto error2;\n\n\t\tif (resblks)\n\t\t\tresblks -= fs_blocks;\n\t\tip->i_d.di_size = pathlen;\n\t\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\t\tcur_chunk = target_path;\n\t\toffset = 0;\n\t\tfor (n = 0; n < nmaps; n++) {\n\t\t\tchar\t*buf;\n\n\t\t\td = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\n\t\t\tbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\n\t\t\tbp = xfs_trans_get_buf(tp, mp->m_ddev_targp, d,\n\t\t\t\t\t       BTOBB(byte_cnt), 0);\n\t\t\tif (!bp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto error2;\n\t\t\t}\n\t\t\tbp->b_ops = &xfs_symlink_buf_ops;\n\n\t\t\tbyte_cnt = XFS_SYMLINK_BUF_SPACE(mp, byte_cnt);\n\t\t\tbyte_cnt = min(byte_cnt, pathlen);\n\n\t\t\tbuf = bp->b_addr;\n\t\t\tbuf += xfs_symlink_hdr_set(mp, ip->i_ino, offset,\n\t\t\t\t\t\t   byte_cnt, bp);\n\n\t\t\tmemcpy(buf, cur_chunk, byte_cnt);\n\n\t\t\tcur_chunk += byte_cnt;\n\t\t\tpathlen -= byte_cnt;\n\t\t\toffset += byte_cnt;\n\n\t\t\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SYMLINK_BUF);\n\t\t\txfs_trans_log_buf(tp, bp, 0, (buf + byte_cnt - 1) -\n\t\t\t\t\t\t\t(char *)bp->b_addr);\n\t\t}\n\t\tASSERT(pathlen == 0);\n\t}\n\n\t/*\n\t * Create the directory entry for the symlink.\n\t */\n\terror = xfs_dir_createname(tp, dp, link_name, ip->i_ino,\n\t\t\t\t\t&first_block, &free_list, resblks);\n\tif (error)\n\t\tgoto error2;\n\txfs_trans_ichgtime(tp, dp, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * If this is a synchronous mount, make sure that the\n\t * symlink transaction goes to disk before returning to\n\t * the user.\n\t */\n\tif (mp->m_flags & (XFS_MOUNT_WSYNC|XFS_MOUNT_DIRSYNC)) {\n\t\txfs_trans_set_sync(tp);\n\t}\n\n\terror = xfs_bmap_finish(&tp, &free_list, &committed);\n\tif (error) {\n\t\tgoto error2;\n\t}\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\t*ipp = ip;\n\treturn 0;\n\n error2:\n\tIRELE(ip);\n error1:\n\txfs_bmap_cancel(&free_list);\n\tcancel_flags |= XFS_TRANS_ABORT;\n error_return:\n\txfs_trans_cancel(tp, cancel_flags);\n\txfs_qm_dqrele(udqp);\n\txfs_qm_dqrele(gdqp);\n\txfs_qm_dqrele(pdqp);\n\n\tif (unlock_dp_on_error)\n\t\txfs_iunlock(dp, XFS_ILOCK_EXCL);\n std_return:\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_symlink.c",
    "lines": "123-163",
    "snippet": "int\nxfs_readlink(\n\tstruct xfs_inode *ip,\n\tchar\t\t*link)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\txfs_fsize_t\tpathlen;\n\tint\t\terror = 0;\n\n\ttrace_xfs_readlink(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\n\tpathlen = ip->i_d.di_size;\n\tif (!pathlen)\n\t\tgoto out;\n\n\tif (pathlen < 0 || pathlen > MAXPATHLEN) {\n\t\txfs_alert(mp, \"%s: inode (%llu) bad symlink length (%lld)\",\n\t\t\t __func__, (unsigned long long) ip->i_ino,\n\t\t\t (long long) pathlen);\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\n\tif (ip->i_df.if_flags & XFS_IFINLINE) {\n\t\tmemcpy(link, ip->i_df.if_u1.if_data, pathlen);\n\t\tlink[pathlen] = '\\0';\n\t} else {\n\t\terror = xfs_readlink_bmap(ip, link);\n\t}\n\n out:\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_readlink_bmap",
          "args": [
            "ip",
            "link"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_readlink_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_symlink.c",
          "lines": "45-121",
          "snippet": "STATIC int\nxfs_readlink_bmap(\n\tstruct xfs_inode\t*ip,\n\tchar\t\t\t*link)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_bmbt_irec\tmval[XFS_SYMLINK_MAPS];\n\tstruct xfs_buf\t\t*bp;\n\txfs_daddr_t\t\td;\n\tchar\t\t\t*cur_chunk;\n\tint\t\t\tpathlen = ip->i_d.di_size;\n\tint\t\t\tnmaps = XFS_SYMLINK_MAPS;\n\tint\t\t\tbyte_cnt;\n\tint\t\t\tn;\n\tint\t\t\terror = 0;\n\tint\t\t\tfsblocks = 0;\n\tint\t\t\toffset;\n\n\tfsblocks = xfs_symlink_blocks(mp, pathlen);\n\terror = xfs_bmapi_read(ip, 0, fsblocks, mval, &nmaps, 0);\n\tif (error)\n\t\tgoto out;\n\n\toffset = 0;\n\tfor (n = 0; n < nmaps; n++) {\n\t\td = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\n\t\tbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\n\n\t\tbp = xfs_buf_read(mp->m_ddev_targp, d, BTOBB(byte_cnt), 0,\n\t\t\t\t  &xfs_symlink_buf_ops);\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\t\terror = bp->b_error;\n\t\tif (error) {\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\t\txfs_buf_relse(bp);\n\n\t\t\t/* bad CRC means corrupted metadata */\n\t\t\tif (error == -EFSBADCRC)\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\tbyte_cnt = XFS_SYMLINK_BUF_SPACE(mp, byte_cnt);\n\t\tif (pathlen < byte_cnt)\n\t\t\tbyte_cnt = pathlen;\n\n\t\tcur_chunk = bp->b_addr;\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tif (!xfs_symlink_hdr_ok(ip->i_ino, offset,\n\t\t\t\t\t\t\tbyte_cnt, bp)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\txfs_alert(mp,\n\"symlink header does not match required off/len/owner (0x%x/Ox%x,0x%llx)\",\n\t\t\t\t\toffset, byte_cnt, ip->i_ino);\n\t\t\t\txfs_buf_relse(bp);\n\t\t\t\tgoto out;\n\n\t\t\t}\n\n\t\t\tcur_chunk += sizeof(struct xfs_dsymlink_hdr);\n\t\t}\n\n\t\tmemcpy(link + offset, bp->b_addr, byte_cnt);\n\n\t\tpathlen -= byte_cnt;\n\t\toffset += byte_cnt;\n\n\t\txfs_buf_relse(bp);\n\t}\n\tASSERT(pathlen == 0);\n\n\tlink[ip->i_d.di_size] = '\\0';\n\terror = 0;\n\n out:\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_readlink_bmap(\n\tstruct xfs_inode\t*ip,\n\tchar\t\t\t*link)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_bmbt_irec\tmval[XFS_SYMLINK_MAPS];\n\tstruct xfs_buf\t\t*bp;\n\txfs_daddr_t\t\td;\n\tchar\t\t\t*cur_chunk;\n\tint\t\t\tpathlen = ip->i_d.di_size;\n\tint\t\t\tnmaps = XFS_SYMLINK_MAPS;\n\tint\t\t\tbyte_cnt;\n\tint\t\t\tn;\n\tint\t\t\terror = 0;\n\tint\t\t\tfsblocks = 0;\n\tint\t\t\toffset;\n\n\tfsblocks = xfs_symlink_blocks(mp, pathlen);\n\terror = xfs_bmapi_read(ip, 0, fsblocks, mval, &nmaps, 0);\n\tif (error)\n\t\tgoto out;\n\n\toffset = 0;\n\tfor (n = 0; n < nmaps; n++) {\n\t\td = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\n\t\tbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\n\n\t\tbp = xfs_buf_read(mp->m_ddev_targp, d, BTOBB(byte_cnt), 0,\n\t\t\t\t  &xfs_symlink_buf_ops);\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\t\terror = bp->b_error;\n\t\tif (error) {\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\t\txfs_buf_relse(bp);\n\n\t\t\t/* bad CRC means corrupted metadata */\n\t\t\tif (error == -EFSBADCRC)\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\tbyte_cnt = XFS_SYMLINK_BUF_SPACE(mp, byte_cnt);\n\t\tif (pathlen < byte_cnt)\n\t\t\tbyte_cnt = pathlen;\n\n\t\tcur_chunk = bp->b_addr;\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tif (!xfs_symlink_hdr_ok(ip->i_ino, offset,\n\t\t\t\t\t\t\tbyte_cnt, bp)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\txfs_alert(mp,\n\"symlink header does not match required off/len/owner (0x%x/Ox%x,0x%llx)\",\n\t\t\t\t\toffset, byte_cnt, ip->i_ino);\n\t\t\t\txfs_buf_relse(bp);\n\t\t\t\tgoto out;\n\n\t\t\t}\n\n\t\t\tcur_chunk += sizeof(struct xfs_dsymlink_hdr);\n\t\t}\n\n\t\tmemcpy(link + offset, bp->b_addr, byte_cnt);\n\n\t\tpathlen -= byte_cnt;\n\t\toffset += byte_cnt;\n\n\t\txfs_buf_relse(bp);\n\t}\n\tASSERT(pathlen == 0);\n\n\tlink[ip->i_d.di_size] = '\\0';\n\terror = 0;\n\n out:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "link",
            "ip->i_df.if_u1.if_data",
            "pathlen"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"%s: inode (%llu) bad symlink length (%lld)\"",
            "__func__",
            "(unsigned long long) ip->i_ino",
            "(long long) pathlen"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_readlink",
          "args": [
            "ip"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nint\nxfs_readlink(\n\tstruct xfs_inode *ip,\n\tchar\t\t*link)\n{\n\tstruct xfs_mount *mp = ip->i_mount;\n\txfs_fsize_t\tpathlen;\n\tint\t\terror = 0;\n\n\ttrace_xfs_readlink(ip);\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\txfs_ilock(ip, XFS_ILOCK_SHARED);\n\n\tpathlen = ip->i_d.di_size;\n\tif (!pathlen)\n\t\tgoto out;\n\n\tif (pathlen < 0 || pathlen > MAXPATHLEN) {\n\t\txfs_alert(mp, \"%s: inode (%llu) bad symlink length (%lld)\",\n\t\t\t __func__, (unsigned long long) ip->i_ino,\n\t\t\t (long long) pathlen);\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\n\n\n\tif (ip->i_df.if_flags & XFS_IFINLINE) {\n\t\tmemcpy(link, ip->i_df.if_u1.if_data, pathlen);\n\t\tlink[pathlen] = '\\0';\n\t} else {\n\t\terror = xfs_readlink_bmap(ip, link);\n\t}\n\n out:\n\txfs_iunlock(ip, XFS_ILOCK_SHARED);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_readlink_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_symlink.c",
    "lines": "45-121",
    "snippet": "STATIC int\nxfs_readlink_bmap(\n\tstruct xfs_inode\t*ip,\n\tchar\t\t\t*link)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_bmbt_irec\tmval[XFS_SYMLINK_MAPS];\n\tstruct xfs_buf\t\t*bp;\n\txfs_daddr_t\t\td;\n\tchar\t\t\t*cur_chunk;\n\tint\t\t\tpathlen = ip->i_d.di_size;\n\tint\t\t\tnmaps = XFS_SYMLINK_MAPS;\n\tint\t\t\tbyte_cnt;\n\tint\t\t\tn;\n\tint\t\t\terror = 0;\n\tint\t\t\tfsblocks = 0;\n\tint\t\t\toffset;\n\n\tfsblocks = xfs_symlink_blocks(mp, pathlen);\n\terror = xfs_bmapi_read(ip, 0, fsblocks, mval, &nmaps, 0);\n\tif (error)\n\t\tgoto out;\n\n\toffset = 0;\n\tfor (n = 0; n < nmaps; n++) {\n\t\td = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\n\t\tbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\n\n\t\tbp = xfs_buf_read(mp->m_ddev_targp, d, BTOBB(byte_cnt), 0,\n\t\t\t\t  &xfs_symlink_buf_ops);\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\t\terror = bp->b_error;\n\t\tif (error) {\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\t\txfs_buf_relse(bp);\n\n\t\t\t/* bad CRC means corrupted metadata */\n\t\t\tif (error == -EFSBADCRC)\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\tbyte_cnt = XFS_SYMLINK_BUF_SPACE(mp, byte_cnt);\n\t\tif (pathlen < byte_cnt)\n\t\t\tbyte_cnt = pathlen;\n\n\t\tcur_chunk = bp->b_addr;\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tif (!xfs_symlink_hdr_ok(ip->i_ino, offset,\n\t\t\t\t\t\t\tbyte_cnt, bp)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\txfs_alert(mp,\n\"symlink header does not match required off/len/owner (0x%x/Ox%x,0x%llx)\",\n\t\t\t\t\toffset, byte_cnt, ip->i_ino);\n\t\t\t\txfs_buf_relse(bp);\n\t\t\t\tgoto out;\n\n\t\t\t}\n\n\t\t\tcur_chunk += sizeof(struct xfs_dsymlink_hdr);\n\t\t}\n\n\t\tmemcpy(link + offset, bp->b_addr, byte_cnt);\n\n\t\tpathlen -= byte_cnt;\n\t\toffset += byte_cnt;\n\n\t\txfs_buf_relse(bp);\n\t}\n\tASSERT(pathlen == 0);\n\n\tlink[ip->i_d.di_size] = '\\0';\n\terror = 0;\n\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "pathlen == 0"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_relse",
          "args": [
            "bp"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_relse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "361-365",
          "snippet": "static inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void xfs_buf_relse(xfs_buf_t *bp)\n{\n\txfs_buf_unlock(bp);\n\txfs_buf_rele(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "link + offset",
            "bp->b_addr",
            "byte_cnt"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"symlink header does not match required off/len/owner (0x%x/Ox%x,0x%llx)\"",
            "offset",
            "byte_cnt",
            "ip->i_ino"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_symlink_hdr_ok",
          "args": [
            "ip->i_ino",
            "offset",
            "byte_cnt",
            "bp"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_symlink_hdr_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_symlink_remote.c",
          "lines": "79-97",
          "snippet": "bool\nxfs_symlink_hdr_ok(\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dsymlink_hdr *dsl = bp->b_addr;\n\n\tif (offset != be32_to_cpu(dsl->sl_offset))\n\t\treturn false;\n\tif (size != be32_to_cpu(dsl->sl_bytes))\n\t\treturn false;\n\tif (ino != be64_to_cpu(dsl->sl_owner))\n\t\treturn false;\n\n\t/* ok */\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_symlink_hdr_ok(\n\txfs_ino_t\t\tino,\n\tuint32_t\t\toffset,\n\tuint32_t\t\tsize,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_dsymlink_hdr *dsl = bp->b_addr;\n\n\tif (offset != be32_to_cpu(dsl->sl_offset))\n\t\treturn false;\n\tif (size != be32_to_cpu(dsl->sl_bytes))\n\t\treturn false;\n\tif (ino != be64_to_cpu(dsl->sl_owner))\n\t\treturn false;\n\n\t/* ok */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_SYMLINK_BUF_SPACE",
          "args": [
            "mp",
            "byte_cnt"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror_alert",
          "args": [
            "bp",
            "__func__"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_read",
          "args": [
            "mp->m_ddev_targp",
            "d",
            "BTOBB(byte_cnt)",
            "0",
            "&xfs_symlink_buf_ops"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "244-254",
          "snippet": "static inline struct xfs_buf *\nxfs_buf_read(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_read_map(target, &map, 1, flags, ops);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline struct xfs_buf *\nxfs_buf_read(\n\tstruct xfs_buftarg\t*target,\n\txfs_daddr_t\t\tblkno,\n\tsize_t\t\t\tnumblks,\n\txfs_buf_flags_t\t\tflags,\n\tconst struct xfs_buf_ops *ops)\n{\n\tDEFINE_SINGLE_BUF_MAP(map, blkno, numblks);\n\treturn xfs_buf_read_map(target, &map, 1, flags, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BTOBB",
          "args": [
            "byte_cnt"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "mval[n].br_blockcount"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "mval[n].br_startblock"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_read",
          "args": [
            "ip",
            "0",
            "fsblocks",
            "mval",
            "&nmaps",
            "0"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4017-4103",
          "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_symlink_blocks",
          "args": [
            "mp",
            "pathlen"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_symlink_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_symlink_remote.c",
          "lines": "40-48",
          "snippet": "int\nxfs_symlink_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tpathlen)\n{\n\tint buflen = XFS_SYMLINK_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\n\treturn (pathlen + buflen - 1) / buflen;\n}",
          "includes": [
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_symlink_blocks(\n\tstruct xfs_mount *mp,\n\tint\t\tpathlen)\n{\n\tint buflen = XFS_SYMLINK_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n\n\treturn (pathlen + buflen - 1) / buflen;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_readlink_bmap(\n\tstruct xfs_inode\t*ip,\n\tchar\t\t\t*link)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_bmbt_irec\tmval[XFS_SYMLINK_MAPS];\n\tstruct xfs_buf\t\t*bp;\n\txfs_daddr_t\t\td;\n\tchar\t\t\t*cur_chunk;\n\tint\t\t\tpathlen = ip->i_d.di_size;\n\tint\t\t\tnmaps = XFS_SYMLINK_MAPS;\n\tint\t\t\tbyte_cnt;\n\tint\t\t\tn;\n\tint\t\t\terror = 0;\n\tint\t\t\tfsblocks = 0;\n\tint\t\t\toffset;\n\n\tfsblocks = xfs_symlink_blocks(mp, pathlen);\n\terror = xfs_bmapi_read(ip, 0, fsblocks, mval, &nmaps, 0);\n\tif (error)\n\t\tgoto out;\n\n\toffset = 0;\n\tfor (n = 0; n < nmaps; n++) {\n\t\td = XFS_FSB_TO_DADDR(mp, mval[n].br_startblock);\n\t\tbyte_cnt = XFS_FSB_TO_B(mp, mval[n].br_blockcount);\n\n\t\tbp = xfs_buf_read(mp->m_ddev_targp, d, BTOBB(byte_cnt), 0,\n\t\t\t\t  &xfs_symlink_buf_ops);\n\t\tif (!bp)\n\t\t\treturn -ENOMEM;\n\t\terror = bp->b_error;\n\t\tif (error) {\n\t\t\txfs_buf_ioerror_alert(bp, __func__);\n\t\t\txfs_buf_relse(bp);\n\n\t\t\t/* bad CRC means corrupted metadata */\n\t\t\tif (error == -EFSBADCRC)\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t\tbyte_cnt = XFS_SYMLINK_BUF_SPACE(mp, byte_cnt);\n\t\tif (pathlen < byte_cnt)\n\t\t\tbyte_cnt = pathlen;\n\n\t\tcur_chunk = bp->b_addr;\n\t\tif (xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\tif (!xfs_symlink_hdr_ok(ip->i_ino, offset,\n\t\t\t\t\t\t\tbyte_cnt, bp)) {\n\t\t\t\terror = -EFSCORRUPTED;\n\t\t\t\txfs_alert(mp,\n\"symlink header does not match required off/len/owner (0x%x/Ox%x,0x%llx)\",\n\t\t\t\t\toffset, byte_cnt, ip->i_ino);\n\t\t\t\txfs_buf_relse(bp);\n\t\t\t\tgoto out;\n\n\t\t\t}\n\n\t\t\tcur_chunk += sizeof(struct xfs_dsymlink_hdr);\n\t\t}\n\n\t\tmemcpy(link + offset, bp->b_addr, byte_cnt);\n\n\t\tpathlen -= byte_cnt;\n\t\toffset += byte_cnt;\n\n\t\txfs_buf_relse(bp);\n\t}\n\tASSERT(pathlen == 0);\n\n\tlink[ip->i_d.di_size] = '\\0';\n\terror = 0;\n\n out:\n\treturn error;\n}"
  }
]