[
  {
    "function_name": "ext3_trim_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "2085-2158",
    "snippet": "int ext3_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\text3_grpblk_t last_block, first_block;\n\tunsigned long group, first_group, last_group;\n\tstruct ext3_group_desc *gdp;\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\tuint64_t start, minlen, end, trimmed = 0;\n\text3_fsblk_t first_data_blk =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n\text3_fsblk_t max_blks = le32_to_cpu(es->s_blocks_count);\n\tint ret = 0;\n\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = range->minlen >> sb->s_blocksize_bits;\n\n\tif (minlen > EXT3_BLOCKS_PER_GROUP(sb) ||\n\t    start >= max_blks ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\tif (end >= max_blks)\n\t\tend = max_blks - 1;\n\tif (end <= first_data_blk)\n\t\tgoto out;\n\tif (start < first_data_blk)\n\t\tstart = first_data_blk;\n\n\tsmp_rmb();\n\n\t/* Determine first and last group to examine based on start and len */\n\text3_get_group_no_and_offset(sb, (ext3_fsblk_t) start,\n\t\t\t\t     &first_group, &first_block);\n\text3_get_group_no_and_offset(sb, (ext3_fsblk_t) end,\n\t\t\t\t     &last_group, &last_block);\n\n\t/* end now represents the last block to discard in this group */\n\tend = EXT3_BLOCKS_PER_GROUP(sb) - 1;\n\n\tfor (group = first_group; group <= last_group; group++) {\n\t\tgdp = ext3_get_group_desc(sb, group, NULL);\n\t\tif (!gdp)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For all the groups except the last one, last block will\n\t\t * always be EXT3_BLOCKS_PER_GROUP(sb)-1, so we only need to\n\t\t * change it for the last group, note that last_block is\n\t\t * already computed earlier by ext3_get_group_no_and_offset()\n\t\t */\n\t\tif (group == last_group)\n\t\t\tend = last_block;\n\n\t\tif (le16_to_cpu(gdp->bg_free_blocks_count) >= minlen) {\n\t\t\tret = ext3_trim_all_free(sb, group, first_block,\n\t\t\t\t\t\t end, minlen);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\ttrimmed += ret;\n\t\t}\n\n\t\t/*\n\t\t * For every group except the first one, we are sure\n\t\t * that the first block to discard will be block #0.\n\t\t */\n\t\tfirst_block = 0;\n\t}\n\n\tif (ret > 0)\n\t\tret = 0;\n\nout:\n\trange->len = trimmed * sb->s_blocksize;\n\treturn ret;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_trim_all_free",
          "args": [
            "sb",
            "group",
            "first_block",
            "end",
            "minlen"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_trim_all_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1920-2072",
          "snippet": "static ext3_grpblk_t ext3_trim_all_free(struct super_block *sb,\n\t\t\t\t\tunsigned int group,\n\t\t\t\t\text3_grpblk_t start, ext3_grpblk_t max,\n\t\t\t\t\text3_grpblk_t minblocks)\n{\n\thandle_t *handle;\n\text3_grpblk_t next, free_blocks, bit, freed, count = 0;\n\text3_fsblk_t discard_block;\n\tstruct ext3_sb_info *sbi;\n\tstruct buffer_head *gdp_bh, *bitmap_bh = NULL;\n\tstruct ext3_group_desc *gdp;\n\tint err = 0, ret = 0;\n\n\t/*\n\t * We will update one block bitmap, and one group descriptor\n\t */\n\thandle = ext3_journal_start_sb(sb, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tbitmap_bh = read_block_bitmap(sb, group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting undo access\");\n\terr = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto err_out;\n\n\tgdp = ext3_get_group_desc(sb, group, &gdp_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, gdp_bh);\n\tif (err)\n\t\tgoto err_out;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\tsbi = EXT3_SB(sb);\n\n\t /* Walk through the whole group */\n\twhile (start <= max) {\n\t\tstart = bitmap_search_next_usable_block(start, bitmap_bh, max);\n\t\tif (start < 0)\n\t\t\tbreak;\n\t\tnext = start;\n\n\t\t/*\n\t\t * Allocate contiguous free extents by setting bits in the\n\t\t * block bitmap\n\t\t */\n\t\twhile (next <= max\n\t\t\t&& claim_block(sb_bgl_lock(sbi, group),\n\t\t\t\t\tnext, bitmap_bh)) {\n\t\t\tnext++;\n\t\t}\n\n\t\t /* We did not claim any blocks */\n\t\tif (next == start)\n\t\t\tcontinue;\n\n\t\tdiscard_block = (ext3_fsblk_t)start +\n\t\t\t\text3_group_first_block_no(sb, group);\n\n\t\t/* Update counters */\n\t\tspin_lock(sb_bgl_lock(sbi, group));\n\t\tle16_add_cpu(&gdp->bg_free_blocks_count, start - next);\n\t\tspin_unlock(sb_bgl_lock(sbi, group));\n\t\tpercpu_counter_sub(&sbi->s_freeblocks_counter, next - start);\n\n\t\tfree_blocks -= next - start;\n\t\t/* Do not issue a TRIM on extents smaller than minblocks */\n\t\tif ((next - start) < minblocks)\n\t\t\tgoto free_extent;\n\n\t\ttrace_ext3_discard_blocks(sb, discard_block, next - start);\n\t\t /* Send the TRIM command down to the device */\n\t\terr = sb_issue_discard(sb, discard_block, next - start,\n\t\t\t\t       GFP_NOFS, 0);\n\t\tcount += (next - start);\nfree_extent:\n\t\tfreed = 0;\n\n\t\t/*\n\t\t * Clear bits in the bitmap\n\t\t */\n\t\tfor (bit = start; bit < next; bit++) {\n\t\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\t\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tbit, bitmap_bh->b_data)) {\n\t\t\t\text3_error(sb, __func__,\n\t\t\t\t\t\"bit already cleared for block \"E3FSBLK,\n\t\t\t\t\t (unsigned long)bit);\n\t\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t\t} else {\n\t\t\t\tfreed++;\n\t\t\t}\n\t\t}\n\n\t\t/* Update couters */\n\t\tspin_lock(sb_bgl_lock(sbi, group));\n\t\tle16_add_cpu(&gdp->bg_free_blocks_count, freed);\n\t\tspin_unlock(sb_bgl_lock(sbi, group));\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\n\t\tstart = next;\n\t\tif (err < 0) {\n\t\t\tif (err != -EOPNOTSUPP)\n\t\t\t\text3_warning(sb, __func__, \"Discard command \"\n\t\t\t\t\t     \"returned error %d\\n\", err);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\n\t\t/* No more suitable extents */\n\t\tif (free_blocks < minblocks)\n\t\t\tbreak;\n\t}\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\tret = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\tif (!err)\n\t\terr = ret;\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gdp_bh, \"dirtied group descriptor block\");\n\tret = ext3_journal_dirty_metadata(handle, gdp_bh);\n\tif (!err)\n\t\terr = ret;\n\n\text3_debug(\"trimmed %d blocks in the group %d\\n\",\n\t\tcount, group);\n\nerr_out:\n\tif (err)\n\t\tcount = err;\n\text3_journal_stop(handle);\n\tbrelse(bitmap_bh);\n\n\treturn count;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic ext3_grpblk_t ext3_trim_all_free(struct super_block *sb,\n\t\t\t\t\tunsigned int group,\n\t\t\t\t\text3_grpblk_t start, ext3_grpblk_t max,\n\t\t\t\t\text3_grpblk_t minblocks)\n{\n\thandle_t *handle;\n\text3_grpblk_t next, free_blocks, bit, freed, count = 0;\n\text3_fsblk_t discard_block;\n\tstruct ext3_sb_info *sbi;\n\tstruct buffer_head *gdp_bh, *bitmap_bh = NULL;\n\tstruct ext3_group_desc *gdp;\n\tint err = 0, ret = 0;\n\n\t/*\n\t * We will update one block bitmap, and one group descriptor\n\t */\n\thandle = ext3_journal_start_sb(sb, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tbitmap_bh = read_block_bitmap(sb, group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting undo access\");\n\terr = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto err_out;\n\n\tgdp = ext3_get_group_desc(sb, group, &gdp_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, gdp_bh);\n\tif (err)\n\t\tgoto err_out;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\tsbi = EXT3_SB(sb);\n\n\t /* Walk through the whole group */\n\twhile (start <= max) {\n\t\tstart = bitmap_search_next_usable_block(start, bitmap_bh, max);\n\t\tif (start < 0)\n\t\t\tbreak;\n\t\tnext = start;\n\n\t\t/*\n\t\t * Allocate contiguous free extents by setting bits in the\n\t\t * block bitmap\n\t\t */\n\t\twhile (next <= max\n\t\t\t&& claim_block(sb_bgl_lock(sbi, group),\n\t\t\t\t\tnext, bitmap_bh)) {\n\t\t\tnext++;\n\t\t}\n\n\t\t /* We did not claim any blocks */\n\t\tif (next == start)\n\t\t\tcontinue;\n\n\t\tdiscard_block = (ext3_fsblk_t)start +\n\t\t\t\text3_group_first_block_no(sb, group);\n\n\t\t/* Update counters */\n\t\tspin_lock(sb_bgl_lock(sbi, group));\n\t\tle16_add_cpu(&gdp->bg_free_blocks_count, start - next);\n\t\tspin_unlock(sb_bgl_lock(sbi, group));\n\t\tpercpu_counter_sub(&sbi->s_freeblocks_counter, next - start);\n\n\t\tfree_blocks -= next - start;\n\t\t/* Do not issue a TRIM on extents smaller than minblocks */\n\t\tif ((next - start) < minblocks)\n\t\t\tgoto free_extent;\n\n\t\ttrace_ext3_discard_blocks(sb, discard_block, next - start);\n\t\t /* Send the TRIM command down to the device */\n\t\terr = sb_issue_discard(sb, discard_block, next - start,\n\t\t\t\t       GFP_NOFS, 0);\n\t\tcount += (next - start);\nfree_extent:\n\t\tfreed = 0;\n\n\t\t/*\n\t\t * Clear bits in the bitmap\n\t\t */\n\t\tfor (bit = start; bit < next; bit++) {\n\t\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\t\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tbit, bitmap_bh->b_data)) {\n\t\t\t\text3_error(sb, __func__,\n\t\t\t\t\t\"bit already cleared for block \"E3FSBLK,\n\t\t\t\t\t (unsigned long)bit);\n\t\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t\t} else {\n\t\t\t\tfreed++;\n\t\t\t}\n\t\t}\n\n\t\t/* Update couters */\n\t\tspin_lock(sb_bgl_lock(sbi, group));\n\t\tle16_add_cpu(&gdp->bg_free_blocks_count, freed);\n\t\tspin_unlock(sb_bgl_lock(sbi, group));\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\n\t\tstart = next;\n\t\tif (err < 0) {\n\t\t\tif (err != -EOPNOTSUPP)\n\t\t\t\text3_warning(sb, __func__, \"Discard command \"\n\t\t\t\t\t     \"returned error %d\\n\", err);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\n\t\t/* No more suitable extents */\n\t\tif (free_blocks < minblocks)\n\t\t\tbreak;\n\t}\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\tret = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\tif (!err)\n\t\terr = ret;\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gdp_bh, \"dirtied group descriptor block\");\n\tret = ext3_journal_dirty_metadata(handle, gdp_bh);\n\tif (!err)\n\t\terr = ret;\n\n\text3_debug(\"trimmed %d blocks in the group %d\\n\",\n\t\tcount, group);\n\nerr_out:\n\tif (err)\n\t\tcount = err;\n\text3_journal_stop(handle);\n\tbrelse(bitmap_bh);\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gdp->bg_free_blocks_count"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "group",
            "NULL"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_group_no_and_offset",
          "args": [
            "sb",
            "(ext3_fsblk_t) end",
            "&last_group",
            "&last_block"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_no_and_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "39-49",
          "snippet": "static void ext3_get_group_no_and_offset(struct super_block *sb,\n\text3_fsblk_t blocknr, unsigned long *blockgrpp, ext3_grpblk_t *offsetp)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\tif (offsetp)\n\t\t*offsetp = blocknr % EXT3_BLOCKS_PER_GROUP(sb);\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr / EXT3_BLOCKS_PER_GROUP(sb);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic void ext3_get_group_no_and_offset(struct super_block *sb,\n\text3_fsblk_t blocknr, unsigned long *blockgrpp, ext3_grpblk_t *offsetp)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\tif (offsetp)\n\t\t*offsetp = blocknr % EXT3_BLOCKS_PER_GROUP(sb);\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr / EXT3_BLOCKS_PER_GROUP(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_blocks_count"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_trim_fs(struct super_block *sb, struct fstrim_range *range)\n{\n\text3_grpblk_t last_block, first_block;\n\tunsigned long group, first_group, last_group;\n\tstruct ext3_group_desc *gdp;\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\tuint64_t start, minlen, end, trimmed = 0;\n\text3_fsblk_t first_data_blk =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n\text3_fsblk_t max_blks = le32_to_cpu(es->s_blocks_count);\n\tint ret = 0;\n\n\tstart = range->start >> sb->s_blocksize_bits;\n\tend = start + (range->len >> sb->s_blocksize_bits) - 1;\n\tminlen = range->minlen >> sb->s_blocksize_bits;\n\n\tif (minlen > EXT3_BLOCKS_PER_GROUP(sb) ||\n\t    start >= max_blks ||\n\t    range->len < sb->s_blocksize)\n\t\treturn -EINVAL;\n\tif (end >= max_blks)\n\t\tend = max_blks - 1;\n\tif (end <= first_data_blk)\n\t\tgoto out;\n\tif (start < first_data_blk)\n\t\tstart = first_data_blk;\n\n\tsmp_rmb();\n\n\t/* Determine first and last group to examine based on start and len */\n\text3_get_group_no_and_offset(sb, (ext3_fsblk_t) start,\n\t\t\t\t     &first_group, &first_block);\n\text3_get_group_no_and_offset(sb, (ext3_fsblk_t) end,\n\t\t\t\t     &last_group, &last_block);\n\n\t/* end now represents the last block to discard in this group */\n\tend = EXT3_BLOCKS_PER_GROUP(sb) - 1;\n\n\tfor (group = first_group; group <= last_group; group++) {\n\t\tgdp = ext3_get_group_desc(sb, group, NULL);\n\t\tif (!gdp)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For all the groups except the last one, last block will\n\t\t * always be EXT3_BLOCKS_PER_GROUP(sb)-1, so we only need to\n\t\t * change it for the last group, note that last_block is\n\t\t * already computed earlier by ext3_get_group_no_and_offset()\n\t\t */\n\t\tif (group == last_group)\n\t\t\tend = last_block;\n\n\t\tif (le16_to_cpu(gdp->bg_free_blocks_count) >= minlen) {\n\t\t\tret = ext3_trim_all_free(sb, group, first_block,\n\t\t\t\t\t\t end, minlen);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\ttrimmed += ret;\n\t\t}\n\n\t\t/*\n\t\t * For every group except the first one, we are sure\n\t\t * that the first block to discard will be block #0.\n\t\t */\n\t\tfirst_block = 0;\n\t}\n\n\tif (ret > 0)\n\t\tret = 0;\n\nout:\n\trange->len = trimmed * sb->s_blocksize;\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_trim_all_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1920-2072",
    "snippet": "static ext3_grpblk_t ext3_trim_all_free(struct super_block *sb,\n\t\t\t\t\tunsigned int group,\n\t\t\t\t\text3_grpblk_t start, ext3_grpblk_t max,\n\t\t\t\t\text3_grpblk_t minblocks)\n{\n\thandle_t *handle;\n\text3_grpblk_t next, free_blocks, bit, freed, count = 0;\n\text3_fsblk_t discard_block;\n\tstruct ext3_sb_info *sbi;\n\tstruct buffer_head *gdp_bh, *bitmap_bh = NULL;\n\tstruct ext3_group_desc *gdp;\n\tint err = 0, ret = 0;\n\n\t/*\n\t * We will update one block bitmap, and one group descriptor\n\t */\n\thandle = ext3_journal_start_sb(sb, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tbitmap_bh = read_block_bitmap(sb, group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting undo access\");\n\terr = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto err_out;\n\n\tgdp = ext3_get_group_desc(sb, group, &gdp_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, gdp_bh);\n\tif (err)\n\t\tgoto err_out;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\tsbi = EXT3_SB(sb);\n\n\t /* Walk through the whole group */\n\twhile (start <= max) {\n\t\tstart = bitmap_search_next_usable_block(start, bitmap_bh, max);\n\t\tif (start < 0)\n\t\t\tbreak;\n\t\tnext = start;\n\n\t\t/*\n\t\t * Allocate contiguous free extents by setting bits in the\n\t\t * block bitmap\n\t\t */\n\t\twhile (next <= max\n\t\t\t&& claim_block(sb_bgl_lock(sbi, group),\n\t\t\t\t\tnext, bitmap_bh)) {\n\t\t\tnext++;\n\t\t}\n\n\t\t /* We did not claim any blocks */\n\t\tif (next == start)\n\t\t\tcontinue;\n\n\t\tdiscard_block = (ext3_fsblk_t)start +\n\t\t\t\text3_group_first_block_no(sb, group);\n\n\t\t/* Update counters */\n\t\tspin_lock(sb_bgl_lock(sbi, group));\n\t\tle16_add_cpu(&gdp->bg_free_blocks_count, start - next);\n\t\tspin_unlock(sb_bgl_lock(sbi, group));\n\t\tpercpu_counter_sub(&sbi->s_freeblocks_counter, next - start);\n\n\t\tfree_blocks -= next - start;\n\t\t/* Do not issue a TRIM on extents smaller than minblocks */\n\t\tif ((next - start) < minblocks)\n\t\t\tgoto free_extent;\n\n\t\ttrace_ext3_discard_blocks(sb, discard_block, next - start);\n\t\t /* Send the TRIM command down to the device */\n\t\terr = sb_issue_discard(sb, discard_block, next - start,\n\t\t\t\t       GFP_NOFS, 0);\n\t\tcount += (next - start);\nfree_extent:\n\t\tfreed = 0;\n\n\t\t/*\n\t\t * Clear bits in the bitmap\n\t\t */\n\t\tfor (bit = start; bit < next; bit++) {\n\t\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\t\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tbit, bitmap_bh->b_data)) {\n\t\t\t\text3_error(sb, __func__,\n\t\t\t\t\t\"bit already cleared for block \"E3FSBLK,\n\t\t\t\t\t (unsigned long)bit);\n\t\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t\t} else {\n\t\t\t\tfreed++;\n\t\t\t}\n\t\t}\n\n\t\t/* Update couters */\n\t\tspin_lock(sb_bgl_lock(sbi, group));\n\t\tle16_add_cpu(&gdp->bg_free_blocks_count, freed);\n\t\tspin_unlock(sb_bgl_lock(sbi, group));\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\n\t\tstart = next;\n\t\tif (err < 0) {\n\t\t\tif (err != -EOPNOTSUPP)\n\t\t\t\text3_warning(sb, __func__, \"Discard command \"\n\t\t\t\t\t     \"returned error %d\\n\", err);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\n\t\t/* No more suitable extents */\n\t\tif (free_blocks < minblocks)\n\t\t\tbreak;\n\t}\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\tret = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\tif (!err)\n\t\terr = ret;\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gdp_bh, \"dirtied group descriptor block\");\n\tret = ext3_journal_dirty_metadata(handle, gdp_bh);\n\tif (!err)\n\t\terr = ret;\n\n\text3_debug(\"trimmed %d blocks in the group %d\\n\",\n\t\tcount, group);\n\nerr_out:\n\tif (err)\n\t\tcount = err;\n\text3_journal_stop(handle);\n\tbrelse(bitmap_bh);\n\n\treturn count;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_stop",
          "args": [
            "handle"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"trimmed %d blocks in the group %d\\n\"",
            "count",
            "group"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "gdp_bh"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gdp_bh",
            "\"dirtied group descriptor block\""
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"dirtied bitmap block\""
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_warning",
          "args": [
            "sb",
            "__func__",
            "\"Discard command \"\n\t\t\t\t\t     \"returned error %d\\n\"",
            "err"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "312-327",
          "snippet": "void ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_warning(struct super_block *sb, const char *function,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_WARNING \"EXT3-fs (%s): warning: %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&sbi->s_freeblocks_counter",
            "freed"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "sb_bgl_lock(sbi, group)"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bgl_lock",
          "args": [
            "sbi",
            "group"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "sb_bgl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "683-687",
          "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&gdp->bg_free_blocks_count",
            "freed"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "sb_bgl_lock(sbi, group)"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"bit already cleared\""
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "__func__",
            "\"bit already cleared for block \"E3FSBLK",
            "(unsigned long)bit"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_clear_bit_atomic",
          "args": [
            "sb_bgl_lock(sbi, group)",
            "bit",
            "bitmap_bh->b_data"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"clear bit\""
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_issue_discard",
          "args": [
            "sb",
            "discard_block",
            "next - start",
            "GFP_NOFS",
            "0"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_discard_blocks",
          "args": [
            "sb",
            "discard_block",
            "next - start"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_freeblocks_counter",
            "next - start"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&gdp->bg_free_blocks_count",
            "start - next"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "972-977",
          "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "claim_block",
          "args": [
            "sb_bgl_lock(sbi, group)",
            "next",
            "bitmap_bh"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "claim_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "832-849",
          "snippet": "static inline int\nclaim_block(spinlock_t *lock, ext3_grpblk_t block, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\tint ret;\n\n\tif (ext3_set_bit_atomic(lock, block, bh->b_data))\n\t\treturn 0;\n\tjbd_lock_bh_state(bh);\n\tif (jh->b_committed_data && ext3_test_bit(block,jh->b_committed_data)) {\n\t\text3_clear_bit_atomic(lock, block, bh->b_data);\n\t\tret = 0;\n\t} else {\n\t\tret = 1;\n\t}\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic inline int\nclaim_block(spinlock_t *lock, ext3_grpblk_t block, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\tint ret;\n\n\tif (ext3_set_bit_atomic(lock, block, bh->b_data))\n\t\treturn 0;\n\tjbd_lock_bh_state(bh);\n\tif (jh->b_committed_data && ext3_test_bit(block,jh->b_committed_data)) {\n\t\text3_clear_bit_atomic(lock, block, bh->b_data);\n\t\tret = 0;\n\t} else {\n\t\tret = 1;\n\t}\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_search_next_usable_block",
          "args": [
            "start",
            "bitmap_bh",
            "max"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_search_next_usable_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "740-760",
          "snippet": "static ext3_grpblk_t\nbitmap_search_next_usable_block(ext3_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text3_grpblk_t maxblocks)\n{\n\text3_grpblk_t next;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\twhile (start < maxblocks) {\n\t\tnext = ext3_find_next_zero_bit(bh->b_data, maxblocks, start);\n\t\tif (next >= maxblocks)\n\t\t\treturn -1;\n\t\tif (ext3_test_allocatable(next, bh))\n\t\t\treturn next;\n\t\tjbd_lock_bh_state(bh);\n\t\tif (jh->b_committed_data)\n\t\t\tstart = ext3_find_next_zero_bit(jh->b_committed_data,\n\t\t\t\t\t\t\tmaxblocks, next);\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic ext3_grpblk_t\nbitmap_search_next_usable_block(ext3_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text3_grpblk_t maxblocks)\n{\n\text3_grpblk_t next;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\twhile (start < maxblocks) {\n\t\tnext = ext3_find_next_zero_bit(bh->b_data, maxblocks, start);\n\t\tif (next >= maxblocks)\n\t\t\treturn -1;\n\t\tif (ext3_test_allocatable(next, bh))\n\t\t\treturn next;\n\t\tjbd_lock_bh_state(bh);\n\t\tif (jh->b_committed_data)\n\t\t\tstart = ext3_find_next_zero_bit(jh->b_committed_data,\n\t\t\t\t\t\t\tmaxblocks, next);\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gdp->bg_free_blocks_count"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "gdp_bh"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gdp_bh",
            "\"get_write_access\""
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "group",
            "&gdp_bh"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_undo_access",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"getting undo access\""
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_block_bitmap",
          "args": [
            "sb",
            "group"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "147-184",
          "snippet": "static struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext3_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text3_fsblk_t bitmap_blk;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\ttrace_ext3_read_block_bitmap(sb, block_group);\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\text3_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext3_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text3_fsblk_t bitmap_blk;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\ttrace_ext3_read_block_bitmap(sb, block_group);\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\text3_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_start_sb",
          "args": [
            "sb",
            "2"
          ],
          "line": 1936
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_journal_start_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "69-87",
          "snippet": "handle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nhandle_t *ext3_journal_start_sb(struct super_block *sb, int nblocks)\n{\n\tjournal_t *journal;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn ERR_PTR(-EROFS);\n\n\t/* Special case here: if the journal has aborted behind our\n\t * backs (eg. EIO in the commit thread), then we still need to\n\t * take the FS itself readonly cleanly. */\n\tjournal = EXT3_SB(sb)->s_journal;\n\tif (is_journal_aborted(journal)) {\n\t\text3_abort(sb, __func__,\n\t\t\t   \"Detected aborted journal\");\n\t\treturn ERR_PTR(-EROFS);\n\t}\n\n\treturn journal_start(journal, nblocks);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic ext3_grpblk_t ext3_trim_all_free(struct super_block *sb,\n\t\t\t\t\tunsigned int group,\n\t\t\t\t\text3_grpblk_t start, ext3_grpblk_t max,\n\t\t\t\t\text3_grpblk_t minblocks)\n{\n\thandle_t *handle;\n\text3_grpblk_t next, free_blocks, bit, freed, count = 0;\n\text3_fsblk_t discard_block;\n\tstruct ext3_sb_info *sbi;\n\tstruct buffer_head *gdp_bh, *bitmap_bh = NULL;\n\tstruct ext3_group_desc *gdp;\n\tint err = 0, ret = 0;\n\n\t/*\n\t * We will update one block bitmap, and one group descriptor\n\t */\n\thandle = ext3_journal_start_sb(sb, 2);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tbitmap_bh = read_block_bitmap(sb, group);\n\tif (!bitmap_bh) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"getting undo access\");\n\terr = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto err_out;\n\n\tgdp = ext3_get_group_desc(sb, group, &gdp_bh);\n\tif (!gdp) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, gdp_bh);\n\tif (err)\n\t\tgoto err_out;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\tsbi = EXT3_SB(sb);\n\n\t /* Walk through the whole group */\n\twhile (start <= max) {\n\t\tstart = bitmap_search_next_usable_block(start, bitmap_bh, max);\n\t\tif (start < 0)\n\t\t\tbreak;\n\t\tnext = start;\n\n\t\t/*\n\t\t * Allocate contiguous free extents by setting bits in the\n\t\t * block bitmap\n\t\t */\n\t\twhile (next <= max\n\t\t\t&& claim_block(sb_bgl_lock(sbi, group),\n\t\t\t\t\tnext, bitmap_bh)) {\n\t\t\tnext++;\n\t\t}\n\n\t\t /* We did not claim any blocks */\n\t\tif (next == start)\n\t\t\tcontinue;\n\n\t\tdiscard_block = (ext3_fsblk_t)start +\n\t\t\t\text3_group_first_block_no(sb, group);\n\n\t\t/* Update counters */\n\t\tspin_lock(sb_bgl_lock(sbi, group));\n\t\tle16_add_cpu(&gdp->bg_free_blocks_count, start - next);\n\t\tspin_unlock(sb_bgl_lock(sbi, group));\n\t\tpercpu_counter_sub(&sbi->s_freeblocks_counter, next - start);\n\n\t\tfree_blocks -= next - start;\n\t\t/* Do not issue a TRIM on extents smaller than minblocks */\n\t\tif ((next - start) < minblocks)\n\t\t\tgoto free_extent;\n\n\t\ttrace_ext3_discard_blocks(sb, discard_block, next - start);\n\t\t /* Send the TRIM command down to the device */\n\t\terr = sb_issue_discard(sb, discard_block, next - start,\n\t\t\t\t       GFP_NOFS, 0);\n\t\tcount += (next - start);\nfree_extent:\n\t\tfreed = 0;\n\n\t\t/*\n\t\t * Clear bits in the bitmap\n\t\t */\n\t\tfor (bit = start; bit < next; bit++) {\n\t\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\t\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, group),\n\t\t\t\t\t\tbit, bitmap_bh->b_data)) {\n\t\t\t\text3_error(sb, __func__,\n\t\t\t\t\t\"bit already cleared for block \"E3FSBLK,\n\t\t\t\t\t (unsigned long)bit);\n\t\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t\t} else {\n\t\t\t\tfreed++;\n\t\t\t}\n\t\t}\n\n\t\t/* Update couters */\n\t\tspin_lock(sb_bgl_lock(sbi, group));\n\t\tle16_add_cpu(&gdp->bg_free_blocks_count, freed);\n\t\tspin_unlock(sb_bgl_lock(sbi, group));\n\t\tpercpu_counter_add(&sbi->s_freeblocks_counter, freed);\n\n\t\tstart = next;\n\t\tif (err < 0) {\n\t\t\tif (err != -EOPNOTSUPP)\n\t\t\t\text3_warning(sb, __func__, \"Discard command \"\n\t\t\t\t\t     \"returned error %d\\n\", err);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fatal_signal_pending(current)) {\n\t\t\terr = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\n\t\t/* No more suitable extents */\n\t\tif (free_blocks < minblocks)\n\t\t\tbreak;\n\t}\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\tret = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\tif (!err)\n\t\terr = ret;\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gdp_bh, \"dirtied group descriptor block\");\n\tret = ext3_journal_dirty_metadata(handle, gdp_bh);\n\tif (!err)\n\t\terr = ret;\n\n\text3_debug(\"trimmed %d blocks in the group %d\\n\",\n\t\tcount, group);\n\nerr_out:\n\tif (err)\n\t\tcount = err;\n\text3_journal_stop(handle);\n\tbrelse(bitmap_bh);\n\n\treturn count;\n}"
  },
  {
    "function_name": "ext3_bg_num_gdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1891-1903",
    "snippet": "unsigned long ext3_bg_num_gdb(struct super_block *sb, int group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb,EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext3_bg_num_gdb_nometa(sb,group);\n\n\treturn ext3_bg_num_gdb_meta(sb,group);\n\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_bg_num_gdb_meta",
          "args": [
            "sb",
            "group"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bg_num_gdb_meta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1866-1875",
          "snippet": "static unsigned long ext3_bg_num_gdb_meta(struct super_block *sb, int group)\n{\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\tunsigned long first = metagroup * EXT3_DESC_PER_BLOCK(sb);\n\tunsigned long last = first + EXT3_DESC_PER_BLOCK(sb) - 1;\n\n\tif (group == first || group == first + 1 || group == last)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic unsigned long ext3_bg_num_gdb_meta(struct super_block *sb, int group)\n{\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\tunsigned long first = metagroup * EXT3_DESC_PER_BLOCK(sb);\n\tunsigned long last = first + EXT3_DESC_PER_BLOCK(sb) - 1;\n\n\tif (group == first || group == first + 1 || group == last)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_bg_num_gdb_nometa",
          "args": [
            "sb",
            "group"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bg_num_gdb_nometa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1877-1880",
          "snippet": "static unsigned long ext3_bg_num_gdb_nometa(struct super_block *sb, int group)\n{\n\treturn ext3_bg_has_super(sb, group) ? EXT3_SB(sb)->s_gdb_count : 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic unsigned long ext3_bg_num_gdb_nometa(struct super_block *sb, int group)\n{\n\treturn ext3_bg_has_super(sb, group) ? EXT3_SB(sb)->s_gdb_count : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_INCOMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_INCOMPAT_META_BG"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "EXT3_SB(sb)->s_es->s_first_meta_bg"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nunsigned long ext3_bg_num_gdb(struct super_block *sb, int group)\n{\n\tunsigned long first_meta_bg =\n\t\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_meta_bg);\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\n\tif (!EXT3_HAS_INCOMPAT_FEATURE(sb,EXT3_FEATURE_INCOMPAT_META_BG) ||\n\t\t\tmetagroup < first_meta_bg)\n\t\treturn ext3_bg_num_gdb_nometa(sb,group);\n\n\treturn ext3_bg_num_gdb_meta(sb,group);\n\n}"
  },
  {
    "function_name": "ext3_bg_num_gdb_nometa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1877-1880",
    "snippet": "static unsigned long ext3_bg_num_gdb_nometa(struct super_block *sb, int group)\n{\n\treturn ext3_bg_has_super(sb, group) ? EXT3_SB(sb)->s_gdb_count : 0;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_bg_has_super",
          "args": [
            "sb",
            "group"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_bg_has_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1857-1864",
          "snippet": "int ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic unsigned long ext3_bg_num_gdb_nometa(struct super_block *sb, int group)\n{\n\treturn ext3_bg_has_super(sb, group) ? EXT3_SB(sb)->s_gdb_count : 0;\n}"
  },
  {
    "function_name": "ext3_bg_num_gdb_meta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1866-1875",
    "snippet": "static unsigned long ext3_bg_num_gdb_meta(struct super_block *sb, int group)\n{\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\tunsigned long first = metagroup * EXT3_DESC_PER_BLOCK(sb);\n\tunsigned long last = first + EXT3_DESC_PER_BLOCK(sb) - 1;\n\n\tif (group == first || group == first + 1 || group == last)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic unsigned long ext3_bg_num_gdb_meta(struct super_block *sb, int group)\n{\n\tunsigned long metagroup = group / EXT3_DESC_PER_BLOCK(sb);\n\tunsigned long first = metagroup * EXT3_DESC_PER_BLOCK(sb);\n\tunsigned long last = first + EXT3_DESC_PER_BLOCK(sb) - 1;\n\n\tif (group == first || group == first + 1 || group == last)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_bg_has_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1857-1864",
    "snippet": "int ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_group_sparse",
          "args": [
            "group"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_sparse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1839-1847",
          "snippet": "static int ext3_group_sparse(int group)\n{\n\tif (group <= 1)\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\treturn (test_root(group, 7) || test_root(group, 5) ||\n\t\ttest_root(group, 3));\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int ext3_group_sparse(int group)\n{\n\tif (group <= 1)\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\treturn (test_root(group, 7) || test_root(group, 5) ||\n\t\ttest_root(group, 3));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_HAS_RO_COMPAT_FEATURE",
          "args": [
            "sb",
            "EXT3_FEATURE_RO_COMPAT_SPARSE_SUPER"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_bg_has_super(struct super_block *sb, int group)\n{\n\tif (EXT3_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\tEXT3_FEATURE_RO_COMPAT_SPARSE_SUPER) &&\n\t\t\t!ext3_group_sparse(group))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "ext3_group_sparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1839-1847",
    "snippet": "static int ext3_group_sparse(int group)\n{\n\tif (group <= 1)\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\treturn (test_root(group, 7) || test_root(group, 5) ||\n\t\ttest_root(group, 3));\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_root",
          "args": [
            "group",
            "3"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "test_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1830-1837",
          "snippet": "static inline int test_root(int a, int b)\n{\n\tint num = b;\n\n\twhile (a > num)\n\t\tnum *= b;\n\treturn num == a;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic inline int test_root(int a, int b)\n{\n\tint num = b;\n\n\twhile (a > num)\n\t\tnum *= b;\n\treturn num == a;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int ext3_group_sparse(int group)\n{\n\tif (group <= 1)\n\t\treturn 1;\n\tif (!(group & 1))\n\t\treturn 0;\n\treturn (test_root(group, 7) || test_root(group, 5) ||\n\t\ttest_root(group, 3));\n}"
  },
  {
    "function_name": "test_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1830-1837",
    "snippet": "static inline int test_root(int a, int b)\n{\n\tint num = b;\n\n\twhile (a > num)\n\t\tnum *= b;\n\treturn num == a;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic inline int test_root(int a, int b)\n{\n\tint num = b;\n\n\twhile (a > num)\n\t\tnum *= b;\n\treturn num == a;\n}"
  },
  {
    "function_name": "ext3_count_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1777-1828",
    "snippet": "ext3_fsblk_t ext3_count_free_blocks(struct super_block *sb)\n{\n\text3_fsblk_t desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n\tunsigned long ngroups = EXT3_SB(sb)->s_groups_count;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\text3_fsblk_t bitmap_count;\n\tunsigned long x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_blocks: stored = \"E3FSBLK\n\t\t\", computed = \"E3FSBLK\", \"E3FSBLK\"\\n\",\n\t       (ext3_fsblk_t)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t}\n\n\treturn desc_count;\n#endif\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gdp->bg_free_blocks_count"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "i",
            "NULL"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"ext3_count_free_blocks: stored = \"E3FSBLK\n\t\t\", computed = \"E3FSBLK\", \"E3FSBLK\"\\n\"",
            "(ext3_fsblk_t)le32_to_cpu(es->s_free_blocks_count)",
            "desc_count",
            "bitmap_count"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_free_blocks_count"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_count_free",
          "args": [
            "bitmap_bh",
            "sb->s_blocksize"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_count_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/bitmap.c",
          "lines": "14-17",
          "snippet": "unsigned long ext3_count_free (struct buffer_head * map, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(map->b_data, numchars);\n}",
          "includes": [
            "#include \"ext3.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n\nunsigned long ext3_count_free (struct buffer_head * map, unsigned int numchars)\n{\n\treturn numchars * BITS_PER_BYTE - memweight(map->b_data, numchars);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_block_bitmap",
          "args": [
            "sb",
            "i"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "147-184",
          "snippet": "static struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext3_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text3_fsblk_t bitmap_blk;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\ttrace_ext3_read_block_bitmap(sb, block_group);\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\text3_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext3_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text3_fsblk_t bitmap_blk;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\ttrace_ext3_read_block_bitmap(sb, block_group);\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\text3_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\next3_fsblk_t ext3_count_free_blocks(struct super_block *sb)\n{\n\text3_fsblk_t desc_count;\n\tstruct ext3_group_desc *gdp;\n\tint i;\n\tunsigned long ngroups = EXT3_SB(sb)->s_groups_count;\n#ifdef EXT3FS_DEBUG\n\tstruct ext3_super_block *es;\n\text3_fsblk_t bitmap_count;\n\tunsigned long x;\n\tstruct buffer_head *bitmap_bh = NULL;\n\n\tes = EXT3_SB(sb)->s_es;\n\tdesc_count = 0;\n\tbitmap_count = 0;\n\tgdp = NULL;\n\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, i);\n\t\tif (bitmap_bh == NULL)\n\t\t\tcontinue;\n\n\t\tx = ext3_count_free(bitmap_bh, sb->s_blocksize);\n\t\tprintk(\"group %d: stored = %d, counted = %lu\\n\",\n\t\t\ti, le16_to_cpu(gdp->bg_free_blocks_count), x);\n\t\tbitmap_count += x;\n\t}\n\tbrelse(bitmap_bh);\n\tprintk(\"ext3_count_free_blocks: stored = \"E3FSBLK\n\t\t\", computed = \"E3FSBLK\", \"E3FSBLK\"\\n\",\n\t       (ext3_fsblk_t)le32_to_cpu(es->s_free_blocks_count),\n\t\tdesc_count, bitmap_count);\n\treturn bitmap_count;\n#else\n\tdesc_count = 0;\n\tsmp_rmb();\n\tfor (i = 0; i < ngroups; i++) {\n\t\tgdp = ext3_get_group_desc(sb, i, NULL);\n\t\tif (!gdp)\n\t\t\tcontinue;\n\t\tdesc_count += le16_to_cpu(gdp->bg_free_blocks_count);\n\t}\n\n\treturn desc_count;\n#endif\n}"
  },
  {
    "function_name": "ext3_new_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1763-1769",
    "snippet": "ext3_fsblk_t ext3_new_block(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, int *errp)\n{\n\tunsigned long count = 1;\n\n\treturn ext3_new_blocks(handle, inode, goal, &count, errp);\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_new_blocks",
          "args": [
            "handle",
            "inode",
            "goal",
            "&count",
            "errp"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_new_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1486-1761",
          "snippet": "ext3_fsblk_t ext3_new_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, unsigned long *count, int *errp)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text3_grpblk_t grp_target_blk;\t/* blockgroup relative goal block */\n\text3_grpblk_t grp_alloc_blk;\t/* blockgroup-relative allocated block*/\n\text3_fsblk_t ret_block;\t\t/* filesyetem-wide allocated block */\n\tint bgi;\t\t\t/* blockgroup iteration index */\n\tint fatal = 0, err;\n\tint performed_allocation = 0;\n\text3_grpblk_t free_blocks;\t/* number of free blocks in a group */\n\tstruct super_block *sb;\n\tstruct ext3_group_desc *gdp;\n\tstruct ext3_super_block *es;\n\tstruct ext3_sb_info *sbi;\n\tstruct ext3_reserve_window_node *my_rsv = NULL;\n\tstruct ext3_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n#ifdef EXT3FS_DEBUG\n\tstatic int goal_hits, goal_attempts;\n#endif\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t/*\n\t * Check quota for allocation of this block.\n\t */\n\terr = dquot_alloc_block(inode, num);\n\tif (err) {\n\t\t*errp = err;\n\t\treturn 0;\n\t}\n\n\ttrace_ext3_request_blocks(inode, goal, num);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\text3_debug(\"goal=%lu.\\n\", goal);\n\t/*\n\t * Allocate a block from reservation only when\n\t * filesystem is mounted with reservation(default,-o reservation), and\n\t * it's a regular file, and\n\t * the desired window size is greater than 0 (One could use ioctl\n\t * command EXT3_IOC_SETRSVSZ to set the window size to 0 to turn off\n\t * reservation on that particular file)\n\t */\n\tblock_i = EXT3_I(inode)->i_block_alloc_info;\n\tif (block_i && ((windowsz = block_i->rsv_window_node.rsv_goal_size) > 0))\n\t\tmy_rsv = &block_i->rsv_window_node;\n\n\tif (!ext3_has_free_blocks(sbi, IS_NOQUOTA(inode))) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, test whether the goal block is free.\n\t */\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext3_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t/*\n\t * if there is not enough free blocks to make a new resevation\n\t * turn off reservation for this allocation\n\t */\n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT3_BLOCKS_PER_GROUP(sb));\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext3_try_to_allocate_with_rsv(sb, handle,\n\t\t\t\t\tgroup_no, bitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv,\t&num, &fatal);\n\t\tif (fatal)\n\t\t\tgoto out;\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT3_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t/*\n\t * Now search the rest of the groups.  We assume that\n\t * group_no and gdp correctly point to the last group visited.\n\t */\n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext3_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t/*\n\t\t * skip this group (and avoid loading bitmap) if there\n\t\t * are no free blocks\n\t\t */\n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t/*\n\t\t * skip this group if the number of\n\t\t * free blocks is less than half of the reservation\n\t\t * window size.\n\t\t */\n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t/*\n\t\t * try to allocate block(s) from this group, without a goal(-1).\n\t\t */\n\t\tgrp_alloc_blk = ext3_try_to_allocate_with_rsv(sb, handle,\n\t\t\t\t\tgroup_no, bitmap_bh, -1, my_rsv,\n\t\t\t\t\t&num, &fatal);\n\t\tif (fatal)\n\t\t\tgoto out;\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t/*\n\t * We may end up a bogus earlier ENOSPC error due to\n\t * filesystem is \"full\" of reservations, but\n\t * there maybe indeed free blocks available on disk\n\t * In this case, we just forget about the reservations\n\t * just do block allocation as without reservations.\n\t */\n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t/* No space left on the device */\n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text3_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\tfatal = ext3_journal_get_write_access(handle, gdp_bh);\n\tif (fatal)\n\t\tgoto out;\n\n\tret_block = grp_alloc_blk + ext3_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT3_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT3_SB(sb)->s_itb_per_group)) {\n\t\text3_error(sb, \"ext3_new_block\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E3FSBLK\", length %lu\",\n\t\t\t     ret_block, num);\n\t\t/*\n\t\t * claim_block() marked the blocks we allocated as in use. So we\n\t\t * may want to selectively mark some of the blocks as free.\n\t\t */\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n#ifdef CONFIG_JBD_DEBUG\n\t{\n\t\tstruct buffer_head *debug_bh;\n\n\t\t/* Record bitmap buffer state in the newly allocated block */\n\t\tdebug_bh = sb_find_get_block(sb, ret_block);\n\t\tif (debug_bh) {\n\t\t\tBUFFER_TRACE(debug_bh, \"state when allocated\");\n\t\t\tBUFFER_TRACE2(debug_bh, bitmap_bh, \"bitmap state\");\n\t\t\tbrelse(debug_bh);\n\t\t}\n\t}\n\tjbd_lock_bh_state(bitmap_bh);\n\tspin_lock(sb_bgl_lock(sbi, group_no));\n\tif (buffer_jbd(bitmap_bh) && bh2jh(bitmap_bh)->b_committed_data) {\n\t\tint i;\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (ext3_test_bit(grp_alloc_blk+i,\n\t\t\t\t\tbh2jh(bitmap_bh)->b_committed_data)) {\n\t\t\t\tprintk(\"%s: block was unexpectedly set in \"\n\t\t\t\t\t\"b_committed_data\\n\", __func__);\n\t\t\t}\n\t\t}\n\t}\n\text3_debug(\"found bit %d\\n\", grp_alloc_blk);\n\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\tjbd_unlock_bh_state(bitmap_bh);\n#endif\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text3_error(sb, \"ext3_new_block\",\n\t\t\t    \"block(\"E3FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It is up to the caller to add the new buffer to a journal\n\t * list of some description.  We don't know in advance whether\n\t * the caller wants to use it as metadata or data.\n\t */\n\text3_debug(\"allocating block %lu. Goal hits %d of %d.\\n\",\n\t\t\tret_block, goal_hits, goal_attempts);\n\n\tspin_lock(sb_bgl_lock(sbi, group_no));\n\tle16_add_cpu(&gdp->bg_free_blocks_count, -num);\n\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tBUFFER_TRACE(gdp_bh, \"journal_dirty_metadata for group descriptor\");\n\tfatal = ext3_journal_dirty_metadata(handle, gdp_bh);\n\tif (fatal)\n\t\tgoto out;\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\n\tif (num < *count) {\n\t\tdquot_free_block(inode, *count-num);\n\t\t*count = num;\n\t}\n\n\ttrace_ext3_allocate_blocks(inode, goal, num,\n\t\t\t\t   (unsigned long long)ret_block);\n\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\tif (fatal) {\n\t\t*errp = fatal;\n\t\text3_std_error(sb, fatal);\n\t}\n\t/*\n\t * Undo the block allocation\n\t */\n\tif (!performed_allocation)\n\t\tdquot_free_block(inode, *count);\n\tbrelse(bitmap_bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\next3_fsblk_t ext3_new_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, unsigned long *count, int *errp)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text3_grpblk_t grp_target_blk;\t/* blockgroup relative goal block */\n\text3_grpblk_t grp_alloc_blk;\t/* blockgroup-relative allocated block*/\n\text3_fsblk_t ret_block;\t\t/* filesyetem-wide allocated block */\n\tint bgi;\t\t\t/* blockgroup iteration index */\n\tint fatal = 0, err;\n\tint performed_allocation = 0;\n\text3_grpblk_t free_blocks;\t/* number of free blocks in a group */\n\tstruct super_block *sb;\n\tstruct ext3_group_desc *gdp;\n\tstruct ext3_super_block *es;\n\tstruct ext3_sb_info *sbi;\n\tstruct ext3_reserve_window_node *my_rsv = NULL;\n\tstruct ext3_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n#ifdef EXT3FS_DEBUG\n\tstatic int goal_hits, goal_attempts;\n#endif\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t/*\n\t * Check quota for allocation of this block.\n\t */\n\terr = dquot_alloc_block(inode, num);\n\tif (err) {\n\t\t*errp = err;\n\t\treturn 0;\n\t}\n\n\ttrace_ext3_request_blocks(inode, goal, num);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\text3_debug(\"goal=%lu.\\n\", goal);\n\t/*\n\t * Allocate a block from reservation only when\n\t * filesystem is mounted with reservation(default,-o reservation), and\n\t * it's a regular file, and\n\t * the desired window size is greater than 0 (One could use ioctl\n\t * command EXT3_IOC_SETRSVSZ to set the window size to 0 to turn off\n\t * reservation on that particular file)\n\t */\n\tblock_i = EXT3_I(inode)->i_block_alloc_info;\n\tif (block_i && ((windowsz = block_i->rsv_window_node.rsv_goal_size) > 0))\n\t\tmy_rsv = &block_i->rsv_window_node;\n\n\tif (!ext3_has_free_blocks(sbi, IS_NOQUOTA(inode))) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, test whether the goal block is free.\n\t */\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext3_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t/*\n\t * if there is not enough free blocks to make a new resevation\n\t * turn off reservation for this allocation\n\t */\n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT3_BLOCKS_PER_GROUP(sb));\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext3_try_to_allocate_with_rsv(sb, handle,\n\t\t\t\t\tgroup_no, bitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv,\t&num, &fatal);\n\t\tif (fatal)\n\t\t\tgoto out;\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT3_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t/*\n\t * Now search the rest of the groups.  We assume that\n\t * group_no and gdp correctly point to the last group visited.\n\t */\n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext3_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t/*\n\t\t * skip this group (and avoid loading bitmap) if there\n\t\t * are no free blocks\n\t\t */\n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t/*\n\t\t * skip this group if the number of\n\t\t * free blocks is less than half of the reservation\n\t\t * window size.\n\t\t */\n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t/*\n\t\t * try to allocate block(s) from this group, without a goal(-1).\n\t\t */\n\t\tgrp_alloc_blk = ext3_try_to_allocate_with_rsv(sb, handle,\n\t\t\t\t\tgroup_no, bitmap_bh, -1, my_rsv,\n\t\t\t\t\t&num, &fatal);\n\t\tif (fatal)\n\t\t\tgoto out;\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t/*\n\t * We may end up a bogus earlier ENOSPC error due to\n\t * filesystem is \"full\" of reservations, but\n\t * there maybe indeed free blocks available on disk\n\t * In this case, we just forget about the reservations\n\t * just do block allocation as without reservations.\n\t */\n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t/* No space left on the device */\n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text3_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\tfatal = ext3_journal_get_write_access(handle, gdp_bh);\n\tif (fatal)\n\t\tgoto out;\n\n\tret_block = grp_alloc_blk + ext3_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT3_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT3_SB(sb)->s_itb_per_group)) {\n\t\text3_error(sb, \"ext3_new_block\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E3FSBLK\", length %lu\",\n\t\t\t     ret_block, num);\n\t\t/*\n\t\t * claim_block() marked the blocks we allocated as in use. So we\n\t\t * may want to selectively mark some of the blocks as free.\n\t\t */\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n#ifdef CONFIG_JBD_DEBUG\n\t{\n\t\tstruct buffer_head *debug_bh;\n\n\t\t/* Record bitmap buffer state in the newly allocated block */\n\t\tdebug_bh = sb_find_get_block(sb, ret_block);\n\t\tif (debug_bh) {\n\t\t\tBUFFER_TRACE(debug_bh, \"state when allocated\");\n\t\t\tBUFFER_TRACE2(debug_bh, bitmap_bh, \"bitmap state\");\n\t\t\tbrelse(debug_bh);\n\t\t}\n\t}\n\tjbd_lock_bh_state(bitmap_bh);\n\tspin_lock(sb_bgl_lock(sbi, group_no));\n\tif (buffer_jbd(bitmap_bh) && bh2jh(bitmap_bh)->b_committed_data) {\n\t\tint i;\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (ext3_test_bit(grp_alloc_blk+i,\n\t\t\t\t\tbh2jh(bitmap_bh)->b_committed_data)) {\n\t\t\t\tprintk(\"%s: block was unexpectedly set in \"\n\t\t\t\t\t\"b_committed_data\\n\", __func__);\n\t\t\t}\n\t\t}\n\t}\n\text3_debug(\"found bit %d\\n\", grp_alloc_blk);\n\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\tjbd_unlock_bh_state(bitmap_bh);\n#endif\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text3_error(sb, \"ext3_new_block\",\n\t\t\t    \"block(\"E3FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It is up to the caller to add the new buffer to a journal\n\t * list of some description.  We don't know in advance whether\n\t * the caller wants to use it as metadata or data.\n\t */\n\text3_debug(\"allocating block %lu. Goal hits %d of %d.\\n\",\n\t\t\tret_block, goal_hits, goal_attempts);\n\n\tspin_lock(sb_bgl_lock(sbi, group_no));\n\tle16_add_cpu(&gdp->bg_free_blocks_count, -num);\n\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tBUFFER_TRACE(gdp_bh, \"journal_dirty_metadata for group descriptor\");\n\tfatal = ext3_journal_dirty_metadata(handle, gdp_bh);\n\tif (fatal)\n\t\tgoto out;\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\n\tif (num < *count) {\n\t\tdquot_free_block(inode, *count-num);\n\t\t*count = num;\n\t}\n\n\ttrace_ext3_allocate_blocks(inode, goal, num,\n\t\t\t\t   (unsigned long long)ret_block);\n\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\tif (fatal) {\n\t\t*errp = fatal;\n\t\text3_std_error(sb, fatal);\n\t}\n\t/*\n\t * Undo the block allocation\n\t */\n\tif (!performed_allocation)\n\t\tdquot_free_block(inode, *count);\n\tbrelse(bitmap_bh);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\next3_fsblk_t ext3_new_block(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, int *errp)\n{\n\tunsigned long count = 1;\n\n\treturn ext3_new_blocks(handle, inode, goal, &count, errp);\n}"
  },
  {
    "function_name": "ext3_new_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1486-1761",
    "snippet": "ext3_fsblk_t ext3_new_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, unsigned long *count, int *errp)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text3_grpblk_t grp_target_blk;\t/* blockgroup relative goal block */\n\text3_grpblk_t grp_alloc_blk;\t/* blockgroup-relative allocated block*/\n\text3_fsblk_t ret_block;\t\t/* filesyetem-wide allocated block */\n\tint bgi;\t\t\t/* blockgroup iteration index */\n\tint fatal = 0, err;\n\tint performed_allocation = 0;\n\text3_grpblk_t free_blocks;\t/* number of free blocks in a group */\n\tstruct super_block *sb;\n\tstruct ext3_group_desc *gdp;\n\tstruct ext3_super_block *es;\n\tstruct ext3_sb_info *sbi;\n\tstruct ext3_reserve_window_node *my_rsv = NULL;\n\tstruct ext3_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n#ifdef EXT3FS_DEBUG\n\tstatic int goal_hits, goal_attempts;\n#endif\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t/*\n\t * Check quota for allocation of this block.\n\t */\n\terr = dquot_alloc_block(inode, num);\n\tif (err) {\n\t\t*errp = err;\n\t\treturn 0;\n\t}\n\n\ttrace_ext3_request_blocks(inode, goal, num);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\text3_debug(\"goal=%lu.\\n\", goal);\n\t/*\n\t * Allocate a block from reservation only when\n\t * filesystem is mounted with reservation(default,-o reservation), and\n\t * it's a regular file, and\n\t * the desired window size is greater than 0 (One could use ioctl\n\t * command EXT3_IOC_SETRSVSZ to set the window size to 0 to turn off\n\t * reservation on that particular file)\n\t */\n\tblock_i = EXT3_I(inode)->i_block_alloc_info;\n\tif (block_i && ((windowsz = block_i->rsv_window_node.rsv_goal_size) > 0))\n\t\tmy_rsv = &block_i->rsv_window_node;\n\n\tif (!ext3_has_free_blocks(sbi, IS_NOQUOTA(inode))) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, test whether the goal block is free.\n\t */\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext3_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t/*\n\t * if there is not enough free blocks to make a new resevation\n\t * turn off reservation for this allocation\n\t */\n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT3_BLOCKS_PER_GROUP(sb));\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext3_try_to_allocate_with_rsv(sb, handle,\n\t\t\t\t\tgroup_no, bitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv,\t&num, &fatal);\n\t\tif (fatal)\n\t\t\tgoto out;\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT3_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t/*\n\t * Now search the rest of the groups.  We assume that\n\t * group_no and gdp correctly point to the last group visited.\n\t */\n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext3_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t/*\n\t\t * skip this group (and avoid loading bitmap) if there\n\t\t * are no free blocks\n\t\t */\n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t/*\n\t\t * skip this group if the number of\n\t\t * free blocks is less than half of the reservation\n\t\t * window size.\n\t\t */\n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t/*\n\t\t * try to allocate block(s) from this group, without a goal(-1).\n\t\t */\n\t\tgrp_alloc_blk = ext3_try_to_allocate_with_rsv(sb, handle,\n\t\t\t\t\tgroup_no, bitmap_bh, -1, my_rsv,\n\t\t\t\t\t&num, &fatal);\n\t\tif (fatal)\n\t\t\tgoto out;\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t/*\n\t * We may end up a bogus earlier ENOSPC error due to\n\t * filesystem is \"full\" of reservations, but\n\t * there maybe indeed free blocks available on disk\n\t * In this case, we just forget about the reservations\n\t * just do block allocation as without reservations.\n\t */\n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t/* No space left on the device */\n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text3_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\tfatal = ext3_journal_get_write_access(handle, gdp_bh);\n\tif (fatal)\n\t\tgoto out;\n\n\tret_block = grp_alloc_blk + ext3_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT3_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT3_SB(sb)->s_itb_per_group)) {\n\t\text3_error(sb, \"ext3_new_block\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E3FSBLK\", length %lu\",\n\t\t\t     ret_block, num);\n\t\t/*\n\t\t * claim_block() marked the blocks we allocated as in use. So we\n\t\t * may want to selectively mark some of the blocks as free.\n\t\t */\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n#ifdef CONFIG_JBD_DEBUG\n\t{\n\t\tstruct buffer_head *debug_bh;\n\n\t\t/* Record bitmap buffer state in the newly allocated block */\n\t\tdebug_bh = sb_find_get_block(sb, ret_block);\n\t\tif (debug_bh) {\n\t\t\tBUFFER_TRACE(debug_bh, \"state when allocated\");\n\t\t\tBUFFER_TRACE2(debug_bh, bitmap_bh, \"bitmap state\");\n\t\t\tbrelse(debug_bh);\n\t\t}\n\t}\n\tjbd_lock_bh_state(bitmap_bh);\n\tspin_lock(sb_bgl_lock(sbi, group_no));\n\tif (buffer_jbd(bitmap_bh) && bh2jh(bitmap_bh)->b_committed_data) {\n\t\tint i;\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (ext3_test_bit(grp_alloc_blk+i,\n\t\t\t\t\tbh2jh(bitmap_bh)->b_committed_data)) {\n\t\t\t\tprintk(\"%s: block was unexpectedly set in \"\n\t\t\t\t\t\"b_committed_data\\n\", __func__);\n\t\t\t}\n\t\t}\n\t}\n\text3_debug(\"found bit %d\\n\", grp_alloc_blk);\n\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\tjbd_unlock_bh_state(bitmap_bh);\n#endif\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text3_error(sb, \"ext3_new_block\",\n\t\t\t    \"block(\"E3FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It is up to the caller to add the new buffer to a journal\n\t * list of some description.  We don't know in advance whether\n\t * the caller wants to use it as metadata or data.\n\t */\n\text3_debug(\"allocating block %lu. Goal hits %d of %d.\\n\",\n\t\t\tret_block, goal_hits, goal_attempts);\n\n\tspin_lock(sb_bgl_lock(sbi, group_no));\n\tle16_add_cpu(&gdp->bg_free_blocks_count, -num);\n\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tBUFFER_TRACE(gdp_bh, \"journal_dirty_metadata for group descriptor\");\n\tfatal = ext3_journal_dirty_metadata(handle, gdp_bh);\n\tif (fatal)\n\t\tgoto out;\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\n\tif (num < *count) {\n\t\tdquot_free_block(inode, *count-num);\n\t\t*count = num;\n\t}\n\n\ttrace_ext3_allocate_blocks(inode, goal, num,\n\t\t\t\t   (unsigned long long)ret_block);\n\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\tif (fatal) {\n\t\t*errp = fatal;\n\t\text3_std_error(sb, fatal);\n\t}\n\t/*\n\t * Undo the block allocation\n\t */\n\tif (!performed_allocation)\n\t\tdquot_free_block(inode, *count);\n\tbrelse(bitmap_bh);\n\treturn 0;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "inode",
            "*count"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "sb",
            "fatal"
          ],
          "line": 1752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_allocate_blocks",
          "args": [
            "inode",
            "goal",
            "num",
            "(unsigned long long)ret_block"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "inode",
            "*count-num"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "gdp_bh"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gdp_bh",
            "\"journal_dirty_metadata for group descriptor\""
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_sub",
          "args": [
            "&sbi->s_freeblocks_counter",
            "num"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "sb_bgl_lock(sbi, group_no)"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bgl_lock",
          "args": [
            "sbi",
            "group_no"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "sb_bgl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "683-687",
          "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&gdp->bg_free_blocks_count",
            "-num"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "sb_bgl_lock(sbi, group_no)"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"allocating block %lu. Goal hits %d of %d.\\n\"",
            "ret_block",
            "goal_hits",
            "goal_attempts"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "\"ext3_new_block\"",
            "\"block(\"E3FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \"",
            "ret_block",
            "le32_to_cpu(es->s_blocks_count)",
            "group_no",
            "es"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_blocks_count"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bitmap_bh"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"found bit %d\\n\"",
            "grp_alloc_blk"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%s: block was unexpectedly set in \"\n\t\t\t\t\t\"b_committed_data\\n\"",
            "__func__"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_test_bit",
          "args": [
            "grp_alloc_blk+i",
            "bh2jh(bitmap_bh)->b_committed_data"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bitmap_bh"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bitmap_bh"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bitmap_bh"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bitmap_bh"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE2",
          "args": [
            "debug_bh",
            "bitmap_bh",
            "\"bitmap state\""
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "debug_bh",
            "\"state when allocated\""
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_find_get_block",
          "args": [
            "sb",
            "ret_block"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_range",
          "args": [
            "ret_block + num - 1",
            "le32_to_cpu(gdp->bg_inode_table)",
            "EXT3_SB(sb)->s_itb_per_group"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_page_exists_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "7049-7117",
          "snippet": "bool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nbool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_group_first_block_no",
          "args": [
            "sb",
            "group_no"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "972-977",
          "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "gdp_bh"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gdp_bh",
            "\"get_write_access\""
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"using block group %d(%d)\\n\"",
            "group_no",
            "gdp->bg_free_blocks_count"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_try_to_allocate_with_rsv",
          "args": [
            "sb",
            "handle",
            "group_no",
            "bitmap_bh",
            "-1",
            "my_rsv",
            "&num",
            "&fatal"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_try_to_allocate_with_rsv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1314-1427",
          "snippet": "static ext3_grpblk_t\next3_try_to_allocate_with_rsv(struct super_block *sb, handle_t *handle,\n\t\t\tunsigned int group, struct buffer_head *bitmap_bh,\n\t\t\text3_grpblk_t grp_goal,\n\t\t\tstruct ext3_reserve_window_node * my_rsv,\n\t\t\tunsigned long *count, int *errp)\n{\n\text3_fsblk_t group_first_block, group_last_block;\n\text3_grpblk_t ret = 0;\n\tint fatal;\n\tunsigned long num = *count;\n\n\t*errp = 0;\n\n\t/*\n\t * Make sure we use undo access for the bitmap, because it is critical\n\t * that we do the frozen_data COW on bitmap buffers in all cases even\n\t * if the buffer is in BJ_Forget state in the committing transaction.\n\t */\n\tBUFFER_TRACE(bitmap_bh, \"get undo access for new block\");\n\tfatal = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (fatal) {\n\t\t*errp = fatal;\n\t\treturn -1;\n\t}\n\n\t/*\n\t * we don't deal with reservation when\n\t * filesystem is mounted without reservation\n\t * or the file is not a regular file\n\t * or last attempt to allocate a block with reservation turned on failed\n\t */\n\tif (my_rsv == NULL ) {\n\t\tret = ext3_try_to_allocate(sb, handle, group, bitmap_bh,\n\t\t\t\t\t\tgrp_goal, count, NULL);\n\t\tgoto out;\n\t}\n\t/*\n\t * grp_goal is a group relative block number (if there is a goal)\n\t * 0 <= grp_goal < EXT3_BLOCKS_PER_GROUP(sb)\n\t * first block is a filesystem wide block number\n\t * first block is the block number of the first block in this group\n\t */\n\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\t/*\n\t * Basically we will allocate a new block from inode's reservation\n\t * window.\n\t *\n\t * We need to allocate a new reservation window, if:\n\t * a) inode does not have a reservation window; or\n\t * b) last attempt to allocate a block from existing reservation\n\t *    failed; or\n\t * c) we come here with a goal and with a reservation window\n\t *\n\t * We do not need to allocate a new reservation window if we come here\n\t * at the beginning with a goal and the goal is inside the window, or\n\t * we don't have a goal but already have a reservation window.\n\t * then we could go to allocate from the reservation window directly.\n\t */\n\twhile (1) {\n\t\tif (rsv_is_empty(&my_rsv->rsv_window) || (ret < 0) ||\n\t\t\t!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\tgrp_goal, group, sb)) {\n\t\t\tif (my_rsv->rsv_goal_size < *count)\n\t\t\t\tmy_rsv->rsv_goal_size = *count;\n\t\t\tret = alloc_new_reservation(my_rsv, grp_goal, sb,\n\t\t\t\t\t\t\tgroup, bitmap_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\t\t\t/* failed */\n\n\t\t\tif (!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\t\tgrp_goal, group, sb))\n\t\t\t\tgrp_goal = -1;\n\t\t} else if (grp_goal >= 0) {\n\t\t\tint curr = my_rsv->rsv_end -\n\t\t\t\t\t(grp_goal + group_first_block) + 1;\n\n\t\t\tif (curr < *count)\n\t\t\t\ttry_to_extend_reservation(my_rsv, sb,\n\t\t\t\t\t\t\t*count - curr);\n\t\t}\n\n\t\tif ((my_rsv->rsv_start > group_last_block) ||\n\t\t\t\t(my_rsv->rsv_end < group_first_block)) {\n\t\t\trsv_window_dump(&EXT3_SB(sb)->s_rsv_window_root, 1);\n\t\t\tBUG();\n\t\t}\n\t\tret = ext3_try_to_allocate(sb, handle, group, bitmap_bh,\n\t\t\t\t\t   grp_goal, &num, &my_rsv->rsv_window);\n\t\tif (ret >= 0) {\n\t\t\tmy_rsv->rsv_alloc_hit += num;\n\t\t\t*count = num;\n\t\t\tbreak;\t\t\t\t/* succeed */\n\t\t}\n\t\tnum = *count;\n\t}\nout:\n\tif (ret >= 0) {\n\t\tBUFFER_TRACE(bitmap_bh, \"journal_dirty_metadata for \"\n\t\t\t\t\t\"bitmap block\");\n\t\tfatal = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\t\tif (fatal) {\n\t\t\t*errp = fatal;\n\t\t\treturn -1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"journal_release_buffer\");\n\text3_journal_release_buffer(handle, bitmap_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic ext3_grpblk_t\next3_try_to_allocate_with_rsv(struct super_block *sb, handle_t *handle,\n\t\t\tunsigned int group, struct buffer_head *bitmap_bh,\n\t\t\text3_grpblk_t grp_goal,\n\t\t\tstruct ext3_reserve_window_node * my_rsv,\n\t\t\tunsigned long *count, int *errp)\n{\n\text3_fsblk_t group_first_block, group_last_block;\n\text3_grpblk_t ret = 0;\n\tint fatal;\n\tunsigned long num = *count;\n\n\t*errp = 0;\n\n\t/*\n\t * Make sure we use undo access for the bitmap, because it is critical\n\t * that we do the frozen_data COW on bitmap buffers in all cases even\n\t * if the buffer is in BJ_Forget state in the committing transaction.\n\t */\n\tBUFFER_TRACE(bitmap_bh, \"get undo access for new block\");\n\tfatal = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (fatal) {\n\t\t*errp = fatal;\n\t\treturn -1;\n\t}\n\n\t/*\n\t * we don't deal with reservation when\n\t * filesystem is mounted without reservation\n\t * or the file is not a regular file\n\t * or last attempt to allocate a block with reservation turned on failed\n\t */\n\tif (my_rsv == NULL ) {\n\t\tret = ext3_try_to_allocate(sb, handle, group, bitmap_bh,\n\t\t\t\t\t\tgrp_goal, count, NULL);\n\t\tgoto out;\n\t}\n\t/*\n\t * grp_goal is a group relative block number (if there is a goal)\n\t * 0 <= grp_goal < EXT3_BLOCKS_PER_GROUP(sb)\n\t * first block is a filesystem wide block number\n\t * first block is the block number of the first block in this group\n\t */\n\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\t/*\n\t * Basically we will allocate a new block from inode's reservation\n\t * window.\n\t *\n\t * We need to allocate a new reservation window, if:\n\t * a) inode does not have a reservation window; or\n\t * b) last attempt to allocate a block from existing reservation\n\t *    failed; or\n\t * c) we come here with a goal and with a reservation window\n\t *\n\t * We do not need to allocate a new reservation window if we come here\n\t * at the beginning with a goal and the goal is inside the window, or\n\t * we don't have a goal but already have a reservation window.\n\t * then we could go to allocate from the reservation window directly.\n\t */\n\twhile (1) {\n\t\tif (rsv_is_empty(&my_rsv->rsv_window) || (ret < 0) ||\n\t\t\t!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\tgrp_goal, group, sb)) {\n\t\t\tif (my_rsv->rsv_goal_size < *count)\n\t\t\t\tmy_rsv->rsv_goal_size = *count;\n\t\t\tret = alloc_new_reservation(my_rsv, grp_goal, sb,\n\t\t\t\t\t\t\tgroup, bitmap_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\t\t\t/* failed */\n\n\t\t\tif (!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\t\tgrp_goal, group, sb))\n\t\t\t\tgrp_goal = -1;\n\t\t} else if (grp_goal >= 0) {\n\t\t\tint curr = my_rsv->rsv_end -\n\t\t\t\t\t(grp_goal + group_first_block) + 1;\n\n\t\t\tif (curr < *count)\n\t\t\t\ttry_to_extend_reservation(my_rsv, sb,\n\t\t\t\t\t\t\t*count - curr);\n\t\t}\n\n\t\tif ((my_rsv->rsv_start > group_last_block) ||\n\t\t\t\t(my_rsv->rsv_end < group_first_block)) {\n\t\t\trsv_window_dump(&EXT3_SB(sb)->s_rsv_window_root, 1);\n\t\t\tBUG();\n\t\t}\n\t\tret = ext3_try_to_allocate(sb, handle, group, bitmap_bh,\n\t\t\t\t\t   grp_goal, &num, &my_rsv->rsv_window);\n\t\tif (ret >= 0) {\n\t\t\tmy_rsv->rsv_alloc_hit += num;\n\t\t\t*count = num;\n\t\t\tbreak;\t\t\t\t/* succeed */\n\t\t}\n\t\tnum = *count;\n\t}\nout:\n\tif (ret >= 0) {\n\t\tBUFFER_TRACE(bitmap_bh, \"journal_dirty_metadata for \"\n\t\t\t\t\t\"bitmap block\");\n\t\tfatal = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\t\tif (fatal) {\n\t\t\t*errp = fatal;\n\t\t\treturn -1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"journal_release_buffer\");\n\text3_journal_release_buffer(handle, bitmap_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_block_bitmap",
          "args": [
            "sb",
            "group_no"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "147-184",
          "snippet": "static struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext3_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text3_fsblk_t bitmap_blk;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\ttrace_ext3_read_block_bitmap(sb, block_group);\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\text3_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext3_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text3_fsblk_t bitmap_blk;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\ttrace_ext3_read_block_bitmap(sb, block_group);\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\text3_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gdp->bg_free_blocks_count"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "group_no",
            "&gdp_bh"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsv_is_empty",
          "args": [
            "&my_rsv->rsv_window"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "392-396",
          "snippet": "static inline int rsv_is_empty(struct ext3_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic inline int rsv_is_empty(struct ext3_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_has_free_blocks",
          "args": [
            "sbi",
            "IS_NOQUOTA(inode)"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_has_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1435-1448",
          "snippet": "static int ext3_has_free_blocks(struct ext3_sb_info *sbi, int use_reservation)\n{\n\text3_fsblk_t free_blocks, root_blocks;\n\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\troot_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);\n\tif (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&\n\t\t!use_reservation && !uid_eq(sbi->s_resuid, current_fsuid()) &&\n\t\t(gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) ||\n\t\t !in_group_p (sbi->s_resgid))) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int ext3_has_free_blocks(struct ext3_sb_info *sbi, int use_reservation)\n{\n\text3_fsblk_t free_blocks, root_blocks;\n\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\troot_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);\n\tif (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&\n\t\t!use_reservation && !uid_eq(sbi->s_resuid, current_fsuid()) &&\n\t\t(gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) ||\n\t\t !in_group_p (sbi->s_resgid))) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_NOQUOTA",
          "args": [
            "inode"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"goal=%lu.\\n\"",
            "goal"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_request_blocks",
          "args": [
            "inode",
            "goal",
            "num"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dquot_alloc_block",
          "args": [
            "inode",
            "num"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\next3_fsblk_t ext3_new_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t goal, unsigned long *count, int *errp)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gdp_bh;\n\tint group_no;\n\tint goal_group;\n\text3_grpblk_t grp_target_blk;\t/* blockgroup relative goal block */\n\text3_grpblk_t grp_alloc_blk;\t/* blockgroup-relative allocated block*/\n\text3_fsblk_t ret_block;\t\t/* filesyetem-wide allocated block */\n\tint bgi;\t\t\t/* blockgroup iteration index */\n\tint fatal = 0, err;\n\tint performed_allocation = 0;\n\text3_grpblk_t free_blocks;\t/* number of free blocks in a group */\n\tstruct super_block *sb;\n\tstruct ext3_group_desc *gdp;\n\tstruct ext3_super_block *es;\n\tstruct ext3_sb_info *sbi;\n\tstruct ext3_reserve_window_node *my_rsv = NULL;\n\tstruct ext3_block_alloc_info *block_i;\n\tunsigned short windowsz = 0;\n#ifdef EXT3FS_DEBUG\n\tstatic int goal_hits, goal_attempts;\n#endif\n\tunsigned long ngroups;\n\tunsigned long num = *count;\n\n\t*errp = -ENOSPC;\n\tsb = inode->i_sb;\n\n\t/*\n\t * Check quota for allocation of this block.\n\t */\n\terr = dquot_alloc_block(inode, num);\n\tif (err) {\n\t\t*errp = err;\n\t\treturn 0;\n\t}\n\n\ttrace_ext3_request_blocks(inode, goal, num);\n\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\text3_debug(\"goal=%lu.\\n\", goal);\n\t/*\n\t * Allocate a block from reservation only when\n\t * filesystem is mounted with reservation(default,-o reservation), and\n\t * it's a regular file, and\n\t * the desired window size is greater than 0 (One could use ioctl\n\t * command EXT3_IOC_SETRSVSZ to set the window size to 0 to turn off\n\t * reservation on that particular file)\n\t */\n\tblock_i = EXT3_I(inode)->i_block_alloc_info;\n\tif (block_i && ((windowsz = block_i->rsv_window_node.rsv_goal_size) > 0))\n\t\tmy_rsv = &block_i->rsv_window_node;\n\n\tif (!ext3_has_free_blocks(sbi, IS_NOQUOTA(inode))) {\n\t\t*errp = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * First, test whether the goal block is free.\n\t */\n\tif (goal < le32_to_cpu(es->s_first_data_block) ||\n\t    goal >= le32_to_cpu(es->s_blocks_count))\n\t\tgoal = le32_to_cpu(es->s_first_data_block);\n\tgroup_no = (goal - le32_to_cpu(es->s_first_data_block)) /\n\t\t\tEXT3_BLOCKS_PER_GROUP(sb);\n\tgoal_group = group_no;\nretry_alloc:\n\tgdp = ext3_get_group_desc(sb, group_no, &gdp_bh);\n\tif (!gdp)\n\t\tgoto io_error;\n\n\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t/*\n\t * if there is not enough free blocks to make a new resevation\n\t * turn off reservation for this allocation\n\t */\n\tif (my_rsv && (free_blocks < windowsz)\n\t\t&& (free_blocks > 0)\n\t\t&& (rsv_is_empty(&my_rsv->rsv_window)))\n\t\tmy_rsv = NULL;\n\n\tif (free_blocks > 0) {\n\t\tgrp_target_blk = ((goal - le32_to_cpu(es->s_first_data_block)) %\n\t\t\t\tEXT3_BLOCKS_PER_GROUP(sb));\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\tgrp_alloc_blk = ext3_try_to_allocate_with_rsv(sb, handle,\n\t\t\t\t\tgroup_no, bitmap_bh, grp_target_blk,\n\t\t\t\t\tmy_rsv,\t&num, &fatal);\n\t\tif (fatal)\n\t\t\tgoto out;\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\n\tngroups = EXT3_SB(sb)->s_groups_count;\n\tsmp_rmb();\n\n\t/*\n\t * Now search the rest of the groups.  We assume that\n\t * group_no and gdp correctly point to the last group visited.\n\t */\n\tfor (bgi = 0; bgi < ngroups; bgi++) {\n\t\tgroup_no++;\n\t\tif (group_no >= ngroups)\n\t\t\tgroup_no = 0;\n\t\tgdp = ext3_get_group_desc(sb, group_no, &gdp_bh);\n\t\tif (!gdp)\n\t\t\tgoto io_error;\n\t\tfree_blocks = le16_to_cpu(gdp->bg_free_blocks_count);\n\t\t/*\n\t\t * skip this group (and avoid loading bitmap) if there\n\t\t * are no free blocks\n\t\t */\n\t\tif (!free_blocks)\n\t\t\tcontinue;\n\t\t/*\n\t\t * skip this group if the number of\n\t\t * free blocks is less than half of the reservation\n\t\t * window size.\n\t\t */\n\t\tif (my_rsv && (free_blocks <= (windowsz/2)))\n\t\t\tcontinue;\n\n\t\tbrelse(bitmap_bh);\n\t\tbitmap_bh = read_block_bitmap(sb, group_no);\n\t\tif (!bitmap_bh)\n\t\t\tgoto io_error;\n\t\t/*\n\t\t * try to allocate block(s) from this group, without a goal(-1).\n\t\t */\n\t\tgrp_alloc_blk = ext3_try_to_allocate_with_rsv(sb, handle,\n\t\t\t\t\tgroup_no, bitmap_bh, -1, my_rsv,\n\t\t\t\t\t&num, &fatal);\n\t\tif (fatal)\n\t\t\tgoto out;\n\t\tif (grp_alloc_blk >= 0)\n\t\t\tgoto allocated;\n\t}\n\t/*\n\t * We may end up a bogus earlier ENOSPC error due to\n\t * filesystem is \"full\" of reservations, but\n\t * there maybe indeed free blocks available on disk\n\t * In this case, we just forget about the reservations\n\t * just do block allocation as without reservations.\n\t */\n\tif (my_rsv) {\n\t\tmy_rsv = NULL;\n\t\twindowsz = 0;\n\t\tgroup_no = goal_group;\n\t\tgoto retry_alloc;\n\t}\n\t/* No space left on the device */\n\t*errp = -ENOSPC;\n\tgoto out;\n\nallocated:\n\n\text3_debug(\"using block group %d(%d)\\n\",\n\t\t\tgroup_no, gdp->bg_free_blocks_count);\n\n\tBUFFER_TRACE(gdp_bh, \"get_write_access\");\n\tfatal = ext3_journal_get_write_access(handle, gdp_bh);\n\tif (fatal)\n\t\tgoto out;\n\n\tret_block = grp_alloc_blk + ext3_group_first_block_no(sb, group_no);\n\n\tif (in_range(le32_to_cpu(gdp->bg_block_bitmap), ret_block, num) ||\n\t    in_range(le32_to_cpu(gdp->bg_inode_bitmap), ret_block, num) ||\n\t    in_range(ret_block, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT3_SB(sb)->s_itb_per_group) ||\n\t    in_range(ret_block + num - 1, le32_to_cpu(gdp->bg_inode_table),\n\t\t      EXT3_SB(sb)->s_itb_per_group)) {\n\t\text3_error(sb, \"ext3_new_block\",\n\t\t\t    \"Allocating block in system zone - \"\n\t\t\t    \"blocks from \"E3FSBLK\", length %lu\",\n\t\t\t     ret_block, num);\n\t\t/*\n\t\t * claim_block() marked the blocks we allocated as in use. So we\n\t\t * may want to selectively mark some of the blocks as free.\n\t\t */\n\t\tgoto retry_alloc;\n\t}\n\n\tperformed_allocation = 1;\n\n#ifdef CONFIG_JBD_DEBUG\n\t{\n\t\tstruct buffer_head *debug_bh;\n\n\t\t/* Record bitmap buffer state in the newly allocated block */\n\t\tdebug_bh = sb_find_get_block(sb, ret_block);\n\t\tif (debug_bh) {\n\t\t\tBUFFER_TRACE(debug_bh, \"state when allocated\");\n\t\t\tBUFFER_TRACE2(debug_bh, bitmap_bh, \"bitmap state\");\n\t\t\tbrelse(debug_bh);\n\t\t}\n\t}\n\tjbd_lock_bh_state(bitmap_bh);\n\tspin_lock(sb_bgl_lock(sbi, group_no));\n\tif (buffer_jbd(bitmap_bh) && bh2jh(bitmap_bh)->b_committed_data) {\n\t\tint i;\n\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tif (ext3_test_bit(grp_alloc_blk+i,\n\t\t\t\t\tbh2jh(bitmap_bh)->b_committed_data)) {\n\t\t\t\tprintk(\"%s: block was unexpectedly set in \"\n\t\t\t\t\t\"b_committed_data\\n\", __func__);\n\t\t\t}\n\t\t}\n\t}\n\text3_debug(\"found bit %d\\n\", grp_alloc_blk);\n\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\tjbd_unlock_bh_state(bitmap_bh);\n#endif\n\n\tif (ret_block + num - 1 >= le32_to_cpu(es->s_blocks_count)) {\n\t\text3_error(sb, \"ext3_new_block\",\n\t\t\t    \"block(\"E3FSBLK\") >= blocks count(%d) - \"\n\t\t\t    \"block_group = %d, es == %p \", ret_block,\n\t\t\tle32_to_cpu(es->s_blocks_count), group_no, es);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * It is up to the caller to add the new buffer to a journal\n\t * list of some description.  We don't know in advance whether\n\t * the caller wants to use it as metadata or data.\n\t */\n\text3_debug(\"allocating block %lu. Goal hits %d of %d.\\n\",\n\t\t\tret_block, goal_hits, goal_attempts);\n\n\tspin_lock(sb_bgl_lock(sbi, group_no));\n\tle16_add_cpu(&gdp->bg_free_blocks_count, -num);\n\tspin_unlock(sb_bgl_lock(sbi, group_no));\n\tpercpu_counter_sub(&sbi->s_freeblocks_counter, num);\n\n\tBUFFER_TRACE(gdp_bh, \"journal_dirty_metadata for group descriptor\");\n\tfatal = ext3_journal_dirty_metadata(handle, gdp_bh);\n\tif (fatal)\n\t\tgoto out;\n\n\t*errp = 0;\n\tbrelse(bitmap_bh);\n\n\tif (num < *count) {\n\t\tdquot_free_block(inode, *count-num);\n\t\t*count = num;\n\t}\n\n\ttrace_ext3_allocate_blocks(inode, goal, num,\n\t\t\t\t   (unsigned long long)ret_block);\n\n\treturn ret_block;\n\nio_error:\n\t*errp = -EIO;\nout:\n\tif (fatal) {\n\t\t*errp = fatal;\n\t\text3_std_error(sb, fatal);\n\t}\n\t/*\n\t * Undo the block allocation\n\t */\n\tif (!performed_allocation)\n\t\tdquot_free_block(inode, *count);\n\tbrelse(bitmap_bh);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_should_retry_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1462-1470",
    "snippet": "int ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_force_commit_nested",
          "args": [
            "EXT3_SB(sb)->s_journal"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "journal_force_commit_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "510-531",
          "snippet": "int journal_force_commit_nested(journal_t *journal)\n{\n\ttransaction_t *transaction = NULL;\n\ttid_t tid;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction && !current->journal_info) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\tif (!transaction) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 0;\t/* Nothing to retry */\n\t}\n\n\ttid = transaction->t_tid;\n\tspin_unlock(&journal->j_state_lock);\n\tlog_wait_commit(journal, tid);\n\treturn 1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_force_commit_nested(journal_t *journal)\n{\n\ttransaction_t *transaction = NULL;\n\ttid_t tid;\n\n\tspin_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction && !current->journal_info) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\tif (!transaction) {\n\t\tspin_unlock(&journal->j_state_lock);\n\t\treturn 0;\t/* Nothing to retry */\n\t}\n\n\ttid = transaction->t_tid;\n\tspin_unlock(&journal->j_state_lock);\n\tlog_wait_commit(journal, tid);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"%s: retrying operation after ENOSPC\\n\"",
            "sb->s_id"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_has_free_blocks",
          "args": [
            "EXT3_SB(sb)",
            "0"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_has_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1435-1448",
          "snippet": "static int ext3_has_free_blocks(struct ext3_sb_info *sbi, int use_reservation)\n{\n\text3_fsblk_t free_blocks, root_blocks;\n\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\troot_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);\n\tif (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&\n\t\t!use_reservation && !uid_eq(sbi->s_resuid, current_fsuid()) &&\n\t\t(gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) ||\n\t\t !in_group_p (sbi->s_resgid))) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int ext3_has_free_blocks(struct ext3_sb_info *sbi, int use_reservation)\n{\n\text3_fsblk_t free_blocks, root_blocks;\n\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\troot_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);\n\tif (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&\n\t\t!use_reservation && !uid_eq(sbi->s_resuid, current_fsuid()) &&\n\t\t(gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) ||\n\t\t !in_group_p (sbi->s_resgid))) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nint ext3_should_retry_alloc(struct super_block *sb, int *retries)\n{\n\tif (!ext3_has_free_blocks(EXT3_SB(sb), 0) || (*retries)++ > 3)\n\t\treturn 0;\n\n\tjbd_debug(1, \"%s: retrying operation after ENOSPC\\n\", sb->s_id);\n\n\treturn journal_force_commit_nested(EXT3_SB(sb)->s_journal);\n}"
  },
  {
    "function_name": "ext3_has_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1435-1448",
    "snippet": "static int ext3_has_free_blocks(struct ext3_sb_info *sbi, int use_reservation)\n{\n\text3_fsblk_t free_blocks, root_blocks;\n\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\troot_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);\n\tif (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&\n\t\t!use_reservation && !uid_eq(sbi->s_resuid, current_fsuid()) &&\n\t\t(gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) ||\n\t\t !in_group_p (sbi->s_resgid))) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "sbi->s_resgid"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "sbi->s_resgid",
            "GLOBAL_ROOT_GID"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "sbi->s_resuid",
            "current_fsuid()"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "sbi->s_es->s_r_blocks_count"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&sbi->s_freeblocks_counter"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int ext3_has_free_blocks(struct ext3_sb_info *sbi, int use_reservation)\n{\n\text3_fsblk_t free_blocks, root_blocks;\n\n\tfree_blocks = percpu_counter_read_positive(&sbi->s_freeblocks_counter);\n\troot_blocks = le32_to_cpu(sbi->s_es->s_r_blocks_count);\n\tif (free_blocks < root_blocks + 1 && !capable(CAP_SYS_RESOURCE) &&\n\t\t!use_reservation && !uid_eq(sbi->s_resuid, current_fsuid()) &&\n\t\t(gid_eq(sbi->s_resgid, GLOBAL_ROOT_GID) ||\n\t\t !in_group_p (sbi->s_resgid))) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "ext3_try_to_allocate_with_rsv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1314-1427",
    "snippet": "static ext3_grpblk_t\next3_try_to_allocate_with_rsv(struct super_block *sb, handle_t *handle,\n\t\t\tunsigned int group, struct buffer_head *bitmap_bh,\n\t\t\text3_grpblk_t grp_goal,\n\t\t\tstruct ext3_reserve_window_node * my_rsv,\n\t\t\tunsigned long *count, int *errp)\n{\n\text3_fsblk_t group_first_block, group_last_block;\n\text3_grpblk_t ret = 0;\n\tint fatal;\n\tunsigned long num = *count;\n\n\t*errp = 0;\n\n\t/*\n\t * Make sure we use undo access for the bitmap, because it is critical\n\t * that we do the frozen_data COW on bitmap buffers in all cases even\n\t * if the buffer is in BJ_Forget state in the committing transaction.\n\t */\n\tBUFFER_TRACE(bitmap_bh, \"get undo access for new block\");\n\tfatal = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (fatal) {\n\t\t*errp = fatal;\n\t\treturn -1;\n\t}\n\n\t/*\n\t * we don't deal with reservation when\n\t * filesystem is mounted without reservation\n\t * or the file is not a regular file\n\t * or last attempt to allocate a block with reservation turned on failed\n\t */\n\tif (my_rsv == NULL ) {\n\t\tret = ext3_try_to_allocate(sb, handle, group, bitmap_bh,\n\t\t\t\t\t\tgrp_goal, count, NULL);\n\t\tgoto out;\n\t}\n\t/*\n\t * grp_goal is a group relative block number (if there is a goal)\n\t * 0 <= grp_goal < EXT3_BLOCKS_PER_GROUP(sb)\n\t * first block is a filesystem wide block number\n\t * first block is the block number of the first block in this group\n\t */\n\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\t/*\n\t * Basically we will allocate a new block from inode's reservation\n\t * window.\n\t *\n\t * We need to allocate a new reservation window, if:\n\t * a) inode does not have a reservation window; or\n\t * b) last attempt to allocate a block from existing reservation\n\t *    failed; or\n\t * c) we come here with a goal and with a reservation window\n\t *\n\t * We do not need to allocate a new reservation window if we come here\n\t * at the beginning with a goal and the goal is inside the window, or\n\t * we don't have a goal but already have a reservation window.\n\t * then we could go to allocate from the reservation window directly.\n\t */\n\twhile (1) {\n\t\tif (rsv_is_empty(&my_rsv->rsv_window) || (ret < 0) ||\n\t\t\t!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\tgrp_goal, group, sb)) {\n\t\t\tif (my_rsv->rsv_goal_size < *count)\n\t\t\t\tmy_rsv->rsv_goal_size = *count;\n\t\t\tret = alloc_new_reservation(my_rsv, grp_goal, sb,\n\t\t\t\t\t\t\tgroup, bitmap_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\t\t\t/* failed */\n\n\t\t\tif (!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\t\tgrp_goal, group, sb))\n\t\t\t\tgrp_goal = -1;\n\t\t} else if (grp_goal >= 0) {\n\t\t\tint curr = my_rsv->rsv_end -\n\t\t\t\t\t(grp_goal + group_first_block) + 1;\n\n\t\t\tif (curr < *count)\n\t\t\t\ttry_to_extend_reservation(my_rsv, sb,\n\t\t\t\t\t\t\t*count - curr);\n\t\t}\n\n\t\tif ((my_rsv->rsv_start > group_last_block) ||\n\t\t\t\t(my_rsv->rsv_end < group_first_block)) {\n\t\t\trsv_window_dump(&EXT3_SB(sb)->s_rsv_window_root, 1);\n\t\t\tBUG();\n\t\t}\n\t\tret = ext3_try_to_allocate(sb, handle, group, bitmap_bh,\n\t\t\t\t\t   grp_goal, &num, &my_rsv->rsv_window);\n\t\tif (ret >= 0) {\n\t\t\tmy_rsv->rsv_alloc_hit += num;\n\t\t\t*count = num;\n\t\t\tbreak;\t\t\t\t/* succeed */\n\t\t}\n\t\tnum = *count;\n\t}\nout:\n\tif (ret >= 0) {\n\t\tBUFFER_TRACE(bitmap_bh, \"journal_dirty_metadata for \"\n\t\t\t\t\t\"bitmap block\");\n\t\tfatal = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\t\tif (fatal) {\n\t\t\t*errp = fatal;\n\t\t\treturn -1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"journal_release_buffer\");\n\text3_journal_release_buffer(handle, bitmap_bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_journal_release_buffer",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"journal_release_buffer\""
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"journal_dirty_metadata for \"\n\t\t\t\t\t\"bitmap block\""
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_try_to_allocate",
          "args": [
            "sb",
            "handle",
            "group",
            "bitmap_bh",
            "grp_goal",
            "&num",
            "&my_rsv->rsv_window"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_try_to_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "875-953",
          "snippet": "static ext3_grpblk_t\next3_try_to_allocate(struct super_block *sb, handle_t *handle, int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext3_grpblk_t grp_goal,\n\t\t\tunsigned long *count, struct ext3_reserve_window *my_rsv)\n{\n\text3_fsblk_t group_first_block;\n\text3_grpblk_t start, end;\n\tunsigned long num = 0;\n\n\t/* we do allocation within the reservation window if we have a window */\n\tif (my_rsv) {\n\t\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\t\tif (my_rsv->_rsv_start >= group_first_block)\n\t\t\tstart = my_rsv->_rsv_start - group_first_block;\n\t\telse\n\t\t\t/* reservation window cross group boundary */\n\t\t\tstart = 0;\n\t\tend = my_rsv->_rsv_end - group_first_block + 1;\n\t\tif (end > EXT3_BLOCKS_PER_GROUP(sb))\n\t\t\t/* reservation window crosses group boundary */\n\t\t\tend = EXT3_BLOCKS_PER_GROUP(sb);\n\t\tif ((start <= grp_goal) && (grp_goal < end))\n\t\t\tstart = grp_goal;\n\t\telse\n\t\t\tgrp_goal = -1;\n\t} else {\n\t\tif (grp_goal > 0)\n\t\t\tstart = grp_goal;\n\t\telse\n\t\t\tstart = 0;\n\t\tend = EXT3_BLOCKS_PER_GROUP(sb);\n\t}\n\n\tBUG_ON(start > EXT3_BLOCKS_PER_GROUP(sb));\n\nrepeat:\n\tif (grp_goal < 0 || !ext3_test_allocatable(grp_goal, bitmap_bh)) {\n\t\tgrp_goal = find_next_usable_block(start, bitmap_bh, end);\n\t\tif (grp_goal < 0)\n\t\t\tgoto fail_access;\n\t\tif (!my_rsv) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 7 && grp_goal > start &&\n\t\t\t\t\text3_test_allocatable(grp_goal - 1,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\t\ti++, grp_goal--)\n\t\t\t\t;\n\t\t}\n\t}\n\tstart = grp_goal;\n\n\tif (!claim_block(sb_bgl_lock(EXT3_SB(sb), group),\n\t\tgrp_goal, bitmap_bh)) {\n\t\t/*\n\t\t * The block was allocated by another thread, or it was\n\t\t * allocated and then freed by another thread\n\t\t */\n\t\tstart++;\n\t\tgrp_goal++;\n\t\tif (start >= end)\n\t\t\tgoto fail_access;\n\t\tgoto repeat;\n\t}\n\tnum++;\n\tgrp_goal++;\n\twhile (num < *count && grp_goal < end\n\t\t&& ext3_test_allocatable(grp_goal, bitmap_bh)\n\t\t&& claim_block(sb_bgl_lock(EXT3_SB(sb), group),\n\t\t\t\tgrp_goal, bitmap_bh)) {\n\t\tnum++;\n\t\tgrp_goal++;\n\t}\n\t*count = num;\n\treturn grp_goal - num;\nfail_access:\n\t*count = num;\n\treturn -1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic ext3_grpblk_t\next3_try_to_allocate(struct super_block *sb, handle_t *handle, int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext3_grpblk_t grp_goal,\n\t\t\tunsigned long *count, struct ext3_reserve_window *my_rsv)\n{\n\text3_fsblk_t group_first_block;\n\text3_grpblk_t start, end;\n\tunsigned long num = 0;\n\n\t/* we do allocation within the reservation window if we have a window */\n\tif (my_rsv) {\n\t\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\t\tif (my_rsv->_rsv_start >= group_first_block)\n\t\t\tstart = my_rsv->_rsv_start - group_first_block;\n\t\telse\n\t\t\t/* reservation window cross group boundary */\n\t\t\tstart = 0;\n\t\tend = my_rsv->_rsv_end - group_first_block + 1;\n\t\tif (end > EXT3_BLOCKS_PER_GROUP(sb))\n\t\t\t/* reservation window crosses group boundary */\n\t\t\tend = EXT3_BLOCKS_PER_GROUP(sb);\n\t\tif ((start <= grp_goal) && (grp_goal < end))\n\t\t\tstart = grp_goal;\n\t\telse\n\t\t\tgrp_goal = -1;\n\t} else {\n\t\tif (grp_goal > 0)\n\t\t\tstart = grp_goal;\n\t\telse\n\t\t\tstart = 0;\n\t\tend = EXT3_BLOCKS_PER_GROUP(sb);\n\t}\n\n\tBUG_ON(start > EXT3_BLOCKS_PER_GROUP(sb));\n\nrepeat:\n\tif (grp_goal < 0 || !ext3_test_allocatable(grp_goal, bitmap_bh)) {\n\t\tgrp_goal = find_next_usable_block(start, bitmap_bh, end);\n\t\tif (grp_goal < 0)\n\t\t\tgoto fail_access;\n\t\tif (!my_rsv) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 7 && grp_goal > start &&\n\t\t\t\t\text3_test_allocatable(grp_goal - 1,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\t\ti++, grp_goal--)\n\t\t\t\t;\n\t\t}\n\t}\n\tstart = grp_goal;\n\n\tif (!claim_block(sb_bgl_lock(EXT3_SB(sb), group),\n\t\tgrp_goal, bitmap_bh)) {\n\t\t/*\n\t\t * The block was allocated by another thread, or it was\n\t\t * allocated and then freed by another thread\n\t\t */\n\t\tstart++;\n\t\tgrp_goal++;\n\t\tif (start >= end)\n\t\t\tgoto fail_access;\n\t\tgoto repeat;\n\t}\n\tnum++;\n\tgrp_goal++;\n\twhile (num < *count && grp_goal < end\n\t\t&& ext3_test_allocatable(grp_goal, bitmap_bh)\n\t\t&& claim_block(sb_bgl_lock(EXT3_SB(sb), group),\n\t\t\t\tgrp_goal, bitmap_bh)) {\n\t\tnum++;\n\t\tgrp_goal++;\n\t}\n\t*count = num;\n\treturn grp_goal - num;\nfail_access:\n\t*count = num;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsv_window_dump",
          "args": [
            "&EXT3_SB(sb)->s_rsv_window_root",
            "1"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_to_extend_reservation",
          "args": [
            "my_rsv",
            "sb",
            "*count - curr"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_extend_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1260-1283",
          "snippet": "static void try_to_extend_reservation(struct ext3_reserve_window_node *my_rsv,\n\t\t\tstruct super_block *sb, int size)\n{\n\tstruct ext3_reserve_window_node *next_rsv;\n\tstruct rb_node *next;\n\tspinlock_t *rsv_lock = &EXT3_SB(sb)->s_rsv_window_lock;\n\n\tif (!spin_trylock(rsv_lock))\n\t\treturn;\n\n\tnext = rb_next(&my_rsv->rsv_node);\n\n\tif (!next)\n\t\tmy_rsv->rsv_end += size;\n\telse {\n\t\tnext_rsv = rb_entry(next, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif ((next_rsv->rsv_start - my_rsv->rsv_end - 1) >= size)\n\t\t\tmy_rsv->rsv_end += size;\n\t\telse\n\t\t\tmy_rsv->rsv_end = next_rsv->rsv_start - 1;\n\t}\n\tspin_unlock(rsv_lock);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic void try_to_extend_reservation(struct ext3_reserve_window_node *my_rsv,\n\t\t\tstruct super_block *sb, int size)\n{\n\tstruct ext3_reserve_window_node *next_rsv;\n\tstruct rb_node *next;\n\tspinlock_t *rsv_lock = &EXT3_SB(sb)->s_rsv_window_lock;\n\n\tif (!spin_trylock(rsv_lock))\n\t\treturn;\n\n\tnext = rb_next(&my_rsv->rsv_node);\n\n\tif (!next)\n\t\tmy_rsv->rsv_end += size;\n\telse {\n\t\tnext_rsv = rb_entry(next, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif ((next_rsv->rsv_start - my_rsv->rsv_end - 1) >= size)\n\t\t\tmy_rsv->rsv_end += size;\n\t\telse\n\t\t\tmy_rsv->rsv_end = next_rsv->rsv_start - 1;\n\t}\n\tspin_unlock(rsv_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "goal_in_my_reservation",
          "args": [
            "&my_rsv->rsv_window",
            "grp_goal",
            "group",
            "sb"
          ],
          "line": 1386
        },
        "resolved": true,
        "details": {
          "function_name": "goal_in_my_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "271-287",
          "snippet": "static int\ngoal_in_my_reservation(struct ext3_reserve_window *rsv, ext3_grpblk_t grp_goal,\n\t\t\tunsigned int group, struct super_block * sb)\n{\n\text3_fsblk_t group_first_block, group_last_block;\n\n\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\tif ((rsv->_rsv_start > group_last_block) ||\n\t    (rsv->_rsv_end < group_first_block))\n\t\treturn 0;\n\tif ((grp_goal >= 0) && ((grp_goal + group_first_block < rsv->_rsv_start)\n\t\t|| (grp_goal + group_first_block > rsv->_rsv_end)))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int\ngoal_in_my_reservation(struct ext3_reserve_window *rsv, ext3_grpblk_t grp_goal,\n\t\t\tunsigned int group, struct super_block * sb)\n{\n\text3_fsblk_t group_first_block, group_last_block;\n\n\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\tif ((rsv->_rsv_start > group_last_block) ||\n\t    (rsv->_rsv_end < group_first_block))\n\t\treturn 0;\n\tif ((grp_goal >= 0) && ((grp_goal + group_first_block < rsv->_rsv_start)\n\t\t|| (grp_goal + group_first_block > rsv->_rsv_end)))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_new_reservation",
          "args": [
            "my_rsv",
            "grp_goal",
            "sb",
            "group",
            "bitmap_bh"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_new_reservation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "1112-1241",
          "snippet": "static int alloc_new_reservation(struct ext3_reserve_window_node *my_rsv,\n\t\text3_grpblk_t grp_goal, struct super_block *sb,\n\t\tunsigned int group, struct buffer_head *bitmap_bh)\n{\n\tstruct ext3_reserve_window_node *search_head;\n\text3_fsblk_t group_first_block, group_end_block, start_block;\n\text3_grpblk_t first_free_block;\n\tstruct rb_root *fs_rsv_root = &EXT3_SB(sb)->s_rsv_window_root;\n\tunsigned long size;\n\tint ret;\n\tspinlock_t *rsv_lock = &EXT3_SB(sb)->s_rsv_window_lock;\n\n\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\tgroup_end_block = group_first_block + (EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\tif (grp_goal < 0)\n\t\tstart_block = group_first_block;\n\telse\n\t\tstart_block = grp_goal + group_first_block;\n\n\ttrace_ext3_alloc_new_reservation(sb, start_block);\n\tsize = my_rsv->rsv_goal_size;\n\n\tif (!rsv_is_empty(&my_rsv->rsv_window)) {\n\t\t/*\n\t\t * if the old reservation is cross group boundary\n\t\t * and if the goal is inside the old reservation window,\n\t\t * we will come here when we just failed to allocate from\n\t\t * the first part of the window. We still have another part\n\t\t * that belongs to the next group. In this case, there is no\n\t\t * point to discard our window and try to allocate a new one\n\t\t * in this group(which will fail). we should\n\t\t * keep the reservation window, just simply move on.\n\t\t *\n\t\t * Maybe we could shift the start block of the reservation\n\t\t * window to the first block of next group.\n\t\t */\n\n\t\tif ((my_rsv->rsv_start <= group_end_block) &&\n\t\t\t\t(my_rsv->rsv_end > group_end_block) &&\n\t\t\t\t(start_block >= my_rsv->rsv_start))\n\t\t\treturn -1;\n\n\t\tif ((my_rsv->rsv_alloc_hit >\n\t\t     (my_rsv->rsv_end - my_rsv->rsv_start + 1) / 2)) {\n\t\t\t/*\n\t\t\t * if the previously allocation hit ratio is\n\t\t\t * greater than 1/2, then we double the size of\n\t\t\t * the reservation window the next time,\n\t\t\t * otherwise we keep the same size window\n\t\t\t */\n\t\t\tsize = size * 2;\n\t\t\tif (size > EXT3_MAX_RESERVE_BLOCKS)\n\t\t\t\tsize = EXT3_MAX_RESERVE_BLOCKS;\n\t\t\tmy_rsv->rsv_goal_size= size;\n\t\t}\n\t}\n\n\tspin_lock(rsv_lock);\n\t/*\n\t * shift the search start to the window near the goal block\n\t */\n\tsearch_head = search_reserve_window(fs_rsv_root, start_block);\n\n\t/*\n\t * find_next_reservable_window() simply finds a reservable window\n\t * inside the given range(start_block, group_end_block).\n\t *\n\t * To make sure the reservation window has a free bit inside it, we\n\t * need to check the bitmap after we found a reservable window.\n\t */\nretry:\n\tret = find_next_reservable_window(search_head, my_rsv, sb,\n\t\t\t\t\t\tstart_block, group_end_block);\n\n\tif (ret == -1) {\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * On success, find_next_reservable_window() returns the\n\t * reservation window where there is a reservable space after it.\n\t * Before we reserve this reservable space, we need\n\t * to make sure there is at least a free block inside this region.\n\t *\n\t * searching the first free bit on the block bitmap and copy of\n\t * last committed bitmap alternatively, until we found a allocatable\n\t * block. Search start from the start block of the reservable space\n\t * we just found.\n\t */\n\tspin_unlock(rsv_lock);\n\tfirst_free_block = bitmap_search_next_usable_block(\n\t\t\tmy_rsv->rsv_start - group_first_block,\n\t\t\tbitmap_bh, group_end_block - group_first_block + 1);\n\n\tif (first_free_block < 0) {\n\t\t/*\n\t\t * no free block left on the bitmap, no point\n\t\t * to reserve the space. return failed.\n\t\t */\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\t\t/* failed */\n\t}\n\n\tstart_block = first_free_block + group_first_block;\n\t/*\n\t * check if the first free block is within the\n\t * free space we just reserved\n\t */\n\tif (start_block >= my_rsv->rsv_start &&\n\t    start_block <= my_rsv->rsv_end) {\n\t\ttrace_ext3_reserved(sb, start_block, my_rsv);\n\t\treturn 0;\t\t/* success */\n\t}\n\t/*\n\t * if the first free bit we found is out of the reservable space\n\t * continue search for next reservable space,\n\t * start from where the free block is,\n\t * we also shift the list head to where we stopped last time\n\t */\n\tsearch_head = my_rsv;\n\tspin_lock(rsv_lock);\n\tgoto retry;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int alloc_new_reservation(struct ext3_reserve_window_node *my_rsv,\n\t\text3_grpblk_t grp_goal, struct super_block *sb,\n\t\tunsigned int group, struct buffer_head *bitmap_bh)\n{\n\tstruct ext3_reserve_window_node *search_head;\n\text3_fsblk_t group_first_block, group_end_block, start_block;\n\text3_grpblk_t first_free_block;\n\tstruct rb_root *fs_rsv_root = &EXT3_SB(sb)->s_rsv_window_root;\n\tunsigned long size;\n\tint ret;\n\tspinlock_t *rsv_lock = &EXT3_SB(sb)->s_rsv_window_lock;\n\n\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\tgroup_end_block = group_first_block + (EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\tif (grp_goal < 0)\n\t\tstart_block = group_first_block;\n\telse\n\t\tstart_block = grp_goal + group_first_block;\n\n\ttrace_ext3_alloc_new_reservation(sb, start_block);\n\tsize = my_rsv->rsv_goal_size;\n\n\tif (!rsv_is_empty(&my_rsv->rsv_window)) {\n\t\t/*\n\t\t * if the old reservation is cross group boundary\n\t\t * and if the goal is inside the old reservation window,\n\t\t * we will come here when we just failed to allocate from\n\t\t * the first part of the window. We still have another part\n\t\t * that belongs to the next group. In this case, there is no\n\t\t * point to discard our window and try to allocate a new one\n\t\t * in this group(which will fail). we should\n\t\t * keep the reservation window, just simply move on.\n\t\t *\n\t\t * Maybe we could shift the start block of the reservation\n\t\t * window to the first block of next group.\n\t\t */\n\n\t\tif ((my_rsv->rsv_start <= group_end_block) &&\n\t\t\t\t(my_rsv->rsv_end > group_end_block) &&\n\t\t\t\t(start_block >= my_rsv->rsv_start))\n\t\t\treturn -1;\n\n\t\tif ((my_rsv->rsv_alloc_hit >\n\t\t     (my_rsv->rsv_end - my_rsv->rsv_start + 1) / 2)) {\n\t\t\t/*\n\t\t\t * if the previously allocation hit ratio is\n\t\t\t * greater than 1/2, then we double the size of\n\t\t\t * the reservation window the next time,\n\t\t\t * otherwise we keep the same size window\n\t\t\t */\n\t\t\tsize = size * 2;\n\t\t\tif (size > EXT3_MAX_RESERVE_BLOCKS)\n\t\t\t\tsize = EXT3_MAX_RESERVE_BLOCKS;\n\t\t\tmy_rsv->rsv_goal_size= size;\n\t\t}\n\t}\n\n\tspin_lock(rsv_lock);\n\t/*\n\t * shift the search start to the window near the goal block\n\t */\n\tsearch_head = search_reserve_window(fs_rsv_root, start_block);\n\n\t/*\n\t * find_next_reservable_window() simply finds a reservable window\n\t * inside the given range(start_block, group_end_block).\n\t *\n\t * To make sure the reservation window has a free bit inside it, we\n\t * need to check the bitmap after we found a reservable window.\n\t */\nretry:\n\tret = find_next_reservable_window(search_head, my_rsv, sb,\n\t\t\t\t\t\tstart_block, group_end_block);\n\n\tif (ret == -1) {\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * On success, find_next_reservable_window() returns the\n\t * reservation window where there is a reservable space after it.\n\t * Before we reserve this reservable space, we need\n\t * to make sure there is at least a free block inside this region.\n\t *\n\t * searching the first free bit on the block bitmap and copy of\n\t * last committed bitmap alternatively, until we found a allocatable\n\t * block. Search start from the start block of the reservable space\n\t * we just found.\n\t */\n\tspin_unlock(rsv_lock);\n\tfirst_free_block = bitmap_search_next_usable_block(\n\t\t\tmy_rsv->rsv_start - group_first_block,\n\t\t\tbitmap_bh, group_end_block - group_first_block + 1);\n\n\tif (first_free_block < 0) {\n\t\t/*\n\t\t * no free block left on the bitmap, no point\n\t\t * to reserve the space. return failed.\n\t\t */\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\t\t/* failed */\n\t}\n\n\tstart_block = first_free_block + group_first_block;\n\t/*\n\t * check if the first free block is within the\n\t * free space we just reserved\n\t */\n\tif (start_block >= my_rsv->rsv_start &&\n\t    start_block <= my_rsv->rsv_end) {\n\t\ttrace_ext3_reserved(sb, start_block, my_rsv);\n\t\treturn 0;\t\t/* success */\n\t}\n\t/*\n\t * if the first free bit we found is out of the reservable space\n\t * continue search for next reservable space,\n\t * start from where the free block is,\n\t * we also shift the list head to where we stopped last time\n\t */\n\tsearch_head = my_rsv;\n\tspin_lock(rsv_lock);\n\tgoto retry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_is_empty",
          "args": [
            "&my_rsv->rsv_window"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "392-396",
          "snippet": "static inline int rsv_is_empty(struct ext3_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic inline int rsv_is_empty(struct ext3_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "972-977",
          "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_undo_access",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"get undo access for new block\""
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic ext3_grpblk_t\next3_try_to_allocate_with_rsv(struct super_block *sb, handle_t *handle,\n\t\t\tunsigned int group, struct buffer_head *bitmap_bh,\n\t\t\text3_grpblk_t grp_goal,\n\t\t\tstruct ext3_reserve_window_node * my_rsv,\n\t\t\tunsigned long *count, int *errp)\n{\n\text3_fsblk_t group_first_block, group_last_block;\n\text3_grpblk_t ret = 0;\n\tint fatal;\n\tunsigned long num = *count;\n\n\t*errp = 0;\n\n\t/*\n\t * Make sure we use undo access for the bitmap, because it is critical\n\t * that we do the frozen_data COW on bitmap buffers in all cases even\n\t * if the buffer is in BJ_Forget state in the committing transaction.\n\t */\n\tBUFFER_TRACE(bitmap_bh, \"get undo access for new block\");\n\tfatal = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (fatal) {\n\t\t*errp = fatal;\n\t\treturn -1;\n\t}\n\n\t/*\n\t * we don't deal with reservation when\n\t * filesystem is mounted without reservation\n\t * or the file is not a regular file\n\t * or last attempt to allocate a block with reservation turned on failed\n\t */\n\tif (my_rsv == NULL ) {\n\t\tret = ext3_try_to_allocate(sb, handle, group, bitmap_bh,\n\t\t\t\t\t\tgrp_goal, count, NULL);\n\t\tgoto out;\n\t}\n\t/*\n\t * grp_goal is a group relative block number (if there is a goal)\n\t * 0 <= grp_goal < EXT3_BLOCKS_PER_GROUP(sb)\n\t * first block is a filesystem wide block number\n\t * first block is the block number of the first block in this group\n\t */\n\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\t/*\n\t * Basically we will allocate a new block from inode's reservation\n\t * window.\n\t *\n\t * We need to allocate a new reservation window, if:\n\t * a) inode does not have a reservation window; or\n\t * b) last attempt to allocate a block from existing reservation\n\t *    failed; or\n\t * c) we come here with a goal and with a reservation window\n\t *\n\t * We do not need to allocate a new reservation window if we come here\n\t * at the beginning with a goal and the goal is inside the window, or\n\t * we don't have a goal but already have a reservation window.\n\t * then we could go to allocate from the reservation window directly.\n\t */\n\twhile (1) {\n\t\tif (rsv_is_empty(&my_rsv->rsv_window) || (ret < 0) ||\n\t\t\t!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\tgrp_goal, group, sb)) {\n\t\t\tif (my_rsv->rsv_goal_size < *count)\n\t\t\t\tmy_rsv->rsv_goal_size = *count;\n\t\t\tret = alloc_new_reservation(my_rsv, grp_goal, sb,\n\t\t\t\t\t\t\tgroup, bitmap_bh);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\t\t\t/* failed */\n\n\t\t\tif (!goal_in_my_reservation(&my_rsv->rsv_window,\n\t\t\t\t\t\t\tgrp_goal, group, sb))\n\t\t\t\tgrp_goal = -1;\n\t\t} else if (grp_goal >= 0) {\n\t\t\tint curr = my_rsv->rsv_end -\n\t\t\t\t\t(grp_goal + group_first_block) + 1;\n\n\t\t\tif (curr < *count)\n\t\t\t\ttry_to_extend_reservation(my_rsv, sb,\n\t\t\t\t\t\t\t*count - curr);\n\t\t}\n\n\t\tif ((my_rsv->rsv_start > group_last_block) ||\n\t\t\t\t(my_rsv->rsv_end < group_first_block)) {\n\t\t\trsv_window_dump(&EXT3_SB(sb)->s_rsv_window_root, 1);\n\t\t\tBUG();\n\t\t}\n\t\tret = ext3_try_to_allocate(sb, handle, group, bitmap_bh,\n\t\t\t\t\t   grp_goal, &num, &my_rsv->rsv_window);\n\t\tif (ret >= 0) {\n\t\t\tmy_rsv->rsv_alloc_hit += num;\n\t\t\t*count = num;\n\t\t\tbreak;\t\t\t\t/* succeed */\n\t\t}\n\t\tnum = *count;\n\t}\nout:\n\tif (ret >= 0) {\n\t\tBUFFER_TRACE(bitmap_bh, \"journal_dirty_metadata for \"\n\t\t\t\t\t\"bitmap block\");\n\t\tfatal = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\t\tif (fatal) {\n\t\t\t*errp = fatal;\n\t\t\treturn -1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tBUFFER_TRACE(bitmap_bh, \"journal_release_buffer\");\n\text3_journal_release_buffer(handle, bitmap_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "try_to_extend_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1260-1283",
    "snippet": "static void try_to_extend_reservation(struct ext3_reserve_window_node *my_rsv,\n\t\t\tstruct super_block *sb, int size)\n{\n\tstruct ext3_reserve_window_node *next_rsv;\n\tstruct rb_node *next;\n\tspinlock_t *rsv_lock = &EXT3_SB(sb)->s_rsv_window_lock;\n\n\tif (!spin_trylock(rsv_lock))\n\t\treturn;\n\n\tnext = rb_next(&my_rsv->rsv_node);\n\n\tif (!next)\n\t\tmy_rsv->rsv_end += size;\n\telse {\n\t\tnext_rsv = rb_entry(next, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif ((next_rsv->rsv_start - my_rsv->rsv_end - 1) >= size)\n\t\t\tmy_rsv->rsv_end += size;\n\t\telse\n\t\t\tmy_rsv->rsv_end = next_rsv->rsv_start - 1;\n\t}\n\tspin_unlock(rsv_lock);\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "rsv_lock"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next",
            "structext3_reserve_window_node",
            "rsv_node"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&my_rsv->rsv_node"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "rsv_lock"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic void try_to_extend_reservation(struct ext3_reserve_window_node *my_rsv,\n\t\t\tstruct super_block *sb, int size)\n{\n\tstruct ext3_reserve_window_node *next_rsv;\n\tstruct rb_node *next;\n\tspinlock_t *rsv_lock = &EXT3_SB(sb)->s_rsv_window_lock;\n\n\tif (!spin_trylock(rsv_lock))\n\t\treturn;\n\n\tnext = rb_next(&my_rsv->rsv_node);\n\n\tif (!next)\n\t\tmy_rsv->rsv_end += size;\n\telse {\n\t\tnext_rsv = rb_entry(next, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif ((next_rsv->rsv_start - my_rsv->rsv_end - 1) >= size)\n\t\t\tmy_rsv->rsv_end += size;\n\t\telse\n\t\t\tmy_rsv->rsv_end = next_rsv->rsv_start - 1;\n\t}\n\tspin_unlock(rsv_lock);\n}"
  },
  {
    "function_name": "alloc_new_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "1112-1241",
    "snippet": "static int alloc_new_reservation(struct ext3_reserve_window_node *my_rsv,\n\t\text3_grpblk_t grp_goal, struct super_block *sb,\n\t\tunsigned int group, struct buffer_head *bitmap_bh)\n{\n\tstruct ext3_reserve_window_node *search_head;\n\text3_fsblk_t group_first_block, group_end_block, start_block;\n\text3_grpblk_t first_free_block;\n\tstruct rb_root *fs_rsv_root = &EXT3_SB(sb)->s_rsv_window_root;\n\tunsigned long size;\n\tint ret;\n\tspinlock_t *rsv_lock = &EXT3_SB(sb)->s_rsv_window_lock;\n\n\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\tgroup_end_block = group_first_block + (EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\tif (grp_goal < 0)\n\t\tstart_block = group_first_block;\n\telse\n\t\tstart_block = grp_goal + group_first_block;\n\n\ttrace_ext3_alloc_new_reservation(sb, start_block);\n\tsize = my_rsv->rsv_goal_size;\n\n\tif (!rsv_is_empty(&my_rsv->rsv_window)) {\n\t\t/*\n\t\t * if the old reservation is cross group boundary\n\t\t * and if the goal is inside the old reservation window,\n\t\t * we will come here when we just failed to allocate from\n\t\t * the first part of the window. We still have another part\n\t\t * that belongs to the next group. In this case, there is no\n\t\t * point to discard our window and try to allocate a new one\n\t\t * in this group(which will fail). we should\n\t\t * keep the reservation window, just simply move on.\n\t\t *\n\t\t * Maybe we could shift the start block of the reservation\n\t\t * window to the first block of next group.\n\t\t */\n\n\t\tif ((my_rsv->rsv_start <= group_end_block) &&\n\t\t\t\t(my_rsv->rsv_end > group_end_block) &&\n\t\t\t\t(start_block >= my_rsv->rsv_start))\n\t\t\treturn -1;\n\n\t\tif ((my_rsv->rsv_alloc_hit >\n\t\t     (my_rsv->rsv_end - my_rsv->rsv_start + 1) / 2)) {\n\t\t\t/*\n\t\t\t * if the previously allocation hit ratio is\n\t\t\t * greater than 1/2, then we double the size of\n\t\t\t * the reservation window the next time,\n\t\t\t * otherwise we keep the same size window\n\t\t\t */\n\t\t\tsize = size * 2;\n\t\t\tif (size > EXT3_MAX_RESERVE_BLOCKS)\n\t\t\t\tsize = EXT3_MAX_RESERVE_BLOCKS;\n\t\t\tmy_rsv->rsv_goal_size= size;\n\t\t}\n\t}\n\n\tspin_lock(rsv_lock);\n\t/*\n\t * shift the search start to the window near the goal block\n\t */\n\tsearch_head = search_reserve_window(fs_rsv_root, start_block);\n\n\t/*\n\t * find_next_reservable_window() simply finds a reservable window\n\t * inside the given range(start_block, group_end_block).\n\t *\n\t * To make sure the reservation window has a free bit inside it, we\n\t * need to check the bitmap after we found a reservable window.\n\t */\nretry:\n\tret = find_next_reservable_window(search_head, my_rsv, sb,\n\t\t\t\t\t\tstart_block, group_end_block);\n\n\tif (ret == -1) {\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * On success, find_next_reservable_window() returns the\n\t * reservation window where there is a reservable space after it.\n\t * Before we reserve this reservable space, we need\n\t * to make sure there is at least a free block inside this region.\n\t *\n\t * searching the first free bit on the block bitmap and copy of\n\t * last committed bitmap alternatively, until we found a allocatable\n\t * block. Search start from the start block of the reservable space\n\t * we just found.\n\t */\n\tspin_unlock(rsv_lock);\n\tfirst_free_block = bitmap_search_next_usable_block(\n\t\t\tmy_rsv->rsv_start - group_first_block,\n\t\t\tbitmap_bh, group_end_block - group_first_block + 1);\n\n\tif (first_free_block < 0) {\n\t\t/*\n\t\t * no free block left on the bitmap, no point\n\t\t * to reserve the space. return failed.\n\t\t */\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\t\t/* failed */\n\t}\n\n\tstart_block = first_free_block + group_first_block;\n\t/*\n\t * check if the first free block is within the\n\t * free space we just reserved\n\t */\n\tif (start_block >= my_rsv->rsv_start &&\n\t    start_block <= my_rsv->rsv_end) {\n\t\ttrace_ext3_reserved(sb, start_block, my_rsv);\n\t\treturn 0;\t\t/* success */\n\t}\n\t/*\n\t * if the first free bit we found is out of the reservable space\n\t * continue search for next reservable space,\n\t * start from where the free block is,\n\t * we also shift the list head to where we stopped last time\n\t */\n\tsearch_head = my_rsv;\n\tspin_lock(rsv_lock);\n\tgoto retry;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "rsv_lock"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_reserved",
          "args": [
            "sb",
            "start_block",
            "my_rsv"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "rsv_lock"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_window_remove",
          "args": [
            "sb",
            "my_rsv"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_window_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "377-384",
          "snippet": "static void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext3_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT3_SB(sb)->s_rsv_window_root);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext3_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT3_SB(sb)->s_rsv_window_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_is_empty",
          "args": [
            "&my_rsv->rsv_window"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "392-396",
          "snippet": "static inline int rsv_is_empty(struct ext3_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic inline int rsv_is_empty(struct ext3_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_search_next_usable_block",
          "args": [
            "my_rsv->rsv_start - group_first_block",
            "bitmap_bh",
            "group_end_block - group_first_block + 1"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_search_next_usable_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "740-760",
          "snippet": "static ext3_grpblk_t\nbitmap_search_next_usable_block(ext3_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text3_grpblk_t maxblocks)\n{\n\text3_grpblk_t next;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\twhile (start < maxblocks) {\n\t\tnext = ext3_find_next_zero_bit(bh->b_data, maxblocks, start);\n\t\tif (next >= maxblocks)\n\t\t\treturn -1;\n\t\tif (ext3_test_allocatable(next, bh))\n\t\t\treturn next;\n\t\tjbd_lock_bh_state(bh);\n\t\tif (jh->b_committed_data)\n\t\t\tstart = ext3_find_next_zero_bit(jh->b_committed_data,\n\t\t\t\t\t\t\tmaxblocks, next);\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic ext3_grpblk_t\nbitmap_search_next_usable_block(ext3_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text3_grpblk_t maxblocks)\n{\n\text3_grpblk_t next;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\twhile (start < maxblocks) {\n\t\tnext = ext3_find_next_zero_bit(bh->b_data, maxblocks, start);\n\t\tif (next >= maxblocks)\n\t\t\treturn -1;\n\t\tif (ext3_test_allocatable(next, bh))\n\t\t\treturn next;\n\t\tjbd_lock_bh_state(bh);\n\t\tif (jh->b_committed_data)\n\t\t\tstart = ext3_find_next_zero_bit(jh->b_committed_data,\n\t\t\t\t\t\t\tmaxblocks, next);\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_reservable_window",
          "args": [
            "search_head",
            "my_rsv",
            "sb",
            "start_block",
            "group_end_block"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_reservable_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "990-1073",
          "snippet": "static int find_next_reservable_window(\n\t\t\t\tstruct ext3_reserve_window_node *search_head,\n\t\t\t\tstruct ext3_reserve_window_node *my_rsv,\n\t\t\t\tstruct super_block * sb,\n\t\t\t\text3_fsblk_t start_block,\n\t\t\t\text3_fsblk_t last_block)\n{\n\tstruct rb_node *next;\n\tstruct ext3_reserve_window_node *rsv, *prev;\n\text3_fsblk_t cur;\n\tint size = my_rsv->rsv_goal_size;\n\n\t/* TODO: make the start of the reservation window byte-aligned */\n\t/* cur = *start_block & ~7;*/\n\tcur = start_block;\n\trsv = search_head;\n\tif (!rsv)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tif (cur <= rsv->rsv_end)\n\t\t\tcur = rsv->rsv_end + 1;\n\n\t\t/* TODO?\n\t\t * in the case we could not find a reservable space\n\t\t * that is what is expected, during the re-search, we could\n\t\t * remember what's the largest reservable space we could have\n\t\t * and return that one.\n\t\t *\n\t\t * For now it will fail if we could not find the reservable\n\t\t * space with expected-size (or more)...\n\t\t */\n\t\tif (cur > last_block)\n\t\t\treturn -1;\t\t/* fail */\n\n\t\tprev = rsv;\n\t\tnext = rb_next(&rsv->rsv_node);\n\t\trsv = rb_entry(next,struct ext3_reserve_window_node,rsv_node);\n\n\t\t/*\n\t\t * Reached the last reservation, we can just append to the\n\t\t * previous one.\n\t\t */\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (cur + size <= rsv->rsv_start) {\n\t\t\t/*\n\t\t\t * Found a reserveable space big enough.  We could\n\t\t\t * have a reservation across the group boundary here\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * we come here either :\n\t * when we reach the end of the whole list,\n\t * and there is empty reservable space after last entry in the list.\n\t * append it to the end of the list.\n\t *\n\t * or we found one reservable space in the middle of the list,\n\t * return the reservation window that we could append to.\n\t * succeed.\n\t */\n\n\tif ((prev != my_rsv) && (!rsv_is_empty(&my_rsv->rsv_window)))\n\t\trsv_window_remove(sb, my_rsv);\n\n\t/*\n\t * Let's book the whole available window for now.  We will check the\n\t * disk bitmap later and then, if there are free blocks then we adjust\n\t * the window size if it's larger than requested.\n\t * Otherwise, we will remove this node from the tree next time\n\t * call find_next_reservable_window.\n\t */\n\tmy_rsv->rsv_start = cur;\n\tmy_rsv->rsv_end = cur + size - 1;\n\tmy_rsv->rsv_alloc_hit = 0;\n\n\tif (prev != my_rsv)\n\t\text3_rsv_window_add(sb, my_rsv);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int find_next_reservable_window(\n\t\t\t\tstruct ext3_reserve_window_node *search_head,\n\t\t\t\tstruct ext3_reserve_window_node *my_rsv,\n\t\t\t\tstruct super_block * sb,\n\t\t\t\text3_fsblk_t start_block,\n\t\t\t\text3_fsblk_t last_block)\n{\n\tstruct rb_node *next;\n\tstruct ext3_reserve_window_node *rsv, *prev;\n\text3_fsblk_t cur;\n\tint size = my_rsv->rsv_goal_size;\n\n\t/* TODO: make the start of the reservation window byte-aligned */\n\t/* cur = *start_block & ~7;*/\n\tcur = start_block;\n\trsv = search_head;\n\tif (!rsv)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tif (cur <= rsv->rsv_end)\n\t\t\tcur = rsv->rsv_end + 1;\n\n\t\t/* TODO?\n\t\t * in the case we could not find a reservable space\n\t\t * that is what is expected, during the re-search, we could\n\t\t * remember what's the largest reservable space we could have\n\t\t * and return that one.\n\t\t *\n\t\t * For now it will fail if we could not find the reservable\n\t\t * space with expected-size (or more)...\n\t\t */\n\t\tif (cur > last_block)\n\t\t\treturn -1;\t\t/* fail */\n\n\t\tprev = rsv;\n\t\tnext = rb_next(&rsv->rsv_node);\n\t\trsv = rb_entry(next,struct ext3_reserve_window_node,rsv_node);\n\n\t\t/*\n\t\t * Reached the last reservation, we can just append to the\n\t\t * previous one.\n\t\t */\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (cur + size <= rsv->rsv_start) {\n\t\t\t/*\n\t\t\t * Found a reserveable space big enough.  We could\n\t\t\t * have a reservation across the group boundary here\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * we come here either :\n\t * when we reach the end of the whole list,\n\t * and there is empty reservable space after last entry in the list.\n\t * append it to the end of the list.\n\t *\n\t * or we found one reservable space in the middle of the list,\n\t * return the reservation window that we could append to.\n\t * succeed.\n\t */\n\n\tif ((prev != my_rsv) && (!rsv_is_empty(&my_rsv->rsv_window)))\n\t\trsv_window_remove(sb, my_rsv);\n\n\t/*\n\t * Let's book the whole available window for now.  We will check the\n\t * disk bitmap later and then, if there are free blocks then we adjust\n\t * the window size if it's larger than requested.\n\t * Otherwise, we will remove this node from the tree next time\n\t * call find_next_reservable_window.\n\t */\n\tmy_rsv->rsv_start = cur;\n\tmy_rsv->rsv_end = cur + size - 1;\n\tmy_rsv->rsv_alloc_hit = 0;\n\n\tif (prev != my_rsv)\n\t\text3_rsv_window_add(sb, my_rsv);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "search_reserve_window",
          "args": [
            "fs_rsv_root",
            "start_block"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "search_reserve_window",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "298-328",
          "snippet": "static struct ext3_reserve_window_node *\nsearch_reserve_window(struct rb_root *root, ext3_fsblk_t goal)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct ext3_reserve_window_node *rsv;\n\n\tif (!n)\n\t\treturn NULL;\n\n\tdo {\n\t\trsv = rb_entry(n, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif (goal < rsv->rsv_start)\n\t\t\tn = n->rb_left;\n\t\telse if (goal > rsv->rsv_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn rsv;\n\t} while (n);\n\t/*\n\t * We've fallen off the end of the tree: the goal wasn't inside\n\t * any particular node.  OK, the previous node must be to one\n\t * side of the interval containing the goal.  If it's the RHS,\n\t * we need to back up one.\n\t */\n\tif (rsv->rsv_start > goal) {\n\t\tn = rb_prev(&rsv->rsv_node);\n\t\trsv = rb_entry(n, struct ext3_reserve_window_node, rsv_node);\n\t}\n\treturn rsv;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic struct ext3_reserve_window_node *\nsearch_reserve_window(struct rb_root *root, ext3_fsblk_t goal)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct ext3_reserve_window_node *rsv;\n\n\tif (!n)\n\t\treturn NULL;\n\n\tdo {\n\t\trsv = rb_entry(n, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif (goal < rsv->rsv_start)\n\t\t\tn = n->rb_left;\n\t\telse if (goal > rsv->rsv_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn rsv;\n\t} while (n);\n\t/*\n\t * We've fallen off the end of the tree: the goal wasn't inside\n\t * any particular node.  OK, the previous node must be to one\n\t * side of the interval containing the goal.  If it's the RHS,\n\t * we need to back up one.\n\t */\n\tif (rsv->rsv_start > goal) {\n\t\tn = rb_prev(&rsv->rsv_node);\n\t\trsv = rb_entry(n, struct ext3_reserve_window_node, rsv_node);\n\t}\n\treturn rsv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_alloc_new_reservation",
          "args": [
            "sb",
            "start_block"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "972-977",
          "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int alloc_new_reservation(struct ext3_reserve_window_node *my_rsv,\n\t\text3_grpblk_t grp_goal, struct super_block *sb,\n\t\tunsigned int group, struct buffer_head *bitmap_bh)\n{\n\tstruct ext3_reserve_window_node *search_head;\n\text3_fsblk_t group_first_block, group_end_block, start_block;\n\text3_grpblk_t first_free_block;\n\tstruct rb_root *fs_rsv_root = &EXT3_SB(sb)->s_rsv_window_root;\n\tunsigned long size;\n\tint ret;\n\tspinlock_t *rsv_lock = &EXT3_SB(sb)->s_rsv_window_lock;\n\n\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\tgroup_end_block = group_first_block + (EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\tif (grp_goal < 0)\n\t\tstart_block = group_first_block;\n\telse\n\t\tstart_block = grp_goal + group_first_block;\n\n\ttrace_ext3_alloc_new_reservation(sb, start_block);\n\tsize = my_rsv->rsv_goal_size;\n\n\tif (!rsv_is_empty(&my_rsv->rsv_window)) {\n\t\t/*\n\t\t * if the old reservation is cross group boundary\n\t\t * and if the goal is inside the old reservation window,\n\t\t * we will come here when we just failed to allocate from\n\t\t * the first part of the window. We still have another part\n\t\t * that belongs to the next group. In this case, there is no\n\t\t * point to discard our window and try to allocate a new one\n\t\t * in this group(which will fail). we should\n\t\t * keep the reservation window, just simply move on.\n\t\t *\n\t\t * Maybe we could shift the start block of the reservation\n\t\t * window to the first block of next group.\n\t\t */\n\n\t\tif ((my_rsv->rsv_start <= group_end_block) &&\n\t\t\t\t(my_rsv->rsv_end > group_end_block) &&\n\t\t\t\t(start_block >= my_rsv->rsv_start))\n\t\t\treturn -1;\n\n\t\tif ((my_rsv->rsv_alloc_hit >\n\t\t     (my_rsv->rsv_end - my_rsv->rsv_start + 1) / 2)) {\n\t\t\t/*\n\t\t\t * if the previously allocation hit ratio is\n\t\t\t * greater than 1/2, then we double the size of\n\t\t\t * the reservation window the next time,\n\t\t\t * otherwise we keep the same size window\n\t\t\t */\n\t\t\tsize = size * 2;\n\t\t\tif (size > EXT3_MAX_RESERVE_BLOCKS)\n\t\t\t\tsize = EXT3_MAX_RESERVE_BLOCKS;\n\t\t\tmy_rsv->rsv_goal_size= size;\n\t\t}\n\t}\n\n\tspin_lock(rsv_lock);\n\t/*\n\t * shift the search start to the window near the goal block\n\t */\n\tsearch_head = search_reserve_window(fs_rsv_root, start_block);\n\n\t/*\n\t * find_next_reservable_window() simply finds a reservable window\n\t * inside the given range(start_block, group_end_block).\n\t *\n\t * To make sure the reservation window has a free bit inside it, we\n\t * need to check the bitmap after we found a reservable window.\n\t */\nretry:\n\tret = find_next_reservable_window(search_head, my_rsv, sb,\n\t\t\t\t\t\tstart_block, group_end_block);\n\n\tif (ret == -1) {\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * On success, find_next_reservable_window() returns the\n\t * reservation window where there is a reservable space after it.\n\t * Before we reserve this reservable space, we need\n\t * to make sure there is at least a free block inside this region.\n\t *\n\t * searching the first free bit on the block bitmap and copy of\n\t * last committed bitmap alternatively, until we found a allocatable\n\t * block. Search start from the start block of the reservable space\n\t * we just found.\n\t */\n\tspin_unlock(rsv_lock);\n\tfirst_free_block = bitmap_search_next_usable_block(\n\t\t\tmy_rsv->rsv_start - group_first_block,\n\t\t\tbitmap_bh, group_end_block - group_first_block + 1);\n\n\tif (first_free_block < 0) {\n\t\t/*\n\t\t * no free block left on the bitmap, no point\n\t\t * to reserve the space. return failed.\n\t\t */\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&my_rsv->rsv_window))\n\t\t\trsv_window_remove(sb, my_rsv);\n\t\tspin_unlock(rsv_lock);\n\t\treturn -1;\t\t/* failed */\n\t}\n\n\tstart_block = first_free_block + group_first_block;\n\t/*\n\t * check if the first free block is within the\n\t * free space we just reserved\n\t */\n\tif (start_block >= my_rsv->rsv_start &&\n\t    start_block <= my_rsv->rsv_end) {\n\t\ttrace_ext3_reserved(sb, start_block, my_rsv);\n\t\treturn 0;\t\t/* success */\n\t}\n\t/*\n\t * if the first free bit we found is out of the reservable space\n\t * continue search for next reservable space,\n\t * start from where the free block is,\n\t * we also shift the list head to where we stopped last time\n\t */\n\tsearch_head = my_rsv;\n\tspin_lock(rsv_lock);\n\tgoto retry;\n}"
  },
  {
    "function_name": "find_next_reservable_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "990-1073",
    "snippet": "static int find_next_reservable_window(\n\t\t\t\tstruct ext3_reserve_window_node *search_head,\n\t\t\t\tstruct ext3_reserve_window_node *my_rsv,\n\t\t\t\tstruct super_block * sb,\n\t\t\t\text3_fsblk_t start_block,\n\t\t\t\text3_fsblk_t last_block)\n{\n\tstruct rb_node *next;\n\tstruct ext3_reserve_window_node *rsv, *prev;\n\text3_fsblk_t cur;\n\tint size = my_rsv->rsv_goal_size;\n\n\t/* TODO: make the start of the reservation window byte-aligned */\n\t/* cur = *start_block & ~7;*/\n\tcur = start_block;\n\trsv = search_head;\n\tif (!rsv)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tif (cur <= rsv->rsv_end)\n\t\t\tcur = rsv->rsv_end + 1;\n\n\t\t/* TODO?\n\t\t * in the case we could not find a reservable space\n\t\t * that is what is expected, during the re-search, we could\n\t\t * remember what's the largest reservable space we could have\n\t\t * and return that one.\n\t\t *\n\t\t * For now it will fail if we could not find the reservable\n\t\t * space with expected-size (or more)...\n\t\t */\n\t\tif (cur > last_block)\n\t\t\treturn -1;\t\t/* fail */\n\n\t\tprev = rsv;\n\t\tnext = rb_next(&rsv->rsv_node);\n\t\trsv = rb_entry(next,struct ext3_reserve_window_node,rsv_node);\n\n\t\t/*\n\t\t * Reached the last reservation, we can just append to the\n\t\t * previous one.\n\t\t */\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (cur + size <= rsv->rsv_start) {\n\t\t\t/*\n\t\t\t * Found a reserveable space big enough.  We could\n\t\t\t * have a reservation across the group boundary here\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * we come here either :\n\t * when we reach the end of the whole list,\n\t * and there is empty reservable space after last entry in the list.\n\t * append it to the end of the list.\n\t *\n\t * or we found one reservable space in the middle of the list,\n\t * return the reservation window that we could append to.\n\t * succeed.\n\t */\n\n\tif ((prev != my_rsv) && (!rsv_is_empty(&my_rsv->rsv_window)))\n\t\trsv_window_remove(sb, my_rsv);\n\n\t/*\n\t * Let's book the whole available window for now.  We will check the\n\t * disk bitmap later and then, if there are free blocks then we adjust\n\t * the window size if it's larger than requested.\n\t * Otherwise, we will remove this node from the tree next time\n\t * call find_next_reservable_window.\n\t */\n\tmy_rsv->rsv_start = cur;\n\tmy_rsv->rsv_end = cur + size - 1;\n\tmy_rsv->rsv_alloc_hit = 0;\n\n\tif (prev != my_rsv)\n\t\text3_rsv_window_add(sb, my_rsv);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_rsv_window_add",
          "args": [
            "sb",
            "my_rsv"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_rsv_window_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "337-366",
          "snippet": "void ext3_rsv_window_add(struct super_block *sb,\n\t\t    struct ext3_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT3_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text3_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext3_reserve_window_node *this;\n\n\ttrace_ext3_rsv_window_add(sb, rsv);\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_rsv_window_add(struct super_block *sb,\n\t\t    struct ext3_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT3_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text3_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext3_reserve_window_node *this;\n\n\ttrace_ext3_rsv_window_add(sb, rsv);\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_window_remove",
          "args": [
            "sb",
            "my_rsv"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_window_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "377-384",
          "snippet": "static void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext3_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT3_SB(sb)->s_rsv_window_root);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext3_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT3_SB(sb)->s_rsv_window_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_is_empty",
          "args": [
            "&my_rsv->rsv_window"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "392-396",
          "snippet": "static inline int rsv_is_empty(struct ext3_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic inline int rsv_is_empty(struct ext3_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next",
            "structext3_reserve_window_node",
            "rsv_node"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&rsv->rsv_node"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int find_next_reservable_window(\n\t\t\t\tstruct ext3_reserve_window_node *search_head,\n\t\t\t\tstruct ext3_reserve_window_node *my_rsv,\n\t\t\t\tstruct super_block * sb,\n\t\t\t\text3_fsblk_t start_block,\n\t\t\t\text3_fsblk_t last_block)\n{\n\tstruct rb_node *next;\n\tstruct ext3_reserve_window_node *rsv, *prev;\n\text3_fsblk_t cur;\n\tint size = my_rsv->rsv_goal_size;\n\n\t/* TODO: make the start of the reservation window byte-aligned */\n\t/* cur = *start_block & ~7;*/\n\tcur = start_block;\n\trsv = search_head;\n\tif (!rsv)\n\t\treturn -1;\n\n\twhile (1) {\n\t\tif (cur <= rsv->rsv_end)\n\t\t\tcur = rsv->rsv_end + 1;\n\n\t\t/* TODO?\n\t\t * in the case we could not find a reservable space\n\t\t * that is what is expected, during the re-search, we could\n\t\t * remember what's the largest reservable space we could have\n\t\t * and return that one.\n\t\t *\n\t\t * For now it will fail if we could not find the reservable\n\t\t * space with expected-size (or more)...\n\t\t */\n\t\tif (cur > last_block)\n\t\t\treturn -1;\t\t/* fail */\n\n\t\tprev = rsv;\n\t\tnext = rb_next(&rsv->rsv_node);\n\t\trsv = rb_entry(next,struct ext3_reserve_window_node,rsv_node);\n\n\t\t/*\n\t\t * Reached the last reservation, we can just append to the\n\t\t * previous one.\n\t\t */\n\t\tif (!next)\n\t\t\tbreak;\n\n\t\tif (cur + size <= rsv->rsv_start) {\n\t\t\t/*\n\t\t\t * Found a reserveable space big enough.  We could\n\t\t\t * have a reservation across the group boundary here\n\t\t\t */\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * we come here either :\n\t * when we reach the end of the whole list,\n\t * and there is empty reservable space after last entry in the list.\n\t * append it to the end of the list.\n\t *\n\t * or we found one reservable space in the middle of the list,\n\t * return the reservation window that we could append to.\n\t * succeed.\n\t */\n\n\tif ((prev != my_rsv) && (!rsv_is_empty(&my_rsv->rsv_window)))\n\t\trsv_window_remove(sb, my_rsv);\n\n\t/*\n\t * Let's book the whole available window for now.  We will check the\n\t * disk bitmap later and then, if there are free blocks then we adjust\n\t * the window size if it's larger than requested.\n\t * Otherwise, we will remove this node from the tree next time\n\t * call find_next_reservable_window.\n\t */\n\tmy_rsv->rsv_start = cur;\n\tmy_rsv->rsv_end = cur + size - 1;\n\tmy_rsv->rsv_alloc_hit = 0;\n\n\tif (prev != my_rsv)\n\t\text3_rsv_window_add(sb, my_rsv);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_try_to_allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "875-953",
    "snippet": "static ext3_grpblk_t\next3_try_to_allocate(struct super_block *sb, handle_t *handle, int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext3_grpblk_t grp_goal,\n\t\t\tunsigned long *count, struct ext3_reserve_window *my_rsv)\n{\n\text3_fsblk_t group_first_block;\n\text3_grpblk_t start, end;\n\tunsigned long num = 0;\n\n\t/* we do allocation within the reservation window if we have a window */\n\tif (my_rsv) {\n\t\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\t\tif (my_rsv->_rsv_start >= group_first_block)\n\t\t\tstart = my_rsv->_rsv_start - group_first_block;\n\t\telse\n\t\t\t/* reservation window cross group boundary */\n\t\t\tstart = 0;\n\t\tend = my_rsv->_rsv_end - group_first_block + 1;\n\t\tif (end > EXT3_BLOCKS_PER_GROUP(sb))\n\t\t\t/* reservation window crosses group boundary */\n\t\t\tend = EXT3_BLOCKS_PER_GROUP(sb);\n\t\tif ((start <= grp_goal) && (grp_goal < end))\n\t\t\tstart = grp_goal;\n\t\telse\n\t\t\tgrp_goal = -1;\n\t} else {\n\t\tif (grp_goal > 0)\n\t\t\tstart = grp_goal;\n\t\telse\n\t\t\tstart = 0;\n\t\tend = EXT3_BLOCKS_PER_GROUP(sb);\n\t}\n\n\tBUG_ON(start > EXT3_BLOCKS_PER_GROUP(sb));\n\nrepeat:\n\tif (grp_goal < 0 || !ext3_test_allocatable(grp_goal, bitmap_bh)) {\n\t\tgrp_goal = find_next_usable_block(start, bitmap_bh, end);\n\t\tif (grp_goal < 0)\n\t\t\tgoto fail_access;\n\t\tif (!my_rsv) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 7 && grp_goal > start &&\n\t\t\t\t\text3_test_allocatable(grp_goal - 1,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\t\ti++, grp_goal--)\n\t\t\t\t;\n\t\t}\n\t}\n\tstart = grp_goal;\n\n\tif (!claim_block(sb_bgl_lock(EXT3_SB(sb), group),\n\t\tgrp_goal, bitmap_bh)) {\n\t\t/*\n\t\t * The block was allocated by another thread, or it was\n\t\t * allocated and then freed by another thread\n\t\t */\n\t\tstart++;\n\t\tgrp_goal++;\n\t\tif (start >= end)\n\t\t\tgoto fail_access;\n\t\tgoto repeat;\n\t}\n\tnum++;\n\tgrp_goal++;\n\twhile (num < *count && grp_goal < end\n\t\t&& ext3_test_allocatable(grp_goal, bitmap_bh)\n\t\t&& claim_block(sb_bgl_lock(EXT3_SB(sb), group),\n\t\t\t\tgrp_goal, bitmap_bh)) {\n\t\tnum++;\n\t\tgrp_goal++;\n\t}\n\t*count = num;\n\treturn grp_goal - num;\nfail_access:\n\t*count = num;\n\treturn -1;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "claim_block",
          "args": [
            "sb_bgl_lock(EXT3_SB(sb), group)",
            "grp_goal",
            "bitmap_bh"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "claim_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "832-849",
          "snippet": "static inline int\nclaim_block(spinlock_t *lock, ext3_grpblk_t block, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\tint ret;\n\n\tif (ext3_set_bit_atomic(lock, block, bh->b_data))\n\t\treturn 0;\n\tjbd_lock_bh_state(bh);\n\tif (jh->b_committed_data && ext3_test_bit(block,jh->b_committed_data)) {\n\t\text3_clear_bit_atomic(lock, block, bh->b_data);\n\t\tret = 0;\n\t} else {\n\t\tret = 1;\n\t}\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic inline int\nclaim_block(spinlock_t *lock, ext3_grpblk_t block, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\tint ret;\n\n\tif (ext3_set_bit_atomic(lock, block, bh->b_data))\n\t\treturn 0;\n\tjbd_lock_bh_state(bh);\n\tif (jh->b_committed_data && ext3_test_bit(block,jh->b_committed_data)) {\n\t\text3_clear_bit_atomic(lock, block, bh->b_data);\n\t\tret = 0;\n\t} else {\n\t\tret = 1;\n\t}\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bgl_lock",
          "args": [
            "EXT3_SB(sb)",
            "group"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "sb_bgl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "683-687",
          "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_test_allocatable",
          "args": [
            "grp_goal",
            "bitmap_bh"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_test_allocatable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "713-728",
          "snippet": "static int ext3_test_allocatable(ext3_grpblk_t nr, struct buffer_head *bh)\n{\n\tint ret;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tif (ext3_test_bit(nr, bh->b_data))\n\t\treturn 0;\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data)\n\t\tret = 1;\n\telse\n\t\tret = !ext3_test_bit(nr, jh->b_committed_data);\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int ext3_test_allocatable(ext3_grpblk_t nr, struct buffer_head *bh)\n{\n\tint ret;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tif (ext3_test_bit(nr, bh->b_data))\n\t\treturn 0;\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data)\n\t\tret = 1;\n\telse\n\t\tret = !ext3_test_bit(nr, jh->b_committed_data);\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_usable_block",
          "args": [
            "start",
            "bitmap_bh",
            "end"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "find_next_usable_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "775-818",
          "snippet": "static ext3_grpblk_t\nfind_next_usable_block(ext3_grpblk_t start, struct buffer_head *bh,\n\t\t\text3_grpblk_t maxblocks)\n{\n\text3_grpblk_t here, next;\n\tchar *p, *r;\n\n\tif (start > 0) {\n\t\t/*\n\t\t * The goal was occupied; search forward for a free\n\t\t * block within the next XX blocks.\n\t\t *\n\t\t * end_goal is more or less random, but it has to be\n\t\t * less than EXT3_BLOCKS_PER_GROUP. Aligning up to the\n\t\t * next 64-bit boundary is simple..\n\t\t */\n\t\text3_grpblk_t end_goal = (start + 63) & ~63;\n\t\tif (end_goal > maxblocks)\n\t\t\tend_goal = maxblocks;\n\t\there = ext3_find_next_zero_bit(bh->b_data, end_goal, start);\n\t\tif (here < end_goal && ext3_test_allocatable(here, bh))\n\t\t\treturn here;\n\t\text3_debug(\"Bit not found near goal\\n\");\n\t}\n\n\there = start;\n\tif (here < 0)\n\t\there = 0;\n\n\tp = bh->b_data + (here >> 3);\n\tr = memscan(p, 0, ((maxblocks + 7) >> 3) - (here >> 3));\n\tnext = (r - bh->b_data) << 3;\n\n\tif (next < maxblocks && next >= start && ext3_test_allocatable(next, bh))\n\t\treturn next;\n\n\t/*\n\t * The bitmap search --- search forward alternately through the actual\n\t * bitmap and the last-committed copy until we find a bit free in\n\t * both\n\t */\n\there = bitmap_search_next_usable_block(here, bh, maxblocks);\n\treturn here;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic ext3_grpblk_t\nfind_next_usable_block(ext3_grpblk_t start, struct buffer_head *bh,\n\t\t\text3_grpblk_t maxblocks)\n{\n\text3_grpblk_t here, next;\n\tchar *p, *r;\n\n\tif (start > 0) {\n\t\t/*\n\t\t * The goal was occupied; search forward for a free\n\t\t * block within the next XX blocks.\n\t\t *\n\t\t * end_goal is more or less random, but it has to be\n\t\t * less than EXT3_BLOCKS_PER_GROUP. Aligning up to the\n\t\t * next 64-bit boundary is simple..\n\t\t */\n\t\text3_grpblk_t end_goal = (start + 63) & ~63;\n\t\tif (end_goal > maxblocks)\n\t\t\tend_goal = maxblocks;\n\t\there = ext3_find_next_zero_bit(bh->b_data, end_goal, start);\n\t\tif (here < end_goal && ext3_test_allocatable(here, bh))\n\t\t\treturn here;\n\t\text3_debug(\"Bit not found near goal\\n\");\n\t}\n\n\there = start;\n\tif (here < 0)\n\t\there = 0;\n\n\tp = bh->b_data + (here >> 3);\n\tr = memscan(p, 0, ((maxblocks + 7) >> 3) - (here >> 3));\n\tnext = (r - bh->b_data) << 3;\n\n\tif (next < maxblocks && next >= start && ext3_test_allocatable(next, bh))\n\t\treturn next;\n\n\t/*\n\t * The bitmap search --- search forward alternately through the actual\n\t * bitmap and the last-committed copy until we find a bit free in\n\t * both\n\t */\n\there = bitmap_search_next_usable_block(here, bh, maxblocks);\n\treturn here;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start > EXT3_BLOCKS_PER_GROUP(sb)"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "972-977",
          "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic ext3_grpblk_t\next3_try_to_allocate(struct super_block *sb, handle_t *handle, int group,\n\t\t\tstruct buffer_head *bitmap_bh, ext3_grpblk_t grp_goal,\n\t\t\tunsigned long *count, struct ext3_reserve_window *my_rsv)\n{\n\text3_fsblk_t group_first_block;\n\text3_grpblk_t start, end;\n\tunsigned long num = 0;\n\n\t/* we do allocation within the reservation window if we have a window */\n\tif (my_rsv) {\n\t\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\t\tif (my_rsv->_rsv_start >= group_first_block)\n\t\t\tstart = my_rsv->_rsv_start - group_first_block;\n\t\telse\n\t\t\t/* reservation window cross group boundary */\n\t\t\tstart = 0;\n\t\tend = my_rsv->_rsv_end - group_first_block + 1;\n\t\tif (end > EXT3_BLOCKS_PER_GROUP(sb))\n\t\t\t/* reservation window crosses group boundary */\n\t\t\tend = EXT3_BLOCKS_PER_GROUP(sb);\n\t\tif ((start <= grp_goal) && (grp_goal < end))\n\t\t\tstart = grp_goal;\n\t\telse\n\t\t\tgrp_goal = -1;\n\t} else {\n\t\tif (grp_goal > 0)\n\t\t\tstart = grp_goal;\n\t\telse\n\t\t\tstart = 0;\n\t\tend = EXT3_BLOCKS_PER_GROUP(sb);\n\t}\n\n\tBUG_ON(start > EXT3_BLOCKS_PER_GROUP(sb));\n\nrepeat:\n\tif (grp_goal < 0 || !ext3_test_allocatable(grp_goal, bitmap_bh)) {\n\t\tgrp_goal = find_next_usable_block(start, bitmap_bh, end);\n\t\tif (grp_goal < 0)\n\t\t\tgoto fail_access;\n\t\tif (!my_rsv) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 7 && grp_goal > start &&\n\t\t\t\t\text3_test_allocatable(grp_goal - 1,\n\t\t\t\t\t\t\t\tbitmap_bh);\n\t\t\t\t\ti++, grp_goal--)\n\t\t\t\t;\n\t\t}\n\t}\n\tstart = grp_goal;\n\n\tif (!claim_block(sb_bgl_lock(EXT3_SB(sb), group),\n\t\tgrp_goal, bitmap_bh)) {\n\t\t/*\n\t\t * The block was allocated by another thread, or it was\n\t\t * allocated and then freed by another thread\n\t\t */\n\t\tstart++;\n\t\tgrp_goal++;\n\t\tif (start >= end)\n\t\t\tgoto fail_access;\n\t\tgoto repeat;\n\t}\n\tnum++;\n\tgrp_goal++;\n\twhile (num < *count && grp_goal < end\n\t\t&& ext3_test_allocatable(grp_goal, bitmap_bh)\n\t\t&& claim_block(sb_bgl_lock(EXT3_SB(sb), group),\n\t\t\t\tgrp_goal, bitmap_bh)) {\n\t\tnum++;\n\t\tgrp_goal++;\n\t}\n\t*count = num;\n\treturn grp_goal - num;\nfail_access:\n\t*count = num;\n\treturn -1;\n}"
  },
  {
    "function_name": "claim_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "832-849",
    "snippet": "static inline int\nclaim_block(spinlock_t *lock, ext3_grpblk_t block, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\tint ret;\n\n\tif (ext3_set_bit_atomic(lock, block, bh->b_data))\n\t\treturn 0;\n\tjbd_lock_bh_state(bh);\n\tif (jh->b_committed_data && ext3_test_bit(block,jh->b_committed_data)) {\n\t\text3_clear_bit_atomic(lock, block, bh->b_data);\n\t\tret = 0;\n\t} else {\n\t\tret = 1;\n\t}\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_clear_bit_atomic",
          "args": [
            "lock",
            "block",
            "bh->b_data"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_test_bit",
          "args": [
            "block",
            "jh->b_committed_data"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_bit_atomic",
          "args": [
            "lock",
            "block",
            "bh->b_data"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic inline int\nclaim_block(spinlock_t *lock, ext3_grpblk_t block, struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\tint ret;\n\n\tif (ext3_set_bit_atomic(lock, block, bh->b_data))\n\t\treturn 0;\n\tjbd_lock_bh_state(bh);\n\tif (jh->b_committed_data && ext3_test_bit(block,jh->b_committed_data)) {\n\t\text3_clear_bit_atomic(lock, block, bh->b_data);\n\t\tret = 0;\n\t} else {\n\t\tret = 1;\n\t}\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_next_usable_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "775-818",
    "snippet": "static ext3_grpblk_t\nfind_next_usable_block(ext3_grpblk_t start, struct buffer_head *bh,\n\t\t\text3_grpblk_t maxblocks)\n{\n\text3_grpblk_t here, next;\n\tchar *p, *r;\n\n\tif (start > 0) {\n\t\t/*\n\t\t * The goal was occupied; search forward for a free\n\t\t * block within the next XX blocks.\n\t\t *\n\t\t * end_goal is more or less random, but it has to be\n\t\t * less than EXT3_BLOCKS_PER_GROUP. Aligning up to the\n\t\t * next 64-bit boundary is simple..\n\t\t */\n\t\text3_grpblk_t end_goal = (start + 63) & ~63;\n\t\tif (end_goal > maxblocks)\n\t\t\tend_goal = maxblocks;\n\t\there = ext3_find_next_zero_bit(bh->b_data, end_goal, start);\n\t\tif (here < end_goal && ext3_test_allocatable(here, bh))\n\t\t\treturn here;\n\t\text3_debug(\"Bit not found near goal\\n\");\n\t}\n\n\there = start;\n\tif (here < 0)\n\t\there = 0;\n\n\tp = bh->b_data + (here >> 3);\n\tr = memscan(p, 0, ((maxblocks + 7) >> 3) - (here >> 3));\n\tnext = (r - bh->b_data) << 3;\n\n\tif (next < maxblocks && next >= start && ext3_test_allocatable(next, bh))\n\t\treturn next;\n\n\t/*\n\t * The bitmap search --- search forward alternately through the actual\n\t * bitmap and the last-committed copy until we find a bit free in\n\t * both\n\t */\n\there = bitmap_search_next_usable_block(here, bh, maxblocks);\n\treturn here;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_search_next_usable_block",
          "args": [
            "here",
            "bh",
            "maxblocks"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "bitmap_search_next_usable_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "740-760",
          "snippet": "static ext3_grpblk_t\nbitmap_search_next_usable_block(ext3_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text3_grpblk_t maxblocks)\n{\n\text3_grpblk_t next;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\twhile (start < maxblocks) {\n\t\tnext = ext3_find_next_zero_bit(bh->b_data, maxblocks, start);\n\t\tif (next >= maxblocks)\n\t\t\treturn -1;\n\t\tif (ext3_test_allocatable(next, bh))\n\t\t\treturn next;\n\t\tjbd_lock_bh_state(bh);\n\t\tif (jh->b_committed_data)\n\t\t\tstart = ext3_find_next_zero_bit(jh->b_committed_data,\n\t\t\t\t\t\t\tmaxblocks, next);\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic ext3_grpblk_t\nbitmap_search_next_usable_block(ext3_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text3_grpblk_t maxblocks)\n{\n\text3_grpblk_t next;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\twhile (start < maxblocks) {\n\t\tnext = ext3_find_next_zero_bit(bh->b_data, maxblocks, start);\n\t\tif (next >= maxblocks)\n\t\t\treturn -1;\n\t\tif (ext3_test_allocatable(next, bh))\n\t\t\treturn next;\n\t\tjbd_lock_bh_state(bh);\n\t\tif (jh->b_committed_data)\n\t\t\tstart = ext3_find_next_zero_bit(jh->b_committed_data,\n\t\t\t\t\t\t\tmaxblocks, next);\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_test_allocatable",
          "args": [
            "next",
            "bh"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_test_allocatable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "713-728",
          "snippet": "static int ext3_test_allocatable(ext3_grpblk_t nr, struct buffer_head *bh)\n{\n\tint ret;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tif (ext3_test_bit(nr, bh->b_data))\n\t\treturn 0;\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data)\n\t\tret = 1;\n\telse\n\t\tret = !ext3_test_bit(nr, jh->b_committed_data);\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int ext3_test_allocatable(ext3_grpblk_t nr, struct buffer_head *bh)\n{\n\tint ret;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tif (ext3_test_bit(nr, bh->b_data))\n\t\treturn 0;\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data)\n\t\tret = 1;\n\telse\n\t\tret = !ext3_test_bit(nr, jh->b_committed_data);\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memscan",
          "args": [
            "p",
            "0",
            "((maxblocks + 7) >> 3) - (here >> 3)"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"Bit not found near goal\\n\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_find_next_zero_bit",
          "args": [
            "bh->b_data",
            "end_goal",
            "start"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic ext3_grpblk_t\nfind_next_usable_block(ext3_grpblk_t start, struct buffer_head *bh,\n\t\t\text3_grpblk_t maxblocks)\n{\n\text3_grpblk_t here, next;\n\tchar *p, *r;\n\n\tif (start > 0) {\n\t\t/*\n\t\t * The goal was occupied; search forward for a free\n\t\t * block within the next XX blocks.\n\t\t *\n\t\t * end_goal is more or less random, but it has to be\n\t\t * less than EXT3_BLOCKS_PER_GROUP. Aligning up to the\n\t\t * next 64-bit boundary is simple..\n\t\t */\n\t\text3_grpblk_t end_goal = (start + 63) & ~63;\n\t\tif (end_goal > maxblocks)\n\t\t\tend_goal = maxblocks;\n\t\there = ext3_find_next_zero_bit(bh->b_data, end_goal, start);\n\t\tif (here < end_goal && ext3_test_allocatable(here, bh))\n\t\t\treturn here;\n\t\text3_debug(\"Bit not found near goal\\n\");\n\t}\n\n\there = start;\n\tif (here < 0)\n\t\there = 0;\n\n\tp = bh->b_data + (here >> 3);\n\tr = memscan(p, 0, ((maxblocks + 7) >> 3) - (here >> 3));\n\tnext = (r - bh->b_data) << 3;\n\n\tif (next < maxblocks && next >= start && ext3_test_allocatable(next, bh))\n\t\treturn next;\n\n\t/*\n\t * The bitmap search --- search forward alternately through the actual\n\t * bitmap and the last-committed copy until we find a bit free in\n\t * both\n\t */\n\there = bitmap_search_next_usable_block(here, bh, maxblocks);\n\treturn here;\n}"
  },
  {
    "function_name": "bitmap_search_next_usable_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "740-760",
    "snippet": "static ext3_grpblk_t\nbitmap_search_next_usable_block(ext3_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text3_grpblk_t maxblocks)\n{\n\text3_grpblk_t next;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\twhile (start < maxblocks) {\n\t\tnext = ext3_find_next_zero_bit(bh->b_data, maxblocks, start);\n\t\tif (next >= maxblocks)\n\t\t\treturn -1;\n\t\tif (ext3_test_allocatable(next, bh))\n\t\t\treturn next;\n\t\tjbd_lock_bh_state(bh);\n\t\tif (jh->b_committed_data)\n\t\t\tstart = ext3_find_next_zero_bit(jh->b_committed_data,\n\t\t\t\t\t\t\tmaxblocks, next);\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_find_next_zero_bit",
          "args": [
            "jh->b_committed_data",
            "maxblocks",
            "next"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_test_allocatable",
          "args": [
            "next",
            "bh"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_test_allocatable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "713-728",
          "snippet": "static int ext3_test_allocatable(ext3_grpblk_t nr, struct buffer_head *bh)\n{\n\tint ret;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tif (ext3_test_bit(nr, bh->b_data))\n\t\treturn 0;\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data)\n\t\tret = 1;\n\telse\n\t\tret = !ext3_test_bit(nr, jh->b_committed_data);\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int ext3_test_allocatable(ext3_grpblk_t nr, struct buffer_head *bh)\n{\n\tint ret;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tif (ext3_test_bit(nr, bh->b_data))\n\t\treturn 0;\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data)\n\t\tret = 1;\n\telse\n\t\tret = !ext3_test_bit(nr, jh->b_committed_data);\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_find_next_zero_bit",
          "args": [
            "bh->b_data",
            "maxblocks",
            "start"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic ext3_grpblk_t\nbitmap_search_next_usable_block(ext3_grpblk_t start, struct buffer_head *bh,\n\t\t\t\t\text3_grpblk_t maxblocks)\n{\n\text3_grpblk_t next;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\twhile (start < maxblocks) {\n\t\tnext = ext3_find_next_zero_bit(bh->b_data, maxblocks, start);\n\t\tif (next >= maxblocks)\n\t\t\treturn -1;\n\t\tif (ext3_test_allocatable(next, bh))\n\t\t\treturn next;\n\t\tjbd_lock_bh_state(bh);\n\t\tif (jh->b_committed_data)\n\t\t\tstart = ext3_find_next_zero_bit(jh->b_committed_data,\n\t\t\t\t\t\t\tmaxblocks, next);\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "ext3_test_allocatable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "713-728",
    "snippet": "static int ext3_test_allocatable(ext3_grpblk_t nr, struct buffer_head *bh)\n{\n\tint ret;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tif (ext3_test_bit(nr, bh->b_data))\n\t\treturn 0;\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data)\n\t\tret = 1;\n\telse\n\t\tret = !ext3_test_bit(nr, jh->b_committed_data);\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_test_bit",
          "args": [
            "nr",
            "jh->b_committed_data"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_test_bit",
          "args": [
            "nr",
            "bh->b_data"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int ext3_test_allocatable(ext3_grpblk_t nr, struct buffer_head *bh)\n{\n\tint ret;\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tif (ext3_test_bit(nr, bh->b_data))\n\t\treturn 0;\n\n\tjbd_lock_bh_state(bh);\n\tif (!jh->b_committed_data)\n\t\tret = 1;\n\telse\n\t\tret = !ext3_test_bit(nr, jh->b_committed_data);\n\tjbd_unlock_bh_state(bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ext3_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "680-691",
    "snippet": "void ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dquot_free_block",
          "args": [
            "inode",
            "dquot_freed_blocks"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_free_blocks_sb",
          "args": [
            "handle",
            "sb",
            "block",
            "count",
            "&dquot_freed_blocks"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_free_blocks_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "490-671",
          "snippet": "void ext3_free_blocks_sb(handle_t *handle, struct super_block *sb,\n\t\t\t ext3_fsblk_t block, unsigned long count,\n\t\t\t unsigned long *pdquot_freed_blocks)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\tunsigned long block_group;\n\text3_grpblk_t bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0, ret;\n\text3_grpblk_t group_freed;\n\n\t*pdquot_freed_blocks = 0;\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text3_error (sb, \"ext3_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = \"E3FSBLK\", count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text3_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT3_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT3_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT3_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT3_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\tdesc = ext3_get_group_desc (sb, block_group, &gd_bh);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text3_error (sb, \"ext3_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = \"E3FSBLK\", count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * We are about to start releasing blocks in the bitmap,\n\t * so we need undo access.\n\t */\n\t/* @@@ check errors */\n\tBUFFER_TRACE(bitmap_bh, \"getting undo access\");\n\terr = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\tjbd_lock_bh_state(bitmap_bh);\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\t/*\n\t\t * An HJ special.  This is expensive...\n\t\t */\n#ifdef CONFIG_JBD_DEBUG\n\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t{\n\t\t\tstruct buffer_head *debug_bh;\n\t\t\tdebug_bh = sb_find_get_block(sb, block + i);\n\t\t\tif (debug_bh) {\n\t\t\t\tBUFFER_TRACE(debug_bh, \"Deleted!\");\n\t\t\t\tif (!bh2jh(bitmap_bh)->b_committed_data)\n\t\t\t\t\tBUFFER_TRACE(debug_bh,\n\t\t\t\t\t\t\"No committed data in bitmap\");\n\t\t\t\tBUFFER_TRACE2(debug_bh, bitmap_bh, \"bitmap\");\n\t\t\t\t__brelse(debug_bh);\n\t\t\t}\n\t\t}\n\t\tjbd_lock_bh_state(bitmap_bh);\n#endif\n\t\tif (need_resched()) {\n\t\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t\tcond_resched();\n\t\t\tjbd_lock_bh_state(bitmap_bh);\n\t\t}\n\t\t/* @@@ This prevents newly-allocated data from being\n\t\t * freed and then reallocated within the same\n\t\t * transaction.\n\t\t *\n\t\t * Ideally we would want to allow that to happen, but to\n\t\t * do so requires making journal_forget() capable of\n\t\t * revoking the queued write of a data block, which\n\t\t * implies blocking on the journal lock.  *forget()\n\t\t * cannot block due to truncate races.\n\t\t *\n\t\t * Eventually we can fix this by making journal_forget()\n\t\t * return a status indicating whether or not it was able\n\t\t * to revoke the buffer.  On successful revoke, it is\n\t\t * safe not to set the allocation bit in the committed\n\t\t * bitmap, because we know that there is no outstanding\n\t\t * activity on the buffer any more and so it is safe to\n\t\t * reallocate it.\n\t\t */\n\t\tBUFFER_TRACE(bitmap_bh, \"set in b_committed_data\");\n\t\tJ_ASSERT_BH(bitmap_bh,\n\t\t\t\tbh2jh(bitmap_bh)->b_committed_data != NULL);\n\t\text3_set_bit_atomic(sb_bgl_lock(sbi, block_group), bit + i,\n\t\t\t\tbh2jh(bitmap_bh)->b_committed_data);\n\n\t\t/*\n\t\t * We clear the bit in the bitmap after setting the committed\n\t\t * data bit, because this is the reverse order to that which\n\t\t * the allocator uses.\n\t\t */\n\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t\text3_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block \"E3FSBLK,\n\t\t\t\t block + i);\n\t\t\tjbd_lock_bh_state(bitmap_bh);\n\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\tjbd_unlock_bh_state(bitmap_bh);\n\n\tspin_lock(sb_bgl_lock(sbi, block_group));\n\tle16_add_cpu(&desc->bg_free_blocks_count, group_freed);\n\tspin_unlock(sb_bgl_lock(sbi, block_group));\n\tpercpu_counter_add(&sbi->s_freeblocks_counter, count);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext3_journal_dirty_metadata(handle, gd_bh);\n\tif (!err) err = ret;\n\t*pdquot_freed_blocks += group_freed;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text3_std_error(sb, err);\n\treturn;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_blocks_sb(handle_t *handle, struct super_block *sb,\n\t\t\t ext3_fsblk_t block, unsigned long count,\n\t\t\t unsigned long *pdquot_freed_blocks)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\tunsigned long block_group;\n\text3_grpblk_t bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0, ret;\n\text3_grpblk_t group_freed;\n\n\t*pdquot_freed_blocks = 0;\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text3_error (sb, \"ext3_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = \"E3FSBLK\", count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text3_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT3_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT3_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT3_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT3_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\tdesc = ext3_get_group_desc (sb, block_group, &gd_bh);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text3_error (sb, \"ext3_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = \"E3FSBLK\", count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * We are about to start releasing blocks in the bitmap,\n\t * so we need undo access.\n\t */\n\t/* @@@ check errors */\n\tBUFFER_TRACE(bitmap_bh, \"getting undo access\");\n\terr = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\tjbd_lock_bh_state(bitmap_bh);\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\t/*\n\t\t * An HJ special.  This is expensive...\n\t\t */\n#ifdef CONFIG_JBD_DEBUG\n\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t{\n\t\t\tstruct buffer_head *debug_bh;\n\t\t\tdebug_bh = sb_find_get_block(sb, block + i);\n\t\t\tif (debug_bh) {\n\t\t\t\tBUFFER_TRACE(debug_bh, \"Deleted!\");\n\t\t\t\tif (!bh2jh(bitmap_bh)->b_committed_data)\n\t\t\t\t\tBUFFER_TRACE(debug_bh,\n\t\t\t\t\t\t\"No committed data in bitmap\");\n\t\t\t\tBUFFER_TRACE2(debug_bh, bitmap_bh, \"bitmap\");\n\t\t\t\t__brelse(debug_bh);\n\t\t\t}\n\t\t}\n\t\tjbd_lock_bh_state(bitmap_bh);\n#endif\n\t\tif (need_resched()) {\n\t\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t\tcond_resched();\n\t\t\tjbd_lock_bh_state(bitmap_bh);\n\t\t}\n\t\t/* @@@ This prevents newly-allocated data from being\n\t\t * freed and then reallocated within the same\n\t\t * transaction.\n\t\t *\n\t\t * Ideally we would want to allow that to happen, but to\n\t\t * do so requires making journal_forget() capable of\n\t\t * revoking the queued write of a data block, which\n\t\t * implies blocking on the journal lock.  *forget()\n\t\t * cannot block due to truncate races.\n\t\t *\n\t\t * Eventually we can fix this by making journal_forget()\n\t\t * return a status indicating whether or not it was able\n\t\t * to revoke the buffer.  On successful revoke, it is\n\t\t * safe not to set the allocation bit in the committed\n\t\t * bitmap, because we know that there is no outstanding\n\t\t * activity on the buffer any more and so it is safe to\n\t\t * reallocate it.\n\t\t */\n\t\tBUFFER_TRACE(bitmap_bh, \"set in b_committed_data\");\n\t\tJ_ASSERT_BH(bitmap_bh,\n\t\t\t\tbh2jh(bitmap_bh)->b_committed_data != NULL);\n\t\text3_set_bit_atomic(sb_bgl_lock(sbi, block_group), bit + i,\n\t\t\t\tbh2jh(bitmap_bh)->b_committed_data);\n\n\t\t/*\n\t\t * We clear the bit in the bitmap after setting the committed\n\t\t * data bit, because this is the reverse order to that which\n\t\t * the allocator uses.\n\t\t */\n\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t\text3_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block \"E3FSBLK,\n\t\t\t\t block + i);\n\t\t\tjbd_lock_bh_state(bitmap_bh);\n\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\tjbd_unlock_bh_state(bitmap_bh);\n\n\tspin_lock(sb_bgl_lock(sbi, block_group));\n\tle16_add_cpu(&desc->bg_free_blocks_count, group_freed);\n\tspin_unlock(sb_bgl_lock(sbi, block_group));\n\tpercpu_counter_add(&sbi->s_freeblocks_counter, count);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext3_journal_dirty_metadata(handle, gd_bh);\n\tif (!err) err = ret;\n\t*pdquot_freed_blocks += group_freed;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text3_std_error(sb, err);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_free_blocks",
          "args": [
            "inode",
            "block",
            "count"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_blocks(handle_t *handle, struct inode *inode,\n\t\t\text3_fsblk_t block, unsigned long count)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tunsigned long dquot_freed_blocks;\n\n\ttrace_ext3_free_blocks(inode, block, count);\n\text3_free_blocks_sb(handle, sb, block, count, &dquot_freed_blocks);\n\tif (dquot_freed_blocks)\n\t\tdquot_free_block(inode, dquot_freed_blocks);\n\treturn;\n}"
  },
  {
    "function_name": "ext3_free_blocks_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "490-671",
    "snippet": "void ext3_free_blocks_sb(handle_t *handle, struct super_block *sb,\n\t\t\t ext3_fsblk_t block, unsigned long count,\n\t\t\t unsigned long *pdquot_freed_blocks)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\tunsigned long block_group;\n\text3_grpblk_t bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0, ret;\n\text3_grpblk_t group_freed;\n\n\t*pdquot_freed_blocks = 0;\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text3_error (sb, \"ext3_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = \"E3FSBLK\", count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text3_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT3_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT3_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT3_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT3_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\tdesc = ext3_get_group_desc (sb, block_group, &gd_bh);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text3_error (sb, \"ext3_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = \"E3FSBLK\", count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * We are about to start releasing blocks in the bitmap,\n\t * so we need undo access.\n\t */\n\t/* @@@ check errors */\n\tBUFFER_TRACE(bitmap_bh, \"getting undo access\");\n\terr = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\tjbd_lock_bh_state(bitmap_bh);\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\t/*\n\t\t * An HJ special.  This is expensive...\n\t\t */\n#ifdef CONFIG_JBD_DEBUG\n\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t{\n\t\t\tstruct buffer_head *debug_bh;\n\t\t\tdebug_bh = sb_find_get_block(sb, block + i);\n\t\t\tif (debug_bh) {\n\t\t\t\tBUFFER_TRACE(debug_bh, \"Deleted!\");\n\t\t\t\tif (!bh2jh(bitmap_bh)->b_committed_data)\n\t\t\t\t\tBUFFER_TRACE(debug_bh,\n\t\t\t\t\t\t\"No committed data in bitmap\");\n\t\t\t\tBUFFER_TRACE2(debug_bh, bitmap_bh, \"bitmap\");\n\t\t\t\t__brelse(debug_bh);\n\t\t\t}\n\t\t}\n\t\tjbd_lock_bh_state(bitmap_bh);\n#endif\n\t\tif (need_resched()) {\n\t\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t\tcond_resched();\n\t\t\tjbd_lock_bh_state(bitmap_bh);\n\t\t}\n\t\t/* @@@ This prevents newly-allocated data from being\n\t\t * freed and then reallocated within the same\n\t\t * transaction.\n\t\t *\n\t\t * Ideally we would want to allow that to happen, but to\n\t\t * do so requires making journal_forget() capable of\n\t\t * revoking the queued write of a data block, which\n\t\t * implies blocking on the journal lock.  *forget()\n\t\t * cannot block due to truncate races.\n\t\t *\n\t\t * Eventually we can fix this by making journal_forget()\n\t\t * return a status indicating whether or not it was able\n\t\t * to revoke the buffer.  On successful revoke, it is\n\t\t * safe not to set the allocation bit in the committed\n\t\t * bitmap, because we know that there is no outstanding\n\t\t * activity on the buffer any more and so it is safe to\n\t\t * reallocate it.\n\t\t */\n\t\tBUFFER_TRACE(bitmap_bh, \"set in b_committed_data\");\n\t\tJ_ASSERT_BH(bitmap_bh,\n\t\t\t\tbh2jh(bitmap_bh)->b_committed_data != NULL);\n\t\text3_set_bit_atomic(sb_bgl_lock(sbi, block_group), bit + i,\n\t\t\t\tbh2jh(bitmap_bh)->b_committed_data);\n\n\t\t/*\n\t\t * We clear the bit in the bitmap after setting the committed\n\t\t * data bit, because this is the reverse order to that which\n\t\t * the allocator uses.\n\t\t */\n\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t\text3_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block \"E3FSBLK,\n\t\t\t\t block + i);\n\t\t\tjbd_lock_bh_state(bitmap_bh);\n\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\tjbd_unlock_bh_state(bitmap_bh);\n\n\tspin_lock(sb_bgl_lock(sbi, block_group));\n\tle16_add_cpu(&desc->bg_free_blocks_count, group_freed);\n\tspin_unlock(sb_bgl_lock(sbi, block_group));\n\tpercpu_counter_add(&sbi->s_freeblocks_counter, count);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext3_journal_dirty_metadata(handle, gd_bh);\n\tif (!err) err = ret;\n\t*pdquot_freed_blocks += group_freed;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text3_std_error(sb, err);\n\treturn;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_std_error",
          "args": [
            "sb",
            "err"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bitmap_bh"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "gd_bh"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gd_bh",
            "\"dirtied group descriptor block\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_dirty_metadata",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"dirtied bitmap block\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&sbi->s_freeblocks_counter",
            "count"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "sb_bgl_lock(sbi, block_group)"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bgl_lock",
          "args": [
            "sbi",
            "block_group"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "sb_bgl_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "683-687",
          "snippet": "static inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nstatic inline spinlock_t *\nsb_bgl_lock(struct ext3_sb_info *sbi, unsigned int block_group)\n{\n\treturn bgl_lock_ptr(sbi->s_blockgroup_lock, block_group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&desc->bg_free_blocks_count",
            "group_freed"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "sb_bgl_lock(sbi, block_group)"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bitmap_bh"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"bit already cleared\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bitmap_bh"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "__func__",
            "\"bit already cleared for block \"E3FSBLK",
            "block + i"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bitmap_bh"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_clear_bit_atomic",
          "args": [
            "sb_bgl_lock(sbi, block_group)",
            "bit + i",
            "bitmap_bh->b_data"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"clear bit\""
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_set_bit_atomic",
          "args": [
            "sb_bgl_lock(sbi, block_group)",
            "bit + i",
            "bh2jh(bitmap_bh)->b_committed_data"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bitmap_bh"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bitmap_bh",
            "bh2jh(bitmap_bh)->b_committed_data != NULL"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bitmap_bh"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"set in b_committed_data\""
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bitmap_bh"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bitmap_bh"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bitmap_bh"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE2",
          "args": [
            "debug_bh",
            "bitmap_bh",
            "\"bitmap\""
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "debug_bh",
            "\"No committed data in bitmap\""
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bitmap_bh"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "debug_bh",
            "\"Deleted!\""
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_find_get_block",
          "args": [
            "sb",
            "block + i"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bitmap_bh"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bitmap_bh"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_write_access",
          "args": [
            "handle",
            "gd_bh"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "gd_bh",
            "\"get_write_access\""
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_journal_get_undo_access",
          "args": [
            "handle",
            "bitmap_bh"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bitmap_bh",
            "\"getting undo access\""
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_range",
          "args": [
            "block + count - 1",
            "le32_to_cpu(desc->bg_inode_table)",
            "sbi->s_itb_per_group"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_page_exists_in_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "7049-7117",
          "snippet": "bool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nbool btrfs_page_exists_in_range(struct inode *inode, loff_t start, loff_t end)\n{\n\tstruct radix_tree_root *root = &inode->i_mapping->page_tree;\n\tint found = false;\n\tvoid **pagep = NULL;\n\tstruct page *page = NULL;\n\tint start_idx;\n\tint end_idx;\n\n\tstart_idx = start >> PAGE_CACHE_SHIFT;\n\n\t/*\n\t * end is the last byte in the last page.  end == start is legal\n\t */\n\tend_idx = end >> PAGE_CACHE_SHIFT;\n\n\trcu_read_lock();\n\n\t/* Most of the code in this while loop is lifted from\n\t * find_get_page.  It's been modified to begin searching from a\n\t * page and return just the first page found in that range.  If the\n\t * found idx is less than or equal to the end idx then we know that\n\t * a page exists.  If no pages are found or if those pages are\n\t * outside of the range then we're fine (yay!) */\n\twhile (page == NULL &&\n\t       radix_tree_gang_lookup_slot(root, &pagep, NULL, start_idx, 1)) {\n\t\tpage = radix_tree_deref_slot(pagep);\n\t\tif (unlikely(!page))\n\t\t\tbreak;\n\n\t\tif (radix_tree_exception(page)) {\n\t\t\tif (radix_tree_deref_retry(page)) {\n\t\t\t\tpage = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Otherwise, shmem/tmpfs must be storing a swap entry\n\t\t\t * here as an exceptional entry: so return it without\n\t\t\t * attempting to raise page count.\n\t\t\t */\n\t\t\tpage = NULL;\n\t\t\tbreak; /* TODO: Is this relevant for this use case? */\n\t\t}\n\n\t\tif (!page_cache_get_speculative(page)) {\n\t\t\tpage = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Has the page moved?\n\t\t * This is part of the lockless pagecache protocol. See\n\t\t * include/linux/pagemap.h for details.\n\t\t */\n\t\tif (unlikely(page != *pagep)) {\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t}\n\t}\n\n\tif (page) {\n\t\tif (page->index <= end_idx)\n\t\t\tfound = true;\n\t\tpage_cache_release(page);\n\t}\n\n\trcu_read_unlock();\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "desc->bg_inode_table"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "&gd_bh"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_block_bitmap",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "read_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "147-184",
          "snippet": "static struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext3_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text3_fsblk_t bitmap_blk;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\ttrace_ext3_read_block_bitmap(sb, block_group);\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\text3_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext3_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text3_fsblk_t bitmap_blk;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\ttrace_ext3_read_block_bitmap(sb, block_group);\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\text3_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_debug",
          "args": [
            "\"freeing block(s) %lu-%lu\\n\"",
            "block",
            "block + count - 1"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_free_blocks_sb(handle_t *handle, struct super_block *sb,\n\t\t\t ext3_fsblk_t block, unsigned long count,\n\t\t\t unsigned long *pdquot_freed_blocks)\n{\n\tstruct buffer_head *bitmap_bh = NULL;\n\tstruct buffer_head *gd_bh;\n\tunsigned long block_group;\n\text3_grpblk_t bit;\n\tunsigned long i;\n\tunsigned long overflow;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_super_block * es;\n\tstruct ext3_sb_info *sbi;\n\tint err = 0, ret;\n\text3_grpblk_t group_freed;\n\n\t*pdquot_freed_blocks = 0;\n\tsbi = EXT3_SB(sb);\n\tes = sbi->s_es;\n\tif (block < le32_to_cpu(es->s_first_data_block) ||\n\t    block + count < block ||\n\t    block + count > le32_to_cpu(es->s_blocks_count)) {\n\t\text3_error (sb, \"ext3_free_blocks\",\n\t\t\t    \"Freeing blocks not in datazone - \"\n\t\t\t    \"block = \"E3FSBLK\", count = %lu\", block, count);\n\t\tgoto error_return;\n\t}\n\n\text3_debug (\"freeing block(s) %lu-%lu\\n\", block, block + count - 1);\n\ndo_more:\n\toverflow = 0;\n\tblock_group = (block - le32_to_cpu(es->s_first_data_block)) /\n\t\t      EXT3_BLOCKS_PER_GROUP(sb);\n\tbit = (block - le32_to_cpu(es->s_first_data_block)) %\n\t\t      EXT3_BLOCKS_PER_GROUP(sb);\n\t/*\n\t * Check to see if we are freeing blocks across a group\n\t * boundary.\n\t */\n\tif (bit + count > EXT3_BLOCKS_PER_GROUP(sb)) {\n\t\toverflow = bit + count - EXT3_BLOCKS_PER_GROUP(sb);\n\t\tcount -= overflow;\n\t}\n\tbrelse(bitmap_bh);\n\tbitmap_bh = read_block_bitmap(sb, block_group);\n\tif (!bitmap_bh)\n\t\tgoto error_return;\n\tdesc = ext3_get_group_desc (sb, block_group, &gd_bh);\n\tif (!desc)\n\t\tgoto error_return;\n\n\tif (in_range (le32_to_cpu(desc->bg_block_bitmap), block, count) ||\n\t    in_range (le32_to_cpu(desc->bg_inode_bitmap), block, count) ||\n\t    in_range (block, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group) ||\n\t    in_range (block + count - 1, le32_to_cpu(desc->bg_inode_table),\n\t\t      sbi->s_itb_per_group)) {\n\t\text3_error (sb, \"ext3_free_blocks\",\n\t\t\t    \"Freeing blocks in system zones - \"\n\t\t\t    \"Block = \"E3FSBLK\", count = %lu\",\n\t\t\t    block, count);\n\t\tgoto error_return;\n\t}\n\n\t/*\n\t * We are about to start releasing blocks in the bitmap,\n\t * so we need undo access.\n\t */\n\t/* @@@ check errors */\n\tBUFFER_TRACE(bitmap_bh, \"getting undo access\");\n\terr = ext3_journal_get_undo_access(handle, bitmap_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\t/*\n\t * We are about to modify some metadata.  Call the journal APIs\n\t * to unshare ->b_data if a currently-committing transaction is\n\t * using it\n\t */\n\tBUFFER_TRACE(gd_bh, \"get_write_access\");\n\terr = ext3_journal_get_write_access(handle, gd_bh);\n\tif (err)\n\t\tgoto error_return;\n\n\tjbd_lock_bh_state(bitmap_bh);\n\n\tfor (i = 0, group_freed = 0; i < count; i++) {\n\t\t/*\n\t\t * An HJ special.  This is expensive...\n\t\t */\n#ifdef CONFIG_JBD_DEBUG\n\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t{\n\t\t\tstruct buffer_head *debug_bh;\n\t\t\tdebug_bh = sb_find_get_block(sb, block + i);\n\t\t\tif (debug_bh) {\n\t\t\t\tBUFFER_TRACE(debug_bh, \"Deleted!\");\n\t\t\t\tif (!bh2jh(bitmap_bh)->b_committed_data)\n\t\t\t\t\tBUFFER_TRACE(debug_bh,\n\t\t\t\t\t\t\"No committed data in bitmap\");\n\t\t\t\tBUFFER_TRACE2(debug_bh, bitmap_bh, \"bitmap\");\n\t\t\t\t__brelse(debug_bh);\n\t\t\t}\n\t\t}\n\t\tjbd_lock_bh_state(bitmap_bh);\n#endif\n\t\tif (need_resched()) {\n\t\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t\tcond_resched();\n\t\t\tjbd_lock_bh_state(bitmap_bh);\n\t\t}\n\t\t/* @@@ This prevents newly-allocated data from being\n\t\t * freed and then reallocated within the same\n\t\t * transaction.\n\t\t *\n\t\t * Ideally we would want to allow that to happen, but to\n\t\t * do so requires making journal_forget() capable of\n\t\t * revoking the queued write of a data block, which\n\t\t * implies blocking on the journal lock.  *forget()\n\t\t * cannot block due to truncate races.\n\t\t *\n\t\t * Eventually we can fix this by making journal_forget()\n\t\t * return a status indicating whether or not it was able\n\t\t * to revoke the buffer.  On successful revoke, it is\n\t\t * safe not to set the allocation bit in the committed\n\t\t * bitmap, because we know that there is no outstanding\n\t\t * activity on the buffer any more and so it is safe to\n\t\t * reallocate it.\n\t\t */\n\t\tBUFFER_TRACE(bitmap_bh, \"set in b_committed_data\");\n\t\tJ_ASSERT_BH(bitmap_bh,\n\t\t\t\tbh2jh(bitmap_bh)->b_committed_data != NULL);\n\t\text3_set_bit_atomic(sb_bgl_lock(sbi, block_group), bit + i,\n\t\t\t\tbh2jh(bitmap_bh)->b_committed_data);\n\n\t\t/*\n\t\t * We clear the bit in the bitmap after setting the committed\n\t\t * data bit, because this is the reverse order to that which\n\t\t * the allocator uses.\n\t\t */\n\t\tBUFFER_TRACE(bitmap_bh, \"clear bit\");\n\t\tif (!ext3_clear_bit_atomic(sb_bgl_lock(sbi, block_group),\n\t\t\t\t\t\tbit + i, bitmap_bh->b_data)) {\n\t\t\tjbd_unlock_bh_state(bitmap_bh);\n\t\t\text3_error(sb, __func__,\n\t\t\t\t\"bit already cleared for block \"E3FSBLK,\n\t\t\t\t block + i);\n\t\t\tjbd_lock_bh_state(bitmap_bh);\n\t\t\tBUFFER_TRACE(bitmap_bh, \"bit already cleared\");\n\t\t} else {\n\t\t\tgroup_freed++;\n\t\t}\n\t}\n\tjbd_unlock_bh_state(bitmap_bh);\n\n\tspin_lock(sb_bgl_lock(sbi, block_group));\n\tle16_add_cpu(&desc->bg_free_blocks_count, group_freed);\n\tspin_unlock(sb_bgl_lock(sbi, block_group));\n\tpercpu_counter_add(&sbi->s_freeblocks_counter, count);\n\n\t/* We dirtied the bitmap block */\n\tBUFFER_TRACE(bitmap_bh, \"dirtied bitmap block\");\n\terr = ext3_journal_dirty_metadata(handle, bitmap_bh);\n\n\t/* And the group descriptor block */\n\tBUFFER_TRACE(gd_bh, \"dirtied group descriptor block\");\n\tret = ext3_journal_dirty_metadata(handle, gd_bh);\n\tif (!err) err = ret;\n\t*pdquot_freed_blocks += group_freed;\n\n\tif (overflow && !err) {\n\t\tblock += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\nerror_return:\n\tbrelse(bitmap_bh);\n\text3_std_error(sb, err);\n\treturn;\n}"
  },
  {
    "function_name": "ext3_discard_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "461-480",
    "snippet": "void ext3_discard_reservation(struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext3_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT3_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\t\ttrace_ext3_discard_reservation(inode, rsv);\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\t}\n\t\tspin_unlock(rsv_lock);\n\t}\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "rsv_lock"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsv_window_remove",
          "args": [
            "inode->i_sb",
            "rsv"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_window_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "377-384",
          "snippet": "static void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext3_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT3_SB(sb)->s_rsv_window_root);\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext3_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT3_SB(sb)->s_rsv_window_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ext3_discard_reservation",
          "args": [
            "inode",
            "rsv"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsv_is_empty",
          "args": [
            "&rsv->rsv_window"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "rsv_is_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "392-396",
          "snippet": "static inline int rsv_is_empty(struct ext3_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic inline int rsv_is_empty(struct ext3_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "rsv_lock"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_discard_reservation(struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *block_i = ei->i_block_alloc_info;\n\tstruct ext3_reserve_window_node *rsv;\n\tspinlock_t *rsv_lock = &EXT3_SB(inode->i_sb)->s_rsv_window_lock;\n\n\tif (!block_i)\n\t\treturn;\n\n\trsv = &block_i->rsv_window_node;\n\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\tspin_lock(rsv_lock);\n\t\tif (!rsv_is_empty(&rsv->rsv_window)) {\n\t\t\ttrace_ext3_discard_reservation(inode, rsv);\n\t\t\trsv_window_remove(inode->i_sb, rsv);\n\t\t}\n\t\tspin_unlock(rsv_lock);\n\t}\n}"
  },
  {
    "function_name": "ext3_init_block_alloc_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "419-446",
    "snippet": "void ext3_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext3_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t\t/*\n\t\t * if filesystem is mounted with NORESERVATION, the goal\n\t\t * reservation window size is set to zero to indicate\n\t\t * block reservation is off\n\t\t */\n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT3_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_opt",
          "args": [
            "sb",
            "RESERVATION"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*block_i)",
            "GFP_NOFS"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_I",
          "args": [
            "inode"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "693-696",
          "snippet": "static inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ext3_init_block_alloc_info(struct inode *);",
            "extern void ext3_free_inode (handle_t *, struct inode *);",
            "struct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);",
            "struct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);",
            "extern void ext3_evict_inode (struct inode *);",
            "extern int  ext3_sync_inode (handle_t *, struct inode *);",
            "extern void ext3_discard_reservation (struct inode *);",
            "extern void ext3_dirty_inode(struct inode *, int);",
            "extern int ext3_change_inode_journal_flag(struct inode *, int);",
            "extern int ext3_can_truncate(struct inode *inode);",
            "extern void ext3_truncate(struct inode *inode);",
            "extern void ext3_set_inode_flags(struct inode *);",
            "extern void ext3_get_inode_flags(struct ext3_inode_info *);",
            "extern void ext3_set_aops(struct inode *inode);",
            "extern int ext3_orphan_add(handle_t *, struct inode *);",
            "extern int ext3_orphan_del(handle_t *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern void ext3_init_block_alloc_info(struct inode *);\nextern void ext3_free_inode (handle_t *, struct inode *);\nstruct buffer_head * ext3_getblk (handle_t *, struct inode *, long, int, int *);\nstruct buffer_head * ext3_bread (handle_t *, struct inode *, int, int, int *);\nextern void ext3_evict_inode (struct inode *);\nextern int  ext3_sync_inode (handle_t *, struct inode *);\nextern void ext3_discard_reservation (struct inode *);\nextern void ext3_dirty_inode(struct inode *, int);\nextern int ext3_change_inode_journal_flag(struct inode *, int);\nextern int ext3_can_truncate(struct inode *inode);\nextern void ext3_truncate(struct inode *inode);\nextern void ext3_set_inode_flags(struct inode *);\nextern void ext3_get_inode_flags(struct ext3_inode_info *);\nextern void ext3_set_aops(struct inode *inode);\nextern int ext3_orphan_add(handle_t *, struct inode *);\nextern int ext3_orphan_del(handle_t *, struct inode *);\n\nstatic inline struct ext3_inode_info *EXT3_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ext3_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_init_block_alloc_info(struct inode *inode)\n{\n\tstruct ext3_inode_info *ei = EXT3_I(inode);\n\tstruct ext3_block_alloc_info *block_i;\n\tstruct super_block *sb = inode->i_sb;\n\n\tblock_i = kmalloc(sizeof(*block_i), GFP_NOFS);\n\tif (block_i) {\n\t\tstruct ext3_reserve_window_node *rsv = &block_i->rsv_window_node;\n\n\t\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\t\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\n\t\t/*\n\t\t * if filesystem is mounted with NORESERVATION, the goal\n\t\t * reservation window size is set to zero to indicate\n\t\t * block reservation is off\n\t\t */\n\t\tif (!test_opt(sb, RESERVATION))\n\t\t\trsv->rsv_goal_size = 0;\n\t\telse\n\t\t\trsv->rsv_goal_size = EXT3_DEFAULT_RESERVE_BLOCKS;\n\t\trsv->rsv_alloc_hit = 0;\n\t\tblock_i->last_alloc_logical_block = 0;\n\t\tblock_i->last_alloc_physical_block = 0;\n\t}\n\tei->i_block_alloc_info = block_i;\n}"
  },
  {
    "function_name": "rsv_is_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "392-396",
    "snippet": "static inline int rsv_is_empty(struct ext3_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic inline int rsv_is_empty(struct ext3_reserve_window *rsv)\n{\n\t/* a valid reservation end block could not be 0 */\n\treturn rsv->_rsv_end == EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n}"
  },
  {
    "function_name": "rsv_window_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "377-384",
    "snippet": "static void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext3_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT3_SB(sb)->s_rsv_window_root);\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&rsv->rsv_node",
            "&EXT3_SB(sb)->s_rsv_window_root"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic void rsv_window_remove(struct super_block *sb,\n\t\t\t      struct ext3_reserve_window_node *rsv)\n{\n\trsv->rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n\trsv->rsv_alloc_hit = 0;\n\trb_erase(&rsv->rsv_node, &EXT3_SB(sb)->s_rsv_window_root);\n}"
  },
  {
    "function_name": "ext3_rsv_window_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "337-366",
    "snippet": "void ext3_rsv_window_add(struct super_block *sb,\n\t\t    struct ext3_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT3_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text3_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext3_reserve_window_node *this;\n\n\ttrace_ext3_rsv_window_add(sb, rsv);\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "node",
            "root"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "node",
            "parent",
            "p"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsv_window_dump",
          "args": [
            "root",
            "1"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structext3_reserve_window_node",
            "rsv_node"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_rsv_window_add",
          "args": [
            "sb",
            "rsv"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nvoid ext3_rsv_window_add(struct super_block *sb,\n\t\t    struct ext3_reserve_window_node *rsv)\n{\n\tstruct rb_root *root = &EXT3_SB(sb)->s_rsv_window_root;\n\tstruct rb_node *node = &rsv->rsv_node;\n\text3_fsblk_t start = rsv->rsv_start;\n\n\tstruct rb_node ** p = &root->rb_node;\n\tstruct rb_node * parent = NULL;\n\tstruct ext3_reserve_window_node *this;\n\n\ttrace_ext3_rsv_window_add(sb, rsv);\n\twhile (*p)\n\t{\n\t\tparent = *p;\n\t\tthis = rb_entry(parent, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif (start < this->rsv_start)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (start > this->rsv_end)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\trsv_window_dump(root, 1);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(node, parent, p);\n\trb_insert_color(node, root);\n}"
  },
  {
    "function_name": "search_reserve_window",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "298-328",
    "snippet": "static struct ext3_reserve_window_node *\nsearch_reserve_window(struct rb_root *root, ext3_fsblk_t goal)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct ext3_reserve_window_node *rsv;\n\n\tif (!n)\n\t\treturn NULL;\n\n\tdo {\n\t\trsv = rb_entry(n, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif (goal < rsv->rsv_start)\n\t\t\tn = n->rb_left;\n\t\telse if (goal > rsv->rsv_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn rsv;\n\t} while (n);\n\t/*\n\t * We've fallen off the end of the tree: the goal wasn't inside\n\t * any particular node.  OK, the previous node must be to one\n\t * side of the interval containing the goal.  If it's the RHS,\n\t * we need to back up one.\n\t */\n\tif (rsv->rsv_start > goal) {\n\t\tn = rb_prev(&rsv->rsv_node);\n\t\trsv = rb_entry(n, struct ext3_reserve_window_node, rsv_node);\n\t}\n\treturn rsv;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structext3_reserve_window_node",
            "rsv_node"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_prev",
          "args": [
            "&rsv->rsv_node"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structext3_reserve_window_node",
            "rsv_node"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic struct ext3_reserve_window_node *\nsearch_reserve_window(struct rb_root *root, ext3_fsblk_t goal)\n{\n\tstruct rb_node *n = root->rb_node;\n\tstruct ext3_reserve_window_node *rsv;\n\n\tif (!n)\n\t\treturn NULL;\n\n\tdo {\n\t\trsv = rb_entry(n, struct ext3_reserve_window_node, rsv_node);\n\n\t\tif (goal < rsv->rsv_start)\n\t\t\tn = n->rb_left;\n\t\telse if (goal > rsv->rsv_end)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn rsv;\n\t} while (n);\n\t/*\n\t * We've fallen off the end of the tree: the goal wasn't inside\n\t * any particular node.  OK, the previous node must be to one\n\t * side of the interval containing the goal.  If it's the RHS,\n\t * we need to back up one.\n\t */\n\tif (rsv->rsv_start > goal) {\n\t\tn = rb_prev(&rsv->rsv_node);\n\t\trsv = rb_entry(n, struct ext3_reserve_window_node, rsv_node);\n\t}\n\treturn rsv;\n}"
  },
  {
    "function_name": "goal_in_my_reservation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "271-287",
    "snippet": "static int\ngoal_in_my_reservation(struct ext3_reserve_window *rsv, ext3_grpblk_t grp_goal,\n\t\t\tunsigned int group, struct super_block * sb)\n{\n\text3_fsblk_t group_first_block, group_last_block;\n\n\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\tif ((rsv->_rsv_start > group_last_block) ||\n\t    (rsv->_rsv_end < group_first_block))\n\t\treturn 0;\n\tif ((grp_goal >= 0) && ((grp_goal + group_first_block < rsv->_rsv_start)\n\t\t|| (grp_goal + group_first_block > rsv->_rsv_end)))\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_group_first_block_no",
          "args": [
            "sb",
            "group"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "972-977",
          "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int\ngoal_in_my_reservation(struct ext3_reserve_window *rsv, ext3_grpblk_t grp_goal,\n\t\t\tunsigned int group, struct super_block * sb)\n{\n\text3_fsblk_t group_first_block, group_last_block;\n\n\tgroup_first_block = ext3_group_first_block_no(sb, group);\n\tgroup_last_block = group_first_block + (EXT3_BLOCKS_PER_GROUP(sb) - 1);\n\n\tif ((rsv->_rsv_start > group_last_block) ||\n\t    (rsv->_rsv_end < group_first_block))\n\t\treturn 0;\n\tif ((grp_goal >= 0) && ((grp_goal + group_first_block < rsv->_rsv_start)\n\t\t|| (grp_goal + group_first_block > rsv->_rsv_end)))\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "__rsv_window_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "207-248",
    "snippet": "static void __rsv_window_dump(struct rb_root *root, int verbose,\n\t\t\t      const char *fn)\n{\n\tstruct rb_node *n;\n\tstruct ext3_reserve_window_node *rsv, *prev;\n\tint bad;\n\nrestart:\n\tn = rb_first(root);\n\tbad = 0;\n\tprev = NULL;\n\n\tprintk(\"Block Allocation Reservation Windows Map (%s):\\n\", fn);\n\twhile (n) {\n\t\trsv = rb_entry(n, struct ext3_reserve_window_node, rsv_node);\n\t\tif (verbose)\n\t\t\tprintk(\"reservation window 0x%p \"\n\t\t\t       \"start:  %lu, end:  %lu\\n\",\n\t\t\t       rsv, rsv->rsv_start, rsv->rsv_end);\n\t\tif (rsv->rsv_start && rsv->rsv_start >= rsv->rsv_end) {\n\t\t\tprintk(\"Bad reservation %p (start >= end)\\n\",\n\t\t\t       rsv);\n\t\t\tbad = 1;\n\t\t}\n\t\tif (prev && prev->rsv_end >= rsv->rsv_start) {\n\t\t\tprintk(\"Bad reservation %p (prev->end >= start)\\n\",\n\t\t\t       rsv);\n\t\t\tbad = 1;\n\t\t}\n\t\tif (bad) {\n\t\t\tif (!verbose) {\n\t\t\t\tprintk(\"Restarting reservation walk in verbose mode\\n\");\n\t\t\t\tverbose = 1;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tn = rb_next(n);\n\t\tprev = rsv;\n\t}\n\tprintk(\"Window map complete.\\n\");\n\tBUG_ON(bad);\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bad"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Window map complete.\\n\""
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structext3_reserve_window_node",
            "rsv_node"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "root"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic void __rsv_window_dump(struct rb_root *root, int verbose,\n\t\t\t      const char *fn)\n{\n\tstruct rb_node *n;\n\tstruct ext3_reserve_window_node *rsv, *prev;\n\tint bad;\n\nrestart:\n\tn = rb_first(root);\n\tbad = 0;\n\tprev = NULL;\n\n\tprintk(\"Block Allocation Reservation Windows Map (%s):\\n\", fn);\n\twhile (n) {\n\t\trsv = rb_entry(n, struct ext3_reserve_window_node, rsv_node);\n\t\tif (verbose)\n\t\t\tprintk(\"reservation window 0x%p \"\n\t\t\t       \"start:  %lu, end:  %lu\\n\",\n\t\t\t       rsv, rsv->rsv_start, rsv->rsv_end);\n\t\tif (rsv->rsv_start && rsv->rsv_start >= rsv->rsv_end) {\n\t\t\tprintk(\"Bad reservation %p (start >= end)\\n\",\n\t\t\t       rsv);\n\t\t\tbad = 1;\n\t\t}\n\t\tif (prev && prev->rsv_end >= rsv->rsv_start) {\n\t\t\tprintk(\"Bad reservation %p (prev->end >= start)\\n\",\n\t\t\t       rsv);\n\t\t\tbad = 1;\n\t\t}\n\t\tif (bad) {\n\t\t\tif (!verbose) {\n\t\t\t\tprintk(\"Restarting reservation walk in verbose mode\\n\");\n\t\t\t\tverbose = 1;\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tn = rb_next(n);\n\t\tprev = rsv;\n\t}\n\tprintk(\"Window map complete.\\n\");\n\tBUG_ON(bad);\n}"
  },
  {
    "function_name": "read_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "147-184",
    "snippet": "static struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext3_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text3_fsblk_t bitmap_blk;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\ttrace_ext3_read_block_bitmap(sb, block_group);\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\text3_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_valid_block_bitmap",
          "args": [
            "sb",
            "desc",
            "block_group",
            "bh"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_valid_block_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "93-135",
          "snippet": "static int ext3_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\tstruct ext3_group_desc *desc,\n\t\t\t\t\tunsigned int block_group,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\text3_grpblk_t offset;\n\text3_grpblk_t next_zero_bit;\n\text3_fsblk_t bitmap_blk;\n\text3_fsblk_t group_first_block;\n\n\tgroup_first_block = ext3_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext3_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext3_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode table block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_table);\n\toffset = bitmap_blk - group_first_block;\n\tnext_zero_bit = ext3_find_next_zero_bit(bh->b_data,\n\t\t\t\toffset + EXT3_SB(sb)->s_itb_per_group,\n\t\t\t\toffset);\n\tif (next_zero_bit >= offset + EXT3_SB(sb)->s_itb_per_group)\n\t\t/* good bitmap for inode tables */\n\t\treturn 1;\n\nerr_out:\n\text3_error(sb, __func__,\n\t\t\t\"Invalid block bitmap - \"\n\t\t\t\"block_group = %d, block = %lu\",\n\t\t\tblock_group, bitmap_blk);\n\treturn 0;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int ext3_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\tstruct ext3_group_desc *desc,\n\t\t\t\t\tunsigned int block_group,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\text3_grpblk_t offset;\n\text3_grpblk_t next_zero_bit;\n\text3_fsblk_t bitmap_blk;\n\text3_fsblk_t group_first_block;\n\n\tgroup_first_block = ext3_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext3_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext3_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode table block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_table);\n\toffset = bitmap_blk - group_first_block;\n\tnext_zero_bit = ext3_find_next_zero_bit(bh->b_data,\n\t\t\t\toffset + EXT3_SB(sb)->s_itb_per_group,\n\t\t\t\toffset);\n\tif (next_zero_bit >= offset + EXT3_SB(sb)->s_itb_per_group)\n\t\t/* good bitmap for inode tables */\n\t\treturn 1;\n\nerr_out:\n\text3_error(sb, __func__,\n\t\t\t\"Invalid block bitmap - \"\n\t\t\t\"block_group = %d, block = %lu\",\n\t\t\tblock_group, bitmap_blk);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "__func__",
            "\"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\"",
            "block_group",
            "le32_to_cpu(desc->bg_block_bitmap)"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "desc->bg_block_bitmap"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "bh_submit_read",
          "args": [
            "bh"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "bh_uptodate_or_lock(bh)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_uptodate_or_lock",
          "args": [
            "bh"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!bh"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "bitmap_blk"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ext3_read_block_bitmap",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_get_group_desc",
          "args": [
            "sb",
            "block_group",
            "NULL"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_get_group_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
          "lines": "58-91",
          "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
          "includes": [
            "#include \"ext3.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic struct buffer_head *\nread_block_bitmap(struct super_block *sb, unsigned int block_group)\n{\n\tstruct ext3_group_desc * desc;\n\tstruct buffer_head * bh = NULL;\n\text3_fsblk_t bitmap_blk;\n\n\tdesc = ext3_get_group_desc(sb, block_group, NULL);\n\tif (!desc)\n\t\treturn NULL;\n\ttrace_ext3_read_block_bitmap(sb, block_group);\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\tbh = sb_getblk(sb, bitmap_blk);\n\tif (unlikely(!bh)) {\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\tif (likely(bh_uptodate_or_lock(bh)))\n\t\treturn bh;\n\n\tif (bh_submit_read(bh) < 0) {\n\t\tbrelse(bh);\n\t\text3_error(sb, __func__,\n\t\t\t    \"Cannot read block bitmap - \"\n\t\t\t    \"block_group = %d, block_bitmap = %u\",\n\t\t\t    block_group, le32_to_cpu(desc->bg_block_bitmap));\n\t\treturn NULL;\n\t}\n\text3_valid_block_bitmap(sb, desc, block_group, bh);\n\t/*\n\t * file system mounted not to panic on error, continue with corrupt\n\t * bitmap\n\t */\n\treturn bh;\n}"
  },
  {
    "function_name": "ext3_valid_block_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "93-135",
    "snippet": "static int ext3_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\tstruct ext3_group_desc *desc,\n\t\t\t\t\tunsigned int block_group,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\text3_grpblk_t offset;\n\text3_grpblk_t next_zero_bit;\n\text3_fsblk_t bitmap_blk;\n\text3_fsblk_t group_first_block;\n\n\tgroup_first_block = ext3_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext3_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext3_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode table block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_table);\n\toffset = bitmap_blk - group_first_block;\n\tnext_zero_bit = ext3_find_next_zero_bit(bh->b_data,\n\t\t\t\toffset + EXT3_SB(sb)->s_itb_per_group,\n\t\t\t\toffset);\n\tif (next_zero_bit >= offset + EXT3_SB(sb)->s_itb_per_group)\n\t\t/* good bitmap for inode tables */\n\t\treturn 1;\n\nerr_out:\n\text3_error(sb, __func__,\n\t\t\t\"Invalid block bitmap - \"\n\t\t\t\"block_group = %d, block = %lu\",\n\t\t\tblock_group, bitmap_blk);\n\treturn 0;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "__func__",
            "\"Invalid block bitmap - \"\n\t\t\t\"block_group = %d, block = %lu\"",
            "block_group",
            "bitmap_blk"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_find_next_zero_bit",
          "args": [
            "bh->b_data",
            "offset + EXT3_SB(sb)->s_itb_per_group",
            "offset"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "desc->bg_inode_table"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ext3_test_bit",
          "args": [
            "offset",
            "bh->b_data"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_test_bit",
          "args": [
            "offset",
            "bh->b_data"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ext3_group_first_block_no",
          "args": [
            "sb",
            "block_group"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_group_first_block_no",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "972-977",
          "snippet": "static inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline ext3_fsblk_t\next3_group_first_block_no(struct super_block *sb, unsigned long group_no)\n{\n\treturn group_no * (ext3_fsblk_t)EXT3_BLOCKS_PER_GROUP(sb) +\n\t\tle32_to_cpu(EXT3_SB(sb)->s_es->s_first_data_block);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic int ext3_valid_block_bitmap(struct super_block *sb,\n\t\t\t\t\tstruct ext3_group_desc *desc,\n\t\t\t\t\tunsigned int block_group,\n\t\t\t\t\tstruct buffer_head *bh)\n{\n\text3_grpblk_t offset;\n\text3_grpblk_t next_zero_bit;\n\text3_fsblk_t bitmap_blk;\n\text3_fsblk_t group_first_block;\n\n\tgroup_first_block = ext3_group_first_block_no(sb, block_group);\n\n\t/* check whether block bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_block_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext3_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode bitmap block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_bitmap);\n\toffset = bitmap_blk - group_first_block;\n\tif (!ext3_test_bit(offset, bh->b_data))\n\t\t/* bad block bitmap */\n\t\tgoto err_out;\n\n\t/* check whether the inode table block number is set */\n\tbitmap_blk = le32_to_cpu(desc->bg_inode_table);\n\toffset = bitmap_blk - group_first_block;\n\tnext_zero_bit = ext3_find_next_zero_bit(bh->b_data,\n\t\t\t\toffset + EXT3_SB(sb)->s_itb_per_group,\n\t\t\t\toffset);\n\tif (next_zero_bit >= offset + EXT3_SB(sb)->s_itb_per_group)\n\t\t/* good bitmap for inode tables */\n\t\treturn 1;\n\nerr_out:\n\text3_error(sb, __func__,\n\t\t\t\"Invalid block bitmap - \"\n\t\t\t\"block_group = %d, block = %lu\",\n\t\t\tblock_group, bitmap_blk);\n\treturn 0;\n}"
  },
  {
    "function_name": "ext3_get_group_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "58-91",
    "snippet": "struct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ext3_error",
          "args": [
            "sb",
            "\"ext3_get_group_desc\"",
            "\"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\"",
            "block_group",
            "group_desc",
            "offset"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "ext3_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/super.c",
          "lines": "191-208",
          "snippet": "void ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}",
          "includes": [
            "#include \"namei.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"ext3.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/namei.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mount.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ext3_unfreeze(struct super_block *sb);",
            "static int ext3_freeze(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"namei.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"ext3.h\"\n#include <asm/uaccess.h>\n#include <linux/namei.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/seq_file.h>\n#include <linux/quotaops.h>\n#include <linux/mount.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/exportfs.h>\n#include <linux/parser.h>\n#include <linux/blkdev.h>\n#include <linux/module.h>\n\nstatic int ext3_unfreeze(struct super_block *sb);\nstatic int ext3_freeze(struct super_block *sb);\n\nvoid ext3_error(struct super_block *sb, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(KERN_CRIT \"EXT3-fs error (device %s): %s: %pV\\n\",\n\t       sb->s_id, function, &vaf);\n\n\tva_end(args);\n\n\text3_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_DESC_PER_BLOCK",
          "args": [
            "sb"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_DESC_PER_BLOCK_BITS",
          "args": [
            "sb"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstruct ext3_group_desc * ext3_get_group_desc(struct super_block * sb,\n\t\t\t\t\t     unsigned int block_group,\n\t\t\t\t\t     struct buffer_head ** bh)\n{\n\tunsigned long group_desc;\n\tunsigned long offset;\n\tstruct ext3_group_desc * desc;\n\tstruct ext3_sb_info *sbi = EXT3_SB(sb);\n\n\tif (block_group >= sbi->s_groups_count) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"block_group >= groups_count - \"\n\t\t\t    \"block_group = %d, groups_count = %lu\",\n\t\t\t    block_group, sbi->s_groups_count);\n\n\t\treturn NULL;\n\t}\n\tsmp_rmb();\n\n\tgroup_desc = block_group >> EXT3_DESC_PER_BLOCK_BITS(sb);\n\toffset = block_group & (EXT3_DESC_PER_BLOCK(sb) - 1);\n\tif (!sbi->s_group_desc[group_desc]) {\n\t\text3_error (sb, \"ext3_get_group_desc\",\n\t\t\t    \"Group descriptor not loaded - \"\n\t\t\t    \"block_group = %d, group_desc = %lu, desc = %lu\",\n\t\t\t     block_group, group_desc, offset);\n\t\treturn NULL;\n\t}\n\n\tdesc = (struct ext3_group_desc *) sbi->s_group_desc[group_desc]->b_data;\n\tif (bh)\n\t\t*bh = sbi->s_group_desc[group_desc];\n\treturn desc + offset;\n}"
  },
  {
    "function_name": "ext3_get_group_no_and_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/balloc.c",
    "lines": "39-49",
    "snippet": "static void ext3_get_group_no_and_offset(struct super_block *sb,\n\text3_fsblk_t blocknr, unsigned long *blockgrpp, ext3_grpblk_t *offsetp)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\tif (offsetp)\n\t\t*offsetp = blocknr % EXT3_BLOCKS_PER_GROUP(sb);\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr / EXT3_BLOCKS_PER_GROUP(sb);\n}",
    "includes": [
      "#include \"ext3.h\"",
      "#include <linux/blkdev.h>",
      "#include <linux/quotaops.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXT3_BLOCKS_PER_GROUP",
          "args": [
            "sb"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "es->s_first_data_block"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXT3_SB",
          "args": [
            "sb"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "EXT3_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ext3/ext3.h",
          "lines": "689-692",
          "snippet": "static inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <trace/events/ext3.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/bug.h>",
            "#include <linux/magic.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);",
            "extern void ext3_check_blocks_bitmap (struct super_block *);",
            "extern struct inode * ext3_orphan_get (struct super_block *, unsigned long);",
            "extern unsigned long ext3_count_free_inodes (struct super_block *);",
            "extern unsigned long ext3_count_dirs (struct super_block *);",
            "extern void ext3_check_inodes_bitmap (struct super_block *);",
            "extern struct inode *ext3_iget(struct super_block *, unsigned long);",
            "int ext3_force_commit(struct super_block *sb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/ext3.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/bug.h>\n#include <linux/magic.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n\nextern ext3_fsblk_t ext3_count_free_blocks (struct super_block *);\nextern void ext3_check_blocks_bitmap (struct super_block *);\nextern struct inode * ext3_orphan_get (struct super_block *, unsigned long);\nextern unsigned long ext3_count_free_inodes (struct super_block *);\nextern unsigned long ext3_count_dirs (struct super_block *);\nextern void ext3_check_inodes_bitmap (struct super_block *);\nextern struct inode *ext3_iget(struct super_block *, unsigned long);\nint ext3_force_commit(struct super_block *sb);\n\nstatic inline struct ext3_sb_info * EXT3_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ext3.h\"\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n\nstatic void ext3_get_group_no_and_offset(struct super_block *sb,\n\text3_fsblk_t blocknr, unsigned long *blockgrpp, ext3_grpblk_t *offsetp)\n{\n\tstruct ext3_super_block *es = EXT3_SB(sb)->s_es;\n\n\tblocknr = blocknr - le32_to_cpu(es->s_first_data_block);\n\tif (offsetp)\n\t\t*offsetp = blocknr % EXT3_BLOCKS_PER_GROUP(sb);\n\tif (blockgrpp)\n\t\t*blockgrpp = blocknr / EXT3_BLOCKS_PER_GROUP(sb);\n}"
  }
]