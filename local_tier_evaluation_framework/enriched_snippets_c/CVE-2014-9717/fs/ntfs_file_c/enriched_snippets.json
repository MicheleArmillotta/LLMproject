[
  {
    "function_name": "ntfs_file_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "2163-2195",
    "snippet": "static int ntfs_file_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t   int datasync)\n{\n\tstruct inode *vi = filp->f_mapping->host;\n\tint err, ret = 0;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", vi->i_ino);\n\n\terr = filemap_write_and_wait_range(vi->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&vi->i_mutex);\n\n\tBUG_ON(S_ISDIR(vi->i_mode));\n\tif (!datasync || !NInoNonResident(NTFS_I(vi)))\n\t\tret = __ntfs_write_inode(vi, 1);\n\twrite_inode_now(vi, !datasync);\n\t/*\n\t * NOTE: If we were to use mapping->private_list (see ext2 and\n\t * fs/buffer.c) for dirty blocks then we could optimize the below to be\n\t * sync_mapping_buffers(vi->i_mapping).\n\t */\n\terr = sync_blockdev(vi->i_sb->s_bdev);\n\tif (unlikely(err && !ret))\n\t\tret = err;\n\tif (likely(!ret))\n\t\tntfs_debug(\"Done.\");\n\telse\n\t\tntfs_warning(vi->i_sb, \"Failed to f%ssync inode 0x%lx.  Error \"\n\t\t\t\t\"%u.\", datasync ? \"data\" : \"\", vi->i_ino, -ret);\n\tmutex_unlock(&vi->i_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vi->i_mutex"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vi->i_sb",
            "\"Failed to f%ssync inode 0x%lx.  Error \"\n\t\t\t\t\"%u.\"",
            "datasync ? \"data\" : \"\"",
            "vi->i_ino",
            "-ret"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "43-65",
          "snippet": "void __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_warning(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_warn(\"(device %s): %s(): %pV\\n\",\n\t\t\tsb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_warn(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err && !ret"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "vi->i_sb->s_bdev"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_inode_now",
          "args": [
            "vi",
            "!datasync"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "write_inode_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1469-1484",
          "snippet": "int write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nint write_inode_now(struct inode *inode, int sync)\n{\n\tstruct bdi_writeback *wb = &inode_to_bdi(inode)->wb;\n\tstruct writeback_control wbc = {\n\t\t.nr_to_write = LONG_MAX,\n\t\t.sync_mode = sync ? WB_SYNC_ALL : WB_SYNC_NONE,\n\t\t.range_start = 0,\n\t\t.range_end = LLONG_MAX,\n\t};\n\n\tif (!mapping_cap_writeback_dirty(inode->i_mapping))\n\t\twbc.nr_to_write = 0;\n\n\tmight_sleep();\n\treturn writeback_single_inode(inode, wb, &wbc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ntfs_write_inode",
          "args": [
            "vi",
            "1"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2967-3110",
          "snippet": "int __ntfs_write_inode(struct inode *vi, int sync)\n{\n\tsle64 nt;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tSTANDARD_INFORMATION *si;\n\tint err = 0;\n\tbool modified = false;\n\n\tntfs_debug(\"Entering for %sinode 0x%lx.\", NInoAttr(ni) ? \"attr \" : \"\",\n\t\t\tvi->i_ino);\n\t/*\n\t * Dirty attribute inodes are written via their real inodes so just\n\t * clean them here.  Access time updates are taken care off when the\n\t * real inode is written.\n\t */\n\tif (NInoAttr(ni)) {\n\t\tNInoClearDirty(ni);\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/* Map, pin, and lock the mft record belonging to the inode. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\t/* Update the access times in the standard information attribute. */\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tgoto unm_err_out;\n\t}\n\tsi = (STANDARD_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\t/* Update the access times if they have changed. */\n\tnt = utc2ntfs(vi->i_mtime);\n\tif (si->last_data_change_time != nt) {\n\t\tntfs_debug(\"Updating mtime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_data_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_data_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_ctime);\n\tif (si->last_mft_change_time != nt) {\n\t\tntfs_debug(\"Updating ctime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_mft_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_mft_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_atime);\n\tif (si->last_access_time != nt) {\n\t\tntfs_debug(\"Updating atime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino,\n\t\t\t\t(long long)sle64_to_cpu(si->last_access_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_access_time = nt;\n\t\tmodified = true;\n\t}\n\t/*\n\t * If we just modified the standard information attribute we need to\n\t * mark the mft record it is in dirty.  We do this manually so that\n\t * mark_inode_dirty() is not called which would redirty the inode and\n\t * hence result in an infinite loop of trying to write the inode.\n\t * There is no need to mark the base inode nor the base mft record\n\t * dirty, since we are going to write this mft record below in any case\n\t * and the base mft record may actually not have been modified so it\n\t * might not need to be written out.\n\t * NOTE: It is not a problem when the inode for $MFT itself is being\n\t * written out as mark_ntfs_record_dirty() will only set I_DIRTY_PAGES\n\t * on the $MFT inode and hence ntfs_write_inode() will not be\n\t * re-invoked because of it which in turn is ok since the dirtied mft\n\t * record will be cleaned and written out to disk below, i.e. before\n\t * this function returns.\n\t */\n\tif (modified) {\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tif (!NInoTestSetDirty(ctx->ntfs_ino))\n\t\t\tmark_ntfs_record_dirty(ctx->ntfs_ino->page,\n\t\t\t\t\tctx->ntfs_ino->page_ofs);\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\t/* Now the access times are updated, write the base mft record. */\n\tif (NInoDirty(ni))\n\t\terr = write_mft_record(ni, m, sync);\n\t/* Write all attached extent mft records. */\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents > 0) {\n\t\tntfs_inode **extent_nis = ni->ext.extent_ntfs_inos;\n\t\tint i;\n\n\t\tntfs_debug(\"Writing %i extent inodes.\", ni->nr_extents);\n\t\tfor (i = 0; i < ni->nr_extents; i++) {\n\t\t\tntfs_inode *tni = extent_nis[i];\n\n\t\t\tif (NInoDirty(tni)) {\n\t\t\t\tMFT_RECORD *tm = map_mft_record(tni);\n\t\t\t\tint ret;\n\n\t\t\t\tif (IS_ERR(tm)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = PTR_ERR(tm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret = write_mft_record(tni, tm, sync);\n\t\t\t\tunmap_mft_record(tni);\n\t\t\t\tif (unlikely(ret)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ni->extent_lock);\n\tunmap_mft_record(ni);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\tntfs_debug(\"Done.\");\n\treturn 0;\nunm_err_out:\n\tunmap_mft_record(ni);\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Not enough memory to write inode.  \"\n\t\t\t\t\"Marking the inode dirty again, so the VFS \"\n\t\t\t\t\"retries later.\");\n\t\tmark_inode_dirty(vi);\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Failed (error %i):  Run chkdsk.\", -err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nint __ntfs_write_inode(struct inode *vi, int sync)\n{\n\tsle64 nt;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tSTANDARD_INFORMATION *si;\n\tint err = 0;\n\tbool modified = false;\n\n\tntfs_debug(\"Entering for %sinode 0x%lx.\", NInoAttr(ni) ? \"attr \" : \"\",\n\t\t\tvi->i_ino);\n\t/*\n\t * Dirty attribute inodes are written via their real inodes so just\n\t * clean them here.  Access time updates are taken care off when the\n\t * real inode is written.\n\t */\n\tif (NInoAttr(ni)) {\n\t\tNInoClearDirty(ni);\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/* Map, pin, and lock the mft record belonging to the inode. */\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\t/* Update the access times in the standard information attribute. */\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tgoto unm_err_out;\n\t}\n\tsi = (STANDARD_INFORMATION*)((u8*)ctx->attr +\n\t\t\tle16_to_cpu(ctx->attr->data.resident.value_offset));\n\t/* Update the access times if they have changed. */\n\tnt = utc2ntfs(vi->i_mtime);\n\tif (si->last_data_change_time != nt) {\n\t\tntfs_debug(\"Updating mtime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_data_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_data_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_ctime);\n\tif (si->last_mft_change_time != nt) {\n\t\tntfs_debug(\"Updating ctime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino, (long long)\n\t\t\t\tsle64_to_cpu(si->last_mft_change_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_mft_change_time = nt;\n\t\tmodified = true;\n\t}\n\tnt = utc2ntfs(vi->i_atime);\n\tif (si->last_access_time != nt) {\n\t\tntfs_debug(\"Updating atime for inode 0x%lx: old = 0x%llx, \"\n\t\t\t\t\"new = 0x%llx\", vi->i_ino,\n\t\t\t\t(long long)sle64_to_cpu(si->last_access_time),\n\t\t\t\t(long long)sle64_to_cpu(nt));\n\t\tsi->last_access_time = nt;\n\t\tmodified = true;\n\t}\n\t/*\n\t * If we just modified the standard information attribute we need to\n\t * mark the mft record it is in dirty.  We do this manually so that\n\t * mark_inode_dirty() is not called which would redirty the inode and\n\t * hence result in an infinite loop of trying to write the inode.\n\t * There is no need to mark the base inode nor the base mft record\n\t * dirty, since we are going to write this mft record below in any case\n\t * and the base mft record may actually not have been modified so it\n\t * might not need to be written out.\n\t * NOTE: It is not a problem when the inode for $MFT itself is being\n\t * written out as mark_ntfs_record_dirty() will only set I_DIRTY_PAGES\n\t * on the $MFT inode and hence ntfs_write_inode() will not be\n\t * re-invoked because of it which in turn is ok since the dirtied mft\n\t * record will be cleaned and written out to disk below, i.e. before\n\t * this function returns.\n\t */\n\tif (modified) {\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tif (!NInoTestSetDirty(ctx->ntfs_ino))\n\t\t\tmark_ntfs_record_dirty(ctx->ntfs_ino->page,\n\t\t\t\t\tctx->ntfs_ino->page_ofs);\n\t}\n\tntfs_attr_put_search_ctx(ctx);\n\t/* Now the access times are updated, write the base mft record. */\n\tif (NInoDirty(ni))\n\t\terr = write_mft_record(ni, m, sync);\n\t/* Write all attached extent mft records. */\n\tmutex_lock(&ni->extent_lock);\n\tif (ni->nr_extents > 0) {\n\t\tntfs_inode **extent_nis = ni->ext.extent_ntfs_inos;\n\t\tint i;\n\n\t\tntfs_debug(\"Writing %i extent inodes.\", ni->nr_extents);\n\t\tfor (i = 0; i < ni->nr_extents; i++) {\n\t\t\tntfs_inode *tni = extent_nis[i];\n\n\t\t\tif (NInoDirty(tni)) {\n\t\t\t\tMFT_RECORD *tm = map_mft_record(tni);\n\t\t\t\tint ret;\n\n\t\t\t\tif (IS_ERR(tm)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = PTR_ERR(tm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tret = write_mft_record(tni, tm, sync);\n\t\t\t\tunmap_mft_record(tni);\n\t\t\t\tif (unlikely(ret)) {\n\t\t\t\t\tif (!err || err == -ENOMEM)\n\t\t\t\t\t\terr = ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ni->extent_lock);\n\tunmap_mft_record(ni);\n\tif (unlikely(err))\n\t\tgoto err_out;\n\tntfs_debug(\"Done.\");\n\treturn 0;\nunm_err_out:\n\tunmap_mft_record(ni);\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Not enough memory to write inode.  \"\n\t\t\t\t\"Marking the inode dirty again, so the VFS \"\n\t\t\t\t\"retries later.\");\n\t\tmark_inode_dirty(vi);\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Failed (error %i):  Run chkdsk.\", -err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "NTFS_I(vi)"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "S_ISDIR(vi->i_mode)"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "vi->i_mode"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vi->i_mutex"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "vi->i_mapping",
            "start",
            "end"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx.\"",
            "vi->i_ino"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic int ntfs_file_fsync(struct file *filp, loff_t start, loff_t end,\n\t\t\t   int datasync)\n{\n\tstruct inode *vi = filp->f_mapping->host;\n\tint err, ret = 0;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", vi->i_ino);\n\n\terr = filemap_write_and_wait_range(vi->i_mapping, start, end);\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&vi->i_mutex);\n\n\tBUG_ON(S_ISDIR(vi->i_mode));\n\tif (!datasync || !NInoNonResident(NTFS_I(vi)))\n\t\tret = __ntfs_write_inode(vi, 1);\n\twrite_inode_now(vi, !datasync);\n\t/*\n\t * NOTE: If we were to use mapping->private_list (see ext2 and\n\t * fs/buffer.c) for dirty blocks then we could optimize the below to be\n\t * sync_mapping_buffers(vi->i_mapping).\n\t */\n\terr = sync_blockdev(vi->i_sb->s_bdev);\n\tif (unlikely(err && !ret))\n\t\tret = err;\n\tif (likely(!ret))\n\t\tntfs_debug(\"Done.\");\n\telse\n\t\tntfs_warning(vi->i_sb, \"Failed to f%ssync inode 0x%lx.  Error \"\n\t\t\t\t\"%u.\", datasync ? \"data\" : \"\", vi->i_ino, -ret);\n\tmutex_unlock(&vi->i_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "ntfs_file_aio_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "2118-2137",
    "snippet": "static ssize_t ntfs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,\n\t\tunsigned long nr_segs, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tssize_t ret;\n\n\tBUG_ON(iocb->ki_pos != pos);\n\n\tmutex_lock(&inode->i_mutex);\n\tret = ntfs_file_aio_write_nolock(iocb, iov, nr_segs, &iocb->ki_pos);\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret > 0) {\n\t\tint err = generic_write_sync(file, iocb->ki_pos - ret, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_write_sync",
          "args": [
            "file",
            "iocb->ki_pos - ret",
            "ret"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_file_aio_write_nolock",
          "args": [
            "iocb",
            "iov",
            "nr_segs",
            "&iocb->ki_pos"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_file_aio_write_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "2082-2113",
          "snippet": "static ssize_t ntfs_file_aio_write_nolock(struct kiocb *iocb,\n\t\tconst struct iovec *iov, unsigned long nr_segs, loff_t *ppos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tloff_t pos;\n\tsize_t count;\t\t/* after file limit checks */\n\tssize_t written, err;\n\n\tcount = iov_length(iov, nr_segs);\n\tpos = *ppos;\n\t/* We can write back this queue in page reclaim. */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\twritten = 0;\n\terr = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));\n\tif (err)\n\t\tgoto out;\n\tif (!count)\n\t\tgoto out;\n\terr = file_remove_suid(file);\n\tif (err)\n\t\tgoto out;\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\twritten = ntfs_file_buffered_write(iocb, iov, nr_segs, pos, ppos,\n\t\t\tcount);\nout:\n\tcurrent->backing_dev_info = NULL;\n\treturn written ? written : err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic ssize_t ntfs_file_aio_write_nolock(struct kiocb *iocb,\n\t\tconst struct iovec *iov, unsigned long nr_segs, loff_t *ppos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tloff_t pos;\n\tsize_t count;\t\t/* after file limit checks */\n\tssize_t written, err;\n\n\tcount = iov_length(iov, nr_segs);\n\tpos = *ppos;\n\t/* We can write back this queue in page reclaim. */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\twritten = 0;\n\terr = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));\n\tif (err)\n\t\tgoto out;\n\tif (!count)\n\t\tgoto out;\n\terr = file_remove_suid(file);\n\tif (err)\n\t\tgoto out;\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\twritten = ntfs_file_buffered_write(iocb, iov, nr_segs, pos, ppos,\n\t\t\tcount);\nout:\n\tcurrent->backing_dev_info = NULL;\n\treturn written ? written : err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "iocb->ki_pos != pos"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic ssize_t ntfs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,\n\t\tunsigned long nr_segs, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tssize_t ret;\n\n\tBUG_ON(iocb->ki_pos != pos);\n\n\tmutex_lock(&inode->i_mutex);\n\tret = ntfs_file_aio_write_nolock(iocb, iov, nr_segs, &iocb->ki_pos);\n\tmutex_unlock(&inode->i_mutex);\n\tif (ret > 0) {\n\t\tint err = generic_write_sync(file, iocb->ki_pos - ret, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ntfs_file_aio_write_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "2082-2113",
    "snippet": "static ssize_t ntfs_file_aio_write_nolock(struct kiocb *iocb,\n\t\tconst struct iovec *iov, unsigned long nr_segs, loff_t *ppos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tloff_t pos;\n\tsize_t count;\t\t/* after file limit checks */\n\tssize_t written, err;\n\n\tcount = iov_length(iov, nr_segs);\n\tpos = *ppos;\n\t/* We can write back this queue in page reclaim. */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\twritten = 0;\n\terr = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));\n\tif (err)\n\t\tgoto out;\n\tif (!count)\n\t\tgoto out;\n\terr = file_remove_suid(file);\n\tif (err)\n\t\tgoto out;\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\twritten = ntfs_file_buffered_write(iocb, iov, nr_segs, pos, ppos,\n\t\t\tcount);\nout:\n\tcurrent->backing_dev_info = NULL;\n\treturn written ? written : err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_file_buffered_write",
          "args": [
            "iocb",
            "iov",
            "nr_segs",
            "pos",
            "ppos",
            "count"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_file_buffered_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "1780-2077",
          "snippet": "static ssize_t ntfs_file_buffered_write(struct kiocb *iocb,\n\t\tconst struct iovec *iov, unsigned long nr_segs,\n\t\tloff_t pos, loff_t *ppos, size_t count)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *vi = mapping->host;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tstruct page *pages[NTFS_MAX_PAGES_PER_CLUSTER];\n\tstruct page *cached_page = NULL;\n\tchar __user *buf = NULL;\n\ts64 end, ll;\n\tVCN last_vcn;\n\tLCN lcn;\n\tunsigned long flags;\n\tsize_t bytes, iov_ofs = 0;\t/* Offset in the current iovec. */\n\tssize_t status, written;\n\tunsigned nr_pages;\n\tint err;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"pos 0x%llx, count 0x%lx.\",\n\t\t\tvi->i_ino, (unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)pos, (unsigned long)count);\n\tif (unlikely(!count))\n\t\treturn 0;\n\tBUG_ON(NInoMstProtected(ni));\n\t/*\n\t * If the attribute is not an index root and it is encrypted or\n\t * compressed, we cannot write to it yet.  Note we need to check for\n\t * AT_INDEX_ALLOCATION since this is the type of both directory and\n\t * index inodes.\n\t */\n\tif (ni->type != AT_INDEX_ALLOCATION) {\n\t\t/* If file is encrypted, deny access, just like NT4. */\n\t\tif (NInoEncrypted(ni)) {\n\t\t\t/*\n\t\t\t * Reminder for later: Encrypted files are _always_\n\t\t\t * non-resident so that the content can always be\n\t\t\t * encrypted.\n\t\t\t */\n\t\t\tntfs_debug(\"Denying write access to encrypted file.\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (NInoCompressed(ni)) {\n\t\t\t/* Only unnamed $DATA attribute can be compressed. */\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tBUG_ON(ni->name_len);\n\t\t\t/*\n\t\t\t * Reminder for later: If resident, the data is not\n\t\t\t * actually compressed.  Only on the switch to non-\n\t\t\t * resident does compression kick in.  This is in\n\t\t\t * contrast to encrypted files (see above).\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"Writing to compressed files is \"\n\t\t\t\t\t\"not implemented yet.  Sorry.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\t/*\n\t * If a previous ntfs_truncate() failed, repeat it and abort if it\n\t * fails again.\n\t */\n\tif (unlikely(NInoTruncateFailed(ni))) {\n\t\tinode_dio_wait(vi);\n\t\terr = ntfs_truncate(vi);\n\t\tif (err || NInoTruncateFailed(ni)) {\n\t\t\tif (!err)\n\t\t\t\terr = -EIO;\n\t\t\tntfs_error(vol->sb, \"Cannot perform write to inode \"\n\t\t\t\t\t\"0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\t\"ntfs_truncate() failed (error code \"\n\t\t\t\t\t\"%i).\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\treturn err;\n\t\t}\n\t}\n\t/* The first byte after the write. */\n\tend = pos + count;\n\t/*\n\t * If the write goes beyond the allocated size, extend the allocation\n\t * to cover the whole of the write, rounded up to the nearest cluster.\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tll = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (end > ll) {\n\t\t/* Extend the allocation without changing the data size. */\n\t\tll = ntfs_attr_extend_allocation(ni, end, -1, pos);\n\t\tif (likely(ll >= 0)) {\n\t\t\tBUG_ON(pos >= ll);\n\t\t\t/* If the extension was partial truncate the write. */\n\t\t\tif (end > ll) {\n\t\t\t\tntfs_debug(\"Truncating write to inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x, because \"\n\t\t\t\t\t\t\"the allocation was only \"\n\t\t\t\t\t\t\"partially extended.\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\tend = ll;\n\t\t\t\tcount = ll - pos;\n\t\t\t}\n\t\t} else {\n\t\t\terr = ll;\n\t\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\t\tll = ni->allocated_size;\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\t/* Perform a partial write if possible or fail. */\n\t\t\tif (pos < ll) {\n\t\t\t\tntfs_debug(\"Truncating write to inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x, because \"\n\t\t\t\t\t\t\"extending the allocation \"\n\t\t\t\t\t\t\"failed (error code %i).\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type), err);\n\t\t\t\tend = ll;\n\t\t\t\tcount = ll - pos;\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Cannot perform write to \"\n\t\t\t\t\t\t\"inode 0x%lx, attribute type \"\n\t\t\t\t\t\t\"0x%x, because extending the \"\n\t\t\t\t\t\t\"allocation failed (error \"\n\t\t\t\t\t\t\"code %i).\", vi->i_ino,\n\t\t\t\t\t\t(unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type), err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\twritten = 0;\n\t/*\n\t * If the write starts beyond the initialized size, extend it up to the\n\t * beginning of the write and initialize all non-sparse space between\n\t * the old initialized size and the new one.  This automatically also\n\t * increments the vfs inode->i_size to keep it above or equal to the\n\t * initialized_size.\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tll = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (pos > ll) {\n\t\terr = ntfs_attr_extend_initialized(ni, pos);\n\t\tif (err < 0) {\n\t\t\tntfs_error(vol->sb, \"Cannot perform write to inode \"\n\t\t\t\t\t\"0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\t\"extending the initialized size \"\n\t\t\t\t\t\"failed (error code %i).\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\tstatus = err;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\t/*\n\t * Determine the number of pages per cluster for non-resident\n\t * attributes.\n\t */\n\tnr_pages = 1;\n\tif (vol->cluster_size > PAGE_CACHE_SIZE && NInoNonResident(ni))\n\t\tnr_pages = vol->cluster_size >> PAGE_CACHE_SHIFT;\n\t/* Finally, perform the actual write. */\n\tlast_vcn = -1;\n\tif (likely(nr_segs == 1))\n\t\tbuf = iov->iov_base;\n\tdo {\n\t\tVCN vcn;\n\t\tpgoff_t idx, start_idx;\n\t\tunsigned ofs, do_pages, u;\n\t\tsize_t copied;\n\n\t\tstart_idx = idx = pos >> PAGE_CACHE_SHIFT;\n\t\tofs = pos & ~PAGE_CACHE_MASK;\n\t\tbytes = PAGE_CACHE_SIZE - ofs;\n\t\tdo_pages = 1;\n\t\tif (nr_pages > 1) {\n\t\t\tvcn = pos >> vol->cluster_size_bits;\n\t\t\tif (vcn != last_vcn) {\n\t\t\t\tlast_vcn = vcn;\n\t\t\t\t/*\n\t\t\t\t * Get the lcn of the vcn the write is in.  If\n\t\t\t\t * it is a hole, need to lock down all pages in\n\t\t\t\t * the cluster.\n\t\t\t\t */\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\tlcn = ntfs_attr_vcn_to_lcn_nolock(ni, pos >>\n\t\t\t\t\t\tvol->cluster_size_bits, false);\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\tif (unlikely(lcn < LCN_HOLE)) {\n\t\t\t\t\tstatus = -EIO;\n\t\t\t\t\tif (lcn == LCN_ENOMEM)\n\t\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\telse\n\t\t\t\t\t\tntfs_error(vol->sb, \"Cannot \"\n\t\t\t\t\t\t\t\"perform write to \"\n\t\t\t\t\t\t\t\"inode 0x%lx, \"\n\t\t\t\t\t\t\t\"attribute type 0x%x, \"\n\t\t\t\t\t\t\t\"because the attribute \"\n\t\t\t\t\t\t\t\"is corrupt.\",\n\t\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (lcn == LCN_HOLE) {\n\t\t\t\t\tstart_idx = (pos & ~(s64)\n\t\t\t\t\t\t\tvol->cluster_size_mask)\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n\t\t\t\t\tbytes = vol->cluster_size - (pos &\n\t\t\t\t\t\t\tvol->cluster_size_mask);\n\t\t\t\t\tdo_pages = nr_pages;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\t\t/*\n\t\t * Bring in the user page(s) that we will copy from _first_.\n\t\t * Otherwise there is a nasty deadlock on copying from the same\n\t\t * page(s) as we are writing to, without it/them being marked\n\t\t * up-to-date.  Note, at present there is nothing to stop the\n\t\t * pages being swapped out between us bringing them into memory\n\t\t * and doing the actual copying.\n\t\t */\n\t\tif (likely(nr_segs == 1))\n\t\t\tntfs_fault_in_pages_readable(buf, bytes);\n\t\telse\n\t\t\tntfs_fault_in_pages_readable_iovec(iov, iov_ofs, bytes);\n\t\t/* Get and lock @do_pages starting at index @start_idx. */\n\t\tstatus = __ntfs_grab_cache_pages(mapping, start_idx, do_pages,\n\t\t\t\tpages, &cached_page);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\t/*\n\t\t * For non-resident attributes, we need to fill any holes with\n\t\t * actual clusters and ensure all bufferes are mapped.  We also\n\t\t * need to bring uptodate any buffers that are only partially\n\t\t * being written to.\n\t\t */\n\t\tif (NInoNonResident(ni)) {\n\t\t\tstatus = ntfs_prepare_pages_for_non_resident_write(\n\t\t\t\t\tpages, do_pages, pos, bytes);\n\t\t\tif (unlikely(status)) {\n\t\t\t\tloff_t i_size;\n\n\t\t\t\tdo {\n\t\t\t\t\tunlock_page(pages[--do_pages]);\n\t\t\t\t\tpage_cache_release(pages[do_pages]);\n\t\t\t\t} while (do_pages);\n\t\t\t\t/*\n\t\t\t\t * The write preparation may have instantiated\n\t\t\t\t * allocated space outside i_size.  Trim this\n\t\t\t\t * off again.  We can ignore any errors in this\n\t\t\t\t * case as we will just be waisting a bit of\n\t\t\t\t * allocated space, which is not a disaster.\n\t\t\t\t */\n\t\t\t\ti_size = i_size_read(vi);\n\t\t\t\tif (pos + bytes > i_size) {\n\t\t\t\t\tntfs_write_failed(mapping, pos + bytes);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tu = (pos >> PAGE_CACHE_SHIFT) - pages[0]->index;\n\t\tif (likely(nr_segs == 1)) {\n\t\t\tcopied = ntfs_copy_from_user(pages + u, do_pages - u,\n\t\t\t\t\tofs, buf, bytes);\n\t\t\tbuf += copied;\n\t\t} else\n\t\t\tcopied = ntfs_copy_from_user_iovec(pages + u,\n\t\t\t\t\tdo_pages - u, ofs, &iov, &iov_ofs,\n\t\t\t\t\tbytes);\n\t\tntfs_flush_dcache_pages(pages + u, do_pages - u);\n\t\tstatus = ntfs_commit_pages_after_write(pages, do_pages, pos,\n\t\t\t\tbytes);\n\t\tif (likely(!status)) {\n\t\t\twritten += copied;\n\t\t\tcount -= copied;\n\t\t\tpos += copied;\n\t\t\tif (unlikely(copied != bytes))\n\t\t\t\tstatus = -EFAULT;\n\t\t}\n\t\tdo {\n\t\t\tunlock_page(pages[--do_pages]);\n\t\t\tpage_cache_release(pages[do_pages]);\n\t\t} while (do_pages);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t} while (count);\nerr_out:\n\t*ppos = pos;\n\tif (cached_page)\n\t\tpage_cache_release(cached_page);\n\tntfs_debug(\"Done.  Returning %s (written 0x%lx, status %li).\",\n\t\t\twritten ? \"written\" : \"status\", (unsigned long)written,\n\t\t\t(long)status);\n\treturn written ? written : status;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic ssize_t ntfs_file_buffered_write(struct kiocb *iocb,\n\t\tconst struct iovec *iov, unsigned long nr_segs,\n\t\tloff_t pos, loff_t *ppos, size_t count)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *vi = mapping->host;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tstruct page *pages[NTFS_MAX_PAGES_PER_CLUSTER];\n\tstruct page *cached_page = NULL;\n\tchar __user *buf = NULL;\n\ts64 end, ll;\n\tVCN last_vcn;\n\tLCN lcn;\n\tunsigned long flags;\n\tsize_t bytes, iov_ofs = 0;\t/* Offset in the current iovec. */\n\tssize_t status, written;\n\tunsigned nr_pages;\n\tint err;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"pos 0x%llx, count 0x%lx.\",\n\t\t\tvi->i_ino, (unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)pos, (unsigned long)count);\n\tif (unlikely(!count))\n\t\treturn 0;\n\tBUG_ON(NInoMstProtected(ni));\n\t/*\n\t * If the attribute is not an index root and it is encrypted or\n\t * compressed, we cannot write to it yet.  Note we need to check for\n\t * AT_INDEX_ALLOCATION since this is the type of both directory and\n\t * index inodes.\n\t */\n\tif (ni->type != AT_INDEX_ALLOCATION) {\n\t\t/* If file is encrypted, deny access, just like NT4. */\n\t\tif (NInoEncrypted(ni)) {\n\t\t\t/*\n\t\t\t * Reminder for later: Encrypted files are _always_\n\t\t\t * non-resident so that the content can always be\n\t\t\t * encrypted.\n\t\t\t */\n\t\t\tntfs_debug(\"Denying write access to encrypted file.\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (NInoCompressed(ni)) {\n\t\t\t/* Only unnamed $DATA attribute can be compressed. */\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tBUG_ON(ni->name_len);\n\t\t\t/*\n\t\t\t * Reminder for later: If resident, the data is not\n\t\t\t * actually compressed.  Only on the switch to non-\n\t\t\t * resident does compression kick in.  This is in\n\t\t\t * contrast to encrypted files (see above).\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"Writing to compressed files is \"\n\t\t\t\t\t\"not implemented yet.  Sorry.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\t/*\n\t * If a previous ntfs_truncate() failed, repeat it and abort if it\n\t * fails again.\n\t */\n\tif (unlikely(NInoTruncateFailed(ni))) {\n\t\tinode_dio_wait(vi);\n\t\terr = ntfs_truncate(vi);\n\t\tif (err || NInoTruncateFailed(ni)) {\n\t\t\tif (!err)\n\t\t\t\terr = -EIO;\n\t\t\tntfs_error(vol->sb, \"Cannot perform write to inode \"\n\t\t\t\t\t\"0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\t\"ntfs_truncate() failed (error code \"\n\t\t\t\t\t\"%i).\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\treturn err;\n\t\t}\n\t}\n\t/* The first byte after the write. */\n\tend = pos + count;\n\t/*\n\t * If the write goes beyond the allocated size, extend the allocation\n\t * to cover the whole of the write, rounded up to the nearest cluster.\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tll = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (end > ll) {\n\t\t/* Extend the allocation without changing the data size. */\n\t\tll = ntfs_attr_extend_allocation(ni, end, -1, pos);\n\t\tif (likely(ll >= 0)) {\n\t\t\tBUG_ON(pos >= ll);\n\t\t\t/* If the extension was partial truncate the write. */\n\t\t\tif (end > ll) {\n\t\t\t\tntfs_debug(\"Truncating write to inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x, because \"\n\t\t\t\t\t\t\"the allocation was only \"\n\t\t\t\t\t\t\"partially extended.\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\tend = ll;\n\t\t\t\tcount = ll - pos;\n\t\t\t}\n\t\t} else {\n\t\t\terr = ll;\n\t\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\t\tll = ni->allocated_size;\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\t/* Perform a partial write if possible or fail. */\n\t\t\tif (pos < ll) {\n\t\t\t\tntfs_debug(\"Truncating write to inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x, because \"\n\t\t\t\t\t\t\"extending the allocation \"\n\t\t\t\t\t\t\"failed (error code %i).\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type), err);\n\t\t\t\tend = ll;\n\t\t\t\tcount = ll - pos;\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Cannot perform write to \"\n\t\t\t\t\t\t\"inode 0x%lx, attribute type \"\n\t\t\t\t\t\t\"0x%x, because extending the \"\n\t\t\t\t\t\t\"allocation failed (error \"\n\t\t\t\t\t\t\"code %i).\", vi->i_ino,\n\t\t\t\t\t\t(unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type), err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\twritten = 0;\n\t/*\n\t * If the write starts beyond the initialized size, extend it up to the\n\t * beginning of the write and initialize all non-sparse space between\n\t * the old initialized size and the new one.  This automatically also\n\t * increments the vfs inode->i_size to keep it above or equal to the\n\t * initialized_size.\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tll = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (pos > ll) {\n\t\terr = ntfs_attr_extend_initialized(ni, pos);\n\t\tif (err < 0) {\n\t\t\tntfs_error(vol->sb, \"Cannot perform write to inode \"\n\t\t\t\t\t\"0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\t\"extending the initialized size \"\n\t\t\t\t\t\"failed (error code %i).\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\tstatus = err;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\t/*\n\t * Determine the number of pages per cluster for non-resident\n\t * attributes.\n\t */\n\tnr_pages = 1;\n\tif (vol->cluster_size > PAGE_CACHE_SIZE && NInoNonResident(ni))\n\t\tnr_pages = vol->cluster_size >> PAGE_CACHE_SHIFT;\n\t/* Finally, perform the actual write. */\n\tlast_vcn = -1;\n\tif (likely(nr_segs == 1))\n\t\tbuf = iov->iov_base;\n\tdo {\n\t\tVCN vcn;\n\t\tpgoff_t idx, start_idx;\n\t\tunsigned ofs, do_pages, u;\n\t\tsize_t copied;\n\n\t\tstart_idx = idx = pos >> PAGE_CACHE_SHIFT;\n\t\tofs = pos & ~PAGE_CACHE_MASK;\n\t\tbytes = PAGE_CACHE_SIZE - ofs;\n\t\tdo_pages = 1;\n\t\tif (nr_pages > 1) {\n\t\t\tvcn = pos >> vol->cluster_size_bits;\n\t\t\tif (vcn != last_vcn) {\n\t\t\t\tlast_vcn = vcn;\n\t\t\t\t/*\n\t\t\t\t * Get the lcn of the vcn the write is in.  If\n\t\t\t\t * it is a hole, need to lock down all pages in\n\t\t\t\t * the cluster.\n\t\t\t\t */\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\tlcn = ntfs_attr_vcn_to_lcn_nolock(ni, pos >>\n\t\t\t\t\t\tvol->cluster_size_bits, false);\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\tif (unlikely(lcn < LCN_HOLE)) {\n\t\t\t\t\tstatus = -EIO;\n\t\t\t\t\tif (lcn == LCN_ENOMEM)\n\t\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\telse\n\t\t\t\t\t\tntfs_error(vol->sb, \"Cannot \"\n\t\t\t\t\t\t\t\"perform write to \"\n\t\t\t\t\t\t\t\"inode 0x%lx, \"\n\t\t\t\t\t\t\t\"attribute type 0x%x, \"\n\t\t\t\t\t\t\t\"because the attribute \"\n\t\t\t\t\t\t\t\"is corrupt.\",\n\t\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (lcn == LCN_HOLE) {\n\t\t\t\t\tstart_idx = (pos & ~(s64)\n\t\t\t\t\t\t\tvol->cluster_size_mask)\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n\t\t\t\t\tbytes = vol->cluster_size - (pos &\n\t\t\t\t\t\t\tvol->cluster_size_mask);\n\t\t\t\t\tdo_pages = nr_pages;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\t\t/*\n\t\t * Bring in the user page(s) that we will copy from _first_.\n\t\t * Otherwise there is a nasty deadlock on copying from the same\n\t\t * page(s) as we are writing to, without it/them being marked\n\t\t * up-to-date.  Note, at present there is nothing to stop the\n\t\t * pages being swapped out between us bringing them into memory\n\t\t * and doing the actual copying.\n\t\t */\n\t\tif (likely(nr_segs == 1))\n\t\t\tntfs_fault_in_pages_readable(buf, bytes);\n\t\telse\n\t\t\tntfs_fault_in_pages_readable_iovec(iov, iov_ofs, bytes);\n\t\t/* Get and lock @do_pages starting at index @start_idx. */\n\t\tstatus = __ntfs_grab_cache_pages(mapping, start_idx, do_pages,\n\t\t\t\tpages, &cached_page);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\t/*\n\t\t * For non-resident attributes, we need to fill any holes with\n\t\t * actual clusters and ensure all bufferes are mapped.  We also\n\t\t * need to bring uptodate any buffers that are only partially\n\t\t * being written to.\n\t\t */\n\t\tif (NInoNonResident(ni)) {\n\t\t\tstatus = ntfs_prepare_pages_for_non_resident_write(\n\t\t\t\t\tpages, do_pages, pos, bytes);\n\t\t\tif (unlikely(status)) {\n\t\t\t\tloff_t i_size;\n\n\t\t\t\tdo {\n\t\t\t\t\tunlock_page(pages[--do_pages]);\n\t\t\t\t\tpage_cache_release(pages[do_pages]);\n\t\t\t\t} while (do_pages);\n\t\t\t\t/*\n\t\t\t\t * The write preparation may have instantiated\n\t\t\t\t * allocated space outside i_size.  Trim this\n\t\t\t\t * off again.  We can ignore any errors in this\n\t\t\t\t * case as we will just be waisting a bit of\n\t\t\t\t * allocated space, which is not a disaster.\n\t\t\t\t */\n\t\t\t\ti_size = i_size_read(vi);\n\t\t\t\tif (pos + bytes > i_size) {\n\t\t\t\t\tntfs_write_failed(mapping, pos + bytes);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tu = (pos >> PAGE_CACHE_SHIFT) - pages[0]->index;\n\t\tif (likely(nr_segs == 1)) {\n\t\t\tcopied = ntfs_copy_from_user(pages + u, do_pages - u,\n\t\t\t\t\tofs, buf, bytes);\n\t\t\tbuf += copied;\n\t\t} else\n\t\t\tcopied = ntfs_copy_from_user_iovec(pages + u,\n\t\t\t\t\tdo_pages - u, ofs, &iov, &iov_ofs,\n\t\t\t\t\tbytes);\n\t\tntfs_flush_dcache_pages(pages + u, do_pages - u);\n\t\tstatus = ntfs_commit_pages_after_write(pages, do_pages, pos,\n\t\t\t\tbytes);\n\t\tif (likely(!status)) {\n\t\t\twritten += copied;\n\t\t\tcount -= copied;\n\t\t\tpos += copied;\n\t\t\tif (unlikely(copied != bytes))\n\t\t\t\tstatus = -EFAULT;\n\t\t}\n\t\tdo {\n\t\t\tunlock_page(pages[--do_pages]);\n\t\t\tpage_cache_release(pages[do_pages]);\n\t\t} while (do_pages);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t} while (count);\nerr_out:\n\t*ppos = pos;\n\tif (cached_page)\n\t\tpage_cache_release(cached_page);\n\tntfs_debug(\"Done.  Returning %s (written 0x%lx, status %li).\",\n\t\t\twritten ? \"written\" : \"status\", (unsigned long)written,\n\t\t\t(long)status);\n\treturn written ? written : status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "file"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_remove_suid",
          "args": [
            "file"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "file_remove_suid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1675-1700",
          "snippet": "int file_remove_suid(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint killsuid;\n\tint killpriv;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkillsuid = should_remove_suid(dentry);\n\tkillpriv = security_inode_need_killpriv(dentry);\n\n\tif (killpriv < 0)\n\t\treturn killpriv;\n\tif (killpriv)\n\t\terror = security_inode_killpriv(dentry);\n\tif (!error && killsuid)\n\t\terror = __remove_suid(dentry, killsuid);\n\tif (!error && (inode->i_sb->s_flags & MS_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_remove_suid(struct file *file)\n{\n\tstruct dentry *dentry = file->f_path.dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tint killsuid;\n\tint killpriv;\n\tint error = 0;\n\n\t/* Fast path for nothing security related */\n\tif (IS_NOSEC(inode))\n\t\treturn 0;\n\n\tkillsuid = should_remove_suid(dentry);\n\tkillpriv = security_inode_need_killpriv(dentry);\n\n\tif (killpriv < 0)\n\t\treturn killpriv;\n\tif (killpriv)\n\t\terror = security_inode_killpriv(dentry);\n\tif (!error && killsuid)\n\t\terror = __remove_suid(dentry, killsuid);\n\tif (!error && (inode->i_sb->s_flags & MS_NOSEC))\n\t\tinode->i_flags |= S_NOSEC;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "generic_write_checks",
          "args": [
            "file",
            "&pos",
            "&count",
            "S_ISBLK(inode->i_mode)"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_to_bdi",
          "args": [
            "inode"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "inode_to_bdi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "69-82",
          "snippet": "struct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstruct backing_dev_info *inode_to_bdi(struct inode *inode)\n{\n\tstruct super_block *sb;\n\n\tif (!inode)\n\t\treturn &noop_backing_dev_info;\n\n\tsb = inode->i_sb;\n#ifdef CONFIG_BLOCK\n\tif (sb_is_blkdev_sb(sb))\n\t\treturn blk_get_backing_dev_info(I_BDEV(inode));\n#endif\n\treturn sb->s_bdi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_length",
          "args": [
            "iov",
            "nr_segs"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic ssize_t ntfs_file_aio_write_nolock(struct kiocb *iocb,\n\t\tconst struct iovec *iov, unsigned long nr_segs, loff_t *ppos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tloff_t pos;\n\tsize_t count;\t\t/* after file limit checks */\n\tssize_t written, err;\n\n\tcount = iov_length(iov, nr_segs);\n\tpos = *ppos;\n\t/* We can write back this queue in page reclaim. */\n\tcurrent->backing_dev_info = inode_to_bdi(inode);\n\twritten = 0;\n\terr = generic_write_checks(file, &pos, &count, S_ISBLK(inode->i_mode));\n\tif (err)\n\t\tgoto out;\n\tif (!count)\n\t\tgoto out;\n\terr = file_remove_suid(file);\n\tif (err)\n\t\tgoto out;\n\terr = file_update_time(file);\n\tif (err)\n\t\tgoto out;\n\twritten = ntfs_file_buffered_write(iocb, iov, nr_segs, pos, ppos,\n\t\t\tcount);\nout:\n\tcurrent->backing_dev_info = NULL;\n\treturn written ? written : err;\n}"
  },
  {
    "function_name": "ntfs_file_buffered_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "1780-2077",
    "snippet": "static ssize_t ntfs_file_buffered_write(struct kiocb *iocb,\n\t\tconst struct iovec *iov, unsigned long nr_segs,\n\t\tloff_t pos, loff_t *ppos, size_t count)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *vi = mapping->host;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tstruct page *pages[NTFS_MAX_PAGES_PER_CLUSTER];\n\tstruct page *cached_page = NULL;\n\tchar __user *buf = NULL;\n\ts64 end, ll;\n\tVCN last_vcn;\n\tLCN lcn;\n\tunsigned long flags;\n\tsize_t bytes, iov_ofs = 0;\t/* Offset in the current iovec. */\n\tssize_t status, written;\n\tunsigned nr_pages;\n\tint err;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"pos 0x%llx, count 0x%lx.\",\n\t\t\tvi->i_ino, (unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)pos, (unsigned long)count);\n\tif (unlikely(!count))\n\t\treturn 0;\n\tBUG_ON(NInoMstProtected(ni));\n\t/*\n\t * If the attribute is not an index root and it is encrypted or\n\t * compressed, we cannot write to it yet.  Note we need to check for\n\t * AT_INDEX_ALLOCATION since this is the type of both directory and\n\t * index inodes.\n\t */\n\tif (ni->type != AT_INDEX_ALLOCATION) {\n\t\t/* If file is encrypted, deny access, just like NT4. */\n\t\tif (NInoEncrypted(ni)) {\n\t\t\t/*\n\t\t\t * Reminder for later: Encrypted files are _always_\n\t\t\t * non-resident so that the content can always be\n\t\t\t * encrypted.\n\t\t\t */\n\t\t\tntfs_debug(\"Denying write access to encrypted file.\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (NInoCompressed(ni)) {\n\t\t\t/* Only unnamed $DATA attribute can be compressed. */\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tBUG_ON(ni->name_len);\n\t\t\t/*\n\t\t\t * Reminder for later: If resident, the data is not\n\t\t\t * actually compressed.  Only on the switch to non-\n\t\t\t * resident does compression kick in.  This is in\n\t\t\t * contrast to encrypted files (see above).\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"Writing to compressed files is \"\n\t\t\t\t\t\"not implemented yet.  Sorry.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\t/*\n\t * If a previous ntfs_truncate() failed, repeat it and abort if it\n\t * fails again.\n\t */\n\tif (unlikely(NInoTruncateFailed(ni))) {\n\t\tinode_dio_wait(vi);\n\t\terr = ntfs_truncate(vi);\n\t\tif (err || NInoTruncateFailed(ni)) {\n\t\t\tif (!err)\n\t\t\t\terr = -EIO;\n\t\t\tntfs_error(vol->sb, \"Cannot perform write to inode \"\n\t\t\t\t\t\"0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\t\"ntfs_truncate() failed (error code \"\n\t\t\t\t\t\"%i).\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\treturn err;\n\t\t}\n\t}\n\t/* The first byte after the write. */\n\tend = pos + count;\n\t/*\n\t * If the write goes beyond the allocated size, extend the allocation\n\t * to cover the whole of the write, rounded up to the nearest cluster.\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tll = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (end > ll) {\n\t\t/* Extend the allocation without changing the data size. */\n\t\tll = ntfs_attr_extend_allocation(ni, end, -1, pos);\n\t\tif (likely(ll >= 0)) {\n\t\t\tBUG_ON(pos >= ll);\n\t\t\t/* If the extension was partial truncate the write. */\n\t\t\tif (end > ll) {\n\t\t\t\tntfs_debug(\"Truncating write to inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x, because \"\n\t\t\t\t\t\t\"the allocation was only \"\n\t\t\t\t\t\t\"partially extended.\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\tend = ll;\n\t\t\t\tcount = ll - pos;\n\t\t\t}\n\t\t} else {\n\t\t\terr = ll;\n\t\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\t\tll = ni->allocated_size;\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\t/* Perform a partial write if possible or fail. */\n\t\t\tif (pos < ll) {\n\t\t\t\tntfs_debug(\"Truncating write to inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x, because \"\n\t\t\t\t\t\t\"extending the allocation \"\n\t\t\t\t\t\t\"failed (error code %i).\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type), err);\n\t\t\t\tend = ll;\n\t\t\t\tcount = ll - pos;\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Cannot perform write to \"\n\t\t\t\t\t\t\"inode 0x%lx, attribute type \"\n\t\t\t\t\t\t\"0x%x, because extending the \"\n\t\t\t\t\t\t\"allocation failed (error \"\n\t\t\t\t\t\t\"code %i).\", vi->i_ino,\n\t\t\t\t\t\t(unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type), err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\twritten = 0;\n\t/*\n\t * If the write starts beyond the initialized size, extend it up to the\n\t * beginning of the write and initialize all non-sparse space between\n\t * the old initialized size and the new one.  This automatically also\n\t * increments the vfs inode->i_size to keep it above or equal to the\n\t * initialized_size.\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tll = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (pos > ll) {\n\t\terr = ntfs_attr_extend_initialized(ni, pos);\n\t\tif (err < 0) {\n\t\t\tntfs_error(vol->sb, \"Cannot perform write to inode \"\n\t\t\t\t\t\"0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\t\"extending the initialized size \"\n\t\t\t\t\t\"failed (error code %i).\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\tstatus = err;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\t/*\n\t * Determine the number of pages per cluster for non-resident\n\t * attributes.\n\t */\n\tnr_pages = 1;\n\tif (vol->cluster_size > PAGE_CACHE_SIZE && NInoNonResident(ni))\n\t\tnr_pages = vol->cluster_size >> PAGE_CACHE_SHIFT;\n\t/* Finally, perform the actual write. */\n\tlast_vcn = -1;\n\tif (likely(nr_segs == 1))\n\t\tbuf = iov->iov_base;\n\tdo {\n\t\tVCN vcn;\n\t\tpgoff_t idx, start_idx;\n\t\tunsigned ofs, do_pages, u;\n\t\tsize_t copied;\n\n\t\tstart_idx = idx = pos >> PAGE_CACHE_SHIFT;\n\t\tofs = pos & ~PAGE_CACHE_MASK;\n\t\tbytes = PAGE_CACHE_SIZE - ofs;\n\t\tdo_pages = 1;\n\t\tif (nr_pages > 1) {\n\t\t\tvcn = pos >> vol->cluster_size_bits;\n\t\t\tif (vcn != last_vcn) {\n\t\t\t\tlast_vcn = vcn;\n\t\t\t\t/*\n\t\t\t\t * Get the lcn of the vcn the write is in.  If\n\t\t\t\t * it is a hole, need to lock down all pages in\n\t\t\t\t * the cluster.\n\t\t\t\t */\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\tlcn = ntfs_attr_vcn_to_lcn_nolock(ni, pos >>\n\t\t\t\t\t\tvol->cluster_size_bits, false);\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\tif (unlikely(lcn < LCN_HOLE)) {\n\t\t\t\t\tstatus = -EIO;\n\t\t\t\t\tif (lcn == LCN_ENOMEM)\n\t\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\telse\n\t\t\t\t\t\tntfs_error(vol->sb, \"Cannot \"\n\t\t\t\t\t\t\t\"perform write to \"\n\t\t\t\t\t\t\t\"inode 0x%lx, \"\n\t\t\t\t\t\t\t\"attribute type 0x%x, \"\n\t\t\t\t\t\t\t\"because the attribute \"\n\t\t\t\t\t\t\t\"is corrupt.\",\n\t\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (lcn == LCN_HOLE) {\n\t\t\t\t\tstart_idx = (pos & ~(s64)\n\t\t\t\t\t\t\tvol->cluster_size_mask)\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n\t\t\t\t\tbytes = vol->cluster_size - (pos &\n\t\t\t\t\t\t\tvol->cluster_size_mask);\n\t\t\t\t\tdo_pages = nr_pages;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\t\t/*\n\t\t * Bring in the user page(s) that we will copy from _first_.\n\t\t * Otherwise there is a nasty deadlock on copying from the same\n\t\t * page(s) as we are writing to, without it/them being marked\n\t\t * up-to-date.  Note, at present there is nothing to stop the\n\t\t * pages being swapped out between us bringing them into memory\n\t\t * and doing the actual copying.\n\t\t */\n\t\tif (likely(nr_segs == 1))\n\t\t\tntfs_fault_in_pages_readable(buf, bytes);\n\t\telse\n\t\t\tntfs_fault_in_pages_readable_iovec(iov, iov_ofs, bytes);\n\t\t/* Get and lock @do_pages starting at index @start_idx. */\n\t\tstatus = __ntfs_grab_cache_pages(mapping, start_idx, do_pages,\n\t\t\t\tpages, &cached_page);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\t/*\n\t\t * For non-resident attributes, we need to fill any holes with\n\t\t * actual clusters and ensure all bufferes are mapped.  We also\n\t\t * need to bring uptodate any buffers that are only partially\n\t\t * being written to.\n\t\t */\n\t\tif (NInoNonResident(ni)) {\n\t\t\tstatus = ntfs_prepare_pages_for_non_resident_write(\n\t\t\t\t\tpages, do_pages, pos, bytes);\n\t\t\tif (unlikely(status)) {\n\t\t\t\tloff_t i_size;\n\n\t\t\t\tdo {\n\t\t\t\t\tunlock_page(pages[--do_pages]);\n\t\t\t\t\tpage_cache_release(pages[do_pages]);\n\t\t\t\t} while (do_pages);\n\t\t\t\t/*\n\t\t\t\t * The write preparation may have instantiated\n\t\t\t\t * allocated space outside i_size.  Trim this\n\t\t\t\t * off again.  We can ignore any errors in this\n\t\t\t\t * case as we will just be waisting a bit of\n\t\t\t\t * allocated space, which is not a disaster.\n\t\t\t\t */\n\t\t\t\ti_size = i_size_read(vi);\n\t\t\t\tif (pos + bytes > i_size) {\n\t\t\t\t\tntfs_write_failed(mapping, pos + bytes);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tu = (pos >> PAGE_CACHE_SHIFT) - pages[0]->index;\n\t\tif (likely(nr_segs == 1)) {\n\t\t\tcopied = ntfs_copy_from_user(pages + u, do_pages - u,\n\t\t\t\t\tofs, buf, bytes);\n\t\t\tbuf += copied;\n\t\t} else\n\t\t\tcopied = ntfs_copy_from_user_iovec(pages + u,\n\t\t\t\t\tdo_pages - u, ofs, &iov, &iov_ofs,\n\t\t\t\t\tbytes);\n\t\tntfs_flush_dcache_pages(pages + u, do_pages - u);\n\t\tstatus = ntfs_commit_pages_after_write(pages, do_pages, pos,\n\t\t\t\tbytes);\n\t\tif (likely(!status)) {\n\t\t\twritten += copied;\n\t\t\tcount -= copied;\n\t\t\tpos += copied;\n\t\t\tif (unlikely(copied != bytes))\n\t\t\t\tstatus = -EFAULT;\n\t\t}\n\t\tdo {\n\t\t\tunlock_page(pages[--do_pages]);\n\t\t\tpage_cache_release(pages[do_pages]);\n\t\t} while (do_pages);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t} while (count);\nerr_out:\n\t*ppos = pos;\n\tif (cached_page)\n\t\tpage_cache_release(cached_page);\n\tntfs_debug(\"Done.  Returning %s (written 0x%lx, status %li).\",\n\t\t\twritten ? \"written\" : \"status\", (unsigned long)written,\n\t\t\t(long)status);\n\treturn written ? written : status;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.  Returning %s (written 0x%lx, status %li).\"",
            "written ? \"written\" : \"status\"",
            "(unsigned long)written",
            "(long)status"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "cached_page"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "mapping"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[do_pages]"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pages[--do_pages]"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied != bytes"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!status"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_commit_pages_after_write",
          "args": [
            "pages",
            "do_pages",
            "pos",
            "bytes"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_commit_pages_after_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "1624-1763",
          "snippet": "static int ntfs_commit_pages_after_write(struct page **pages,\n\t\tconst unsigned nr_pages, s64 pos, size_t bytes)\n{\n\ts64 end, initialized_size;\n\tloff_t i_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tstruct page *page;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tchar *kattr, *kaddr;\n\tunsigned long flags;\n\tu32 attr_len;\n\tint err;\n\n\tBUG_ON(!nr_pages);\n\tBUG_ON(!pages);\n\tpage = pages[0];\n\tBUG_ON(!page);\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, start page \"\n\t\t\t\"index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.\",\n\t\t\tvi->i_ino, ni->type, page->index, nr_pages,\n\t\t\t(long long)pos, bytes);\n\tif (NInoNonResident(ni))\n\t\treturn ntfs_commit_pages_after_non_resident_write(pages,\n\t\t\t\tnr_pages, pos, bytes);\n\tBUG_ON(nr_pages > 1);\n\t/*\n\t * Attribute is resident, implying it is not compressed, encrypted, or\n\t * sparse.\n\t */\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tBUG_ON(NInoNonResident(ni));\n\t/* Map, pin, and lock the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\tBUG_ON(a->non_resident);\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\ti_size = i_size_read(vi);\n\tBUG_ON(attr_len != i_size);\n\tBUG_ON(pos > attr_len);\n\tend = pos + bytes;\n\tBUG_ON(end > le32_to_cpu(a->length) -\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\tkattr = (u8*)a + le16_to_cpu(a->data.resident.value_offset);\n\tkaddr = kmap_atomic(page);\n\t/* Copy the received data from the page to the mft record. */\n\tmemcpy(kattr + pos, kaddr + pos, bytes);\n\t/* Update the attribute length if necessary. */\n\tif (end > attr_len) {\n\t\tattr_len = end;\n\t\ta->data.resident.value_length = cpu_to_le32(attr_len);\n\t}\n\t/*\n\t * If the page is not uptodate, bring the out of bounds area(s)\n\t * uptodate by copying data from the mft record to the page.\n\t */\n\tif (!PageUptodate(page)) {\n\t\tif (pos > 0)\n\t\t\tmemcpy(kaddr, kattr, pos);\n\t\tif (end < attr_len)\n\t\t\tmemcpy(kaddr + end, kattr + end, attr_len - end);\n\t\t/* Zero the region outside the end of the attribute value. */\n\t\tmemset(kaddr + attr_len, 0, PAGE_CACHE_SIZE - attr_len);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap_atomic(kaddr);\n\t/* Update initialized_size/i_size if necessary. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tBUG_ON(end > ni->allocated_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tBUG_ON(initialized_size != i_size);\n\tif (end > initialized_size) {\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->initialized_size = end;\n\t\ti_size_write(vi, end);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t}\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Error allocating memory required to \"\n\t\t\t\t\"commit the write.\");\n\t\tif (PageUptodate(page)) {\n\t\t\tntfs_warning(vi->i_sb, \"Page is uptodate, setting \"\n\t\t\t\t\t\"dirty so the write will be retried \"\n\t\t\t\t\t\"later on by the VM.\");\n\t\t\t/*\n\t\t\t * Put the page on mapping->dirty_pages, but leave its\n\t\t\t * buffers' dirty state as-is.\n\t\t\t */\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tntfs_error(vi->i_sb, \"Page is not uptodate.  Written \"\n\t\t\t\t\t\"data has been lost.\");\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Resident attribute commit write failed \"\n\t\t\t\t\"with error %i.\", err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic int ntfs_commit_pages_after_write(struct page **pages,\n\t\tconst unsigned nr_pages, s64 pos, size_t bytes)\n{\n\ts64 end, initialized_size;\n\tloff_t i_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tstruct page *page;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tchar *kattr, *kaddr;\n\tunsigned long flags;\n\tu32 attr_len;\n\tint err;\n\n\tBUG_ON(!nr_pages);\n\tBUG_ON(!pages);\n\tpage = pages[0];\n\tBUG_ON(!page);\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, start page \"\n\t\t\t\"index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.\",\n\t\t\tvi->i_ino, ni->type, page->index, nr_pages,\n\t\t\t(long long)pos, bytes);\n\tif (NInoNonResident(ni))\n\t\treturn ntfs_commit_pages_after_non_resident_write(pages,\n\t\t\t\tnr_pages, pos, bytes);\n\tBUG_ON(nr_pages > 1);\n\t/*\n\t * Attribute is resident, implying it is not compressed, encrypted, or\n\t * sparse.\n\t */\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tBUG_ON(NInoNonResident(ni));\n\t/* Map, pin, and lock the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\tBUG_ON(a->non_resident);\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\ti_size = i_size_read(vi);\n\tBUG_ON(attr_len != i_size);\n\tBUG_ON(pos > attr_len);\n\tend = pos + bytes;\n\tBUG_ON(end > le32_to_cpu(a->length) -\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\tkattr = (u8*)a + le16_to_cpu(a->data.resident.value_offset);\n\tkaddr = kmap_atomic(page);\n\t/* Copy the received data from the page to the mft record. */\n\tmemcpy(kattr + pos, kaddr + pos, bytes);\n\t/* Update the attribute length if necessary. */\n\tif (end > attr_len) {\n\t\tattr_len = end;\n\t\ta->data.resident.value_length = cpu_to_le32(attr_len);\n\t}\n\t/*\n\t * If the page is not uptodate, bring the out of bounds area(s)\n\t * uptodate by copying data from the mft record to the page.\n\t */\n\tif (!PageUptodate(page)) {\n\t\tif (pos > 0)\n\t\t\tmemcpy(kaddr, kattr, pos);\n\t\tif (end < attr_len)\n\t\t\tmemcpy(kaddr + end, kattr + end, attr_len - end);\n\t\t/* Zero the region outside the end of the attribute value. */\n\t\tmemset(kaddr + attr_len, 0, PAGE_CACHE_SIZE - attr_len);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap_atomic(kaddr);\n\t/* Update initialized_size/i_size if necessary. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tBUG_ON(end > ni->allocated_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tBUG_ON(initialized_size != i_size);\n\tif (end > initialized_size) {\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->initialized_size = end;\n\t\ti_size_write(vi, end);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t}\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Error allocating memory required to \"\n\t\t\t\t\"commit the write.\");\n\t\tif (PageUptodate(page)) {\n\t\t\tntfs_warning(vi->i_sb, \"Page is uptodate, setting \"\n\t\t\t\t\t\"dirty so the write will be retried \"\n\t\t\t\t\t\"later on by the VM.\");\n\t\t\t/*\n\t\t\t * Put the page on mapping->dirty_pages, but leave its\n\t\t\t * buffers' dirty state as-is.\n\t\t\t */\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tntfs_error(vi->i_sb, \"Page is not uptodate.  Written \"\n\t\t\t\t\t\"data has been lost.\");\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Resident attribute commit write failed \"\n\t\t\t\t\"with error %i.\", err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_flush_dcache_pages",
          "args": [
            "pages + u",
            "do_pages - u"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_flush_dcache_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "1445-1458",
          "snippet": "static inline void ntfs_flush_dcache_pages(struct page **pages,\n\t\tunsigned nr_pages)\n{\n\tBUG_ON(!nr_pages);\n\t/*\n\t * Warning: Do not do the decrement at the same time as the call to\n\t * flush_dcache_page() because it is a NULL macro on i386 and hence the\n\t * decrement never happens so the loop never terminates.\n\t */\n\tdo {\n\t\t--nr_pages;\n\t\tflush_dcache_page(pages[nr_pages]);\n\t} while (nr_pages > 0);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline void ntfs_flush_dcache_pages(struct page **pages,\n\t\tunsigned nr_pages)\n{\n\tBUG_ON(!nr_pages);\n\t/*\n\t * Warning: Do not do the decrement at the same time as the call to\n\t * flush_dcache_page() because it is a NULL macro on i386 and hence the\n\t * decrement never happens so the loop never terminates.\n\t */\n\tdo {\n\t\t--nr_pages;\n\t\tflush_dcache_page(pages[nr_pages]);\n\t} while (nr_pages > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_copy_from_user_iovec",
          "args": [
            "pages + u",
            "do_pages - u",
            "ofs",
            "&iov",
            "&iov_ofs",
            "bytes"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_copy_from_user_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "1392-1443",
          "snippet": "static inline size_t ntfs_copy_from_user_iovec(struct page **pages,\n\t\tunsigned nr_pages, unsigned ofs, const struct iovec **iov,\n\t\tsize_t *iov_ofs, size_t bytes)\n{\n\tstruct page **last_page = pages + nr_pages;\n\tchar *addr;\n\tsize_t copied, len, total = 0;\n\n\tdo {\n\t\tlen = PAGE_CACHE_SIZE - ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\taddr = kmap_atomic(*pages);\n\t\tcopied = __ntfs_copy_from_user_iovec_inatomic(addr + ofs,\n\t\t\t\t*iov, *iov_ofs, len);\n\t\tkunmap_atomic(addr);\n\t\tif (unlikely(copied != len)) {\n\t\t\t/* Do it the slow way. */\n\t\t\taddr = kmap(*pages);\n\t\t\tcopied = __ntfs_copy_from_user_iovec_inatomic(addr +\n\t\t\t\t\tofs, *iov, *iov_ofs, len);\n\t\t\tif (unlikely(copied != len))\n\t\t\t\tgoto err_out;\n\t\t\tkunmap(*pages);\n\t\t}\n\t\ttotal += len;\n\t\tntfs_set_next_iovec(iov, iov_ofs, len);\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tofs = 0;\n\t} while (++pages < last_page);\nout:\n\treturn total;\nerr_out:\n\tBUG_ON(copied > len);\n\t/* Zero the rest of the target like __copy_from_user(). */\n\tmemset(addr + ofs + copied, 0, len - copied);\n\tkunmap(*pages);\n\ttotal += copied;\n\tntfs_set_next_iovec(iov, iov_ofs, copied);\n\twhile (++pages < last_page) {\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tlen = PAGE_CACHE_SIZE;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tzero_user(*pages, 0, len);\n\t}\n\tgoto out;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline size_t ntfs_copy_from_user_iovec(struct page **pages,\n\t\tunsigned nr_pages, unsigned ofs, const struct iovec **iov,\n\t\tsize_t *iov_ofs, size_t bytes)\n{\n\tstruct page **last_page = pages + nr_pages;\n\tchar *addr;\n\tsize_t copied, len, total = 0;\n\n\tdo {\n\t\tlen = PAGE_CACHE_SIZE - ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\taddr = kmap_atomic(*pages);\n\t\tcopied = __ntfs_copy_from_user_iovec_inatomic(addr + ofs,\n\t\t\t\t*iov, *iov_ofs, len);\n\t\tkunmap_atomic(addr);\n\t\tif (unlikely(copied != len)) {\n\t\t\t/* Do it the slow way. */\n\t\t\taddr = kmap(*pages);\n\t\t\tcopied = __ntfs_copy_from_user_iovec_inatomic(addr +\n\t\t\t\t\tofs, *iov, *iov_ofs, len);\n\t\t\tif (unlikely(copied != len))\n\t\t\t\tgoto err_out;\n\t\t\tkunmap(*pages);\n\t\t}\n\t\ttotal += len;\n\t\tntfs_set_next_iovec(iov, iov_ofs, len);\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tofs = 0;\n\t} while (++pages < last_page);\nout:\n\treturn total;\nerr_out:\n\tBUG_ON(copied > len);\n\t/* Zero the rest of the target like __copy_from_user(). */\n\tmemset(addr + ofs + copied, 0, len - copied);\n\tkunmap(*pages);\n\ttotal += copied;\n\tntfs_set_next_iovec(iov, iov_ofs, copied);\n\twhile (++pages < last_page) {\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tlen = PAGE_CACHE_SIZE;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tzero_user(*pages, 0, len);\n\t}\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_copy_from_user",
          "args": [
            "pages + u",
            "do_pages - u",
            "ofs",
            "buf",
            "bytes"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "1276-1323",
          "snippet": "static inline size_t ntfs_copy_from_user(struct page **pages,\n\t\tunsigned nr_pages, unsigned ofs, const char __user *buf,\n\t\tsize_t bytes)\n{\n\tstruct page **last_page = pages + nr_pages;\n\tchar *addr;\n\tsize_t total = 0;\n\tunsigned len;\n\tint left;\n\n\tdo {\n\t\tlen = PAGE_CACHE_SIZE - ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\taddr = kmap_atomic(*pages);\n\t\tleft = __copy_from_user_inatomic(addr + ofs, buf, len);\n\t\tkunmap_atomic(addr);\n\t\tif (unlikely(left)) {\n\t\t\t/* Do it the slow way. */\n\t\t\taddr = kmap(*pages);\n\t\t\tleft = __copy_from_user(addr + ofs, buf, len);\n\t\t\tkunmap(*pages);\n\t\t\tif (unlikely(left))\n\t\t\t\tgoto err_out;\n\t\t}\n\t\ttotal += len;\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tbuf += len;\n\t\tofs = 0;\n\t} while (++pages < last_page);\nout:\n\treturn total;\nerr_out:\n\ttotal += len - left;\n\t/* Zero the rest of the target like __copy_from_user(). */\n\twhile (++pages < last_page) {\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tlen = PAGE_CACHE_SIZE;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tzero_user(*pages, 0, len);\n\t}\n\tgoto out;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline size_t ntfs_copy_from_user(struct page **pages,\n\t\tunsigned nr_pages, unsigned ofs, const char __user *buf,\n\t\tsize_t bytes)\n{\n\tstruct page **last_page = pages + nr_pages;\n\tchar *addr;\n\tsize_t total = 0;\n\tunsigned len;\n\tint left;\n\n\tdo {\n\t\tlen = PAGE_CACHE_SIZE - ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\taddr = kmap_atomic(*pages);\n\t\tleft = __copy_from_user_inatomic(addr + ofs, buf, len);\n\t\tkunmap_atomic(addr);\n\t\tif (unlikely(left)) {\n\t\t\t/* Do it the slow way. */\n\t\t\taddr = kmap(*pages);\n\t\t\tleft = __copy_from_user(addr + ofs, buf, len);\n\t\t\tkunmap(*pages);\n\t\t\tif (unlikely(left))\n\t\t\t\tgoto err_out;\n\t\t}\n\t\ttotal += len;\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tbuf += len;\n\t\tofs = 0;\n\t} while (++pages < last_page);\nout:\n\treturn total;\nerr_out:\n\ttotal += len - left;\n\t/* Zero the rest of the target like __copy_from_user(). */\n\twhile (++pages < last_page) {\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tlen = PAGE_CACHE_SIZE;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tzero_user(*pages, 0, len);\n\t}\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "nr_segs == 1"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_write_failed",
          "args": [
            "mapping",
            "pos + bytes"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "1765-1773",
          "snippet": "static void ntfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tntfs_truncate_vfs(inode);\n\t}\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic void ntfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tntfs_truncate_vfs(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[do_pages]"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_prepare_pages_for_non_resident_write",
          "args": [
            "pages",
            "do_pages",
            "pos",
            "bytes"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_prepare_pages_for_non_resident_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "480-1269",
          "snippet": "static int ntfs_prepare_pages_for_non_resident_write(struct page **pages,\n\t\tunsigned nr_pages, s64 pos, size_t bytes)\n{\n\tVCN vcn, highest_vcn = 0, cpos, cend, bh_cpos, bh_cend;\n\tLCN lcn;\n\ts64 bh_pos, vcn_len, end, initialized_size;\n\tsector_t lcn_block;\n\tstruct page *page;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni = NULL;\n\tntfs_volume *vol;\n\trunlist_element *rl, *rl2;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh = wait;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a = NULL;\n\tunsigned long flags;\n\tu32 attr_rec_len = 0;\n\tunsigned blocksize, u;\n\tint err, mp_size;\n\tbool rl_write_locked, was_hole, is_retry;\n\tunsigned char blocksize_bits;\n\tstruct {\n\t\tu8 runlist_merged:1;\n\t\tu8 mft_attr_mapped:1;\n\t\tu8 mp_rebuilt:1;\n\t\tu8 attr_switched:1;\n\t} status = { 0, 0, 0, 0 };\n\n\tBUG_ON(!nr_pages);\n\tBUG_ON(!pages);\n\tBUG_ON(!*pages);\n\tvi = pages[0]->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, start page \"\n\t\t\t\"index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.\",\n\t\t\tvi->i_ino, ni->type, pages[0]->index, nr_pages,\n\t\t\t(long long)pos, bytes);\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tu = 0;\n\tdo {\n\t\tpage = pages[u];\n\t\tBUG_ON(!page);\n\t\t/*\n\t\t * create_empty_buffers() will create uptodate/dirty buffers if\n\t\t * the page is uptodate/dirty.\n\t\t */\n\t\tif (!page_has_buffers(page)) {\n\t\t\tcreate_empty_buffers(page, blocksize, 0);\n\t\t\tif (unlikely(!page_has_buffers(page)))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t} while (++u < nr_pages);\n\trl_write_locked = false;\n\trl = NULL;\n\terr = 0;\n\tvcn = lcn = -1;\n\tvcn_len = 0;\n\tlcn_block = -1;\n\twas_hole = false;\n\tcpos = pos >> vol->cluster_size_bits;\n\tend = pos + bytes;\n\tcend = (end + vol->cluster_size - 1) >> vol->cluster_size_bits;\n\t/*\n\t * Loop over each page and for each page over each buffer.  Use goto to\n\t * reduce indentation.\n\t */\n\tu = 0;\ndo_next_page:\n\tpage = pages[u];\n\tbh_pos = (s64)page->index << PAGE_CACHE_SHIFT;\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tVCN cdelta;\n\t\ts64 bh_end;\n\t\tunsigned bh_cofs;\n\n\t\t/* Clear buffer_new on all buffers to reinitialise state. */\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tbh_end = bh_pos + blocksize;\n\t\tbh_cpos = bh_pos >> vol->cluster_size_bits;\n\t\tbh_cofs = bh_pos & vol->cluster_size_mask;\n\t\tif (buffer_mapped(bh)) {\n\t\t\t/*\n\t\t\t * The buffer is already mapped.  If it is uptodate,\n\t\t\t * ignore it.\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The buffer is not uptodate.  If the page is uptodate\n\t\t\t * set the buffer uptodate and otherwise ignore it.\n\t\t\t */\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Neither the page nor the buffer are uptodate.  If\n\t\t\t * the buffer is only partially being written to, we\n\t\t\t * need to read it in before the write, i.e. now.\n\t\t\t */\n\t\t\tif ((bh_pos < pos && bh_end > pos) ||\n\t\t\t\t\t(bh_pos < end && bh_end > end)) {\n\t\t\t\t/*\n\t\t\t\t * If the buffer is fully or partially within\n\t\t\t\t * the initialized size, do an actual read.\n\t\t\t\t * Otherwise, simply zero the buffer.\n\t\t\t\t */\n\t\t\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\t\t\tinitialized_size = ni->initialized_size;\n\t\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\t\tif (bh_pos < initialized_size) {\n\t\t\t\t\tntfs_submit_bh_for_read(bh);\n\t\t\t\t\t*wait_bh++ = bh;\n\t\t\t\t} else {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/* Unmapped buffer.  Need to map it. */\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t/*\n\t\t * If the current buffer is in the same clusters as the map\n\t\t * cache, there is no need to check the runlist again.  The\n\t\t * map cache is made up of @vcn, which is the first cached file\n\t\t * cluster, @vcn_len which is the number of cached file\n\t\t * clusters, @lcn is the device cluster corresponding to @vcn,\n\t\t * and @lcn_block is the block number corresponding to @lcn.\n\t\t */\n\t\tcdelta = bh_cpos - vcn;\n\t\tif (likely(!cdelta || (cdelta > 0 && cdelta < vcn_len))) {\nmap_buffer_cached:\n\t\t\tBUG_ON(lcn < 0);\n\t\t\tbh->b_blocknr = lcn_block +\n\t\t\t\t\t(cdelta << (vol->cluster_size_bits -\n\t\t\t\t\tblocksize_bits)) +\n\t\t\t\t\t(bh_cofs >> blocksize_bits);\n\t\t\tset_buffer_mapped(bh);\n\t\t\t/*\n\t\t\t * If the page is uptodate so is the buffer.  If the\n\t\t\t * buffer is fully outside the write, we ignore it if\n\t\t\t * it was already allocated and we mark it dirty so it\n\t\t\t * gets written out if we allocated it.  On the other\n\t\t\t * hand, if we allocated the buffer but we are not\n\t\t\t * marking it dirty we set buffer_new so we can do\n\t\t\t * error recovery.\n\t\t\t */\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tif (unlikely(was_hole)) {\n\t\t\t\t\t/* We allocated the buffer. */\n\t\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\t\tif (bh_end <= pos || bh_pos >= end)\n\t\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_buffer_new(bh);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Page is _not_ uptodate. */\n\t\t\tif (likely(!was_hole)) {\n\t\t\t\t/*\n\t\t\t\t * Buffer was already allocated.  If it is not\n\t\t\t\t * uptodate and is only partially being written\n\t\t\t\t * to, we need to read it in before the write,\n\t\t\t\t * i.e. now.\n\t\t\t\t */\n\t\t\t\tif (!buffer_uptodate(bh) && bh_pos < end &&\n\t\t\t\t\t\tbh_end > pos &&\n\t\t\t\t\t\t(bh_pos < pos ||\n\t\t\t\t\t\tbh_end > end)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If the buffer is fully or partially\n\t\t\t\t\t * within the initialized size, do an\n\t\t\t\t\t * actual read.  Otherwise, simply zero\n\t\t\t\t\t * the buffer.\n\t\t\t\t\t */\n\t\t\t\t\tread_lock_irqsave(&ni->size_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\t\tinitialized_size = ni->initialized_size;\n\t\t\t\t\tread_unlock_irqrestore(&ni->size_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\t\tif (bh_pos < initialized_size) {\n\t\t\t\t\t\tntfs_submit_bh_for_read(bh);\n\t\t\t\t\t\t*wait_bh++ = bh;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* We allocated the buffer. */\n\t\t\tunmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t\t/*\n\t\t\t * If the buffer is fully outside the write, zero it,\n\t\t\t * set it uptodate, and mark it dirty so it gets\n\t\t\t * written out.  If it is partially being written to,\n\t\t\t * zero region surrounding the write but leave it to\n\t\t\t * commit write to do anything else.  Finally, if the\n\t\t\t * buffer is fully being overwritten, do nothing.\n\t\t\t */\n\t\t\tif (bh_end <= pos || bh_pos >= end) {\n\t\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tset_buffer_new(bh);\n\t\t\tif (!buffer_uptodate(bh) &&\n\t\t\t\t\t(bh_pos < pos || bh_end > end)) {\n\t\t\t\tu8 *kaddr;\n\t\t\t\tunsigned pofs;\n\t\t\t\t\t\n\t\t\t\tkaddr = kmap_atomic(page);\n\t\t\t\tif (bh_pos < pos) {\n\t\t\t\t\tpofs = bh_pos & ~PAGE_CACHE_MASK;\n\t\t\t\t\tmemset(kaddr + pofs, 0, pos - bh_pos);\n\t\t\t\t}\n\t\t\t\tif (bh_end > end) {\n\t\t\t\t\tpofs = end & ~PAGE_CACHE_MASK;\n\t\t\t\t\tmemset(kaddr + pofs, 0, bh_end - end);\n\t\t\t\t}\n\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Slow path: this is the first buffer in the cluster.  If it\n\t\t * is outside allocated size and is not uptodate, zero it and\n\t\t * set it uptodate.\n\t\t */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tinitialized_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (bh_pos > initialized_size) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t} else if (!buffer_uptodate(bh)) {\n\t\t\t\tzero_user(page, bh_offset(bh), blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tis_retry = false;\n\t\tif (!rl) {\n\t\t\tdown_read(&ni->runlist.lock);\nretry_remap:\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t/* Seek to element containing target cluster. */\n\t\t\twhile (rl->length && rl[1].vcn <= bh_cpos)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, bh_cpos);\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/*\n\t\t\t\t * Successful remap, setup the map cache and\n\t\t\t\t * use that to deal with the buffer.\n\t\t\t\t */\n\t\t\t\twas_hole = false;\n\t\t\t\tvcn = bh_cpos;\n\t\t\t\tvcn_len = rl[1].vcn - vcn;\n\t\t\t\tlcn_block = lcn << (vol->cluster_size_bits -\n\t\t\t\t\t\tblocksize_bits);\n\t\t\t\tcdelta = 0;\n\t\t\t\t/*\n\t\t\t\t * If the number of remaining clusters touched\n\t\t\t\t * by the write is smaller or equal to the\n\t\t\t\t * number of cached clusters, unlock the\n\t\t\t\t * runlist as the map cache will be used from\n\t\t\t\t * now on.\n\t\t\t\t */\n\t\t\t\tif (likely(vcn + vcn_len >= cend)) {\n\t\t\t\t\tif (rl_write_locked) {\n\t\t\t\t\t\tup_write(&ni->runlist.lock);\n\t\t\t\t\t\trl_write_locked = false;\n\t\t\t\t\t} else\n\t\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\trl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto map_buffer_cached;\n\t\t\t}\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t/*\n\t\t * If it is not a hole and not out of bounds, the runlist is\n\t\t * probably unmapped so try to map it now.\n\t\t */\n\t\tif (unlikely(lcn != LCN_HOLE && lcn != LCN_ENOENT)) {\n\t\t\tif (likely(!is_retry && lcn == LCN_RL_NOT_MAPPED)) {\n\t\t\t\t/* Attempt to map runlist. */\n\t\t\t\tif (!rl_write_locked) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We need the runlist locked for\n\t\t\t\t\t * writing, so if it is locked for\n\t\t\t\t\t * reading relock it now and retry in\n\t\t\t\t\t * case it changed whilst we dropped\n\t\t\t\t\t * the lock.\n\t\t\t\t\t */\n\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\tdown_write(&ni->runlist.lock);\n\t\t\t\t\trl_write_locked = true;\n\t\t\t\t\tgoto retry_remap;\n\t\t\t\t}\n\t\t\t\terr = ntfs_map_runlist_nolock(ni, bh_cpos,\n\t\t\t\t\t\tNULL);\n\t\t\t\tif (likely(!err)) {\n\t\t\t\t\tis_retry = true;\n\t\t\t\t\tgoto retry_remap;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If @vcn is out of bounds, pretend @lcn is\n\t\t\t\t * LCN_ENOENT.  As long as the buffer is out\n\t\t\t\t * of bounds this will work fine.\n\t\t\t\t */\n\t\t\t\tif (err == -ENOENT) {\n\t\t\t\t\tlcn = LCN_ENOENT;\n\t\t\t\t\terr = 0;\n\t\t\t\t\tgoto rl_not_mapped_enoent;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\terr = -EIO;\n\t\t\t/* Failed to map the buffer, even after retrying. */\n\t\t\tbh->b_blocknr = -1;\n\t\t\tntfs_error(vol->sb, \"Failed to write to inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, \"\n\t\t\t\t\t\"vcn offset 0x%x, because its \"\n\t\t\t\t\t\"location on disk could not be \"\n\t\t\t\t\t\"determined%s (error code %i).\",\n\t\t\t\t\tni->mft_no, ni->type,\n\t\t\t\t\t(unsigned long long)bh_cpos,\n\t\t\t\t\t(unsigned)bh_pos &\n\t\t\t\t\tvol->cluster_size_mask,\n\t\t\t\t\tis_retry ? \" even after retrying\" : \"\",\n\t\t\t\t\terr);\n\t\t\tbreak;\n\t\t}\nrl_not_mapped_enoent:\n\t\t/*\n\t\t * The buffer is in a hole or out of bounds.  We need to fill\n\t\t * the hole, unless the buffer is in a cluster which is not\n\t\t * touched by the write, in which case we just leave the buffer\n\t\t * unmapped.  This can only happen when the cluster size is\n\t\t * less than the page cache size.\n\t\t */\n\t\tif (unlikely(vol->cluster_size < PAGE_CACHE_SIZE)) {\n\t\t\tbh_cend = (bh_end + vol->cluster_size - 1) >>\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tif ((bh_cend <= cpos || bh_cpos >= cend)) {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\t/*\n\t\t\t\t * If the buffer is uptodate we skip it.  If it\n\t\t\t\t * is not but the page is uptodate, we can set\n\t\t\t\t * the buffer uptodate.  If the page is not\n\t\t\t\t * uptodate, we can clear the buffer and set it\n\t\t\t\t * uptodate.  Whether this is worthwhile is\n\t\t\t\t * debatable and this could be removed.\n\t\t\t\t */\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t} else if (!buffer_uptodate(bh)) {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Out of bounds buffer is invalid if it was not really out of\n\t\t * bounds.\n\t\t */\n\t\tBUG_ON(lcn != LCN_HOLE);\n\t\t/*\n\t\t * We need the runlist locked for writing, so if it is locked\n\t\t * for reading relock it now and retry in case it changed\n\t\t * whilst we dropped the lock.\n\t\t */\n\t\tBUG_ON(!rl);\n\t\tif (!rl_write_locked) {\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tdown_write(&ni->runlist.lock);\n\t\t\trl_write_locked = true;\n\t\t\tgoto retry_remap;\n\t\t}\n\t\t/* Find the previous last allocated cluster. */\n\t\tBUG_ON(rl->lcn != LCN_HOLE);\n\t\tlcn = -1;\n\t\trl2 = rl;\n\t\twhile (--rl2 >= ni->runlist.rl) {\n\t\t\tif (rl2->lcn >= 0) {\n\t\t\t\tlcn = rl2->lcn + rl2->length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trl2 = ntfs_cluster_alloc(vol, bh_cpos, 1, lcn, DATA_ZONE,\n\t\t\t\tfalse);\n\t\tif (IS_ERR(rl2)) {\n\t\t\terr = PTR_ERR(rl2);\n\t\t\tntfs_debug(\"Failed to allocate cluster, error code %i.\",\n\t\t\t\t\terr);\n\t\t\tbreak;\n\t\t}\n\t\tlcn = rl2->lcn;\n\t\trl = ntfs_runlists_merge(ni->runlist.rl, rl2);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tif (err != -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to release \"\n\t\t\t\t\t\t\"allocated cluster in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover the lost cluster.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tntfs_free(rl2);\n\t\t\tbreak;\n\t\t}\n\t\tni->runlist.rl = rl;\n\t\tstatus.runlist_merged = 1;\n\t\tntfs_debug(\"Allocated cluster, lcn 0x%llx.\",\n\t\t\t\t(unsigned long long)lcn);\n\t\t/* Map and lock the mft record and get the attribute record. */\n\t\tif (!NInoAttr(ni))\n\t\t\tbase_ni = ni;\n\t\telse\n\t\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tbreak;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tunmap_mft_record(base_ni);\n\t\t\tbreak;\n\t\t}\n\t\tstatus.mft_attr_mapped = 1;\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, bh_cpos, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tm = ctx->mrec;\n\t\ta = ctx->attr;\n\t\t/*\n\t\t * Find the runlist element with which the attribute extent\n\t\t * starts.  Note, we cannot use the _attr_ version because we\n\t\t * have mapped the mft record.  That is ok because we know the\n\t\t * runlist fragment must be mapped already to have ever gotten\n\t\t * here, so we can just use the _rl_ version.\n\t\t */\n\t\tvcn = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t\trl2 = ntfs_rl_find_vcn_nolock(rl, vcn);\n\t\tBUG_ON(!rl2);\n\t\tBUG_ON(!rl2->length);\n\t\tBUG_ON(rl2->lcn < LCN_HOLE);\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\t/*\n\t\t * If @highest_vcn is zero, calculate the real highest_vcn\n\t\t * (which can really be zero).\n\t\t */\n\t\tif (!highest_vcn)\n\t\t\thighest_vcn = (sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size) >>\n\t\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * Determine the size of the mapping pairs array for the new\n\t\t * extent, i.e. the old extent with the hole filled.\n\t\t */\n\t\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, vcn,\n\t\t\t\thighest_vcn);\n\t\tif (unlikely(mp_size <= 0)) {\n\t\t\tif (!(err = mp_size))\n\t\t\t\terr = -EIO;\n\t\t\tntfs_debug(\"Failed to get size for mapping pairs \"\n\t\t\t\t\t\"array, error code %i.\", err);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Resize the attribute record to fit the new mapping pairs\n\t\t * array.\n\t\t */\n\t\tattr_rec_len = le32_to_cpu(a->length);\n\t\terr = ntfs_attr_record_resize(m, a, mp_size + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset));\n\t\tif (unlikely(err)) {\n\t\t\tBUG_ON(err != -ENOSPC);\n\t\t\t// TODO: Deal with this by using the current attribute\n\t\t\t// and fill it with as much of the mapping pairs\n\t\t\t// array as possible.  Then loop over each attribute\n\t\t\t// extent rewriting the mapping pairs arrays as we go\n\t\t\t// along and if when we reach the end we have not\n\t\t\t// enough space, try to resize the last attribute\n\t\t\t// extent and if even that fails, add a new attribute\n\t\t\t// extent.\n\t\t\t// We could also try to resize at each step in the hope\n\t\t\t// that we will not need to rewrite every single extent.\n\t\t\t// Note, we may need to decompress some extents to fill\n\t\t\t// the runlist as we are walking the extents...\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak ;\n\t\t}\n\t\tstatus.mp_rebuilt = 1;\n\t\t/*\n\t\t * Generate the mapping pairs array directly into the attribute\n\t\t * record.\n\t\t */\n\t\terr = ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\tmp_size, rl2, vcn, highest_vcn, NULL);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Cannot fill hole in inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, because building \"\n\t\t\t\t\t\"the mapping pairs failed with error \"\n\t\t\t\t\t\"code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\t/* Update the highest_vcn but only if it was not set. */\n\t\tif (unlikely(!a->data.non_resident.highest_vcn))\n\t\t\ta->data.non_resident.highest_vcn =\n\t\t\t\t\tcpu_to_sle64(highest_vcn);\n\t\t/*\n\t\t * If the attribute is sparse/compressed, update the compressed\n\t\t * size in the ntfs_inode structure and the attribute record.\n\t\t */\n\t\tif (likely(NInoSparse(ni) || NInoCompressed(ni))) {\n\t\t\t/*\n\t\t\t * If we are not in the first attribute extent, switch\n\t\t\t * to it, but first ensure the changes will make it to\n\t\t\t * disk later.\n\t\t\t */\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\t\terr = ntfs_attr_lookup(ni->type, ni->name,\n\t\t\t\t\t\tni->name_len, CASE_SENSITIVE,\n\t\t\t\t\t\t0, NULL, 0, ctx);\n\t\t\t\tif (unlikely(err)) {\n\t\t\t\t\tstatus.attr_switched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* @m is not used any more so do not set it. */\n\t\t\t\ta = ctx->attr;\n\t\t\t}\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->itype.compressed.size += vol->cluster_size;\n\t\t\ta->data.non_resident.compressed_size =\n\t\t\t\t\tcpu_to_sle64(ni->itype.compressed.size);\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t}\n\t\t/* Ensure the changes make it to disk. */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\t/* Successfully filled the hole. */\n\t\tstatus.runlist_merged = 0;\n\t\tstatus.mft_attr_mapped = 0;\n\t\tstatus.mp_rebuilt = 0;\n\t\t/* Setup the map cache and use that to deal with the buffer. */\n\t\twas_hole = true;\n\t\tvcn = bh_cpos;\n\t\tvcn_len = 1;\n\t\tlcn_block = lcn << (vol->cluster_size_bits - blocksize_bits);\n\t\tcdelta = 0;\n\t\t/*\n\t\t * If the number of remaining clusters in the @pages is smaller\n\t\t * or equal to the number of cached clusters, unlock the\n\t\t * runlist as the map cache will be used from now on.\n\t\t */\n\t\tif (likely(vcn + vcn_len >= cend)) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\trl_write_locked = false;\n\t\t\trl = NULL;\n\t\t}\n\t\tgoto map_buffer_cached;\n\t} while (bh_pos += blocksize, (bh = bh->b_this_page) != head);\n\t/* If there are no errors, do the next page. */\n\tif (likely(!err && ++u < nr_pages))\n\t\tgoto do_next_page;\n\t/* If there are no errors, release the runlist lock if we took it. */\n\tif (likely(!err)) {\n\t\tif (unlikely(rl_write_locked)) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\trl_write_locked = false;\n\t\t} else if (unlikely(rl))\n\t\t\tup_read(&ni->runlist.lock);\n\t\trl = NULL;\n\t}\n\t/* If we issued read requests, let them complete. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\twhile (wait_bh > wait) {\n\t\tbh = *--wait_bh;\n\t\twait_on_buffer(bh);\n\t\tif (likely(buffer_uptodate(bh))) {\n\t\t\tpage = bh->b_page;\n\t\t\tbh_pos = ((s64)page->index << PAGE_CACHE_SHIFT) +\n\t\t\t\t\tbh_offset(bh);\n\t\t\t/*\n\t\t\t * If the buffer overflows the initialized size, need\n\t\t\t * to zero the overflowing region.\n\t\t\t */\n\t\t\tif (unlikely(bh_pos + blocksize > initialized_size)) {\n\t\t\t\tint ofs = 0;\n\n\t\t\t\tif (likely(bh_pos < initialized_size))\n\t\t\t\t\tofs = initialized_size - bh_pos;\n\t\t\t\tzero_user_segment(page, bh_offset(bh) + ofs,\n\t\t\t\t\t\tblocksize);\n\t\t\t}\n\t\t} else /* if (unlikely(!buffer_uptodate(bh))) */\n\t\t\terr = -EIO;\n\t}\n\tif (likely(!err)) {\n\t\t/* Clear buffer_new on all buffers. */\n\t\tu = 0;\n\t\tdo {\n\t\t\tbh = head = page_buffers(pages[u]);\n\t\t\tdo {\n\t\t\t\tif (buffer_new(bh))\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t} while (++u < nr_pages);\n\t\tntfs_debug(\"Done.\");\n\t\treturn err;\n\t}\n\tif (status.attr_switched) {\n\t\t/* Get back to the attribute extent we modified. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, bh_cpos, NULL, 0, ctx)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find required \"\n\t\t\t\t\t\"attribute extent of attribute in \"\n\t\t\t\t\t\"error code path.  Run chkdsk to \"\n\t\t\t\t\t\"recover.\");\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->itype.compressed.size += vol->cluster_size;\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t\t/*\n\t\t\t * The only thing that is now wrong is the compressed\n\t\t\t * size of the base attribute extent which chkdsk\n\t\t\t * should be able to fix.\n\t\t\t */\n\t\t\tNVolSetErrors(vol);\n\t\t} else {\n\t\t\tm = ctx->mrec;\n\t\t\ta = ctx->attr;\n\t\t\tstatus.attr_switched = 0;\n\t\t}\n\t}\n\t/*\n\t * If the runlist has been modified, need to restore it by punching a\n\t * hole into it and we then need to deallocate the on-disk cluster as\n\t * well.  Note, we only modify the runlist if we are able to generate a\n\t * new mapping pairs array, i.e. only when the mapped attribute extent\n\t * is not switched.\n\t */\n\tif (status.runlist_merged && !status.attr_switched) {\n\t\tBUG_ON(!rl_write_locked);\n\t\t/* Make the file cluster we allocated sparse in the runlist. */\n\t\tif (ntfs_rl_punch_nolock(vol, &ni->runlist, bh_cpos, 1)) {\n\t\t\tntfs_error(vol->sb, \"Failed to punch hole into \"\n\t\t\t\t\t\"attribute runlist in error code \"\n\t\t\t\t\t\"path.  Run chkdsk to recover the \"\n\t\t\t\t\t\"lost cluster.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tstatus.runlist_merged = 0;\n\t\t\t/*\n\t\t\t * Deallocate the on-disk cluster we allocated but only\n\t\t\t * if we succeeded in punching its vcn out of the\n\t\t\t * runlist.\n\t\t\t */\n\t\t\tdown_write(&vol->lcnbmp_lock);\n\t\t\tif (ntfs_bitmap_clear_bit(vol->lcnbmp_ino, lcn)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to release \"\n\t\t\t\t\t\t\"allocated cluster in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover the lost cluster.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tup_write(&vol->lcnbmp_lock);\n\t\t}\n\t}\n\t/*\n\t * Resize the attribute record to its old size and rebuild the mapping\n\t * pairs array.  Note, we only can do this if the runlist has been\n\t * restored to its old state which also implies that the mapped\n\t * attribute extent is not switched.\n\t */\n\tif (status.mp_rebuilt && !status.runlist_merged) {\n\t\tif (ntfs_attr_record_resize(m, a, attr_rec_len)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), attr_rec_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), ni->runlist.rl,\n\t\t\t\t\tvcn, highest_vcn, NULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t}\n\t}\n\t/* Release the mft record and the attribute. */\n\tif (status.mft_attr_mapped) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t}\n\t/* Release the runlist lock. */\n\tif (rl_write_locked)\n\t\tup_write(&ni->runlist.lock);\n\telse if (rl)\n\t\tup_read(&ni->runlist.lock);\n\t/*\n\t * Zero out any newly allocated blocks to avoid exposing stale data.\n\t * If BH_New is set, we know that the block was newly allocated above\n\t * and that it has not been fully zeroed and marked dirty yet.\n\t */\n\tnr_pages = u;\n\tu = 0;\n\tend = bh_cpos << vol->cluster_size_bits;\n\tdo {\n\t\tpage = pages[u];\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (u == nr_pages &&\n\t\t\t\t\t((s64)page->index << PAGE_CACHE_SHIFT) +\n\t\t\t\t\tbh_offset(bh) >= end)\n\t\t\t\tbreak;\n\t\t\tif (!buffer_new(bh))\n\t\t\t\tcontinue;\n\t\t\tclear_buffer_new(bh);\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tif (PageUptodate(page))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\telse {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmark_buffer_dirty(bh);\n\t\t} while ((bh = bh->b_this_page) != head);\n\t} while (++u <= nr_pages);\n\tntfs_error(vol->sb, \"Failed.  Returning error code %i.\", err);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic int ntfs_prepare_pages_for_non_resident_write(struct page **pages,\n\t\tunsigned nr_pages, s64 pos, size_t bytes)\n{\n\tVCN vcn, highest_vcn = 0, cpos, cend, bh_cpos, bh_cend;\n\tLCN lcn;\n\ts64 bh_pos, vcn_len, end, initialized_size;\n\tsector_t lcn_block;\n\tstruct page *page;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni = NULL;\n\tntfs_volume *vol;\n\trunlist_element *rl, *rl2;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh = wait;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a = NULL;\n\tunsigned long flags;\n\tu32 attr_rec_len = 0;\n\tunsigned blocksize, u;\n\tint err, mp_size;\n\tbool rl_write_locked, was_hole, is_retry;\n\tunsigned char blocksize_bits;\n\tstruct {\n\t\tu8 runlist_merged:1;\n\t\tu8 mft_attr_mapped:1;\n\t\tu8 mp_rebuilt:1;\n\t\tu8 attr_switched:1;\n\t} status = { 0, 0, 0, 0 };\n\n\tBUG_ON(!nr_pages);\n\tBUG_ON(!pages);\n\tBUG_ON(!*pages);\n\tvi = pages[0]->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, start page \"\n\t\t\t\"index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.\",\n\t\t\tvi->i_ino, ni->type, pages[0]->index, nr_pages,\n\t\t\t(long long)pos, bytes);\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tu = 0;\n\tdo {\n\t\tpage = pages[u];\n\t\tBUG_ON(!page);\n\t\t/*\n\t\t * create_empty_buffers() will create uptodate/dirty buffers if\n\t\t * the page is uptodate/dirty.\n\t\t */\n\t\tif (!page_has_buffers(page)) {\n\t\t\tcreate_empty_buffers(page, blocksize, 0);\n\t\t\tif (unlikely(!page_has_buffers(page)))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t} while (++u < nr_pages);\n\trl_write_locked = false;\n\trl = NULL;\n\terr = 0;\n\tvcn = lcn = -1;\n\tvcn_len = 0;\n\tlcn_block = -1;\n\twas_hole = false;\n\tcpos = pos >> vol->cluster_size_bits;\n\tend = pos + bytes;\n\tcend = (end + vol->cluster_size - 1) >> vol->cluster_size_bits;\n\t/*\n\t * Loop over each page and for each page over each buffer.  Use goto to\n\t * reduce indentation.\n\t */\n\tu = 0;\ndo_next_page:\n\tpage = pages[u];\n\tbh_pos = (s64)page->index << PAGE_CACHE_SHIFT;\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tVCN cdelta;\n\t\ts64 bh_end;\n\t\tunsigned bh_cofs;\n\n\t\t/* Clear buffer_new on all buffers to reinitialise state. */\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tbh_end = bh_pos + blocksize;\n\t\tbh_cpos = bh_pos >> vol->cluster_size_bits;\n\t\tbh_cofs = bh_pos & vol->cluster_size_mask;\n\t\tif (buffer_mapped(bh)) {\n\t\t\t/*\n\t\t\t * The buffer is already mapped.  If it is uptodate,\n\t\t\t * ignore it.\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The buffer is not uptodate.  If the page is uptodate\n\t\t\t * set the buffer uptodate and otherwise ignore it.\n\t\t\t */\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Neither the page nor the buffer are uptodate.  If\n\t\t\t * the buffer is only partially being written to, we\n\t\t\t * need to read it in before the write, i.e. now.\n\t\t\t */\n\t\t\tif ((bh_pos < pos && bh_end > pos) ||\n\t\t\t\t\t(bh_pos < end && bh_end > end)) {\n\t\t\t\t/*\n\t\t\t\t * If the buffer is fully or partially within\n\t\t\t\t * the initialized size, do an actual read.\n\t\t\t\t * Otherwise, simply zero the buffer.\n\t\t\t\t */\n\t\t\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\t\t\tinitialized_size = ni->initialized_size;\n\t\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\t\tif (bh_pos < initialized_size) {\n\t\t\t\t\tntfs_submit_bh_for_read(bh);\n\t\t\t\t\t*wait_bh++ = bh;\n\t\t\t\t} else {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/* Unmapped buffer.  Need to map it. */\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t/*\n\t\t * If the current buffer is in the same clusters as the map\n\t\t * cache, there is no need to check the runlist again.  The\n\t\t * map cache is made up of @vcn, which is the first cached file\n\t\t * cluster, @vcn_len which is the number of cached file\n\t\t * clusters, @lcn is the device cluster corresponding to @vcn,\n\t\t * and @lcn_block is the block number corresponding to @lcn.\n\t\t */\n\t\tcdelta = bh_cpos - vcn;\n\t\tif (likely(!cdelta || (cdelta > 0 && cdelta < vcn_len))) {\nmap_buffer_cached:\n\t\t\tBUG_ON(lcn < 0);\n\t\t\tbh->b_blocknr = lcn_block +\n\t\t\t\t\t(cdelta << (vol->cluster_size_bits -\n\t\t\t\t\tblocksize_bits)) +\n\t\t\t\t\t(bh_cofs >> blocksize_bits);\n\t\t\tset_buffer_mapped(bh);\n\t\t\t/*\n\t\t\t * If the page is uptodate so is the buffer.  If the\n\t\t\t * buffer is fully outside the write, we ignore it if\n\t\t\t * it was already allocated and we mark it dirty so it\n\t\t\t * gets written out if we allocated it.  On the other\n\t\t\t * hand, if we allocated the buffer but we are not\n\t\t\t * marking it dirty we set buffer_new so we can do\n\t\t\t * error recovery.\n\t\t\t */\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tif (unlikely(was_hole)) {\n\t\t\t\t\t/* We allocated the buffer. */\n\t\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\t\tif (bh_end <= pos || bh_pos >= end)\n\t\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_buffer_new(bh);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Page is _not_ uptodate. */\n\t\t\tif (likely(!was_hole)) {\n\t\t\t\t/*\n\t\t\t\t * Buffer was already allocated.  If it is not\n\t\t\t\t * uptodate and is only partially being written\n\t\t\t\t * to, we need to read it in before the write,\n\t\t\t\t * i.e. now.\n\t\t\t\t */\n\t\t\t\tif (!buffer_uptodate(bh) && bh_pos < end &&\n\t\t\t\t\t\tbh_end > pos &&\n\t\t\t\t\t\t(bh_pos < pos ||\n\t\t\t\t\t\tbh_end > end)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If the buffer is fully or partially\n\t\t\t\t\t * within the initialized size, do an\n\t\t\t\t\t * actual read.  Otherwise, simply zero\n\t\t\t\t\t * the buffer.\n\t\t\t\t\t */\n\t\t\t\t\tread_lock_irqsave(&ni->size_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\t\tinitialized_size = ni->initialized_size;\n\t\t\t\t\tread_unlock_irqrestore(&ni->size_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\t\tif (bh_pos < initialized_size) {\n\t\t\t\t\t\tntfs_submit_bh_for_read(bh);\n\t\t\t\t\t\t*wait_bh++ = bh;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* We allocated the buffer. */\n\t\t\tunmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t\t/*\n\t\t\t * If the buffer is fully outside the write, zero it,\n\t\t\t * set it uptodate, and mark it dirty so it gets\n\t\t\t * written out.  If it is partially being written to,\n\t\t\t * zero region surrounding the write but leave it to\n\t\t\t * commit write to do anything else.  Finally, if the\n\t\t\t * buffer is fully being overwritten, do nothing.\n\t\t\t */\n\t\t\tif (bh_end <= pos || bh_pos >= end) {\n\t\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tset_buffer_new(bh);\n\t\t\tif (!buffer_uptodate(bh) &&\n\t\t\t\t\t(bh_pos < pos || bh_end > end)) {\n\t\t\t\tu8 *kaddr;\n\t\t\t\tunsigned pofs;\n\t\t\t\t\t\n\t\t\t\tkaddr = kmap_atomic(page);\n\t\t\t\tif (bh_pos < pos) {\n\t\t\t\t\tpofs = bh_pos & ~PAGE_CACHE_MASK;\n\t\t\t\t\tmemset(kaddr + pofs, 0, pos - bh_pos);\n\t\t\t\t}\n\t\t\t\tif (bh_end > end) {\n\t\t\t\t\tpofs = end & ~PAGE_CACHE_MASK;\n\t\t\t\t\tmemset(kaddr + pofs, 0, bh_end - end);\n\t\t\t\t}\n\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Slow path: this is the first buffer in the cluster.  If it\n\t\t * is outside allocated size and is not uptodate, zero it and\n\t\t * set it uptodate.\n\t\t */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tinitialized_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (bh_pos > initialized_size) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t} else if (!buffer_uptodate(bh)) {\n\t\t\t\tzero_user(page, bh_offset(bh), blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tis_retry = false;\n\t\tif (!rl) {\n\t\t\tdown_read(&ni->runlist.lock);\nretry_remap:\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t/* Seek to element containing target cluster. */\n\t\t\twhile (rl->length && rl[1].vcn <= bh_cpos)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, bh_cpos);\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/*\n\t\t\t\t * Successful remap, setup the map cache and\n\t\t\t\t * use that to deal with the buffer.\n\t\t\t\t */\n\t\t\t\twas_hole = false;\n\t\t\t\tvcn = bh_cpos;\n\t\t\t\tvcn_len = rl[1].vcn - vcn;\n\t\t\t\tlcn_block = lcn << (vol->cluster_size_bits -\n\t\t\t\t\t\tblocksize_bits);\n\t\t\t\tcdelta = 0;\n\t\t\t\t/*\n\t\t\t\t * If the number of remaining clusters touched\n\t\t\t\t * by the write is smaller or equal to the\n\t\t\t\t * number of cached clusters, unlock the\n\t\t\t\t * runlist as the map cache will be used from\n\t\t\t\t * now on.\n\t\t\t\t */\n\t\t\t\tif (likely(vcn + vcn_len >= cend)) {\n\t\t\t\t\tif (rl_write_locked) {\n\t\t\t\t\t\tup_write(&ni->runlist.lock);\n\t\t\t\t\t\trl_write_locked = false;\n\t\t\t\t\t} else\n\t\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\trl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto map_buffer_cached;\n\t\t\t}\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t/*\n\t\t * If it is not a hole and not out of bounds, the runlist is\n\t\t * probably unmapped so try to map it now.\n\t\t */\n\t\tif (unlikely(lcn != LCN_HOLE && lcn != LCN_ENOENT)) {\n\t\t\tif (likely(!is_retry && lcn == LCN_RL_NOT_MAPPED)) {\n\t\t\t\t/* Attempt to map runlist. */\n\t\t\t\tif (!rl_write_locked) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We need the runlist locked for\n\t\t\t\t\t * writing, so if it is locked for\n\t\t\t\t\t * reading relock it now and retry in\n\t\t\t\t\t * case it changed whilst we dropped\n\t\t\t\t\t * the lock.\n\t\t\t\t\t */\n\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\tdown_write(&ni->runlist.lock);\n\t\t\t\t\trl_write_locked = true;\n\t\t\t\t\tgoto retry_remap;\n\t\t\t\t}\n\t\t\t\terr = ntfs_map_runlist_nolock(ni, bh_cpos,\n\t\t\t\t\t\tNULL);\n\t\t\t\tif (likely(!err)) {\n\t\t\t\t\tis_retry = true;\n\t\t\t\t\tgoto retry_remap;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If @vcn is out of bounds, pretend @lcn is\n\t\t\t\t * LCN_ENOENT.  As long as the buffer is out\n\t\t\t\t * of bounds this will work fine.\n\t\t\t\t */\n\t\t\t\tif (err == -ENOENT) {\n\t\t\t\t\tlcn = LCN_ENOENT;\n\t\t\t\t\terr = 0;\n\t\t\t\t\tgoto rl_not_mapped_enoent;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\terr = -EIO;\n\t\t\t/* Failed to map the buffer, even after retrying. */\n\t\t\tbh->b_blocknr = -1;\n\t\t\tntfs_error(vol->sb, \"Failed to write to inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, \"\n\t\t\t\t\t\"vcn offset 0x%x, because its \"\n\t\t\t\t\t\"location on disk could not be \"\n\t\t\t\t\t\"determined%s (error code %i).\",\n\t\t\t\t\tni->mft_no, ni->type,\n\t\t\t\t\t(unsigned long long)bh_cpos,\n\t\t\t\t\t(unsigned)bh_pos &\n\t\t\t\t\tvol->cluster_size_mask,\n\t\t\t\t\tis_retry ? \" even after retrying\" : \"\",\n\t\t\t\t\terr);\n\t\t\tbreak;\n\t\t}\nrl_not_mapped_enoent:\n\t\t/*\n\t\t * The buffer is in a hole or out of bounds.  We need to fill\n\t\t * the hole, unless the buffer is in a cluster which is not\n\t\t * touched by the write, in which case we just leave the buffer\n\t\t * unmapped.  This can only happen when the cluster size is\n\t\t * less than the page cache size.\n\t\t */\n\t\tif (unlikely(vol->cluster_size < PAGE_CACHE_SIZE)) {\n\t\t\tbh_cend = (bh_end + vol->cluster_size - 1) >>\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tif ((bh_cend <= cpos || bh_cpos >= cend)) {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\t/*\n\t\t\t\t * If the buffer is uptodate we skip it.  If it\n\t\t\t\t * is not but the page is uptodate, we can set\n\t\t\t\t * the buffer uptodate.  If the page is not\n\t\t\t\t * uptodate, we can clear the buffer and set it\n\t\t\t\t * uptodate.  Whether this is worthwhile is\n\t\t\t\t * debatable and this could be removed.\n\t\t\t\t */\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t} else if (!buffer_uptodate(bh)) {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Out of bounds buffer is invalid if it was not really out of\n\t\t * bounds.\n\t\t */\n\t\tBUG_ON(lcn != LCN_HOLE);\n\t\t/*\n\t\t * We need the runlist locked for writing, so if it is locked\n\t\t * for reading relock it now and retry in case it changed\n\t\t * whilst we dropped the lock.\n\t\t */\n\t\tBUG_ON(!rl);\n\t\tif (!rl_write_locked) {\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tdown_write(&ni->runlist.lock);\n\t\t\trl_write_locked = true;\n\t\t\tgoto retry_remap;\n\t\t}\n\t\t/* Find the previous last allocated cluster. */\n\t\tBUG_ON(rl->lcn != LCN_HOLE);\n\t\tlcn = -1;\n\t\trl2 = rl;\n\t\twhile (--rl2 >= ni->runlist.rl) {\n\t\t\tif (rl2->lcn >= 0) {\n\t\t\t\tlcn = rl2->lcn + rl2->length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trl2 = ntfs_cluster_alloc(vol, bh_cpos, 1, lcn, DATA_ZONE,\n\t\t\t\tfalse);\n\t\tif (IS_ERR(rl2)) {\n\t\t\terr = PTR_ERR(rl2);\n\t\t\tntfs_debug(\"Failed to allocate cluster, error code %i.\",\n\t\t\t\t\terr);\n\t\t\tbreak;\n\t\t}\n\t\tlcn = rl2->lcn;\n\t\trl = ntfs_runlists_merge(ni->runlist.rl, rl2);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tif (err != -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to release \"\n\t\t\t\t\t\t\"allocated cluster in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover the lost cluster.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tntfs_free(rl2);\n\t\t\tbreak;\n\t\t}\n\t\tni->runlist.rl = rl;\n\t\tstatus.runlist_merged = 1;\n\t\tntfs_debug(\"Allocated cluster, lcn 0x%llx.\",\n\t\t\t\t(unsigned long long)lcn);\n\t\t/* Map and lock the mft record and get the attribute record. */\n\t\tif (!NInoAttr(ni))\n\t\t\tbase_ni = ni;\n\t\telse\n\t\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tbreak;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tunmap_mft_record(base_ni);\n\t\t\tbreak;\n\t\t}\n\t\tstatus.mft_attr_mapped = 1;\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, bh_cpos, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tm = ctx->mrec;\n\t\ta = ctx->attr;\n\t\t/*\n\t\t * Find the runlist element with which the attribute extent\n\t\t * starts.  Note, we cannot use the _attr_ version because we\n\t\t * have mapped the mft record.  That is ok because we know the\n\t\t * runlist fragment must be mapped already to have ever gotten\n\t\t * here, so we can just use the _rl_ version.\n\t\t */\n\t\tvcn = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t\trl2 = ntfs_rl_find_vcn_nolock(rl, vcn);\n\t\tBUG_ON(!rl2);\n\t\tBUG_ON(!rl2->length);\n\t\tBUG_ON(rl2->lcn < LCN_HOLE);\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\t/*\n\t\t * If @highest_vcn is zero, calculate the real highest_vcn\n\t\t * (which can really be zero).\n\t\t */\n\t\tif (!highest_vcn)\n\t\t\thighest_vcn = (sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size) >>\n\t\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * Determine the size of the mapping pairs array for the new\n\t\t * extent, i.e. the old extent with the hole filled.\n\t\t */\n\t\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, vcn,\n\t\t\t\thighest_vcn);\n\t\tif (unlikely(mp_size <= 0)) {\n\t\t\tif (!(err = mp_size))\n\t\t\t\terr = -EIO;\n\t\t\tntfs_debug(\"Failed to get size for mapping pairs \"\n\t\t\t\t\t\"array, error code %i.\", err);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Resize the attribute record to fit the new mapping pairs\n\t\t * array.\n\t\t */\n\t\tattr_rec_len = le32_to_cpu(a->length);\n\t\terr = ntfs_attr_record_resize(m, a, mp_size + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset));\n\t\tif (unlikely(err)) {\n\t\t\tBUG_ON(err != -ENOSPC);\n\t\t\t// TODO: Deal with this by using the current attribute\n\t\t\t// and fill it with as much of the mapping pairs\n\t\t\t// array as possible.  Then loop over each attribute\n\t\t\t// extent rewriting the mapping pairs arrays as we go\n\t\t\t// along and if when we reach the end we have not\n\t\t\t// enough space, try to resize the last attribute\n\t\t\t// extent and if even that fails, add a new attribute\n\t\t\t// extent.\n\t\t\t// We could also try to resize at each step in the hope\n\t\t\t// that we will not need to rewrite every single extent.\n\t\t\t// Note, we may need to decompress some extents to fill\n\t\t\t// the runlist as we are walking the extents...\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak ;\n\t\t}\n\t\tstatus.mp_rebuilt = 1;\n\t\t/*\n\t\t * Generate the mapping pairs array directly into the attribute\n\t\t * record.\n\t\t */\n\t\terr = ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\tmp_size, rl2, vcn, highest_vcn, NULL);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Cannot fill hole in inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, because building \"\n\t\t\t\t\t\"the mapping pairs failed with error \"\n\t\t\t\t\t\"code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\t/* Update the highest_vcn but only if it was not set. */\n\t\tif (unlikely(!a->data.non_resident.highest_vcn))\n\t\t\ta->data.non_resident.highest_vcn =\n\t\t\t\t\tcpu_to_sle64(highest_vcn);\n\t\t/*\n\t\t * If the attribute is sparse/compressed, update the compressed\n\t\t * size in the ntfs_inode structure and the attribute record.\n\t\t */\n\t\tif (likely(NInoSparse(ni) || NInoCompressed(ni))) {\n\t\t\t/*\n\t\t\t * If we are not in the first attribute extent, switch\n\t\t\t * to it, but first ensure the changes will make it to\n\t\t\t * disk later.\n\t\t\t */\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\t\terr = ntfs_attr_lookup(ni->type, ni->name,\n\t\t\t\t\t\tni->name_len, CASE_SENSITIVE,\n\t\t\t\t\t\t0, NULL, 0, ctx);\n\t\t\t\tif (unlikely(err)) {\n\t\t\t\t\tstatus.attr_switched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* @m is not used any more so do not set it. */\n\t\t\t\ta = ctx->attr;\n\t\t\t}\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->itype.compressed.size += vol->cluster_size;\n\t\t\ta->data.non_resident.compressed_size =\n\t\t\t\t\tcpu_to_sle64(ni->itype.compressed.size);\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t}\n\t\t/* Ensure the changes make it to disk. */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\t/* Successfully filled the hole. */\n\t\tstatus.runlist_merged = 0;\n\t\tstatus.mft_attr_mapped = 0;\n\t\tstatus.mp_rebuilt = 0;\n\t\t/* Setup the map cache and use that to deal with the buffer. */\n\t\twas_hole = true;\n\t\tvcn = bh_cpos;\n\t\tvcn_len = 1;\n\t\tlcn_block = lcn << (vol->cluster_size_bits - blocksize_bits);\n\t\tcdelta = 0;\n\t\t/*\n\t\t * If the number of remaining clusters in the @pages is smaller\n\t\t * or equal to the number of cached clusters, unlock the\n\t\t * runlist as the map cache will be used from now on.\n\t\t */\n\t\tif (likely(vcn + vcn_len >= cend)) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\trl_write_locked = false;\n\t\t\trl = NULL;\n\t\t}\n\t\tgoto map_buffer_cached;\n\t} while (bh_pos += blocksize, (bh = bh->b_this_page) != head);\n\t/* If there are no errors, do the next page. */\n\tif (likely(!err && ++u < nr_pages))\n\t\tgoto do_next_page;\n\t/* If there are no errors, release the runlist lock if we took it. */\n\tif (likely(!err)) {\n\t\tif (unlikely(rl_write_locked)) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\trl_write_locked = false;\n\t\t} else if (unlikely(rl))\n\t\t\tup_read(&ni->runlist.lock);\n\t\trl = NULL;\n\t}\n\t/* If we issued read requests, let them complete. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\twhile (wait_bh > wait) {\n\t\tbh = *--wait_bh;\n\t\twait_on_buffer(bh);\n\t\tif (likely(buffer_uptodate(bh))) {\n\t\t\tpage = bh->b_page;\n\t\t\tbh_pos = ((s64)page->index << PAGE_CACHE_SHIFT) +\n\t\t\t\t\tbh_offset(bh);\n\t\t\t/*\n\t\t\t * If the buffer overflows the initialized size, need\n\t\t\t * to zero the overflowing region.\n\t\t\t */\n\t\t\tif (unlikely(bh_pos + blocksize > initialized_size)) {\n\t\t\t\tint ofs = 0;\n\n\t\t\t\tif (likely(bh_pos < initialized_size))\n\t\t\t\t\tofs = initialized_size - bh_pos;\n\t\t\t\tzero_user_segment(page, bh_offset(bh) + ofs,\n\t\t\t\t\t\tblocksize);\n\t\t\t}\n\t\t} else /* if (unlikely(!buffer_uptodate(bh))) */\n\t\t\terr = -EIO;\n\t}\n\tif (likely(!err)) {\n\t\t/* Clear buffer_new on all buffers. */\n\t\tu = 0;\n\t\tdo {\n\t\t\tbh = head = page_buffers(pages[u]);\n\t\t\tdo {\n\t\t\t\tif (buffer_new(bh))\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t} while (++u < nr_pages);\n\t\tntfs_debug(\"Done.\");\n\t\treturn err;\n\t}\n\tif (status.attr_switched) {\n\t\t/* Get back to the attribute extent we modified. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, bh_cpos, NULL, 0, ctx)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find required \"\n\t\t\t\t\t\"attribute extent of attribute in \"\n\t\t\t\t\t\"error code path.  Run chkdsk to \"\n\t\t\t\t\t\"recover.\");\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->itype.compressed.size += vol->cluster_size;\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t\t/*\n\t\t\t * The only thing that is now wrong is the compressed\n\t\t\t * size of the base attribute extent which chkdsk\n\t\t\t * should be able to fix.\n\t\t\t */\n\t\t\tNVolSetErrors(vol);\n\t\t} else {\n\t\t\tm = ctx->mrec;\n\t\t\ta = ctx->attr;\n\t\t\tstatus.attr_switched = 0;\n\t\t}\n\t}\n\t/*\n\t * If the runlist has been modified, need to restore it by punching a\n\t * hole into it and we then need to deallocate the on-disk cluster as\n\t * well.  Note, we only modify the runlist if we are able to generate a\n\t * new mapping pairs array, i.e. only when the mapped attribute extent\n\t * is not switched.\n\t */\n\tif (status.runlist_merged && !status.attr_switched) {\n\t\tBUG_ON(!rl_write_locked);\n\t\t/* Make the file cluster we allocated sparse in the runlist. */\n\t\tif (ntfs_rl_punch_nolock(vol, &ni->runlist, bh_cpos, 1)) {\n\t\t\tntfs_error(vol->sb, \"Failed to punch hole into \"\n\t\t\t\t\t\"attribute runlist in error code \"\n\t\t\t\t\t\"path.  Run chkdsk to recover the \"\n\t\t\t\t\t\"lost cluster.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tstatus.runlist_merged = 0;\n\t\t\t/*\n\t\t\t * Deallocate the on-disk cluster we allocated but only\n\t\t\t * if we succeeded in punching its vcn out of the\n\t\t\t * runlist.\n\t\t\t */\n\t\t\tdown_write(&vol->lcnbmp_lock);\n\t\t\tif (ntfs_bitmap_clear_bit(vol->lcnbmp_ino, lcn)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to release \"\n\t\t\t\t\t\t\"allocated cluster in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover the lost cluster.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tup_write(&vol->lcnbmp_lock);\n\t\t}\n\t}\n\t/*\n\t * Resize the attribute record to its old size and rebuild the mapping\n\t * pairs array.  Note, we only can do this if the runlist has been\n\t * restored to its old state which also implies that the mapped\n\t * attribute extent is not switched.\n\t */\n\tif (status.mp_rebuilt && !status.runlist_merged) {\n\t\tif (ntfs_attr_record_resize(m, a, attr_rec_len)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), attr_rec_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), ni->runlist.rl,\n\t\t\t\t\tvcn, highest_vcn, NULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t}\n\t}\n\t/* Release the mft record and the attribute. */\n\tif (status.mft_attr_mapped) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t}\n\t/* Release the runlist lock. */\n\tif (rl_write_locked)\n\t\tup_write(&ni->runlist.lock);\n\telse if (rl)\n\t\tup_read(&ni->runlist.lock);\n\t/*\n\t * Zero out any newly allocated blocks to avoid exposing stale data.\n\t * If BH_New is set, we know that the block was newly allocated above\n\t * and that it has not been fully zeroed and marked dirty yet.\n\t */\n\tnr_pages = u;\n\tu = 0;\n\tend = bh_cpos << vol->cluster_size_bits;\n\tdo {\n\t\tpage = pages[u];\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (u == nr_pages &&\n\t\t\t\t\t((s64)page->index << PAGE_CACHE_SHIFT) +\n\t\t\t\t\tbh_offset(bh) >= end)\n\t\t\t\tbreak;\n\t\t\tif (!buffer_new(bh))\n\t\t\t\tcontinue;\n\t\t\tclear_buffer_new(bh);\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tif (PageUptodate(page))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\telse {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmark_buffer_dirty(bh);\n\t\t} while ((bh = bh->b_this_page) != head);\n\t} while (++u <= nr_pages);\n\tntfs_error(vol->sb, \"Failed.  Returning error code %i.\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ntfs_grab_cache_pages",
          "args": [
            "mapping",
            "start_idx",
            "do_pages",
            "pages",
            "&cached_page"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_grab_cache_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "405-445",
          "snippet": "static inline int __ntfs_grab_cache_pages(struct address_space *mapping,\n\t\tpgoff_t index, const unsigned nr_pages, struct page **pages,\n\t\tstruct page **cached_page)\n{\n\tint err, nr;\n\n\tBUG_ON(!nr_pages);\n\terr = nr = 0;\n\tdo {\n\t\tpages[nr] = find_get_page_flags(mapping, index, FGP_LOCK |\n\t\t\t\tFGP_ACCESSED);\n\t\tif (!pages[nr]) {\n\t\t\tif (!*cached_page) {\n\t\t\t\t*cached_page = page_cache_alloc(mapping);\n\t\t\t\tif (unlikely(!*cached_page)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = add_to_page_cache_lru(*cached_page, mapping, index,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tif (err == -EEXIST)\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tpages[nr] = *cached_page;\n\t\t\t*cached_page = NULL;\n\t\t}\n\t\tindex++;\n\t\tnr++;\n\t} while (nr < nr_pages);\nout:\n\treturn err;\nerr_out:\n\twhile (nr > 0) {\n\t\tunlock_page(pages[--nr]);\n\t\tpage_cache_release(pages[nr]);\n\t}\n\tgoto out;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline int __ntfs_grab_cache_pages(struct address_space *mapping,\n\t\tpgoff_t index, const unsigned nr_pages, struct page **pages,\n\t\tstruct page **cached_page)\n{\n\tint err, nr;\n\n\tBUG_ON(!nr_pages);\n\terr = nr = 0;\n\tdo {\n\t\tpages[nr] = find_get_page_flags(mapping, index, FGP_LOCK |\n\t\t\t\tFGP_ACCESSED);\n\t\tif (!pages[nr]) {\n\t\t\tif (!*cached_page) {\n\t\t\t\t*cached_page = page_cache_alloc(mapping);\n\t\t\t\tif (unlikely(!*cached_page)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = add_to_page_cache_lru(*cached_page, mapping, index,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tif (err == -EEXIST)\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tpages[nr] = *cached_page;\n\t\t\t*cached_page = NULL;\n\t\t}\n\t\tindex++;\n\t\tnr++;\n\t} while (nr < nr_pages);\nout:\n\treturn err;\nerr_out:\n\twhile (nr > 0) {\n\t\tunlock_page(pages[--nr]);\n\t\tpage_cache_release(pages[nr]);\n\t}\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_fault_in_pages_readable_iovec",
          "args": [
            "iov",
            "iov_ofs",
            "bytes"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_fault_in_pages_readable_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "372-388",
          "snippet": "static inline void ntfs_fault_in_pages_readable_iovec(const struct iovec *iov,\n\t\tsize_t iov_ofs, int bytes)\n{\n\tdo {\n\t\tconst char __user *buf;\n\t\tunsigned len;\n\n\t\tbuf = iov->iov_base + iov_ofs;\n\t\tlen = iov->iov_len - iov_ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tntfs_fault_in_pages_readable(buf, len);\n\t\tbytes -= len;\n\t\tiov++;\n\t\tiov_ofs = 0;\n\t} while (bytes);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline void ntfs_fault_in_pages_readable_iovec(const struct iovec *iov,\n\t\tsize_t iov_ofs, int bytes)\n{\n\tdo {\n\t\tconst char __user *buf;\n\t\tunsigned len;\n\n\t\tbuf = iov->iov_base + iov_ofs;\n\t\tlen = iov->iov_len - iov_ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tntfs_fault_in_pages_readable(buf, len);\n\t\tbytes -= len;\n\t\tiov++;\n\t\tiov_ofs = 0;\n\t} while (bytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_fault_in_pages_readable",
          "args": [
            "buf",
            "bytes"
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_fault_in_pages_readable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "354-365",
          "snippet": "static inline void ntfs_fault_in_pages_readable(const char __user *uaddr,\n\t\tint bytes)\n{\n\tconst char __user *end;\n\tvolatile char c;\n\n\t/* Set @end to the first byte outside the last page we care about. */\n\tend = (const char __user*)PAGE_ALIGN((unsigned long)uaddr + bytes);\n\n\twhile (!__get_user(c, uaddr) && (uaddr += PAGE_SIZE, uaddr < end))\n\t\t;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline void ntfs_fault_in_pages_readable(const char __user *uaddr,\n\t\tint bytes)\n{\n\tconst char __user *end;\n\tvolatile char c;\n\n\t/* Set @end to the first byte outside the last page we care about. */\n\tend = (const char __user*)PAGE_ALIGN((unsigned long)uaddr + bytes);\n\n\twhile (!__get_user(c, uaddr) && (uaddr += PAGE_SIZE, uaddr < end))\n\t\t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "nr_segs == 1"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Cannot \"\n\t\t\t\t\t\t\t\"perform write to \"\n\t\t\t\t\t\t\t\"inode 0x%lx, \"\n\t\t\t\t\t\t\t\"attribute type 0x%x, \"\n\t\t\t\t\t\t\t\"because the attribute \"\n\t\t\t\t\t\t\t\"is corrupt.\"",
            "vi->i_ino",
            "(unsigned)\n\t\t\t\t\t\t\tle32_to_cpu(ni->type)"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ni->type"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lcn < LCN_HOLE"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_vcn_to_lcn_nolock",
          "args": [
            "ni",
            "pos >>\n\t\t\t\t\t\tvol->cluster_size_bits",
            "false"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_vcn_to_lcn_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "341-405",
          "snippet": "LCN ntfs_attr_vcn_to_lcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tconst bool write_locked)\n{\n\tLCN lcn;\n\tunsigned long flags;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, %s_locked.\",\n\t\t\tni->mft_no, (unsigned long long)vcn,\n\t\t\twrite_locked ? \"write\" : \"read\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn LCN_ENOENT;\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\t/* Convert vcn to lcn.  If that fails map the runlist and retry once. */\n\tlcn = ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn);\n\tif (likely(lcn >= LCN_HOLE)) {\n\t\tntfs_debug(\"Done, lcn 0x%llx.\", (long long)lcn);\n\t\treturn lcn;\n\t}\n\tif (lcn != LCN_RL_NOT_MAPPED) {\n\t\tif (lcn != LCN_ENOENT)\n\t\t\tlcn = LCN_EIO;\n\t} else if (!is_retry) {\n\t\tint err;\n\n\t\tif (!write_locked) {\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tdown_write(&ni->runlist.lock);\n\t\t\tif (unlikely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) !=\n\t\t\t\t\tLCN_RL_NOT_MAPPED)) {\n\t\t\t\tup_write(&ni->runlist.lock);\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\t\tif (!write_locked) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t}\n\t\tif (likely(!err)) {\n\t\t\tis_retry = true;\n\t\t\tgoto retry_remap;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\tlcn = LCN_ENOENT;\n\t\telse if (err == -ENOMEM)\n\t\t\tlcn = LCN_ENOMEM;\n\t\telse\n\t\t\tlcn = LCN_EIO;\n\t}\n\tif (lcn != LCN_ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %lli.\",\n\t\t\t\t(long long)lcn);\n\treturn lcn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nLCN ntfs_attr_vcn_to_lcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tconst bool write_locked)\n{\n\tLCN lcn;\n\tunsigned long flags;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, %s_locked.\",\n\t\t\tni->mft_no, (unsigned long long)vcn,\n\t\t\twrite_locked ? \"write\" : \"read\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn LCN_ENOENT;\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\t/* Convert vcn to lcn.  If that fails map the runlist and retry once. */\n\tlcn = ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn);\n\tif (likely(lcn >= LCN_HOLE)) {\n\t\tntfs_debug(\"Done, lcn 0x%llx.\", (long long)lcn);\n\t\treturn lcn;\n\t}\n\tif (lcn != LCN_RL_NOT_MAPPED) {\n\t\tif (lcn != LCN_ENOENT)\n\t\t\tlcn = LCN_EIO;\n\t} else if (!is_retry) {\n\t\tint err;\n\n\t\tif (!write_locked) {\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tdown_write(&ni->runlist.lock);\n\t\t\tif (unlikely(ntfs_rl_vcn_to_lcn(ni->runlist.rl, vcn) !=\n\t\t\t\t\tLCN_RL_NOT_MAPPED)) {\n\t\t\t\tup_write(&ni->runlist.lock);\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\terr = ntfs_map_runlist_nolock(ni, vcn, NULL);\n\t\tif (!write_locked) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\tdown_read(&ni->runlist.lock);\n\t\t}\n\t\tif (likely(!err)) {\n\t\t\tis_retry = true;\n\t\t\tgoto retry_remap;\n\t\t}\n\t\tif (err == -ENOENT)\n\t\t\tlcn = LCN_ENOENT;\n\t\telse if (err == -ENOMEM)\n\t\t\tlcn = LCN_ENOMEM;\n\t\telse\n\t\t\tlcn = LCN_EIO;\n\t}\n\tif (lcn != LCN_ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %lli.\",\n\t\t\t\t(long long)lcn);\n\treturn lcn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "nr_segs == 1"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_extend_initialized",
          "args": [
            "ni",
            "pos"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_extend_initialized",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "110-330",
          "snippet": "static int ntfs_attr_extend_initialized(ntfs_inode *ni, const s64 new_init_size)\n{\n\ts64 old_init_size;\n\tloff_t old_i_size;\n\tpgoff_t index, end_index;\n\tunsigned long flags;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *kattr;\n\tint err;\n\tu32 attr_len;\n\n\tread_lock_irqsave(&ni->size_lock, flags);\n\told_init_size = ni->initialized_size;\n\told_i_size = i_size_read(vi);\n\tBUG_ON(new_init_size > ni->allocated_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_initialized_size 0x%llx, \"\n\t\t\t\"new_initialized_size 0x%llx, i_size 0x%llx.\",\n\t\t\tvi->i_ino, (unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)old_init_size,\n\t\t\t(unsigned long long)new_init_size, old_i_size);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/* Use goto to reduce indentation and we need the label below anyway. */\n\tif (NInoNonResident(ni))\n\t\tgoto do_non_resident_extend;\n\tBUG_ON(old_init_size != old_i_size);\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(a->non_resident);\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\tBUG_ON(old_i_size != (loff_t)attr_len);\n\t/*\n\t * Do the zeroing in the mft record and update the attribute size in\n\t * the mft record.\n\t */\n\tkattr = (u8*)a + le16_to_cpu(a->data.resident.value_offset);\n\tmemset(kattr + attr_len, 0, new_init_size - attr_len);\n\ta->data.resident.value_length = cpu_to_le32((u32)new_init_size);\n\t/* Finally, update the sizes in the vfs and ntfs inodes. */\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\ti_size_write(vi, new_init_size);\n\tni->initialized_size = new_init_size;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\tgoto done;\ndo_non_resident_extend:\n\t/*\n\t * If the new initialized size @new_init_size exceeds the current file\n\t * size (vfs inode->i_size), we need to extend the file size to the\n\t * new initialized size.\n\t */\n\tif (new_init_size > old_i_size) {\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tm = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tm = ctx->mrec;\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tBUG_ON(old_i_size != (loff_t)\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size));\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_init_size);\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t/* Update the file size in the vfs inode. */\n\t\ti_size_write(vi, new_init_size);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tctx = NULL;\n\t\tunmap_mft_record(base_ni);\n\t\tm = NULL;\n\t}\n\tmapping = vi->i_mapping;\n\tindex = old_init_size >> PAGE_CACHE_SHIFT;\n\tend_index = (new_init_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\t/*\n\t\t * Read the page.  If the page is not present, this will zero\n\t\t * the uninitialized regions for us.\n\t\t */\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto init_err_out;\n\t\t}\n\t\tif (unlikely(PageError(page))) {\n\t\t\tpage_cache_release(page);\n\t\t\terr = -EIO;\n\t\t\tgoto init_err_out;\n\t\t}\n\t\t/*\n\t\t * Update the initialized size in the ntfs inode.  This is\n\t\t * enough to make ntfs_writepage() work.\n\t\t */\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->initialized_size = (s64)(index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (ni->initialized_size > new_init_size)\n\t\t\tni->initialized_size = new_init_size;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t/* Set the page dirty so it gets written out. */\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t\t/*\n\t\t * Play nice with the vm and the rest of the system.  This is\n\t\t * very much needed as we can potentially be modifying the\n\t\t * initialised size from a very small value to a really huge\n\t\t * value, e.g.\n\t\t *\tf = open(somefile, O_TRUNC);\n\t\t *\ttruncate(f, 10GiB);\n\t\t *\tseek(f, 10GiB);\n\t\t *\twrite(f, 1);\n\t\t * And this would mean we would be marking dirty hundreds of\n\t\t * thousands of pages or as in the above example more than\n\t\t * two and a half million pages!\n\t\t *\n\t\t * TODO: For sparse pages could optimize this workload by using\n\t\t * the FsMisc / MiscFs page bit as a \"PageIsSparse\" bit.  This\n\t\t * would be set in readpage for sparse pages and here we would\n\t\t * not need to mark dirty any pages which have this bit set.\n\t\t * The only caveat is that we have to clear the bit everywhere\n\t\t * where we allocate any clusters that lie in the page or that\n\t\t * contain the page.\n\t\t *\n\t\t * TODO: An even greater optimization would be for us to only\n\t\t * call readpage() on pages which are not in sparse regions as\n\t\t * determined from the runlist.  This would greatly reduce the\n\t\t * number of pages we read and make dirty in the case of sparse\n\t\t * files.\n\t\t */\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t} while (++index < end_index);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tBUG_ON(ni->initialized_size != new_init_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Now bring in sync the initialized_size in the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto init_err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto init_err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto init_err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(!a->non_resident);\n\ta->data.non_resident.initialized_size = cpu_to_sle64(new_init_size);\ndone:\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done, initialized_size 0x%llx, i_size 0x%llx.\",\n\t\t\t(unsigned long long)new_init_size, i_size_read(vi));\n\treturn 0;\ninit_err_out:\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->initialized_size = old_init_size;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic int ntfs_attr_extend_initialized(ntfs_inode *ni, const s64 new_init_size)\n{\n\ts64 old_init_size;\n\tloff_t old_i_size;\n\tpgoff_t index, end_index;\n\tunsigned long flags;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *kattr;\n\tint err;\n\tu32 attr_len;\n\n\tread_lock_irqsave(&ni->size_lock, flags);\n\told_init_size = ni->initialized_size;\n\told_i_size = i_size_read(vi);\n\tBUG_ON(new_init_size > ni->allocated_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_initialized_size 0x%llx, \"\n\t\t\t\"new_initialized_size 0x%llx, i_size 0x%llx.\",\n\t\t\tvi->i_ino, (unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)old_init_size,\n\t\t\t(unsigned long long)new_init_size, old_i_size);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/* Use goto to reduce indentation and we need the label below anyway. */\n\tif (NInoNonResident(ni))\n\t\tgoto do_non_resident_extend;\n\tBUG_ON(old_init_size != old_i_size);\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(a->non_resident);\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\tBUG_ON(old_i_size != (loff_t)attr_len);\n\t/*\n\t * Do the zeroing in the mft record and update the attribute size in\n\t * the mft record.\n\t */\n\tkattr = (u8*)a + le16_to_cpu(a->data.resident.value_offset);\n\tmemset(kattr + attr_len, 0, new_init_size - attr_len);\n\ta->data.resident.value_length = cpu_to_le32((u32)new_init_size);\n\t/* Finally, update the sizes in the vfs and ntfs inodes. */\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\ti_size_write(vi, new_init_size);\n\tni->initialized_size = new_init_size;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\tgoto done;\ndo_non_resident_extend:\n\t/*\n\t * If the new initialized size @new_init_size exceeds the current file\n\t * size (vfs inode->i_size), we need to extend the file size to the\n\t * new initialized size.\n\t */\n\tif (new_init_size > old_i_size) {\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tm = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tm = ctx->mrec;\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tBUG_ON(old_i_size != (loff_t)\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size));\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_init_size);\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t/* Update the file size in the vfs inode. */\n\t\ti_size_write(vi, new_init_size);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tctx = NULL;\n\t\tunmap_mft_record(base_ni);\n\t\tm = NULL;\n\t}\n\tmapping = vi->i_mapping;\n\tindex = old_init_size >> PAGE_CACHE_SHIFT;\n\tend_index = (new_init_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\t/*\n\t\t * Read the page.  If the page is not present, this will zero\n\t\t * the uninitialized regions for us.\n\t\t */\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto init_err_out;\n\t\t}\n\t\tif (unlikely(PageError(page))) {\n\t\t\tpage_cache_release(page);\n\t\t\terr = -EIO;\n\t\t\tgoto init_err_out;\n\t\t}\n\t\t/*\n\t\t * Update the initialized size in the ntfs inode.  This is\n\t\t * enough to make ntfs_writepage() work.\n\t\t */\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->initialized_size = (s64)(index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (ni->initialized_size > new_init_size)\n\t\t\tni->initialized_size = new_init_size;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t/* Set the page dirty so it gets written out. */\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t\t/*\n\t\t * Play nice with the vm and the rest of the system.  This is\n\t\t * very much needed as we can potentially be modifying the\n\t\t * initialised size from a very small value to a really huge\n\t\t * value, e.g.\n\t\t *\tf = open(somefile, O_TRUNC);\n\t\t *\ttruncate(f, 10GiB);\n\t\t *\tseek(f, 10GiB);\n\t\t *\twrite(f, 1);\n\t\t * And this would mean we would be marking dirty hundreds of\n\t\t * thousands of pages or as in the above example more than\n\t\t * two and a half million pages!\n\t\t *\n\t\t * TODO: For sparse pages could optimize this workload by using\n\t\t * the FsMisc / MiscFs page bit as a \"PageIsSparse\" bit.  This\n\t\t * would be set in readpage for sparse pages and here we would\n\t\t * not need to mark dirty any pages which have this bit set.\n\t\t * The only caveat is that we have to clear the bit everywhere\n\t\t * where we allocate any clusters that lie in the page or that\n\t\t * contain the page.\n\t\t *\n\t\t * TODO: An even greater optimization would be for us to only\n\t\t * call readpage() on pages which are not in sparse regions as\n\t\t * determined from the runlist.  This would greatly reduce the\n\t\t * number of pages we read and make dirty in the case of sparse\n\t\t * files.\n\t\t */\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t} while (++index < end_index);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tBUG_ON(ni->initialized_size != new_init_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Now bring in sync the initialized_size in the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto init_err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto init_err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto init_err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(!a->non_resident);\n\ta->data.non_resident.initialized_size = cpu_to_sle64(new_init_size);\ndone:\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done, initialized_size 0x%llx, i_size 0x%llx.\",\n\t\t\t(unsigned long long)new_init_size, i_size_read(vi));\n\treturn 0;\ninit_err_out:\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->initialized_size = old_init_size;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Truncating write to inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x, because \"\n\t\t\t\t\t\t\"the allocation was only \"\n\t\t\t\t\t\t\"partially extended.\"",
            "vi->i_ino",
            "(unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type)"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pos >= ll"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ll >= 0"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_extend_allocation",
          "args": [
            "ni",
            "end",
            "-1",
            "pos"
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_extend_allocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1904-2471",
          "snippet": "s64 ntfs_attr_extend_allocation(ntfs_inode *ni, s64 new_alloc_size,\n\t\tconst s64 new_data_size, const s64 data_start)\n{\n\tVCN vcn;\n\ts64 ll, allocated_size, start = data_start;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\trunlist_element *rl, *rl2;\n\tunsigned long flags;\n\tint err, mp_size;\n\tu32 attr_len = 0; /* Silence stupid gcc warning. */\n\tbool mp_rebuilt;\n\n#ifdef DEBUG\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_allocated_size 0x%llx, \"\n\t\t\t\"new_allocated_size 0x%llx, new_data_size 0x%llx, \"\n\t\t\t\"data_start 0x%llx.\", vi->i_ino,\n\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)allocated_size,\n\t\t\t(unsigned long long)new_alloc_size,\n\t\t\t(unsigned long long)new_data_size,\n\t\t\t(unsigned long long)start);\n#endif\nretry_extend:\n\t/*\n\t * For non-resident attributes, @start and @new_size need to be aligned\n\t * to cluster boundaries for allocation purposes.\n\t */\n\tif (NInoNonResident(ni)) {\n\t\tif (start > 0)\n\t\t\tstart &= ~(s64)vol->cluster_size_mask;\n\t\tnew_alloc_size = (new_alloc_size + vol->cluster_size - 1) &\n\t\t\t\t~(s64)vol->cluster_size_mask;\n\t}\n\tBUG_ON(new_data_size >= 0 && new_data_size > new_alloc_size);\n\t/* Check if new size is allowed in $AttrDef. */\n\terr = ntfs_attr_size_bounds_check(vol, ni->type, new_alloc_size);\n\tif (unlikely(err)) {\n\t\t/* Only emit errors when the write will fail completely. */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size) {\n\t\t\tif (err == -ERANGE) {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the new \"\n\t\t\t\t\t\t\"allocation would exceed the \"\n\t\t\t\t\t\t\"maximum allowed size for \"\n\t\t\t\t\t\t\"this attribute type.\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because this \"\n\t\t\t\t\t\t\"attribute type is not \"\n\t\t\t\t\t\t\"defined on the NTFS volume.  \"\n\t\t\t\t\t\t\"Possible corruption!  You \"\n\t\t\t\t\t\t\"should run chkdsk!\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t}\n\t\t}\n\t\t/* Translate error code to be POSIX conformant for write(2). */\n\t\tif (err == -ERANGE)\n\t\t\terr = -EFBIG;\n\t\telse\n\t\t\terr = -EIO;\n\t\treturn err;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/*\n\t * We will be modifying both the runlist (if non-resident) and the mft\n\t * record so lock them both down.\n\t */\n\tdown_write(&ni->runlist.lock);\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * If non-resident, seek to the last extent.  If resident, there is\n\t * only one extent, so seek to that.\n\t */\n\tvcn = NInoNonResident(ni) ? allocated_size >> vol->cluster_size_bits :\n\t\t\t0;\n\t/*\n\t * Abort if someone did the work whilst we waited for the locks.  If we\n\t * just converted the attribute from resident to non-resident it is\n\t * likely that exactly this has happened already.  We cannot quite\n\t * abort if we need to update the data size.\n\t */\n\tif (unlikely(new_alloc_size <= allocated_size)) {\n\t\tntfs_debug(\"Allocated size already exceeds requested size.\");\n\t\tnew_alloc_size = allocated_size;\n\t\tif (new_data_size < 0)\n\t\t\tgoto done;\n\t\t/*\n\t\t * We want the first attribute extent so that we can update the\n\t\t * data size.\n\t\t */\n\t\tvcn = 0;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/* Use goto to reduce indentation. */\n\tif (a->non_resident)\n\t\tgoto do_non_resident_extend;\n\tBUG_ON(NInoNonResident(ni));\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\t/*\n\t * Extend the attribute record to be able to store the new attribute\n\t * size.  ntfs_attr_record_resize() will not do anything if the size is\n\t * not changing.\n\t */\n\tif (new_alloc_size < vol->mft_record_size &&\n\t\t\t!ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) +\n\t\t\tnew_alloc_size)) {\n\t\t/* The resize succeeded! */\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (new_data_size >= 0) {\n\t\t\tBUG_ON(new_data_size < attr_len);\n\t\t\ta->data.resident.value_length =\n\t\t\t\t\tcpu_to_le32((u32)new_data_size);\n\t\t}\n\t\tgoto flush_done;\n\t}\n\t/*\n\t * We have to drop all the locks so we can call\n\t * ntfs_attr_make_non_resident().  This could be optimised by try-\n\t * locking the first page cache page and only if that fails dropping\n\t * the locks, locking the page, and redoing all the locking and\n\t * lookups.  While this would be a huge optimisation, it is not worth\n\t * it as this is definitely a slow code path.\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\t/*\n\t * Not enough space in the mft record, try to make the attribute\n\t * non-resident and if successful restart the extension process.\n\t */\n\terr = ntfs_attr_make_non_resident(ni, attr_len);\n\tif (likely(!err))\n\t\tgoto retry_extend;\n\t/*\n\t * Could not make non-resident.  If this is due to this not being\n\t * permitted for this attribute type or there not being enough space,\n\t * try to make other attributes non-resident.  Otherwise fail.\n\t */\n\tif (unlikely(err != -EPERM && err != -ENOSPC)) {\n\t\t/* Only emit errors when the write will fail completely. */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the conversion from resident \"\n\t\t\t\t\t\"to non-resident attribute failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tgoto conv_err_out;\n\t}\n\t/* TODO: Not implemented from here, abort. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (start < 0 || start >= allocated_size) {\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record/on disk for the non-resident \"\n\t\t\t\t\t\"attribute value.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\telse /* if (err == -EPERM) */\n\t\t\tntfs_error(vol->sb, \"This attribute type may not be \"\n\t\t\t\t\t\"non-resident.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t}\n\terr = -EOPNOTSUPP;\n\tgoto conv_err_out;\n#if 0\n\t// TODO: Attempt to make other attributes non-resident.\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/*\n\t * Both the attribute list attribute and the standard information\n\t * attribute must remain in the base inode.  Thus, if this is one of\n\t * these attributes, we have to try to move other attributes out into\n\t * extent mft records instead.\n\t */\n\tif (ni->type == AT_ATTRIBUTE_LIST ||\n\t\t\tni->type == AT_STANDARD_INFORMATION) {\n\t\t// TODO: Attempt to move other attributes into extent mft\n\t\t// records.\n\t\terr = -EOPNOTSUPP;\n\t\tif (!err)\n\t\t\tgoto do_resident_extend;\n\t\tgoto err_out;\n\t}\n\t// TODO: Attempt to move this attribute to an extent mft record, but\n\t// only if it is not already the only attribute in an mft record in\n\t// which case there would be nothing to gain.\n\terr = -EOPNOTSUPP;\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/* There is nothing we can do to make enough space. )-: */\n\tgoto err_out;\n#endif\ndo_non_resident_extend:\n\tBUG_ON(!NInoNonResident(ni));\n\tif (new_alloc_size == allocated_size) {\n\t\tBUG_ON(vcn);\n\t\tgoto alloc_done;\n\t}\n\t/*\n\t * If the data starts after the end of the old allocation, this is a\n\t * $DATA attribute and sparse attributes are enabled on the volume and\n\t * for this inode, then create a sparse region between the old\n\t * allocated size and the start of the data.  Otherwise simply proceed\n\t * with filling the whole space between the old allocated size and the\n\t * new allocated size with clusters.\n\t */\n\tif ((start >= 0 && start <= allocated_size) || ni->type != AT_DATA ||\n\t\t\t!NVolSparseEnabled(vol) || NInoSparseDisabled(ni))\n\t\tgoto skip_sparse;\n\t// TODO: This is not implemented yet.  We just fill in with real\n\t// clusters for now...\n\tntfs_debug(\"Inserting holes is not-implemented yet.  Falling back to \"\n\t\t\t\"allocating real clusters instead.\");\nskip_sparse:\n\trl = ni->runlist.rl;\n\tif (likely(rl)) {\n\t\t/* Seek to the end of the runlist. */\n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t/* If this attribute extent is not mapped, map it now. */\n\tif (unlikely(!rl || rl->lcn == LCN_RL_NOT_MAPPED ||\n\t\t\t(rl->lcn == LCN_ENOENT && rl > ni->runlist.rl &&\n\t\t\t(rl-1)->lcn == LCN_RL_NOT_MAPPED))) {\n\t\tif (!rl && !allocated_size)\n\t\t\tgoto first_alloc;\n\t\trl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tif (start < 0 || start >= allocated_size)\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the \"\n\t\t\t\t\t\t\"mapping of a runlist \"\n\t\t\t\t\t\t\"fragment failed with error \"\n\t\t\t\t\t\t\"code %i.\", vi->i_ino,\n\t\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\t\terr);\n\t\t\tif (err != -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tni->runlist.rl = rl;\n\t\t/* Seek to the end of the runlist. */\n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t/*\n\t * We now know the runlist of the last extent is mapped and @rl is at\n\t * the end of the runlist.  We want to begin allocating clusters\n\t * starting at the last allocated cluster to reduce fragmentation.  If\n\t * there are no valid LCNs in the attribute we let the cluster\n\t * allocator choose the starting cluster.\n\t */\n\t/* If the last LCN is a hole or simillar seek back to last real LCN. */\n\twhile (rl->lcn < 0 && rl > ni->runlist.rl)\n\t\trl--;\nfirst_alloc:\n\t// FIXME: Need to implement partial allocations so at least part of the\n\t// write can be performed when start >= 0.  (Needed for POSIX write(2)\n\t// conformance.)\n\trl2 = ntfs_cluster_alloc(vol, allocated_size >> vol->cluster_size_bits,\n\t\t\t(new_alloc_size - allocated_size) >>\n\t\t\tvol->cluster_size_bits, (rl && (rl->lcn >= 0)) ?\n\t\t\trl->lcn + rl->length : -1, DATA_ZONE, true);\n\tif (IS_ERR(rl2)) {\n\t\terr = PTR_ERR(rl2);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the allocation of clusters \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM && err != -ENOSPC)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_runlists_merge(ni->runlist.rl, rl2);\n\tif (IS_ERR(rl)) {\n\t\terr = PTR_ERR(rl);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the runlist merge failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl2);\n\t\tgoto err_out;\n\t}\n\tni->runlist.rl = rl;\n\tntfs_debug(\"Allocated 0x%llx clusters.\", (long long)(new_alloc_size -\n\t\t\tallocated_size) >> vol->cluster_size_bits);\n\t/* Find the runlist element with which the attribute extent starts. */\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\trl2 = ntfs_rl_find_vcn_nolock(rl, ll);\n\tBUG_ON(!rl2);\n\tBUG_ON(!rl2->length);\n\tBUG_ON(rl2->lcn < LCN_HOLE);\n\tmp_rebuilt = false;\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\terr = mp_size;\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because determining the size for the \"\n\t\t\t\t\t\"mapping pairs failed with error code \"\n\t\t\t\t\t\"%i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Extend the attribute record to fit the bigger mapping pairs array. */\n\tattr_len = le32_to_cpu(a->length);\n\terr = ntfs_attr_record_resize(m, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(err)) {\n\t\tBUG_ON(err != -ENOSPC);\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record,\n\t\t// possibly by extending this extent partially and filling it\n\t\t// and creating a new extent for the remainder, or by making\n\t\t// other attributes non-resident and/or by moving other\n\t\t// attributes out of this mft record.\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tmp_rebuilt = true;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(err)) {\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because building the mapping pairs \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_alloc_size >>\n\t\t\tvol->cluster_size_bits) - 1);\n\t/*\n\t * We now have extended the allocated size of the attribute.  Reflect\n\t * this in the ntfs_inode structure and the attribute record.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err))\n\t\t\tgoto restore_undo_alloc;\n\t\t/* @m is not used any more so no need to set it. */\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_alloc_size;\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_alloc_size);\n\t/*\n\t * FIXME: This would fail if @ni is a directory, $MFT, or an index,\n\t * since those can have sparse/compressed set.  For example can be\n\t * set compressed even though it is not compressed itself and in that\n\t * case the bit means that files are to be created compressed in the\n\t * directory...  At present this is ok as this code is only called for\n\t * regular files, and only for their $DATA attribute(s).\n\t * FIXME: The calculation is wrong if we created a hole above.  For now\n\t * it does not matter as we never create holes.\n\t */\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size += new_alloc_size - allocated_size;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\tcpu_to_sle64(ni->itype.compressed.size);\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = new_alloc_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\nalloc_done:\n\tif (new_data_size >= 0) {\n\t\tBUG_ON(new_data_size <\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size));\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_data_size);\n\t}\nflush_done:\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\ndone:\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tntfs_debug(\"Done, new_allocated_size 0x%llx.\",\n\t\t\t(unsigned long long)new_alloc_size);\n\treturn new_alloc_size;\nrestore_undo_alloc:\n\tif (start < 0 || start >= allocated_size)\n\t\tntfs_error(vol->sb, \"Cannot complete extension of allocation \"\n\t\t\t\t\"of inode 0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\"lookup of first attribute extent failed with \"\n\t\t\t\t\"error code %i.\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\tif (err == -ENOENT)\n\t\terr = -EIO;\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len, CASE_SENSITIVE,\n\t\t\tallocated_size >> vol->cluster_size_bits, NULL, 0,\n\t\t\tctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"attribute in error code path.  Run chkdsk to \"\n\t\t\t\t\"recover.\");\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = new_alloc_size;\n\t\t/*\n\t\t * FIXME: This would fail if @ni is a directory...  See above.\n\t\t * FIXME: The calculation is wrong if we created a hole above.\n\t\t * For now it does not matter as we never create holes.\n\t\t */\n\t\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\t\tni->itype.compressed.size += new_alloc_size -\n\t\t\t\t\tallocated_size;\n\t\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t\t} else\n\t\t\tvi->i_blocks = new_alloc_size >> 9;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\tup_write(&ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is the allocated size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn err;\n\t}\n\tctx->attr->data.non_resident.highest_vcn = cpu_to_sle64(\n\t\t\t(allocated_size >> vol->cluster_size_bits) - 1);\nundo_alloc:\n\tll = allocated_size >> vol->cluster_size_bits;\n\tif (ntfs_cluster_free(ni, ll, -1, ctx) < 0) {\n\t\tntfs_error(vol->sb, \"Failed to release allocated cluster(s) \"\n\t\t\t\t\"in error code path.  Run chkdsk to recover \"\n\t\t\t\t\"the lost cluster(s).\");\n\t\tNVolSetErrors(vol);\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/*\n\t * If the runlist truncation fails and/or the search context is no\n\t * longer valid, we cannot resize the attribute record or build the\n\t * mapping pairs array thus we mark the inode bad so that no access to\n\t * the freed clusters can happen.\n\t */\n\tif (ntfs_rl_truncate_nolock(vol, &ni->runlist, ll) || IS_ERR(m)) {\n\t\tntfs_error(vol->sb, \"Failed to %s in error code path.  Run \"\n\t\t\t\t\"chkdsk to recover.\", IS_ERR(m) ?\n\t\t\t\t\"restore attribute search context\" :\n\t\t\t\t\"truncate attribute runlist\");\n\t\tNVolSetErrors(vol);\n\t} else if (mp_rebuilt) {\n\t\tif (ntfs_attr_record_resize(m, a, attr_len)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), attr_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), rl2, ll, -1,\n\t\t\t\t\tNULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t}\n\t}\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\nconv_err_out:\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\ns64 ntfs_attr_extend_allocation(ntfs_inode *ni, s64 new_alloc_size,\n\t\tconst s64 new_data_size, const s64 data_start)\n{\n\tVCN vcn;\n\ts64 ll, allocated_size, start = data_start;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_volume *vol = ni->vol;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx;\n\trunlist_element *rl, *rl2;\n\tunsigned long flags;\n\tint err, mp_size;\n\tu32 attr_len = 0; /* Silence stupid gcc warning. */\n\tbool mp_rebuilt;\n\n#ifdef DEBUG\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_allocated_size 0x%llx, \"\n\t\t\t\"new_allocated_size 0x%llx, new_data_size 0x%llx, \"\n\t\t\t\"data_start 0x%llx.\", vi->i_ino,\n\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)allocated_size,\n\t\t\t(unsigned long long)new_alloc_size,\n\t\t\t(unsigned long long)new_data_size,\n\t\t\t(unsigned long long)start);\n#endif\nretry_extend:\n\t/*\n\t * For non-resident attributes, @start and @new_size need to be aligned\n\t * to cluster boundaries for allocation purposes.\n\t */\n\tif (NInoNonResident(ni)) {\n\t\tif (start > 0)\n\t\t\tstart &= ~(s64)vol->cluster_size_mask;\n\t\tnew_alloc_size = (new_alloc_size + vol->cluster_size - 1) &\n\t\t\t\t~(s64)vol->cluster_size_mask;\n\t}\n\tBUG_ON(new_data_size >= 0 && new_data_size > new_alloc_size);\n\t/* Check if new size is allowed in $AttrDef. */\n\terr = ntfs_attr_size_bounds_check(vol, ni->type, new_alloc_size);\n\tif (unlikely(err)) {\n\t\t/* Only emit errors when the write will fail completely. */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size) {\n\t\t\tif (err == -ERANGE) {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the new \"\n\t\t\t\t\t\t\"allocation would exceed the \"\n\t\t\t\t\t\t\"maximum allowed size for \"\n\t\t\t\t\t\t\"this attribute type.\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because this \"\n\t\t\t\t\t\t\"attribute type is not \"\n\t\t\t\t\t\t\"defined on the NTFS volume.  \"\n\t\t\t\t\t\t\"Possible corruption!  You \"\n\t\t\t\t\t\t\"should run chkdsk!\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t}\n\t\t}\n\t\t/* Translate error code to be POSIX conformant for write(2). */\n\t\tif (err == -ERANGE)\n\t\t\terr = -EFBIG;\n\t\telse\n\t\t\terr = -EIO;\n\t\treturn err;\n\t}\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/*\n\t * We will be modifying both the runlist (if non-resident) and the mft\n\t * record so lock them both down.\n\t */\n\tdown_write(&ni->runlist.lock);\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/*\n\t * If non-resident, seek to the last extent.  If resident, there is\n\t * only one extent, so seek to that.\n\t */\n\tvcn = NInoNonResident(ni) ? allocated_size >> vol->cluster_size_bits :\n\t\t\t0;\n\t/*\n\t * Abort if someone did the work whilst we waited for the locks.  If we\n\t * just converted the attribute from resident to non-resident it is\n\t * likely that exactly this has happened already.  We cannot quite\n\t * abort if we need to update the data size.\n\t */\n\tif (unlikely(new_alloc_size <= allocated_size)) {\n\t\tntfs_debug(\"Allocated size already exceeds requested size.\");\n\t\tnew_alloc_size = allocated_size;\n\t\tif (new_data_size < 0)\n\t\t\tgoto done;\n\t\t/*\n\t\t * We want the first attribute extent so that we can update the\n\t\t * data size.\n\t\t */\n\t\tvcn = 0;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/* Use goto to reduce indentation. */\n\tif (a->non_resident)\n\t\tgoto do_non_resident_extend;\n\tBUG_ON(NInoNonResident(ni));\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\t/*\n\t * Extend the attribute record to be able to store the new attribute\n\t * size.  ntfs_attr_record_resize() will not do anything if the size is\n\t * not changing.\n\t */\n\tif (new_alloc_size < vol->mft_record_size &&\n\t\t\t!ntfs_attr_record_resize(m, a,\n\t\t\tle16_to_cpu(a->data.resident.value_offset) +\n\t\t\tnew_alloc_size)) {\n\t\t/* The resize succeeded! */\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (new_data_size >= 0) {\n\t\t\tBUG_ON(new_data_size < attr_len);\n\t\t\ta->data.resident.value_length =\n\t\t\t\t\tcpu_to_le32((u32)new_data_size);\n\t\t}\n\t\tgoto flush_done;\n\t}\n\t/*\n\t * We have to drop all the locks so we can call\n\t * ntfs_attr_make_non_resident().  This could be optimised by try-\n\t * locking the first page cache page and only if that fails dropping\n\t * the locks, locking the page, and redoing all the locking and\n\t * lookups.  While this would be a huge optimisation, it is not worth\n\t * it as this is definitely a slow code path.\n\t */\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\t/*\n\t * Not enough space in the mft record, try to make the attribute\n\t * non-resident and if successful restart the extension process.\n\t */\n\terr = ntfs_attr_make_non_resident(ni, attr_len);\n\tif (likely(!err))\n\t\tgoto retry_extend;\n\t/*\n\t * Could not make non-resident.  If this is due to this not being\n\t * permitted for this attribute type or there not being enough space,\n\t * try to make other attributes non-resident.  Otherwise fail.\n\t */\n\tif (unlikely(err != -EPERM && err != -ENOSPC)) {\n\t\t/* Only emit errors when the write will fail completely. */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the conversion from resident \"\n\t\t\t\t\t\"to non-resident attribute failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tgoto conv_err_out;\n\t}\n\t/* TODO: Not implemented from here, abort. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tallocated_size = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (start < 0 || start >= allocated_size) {\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record/on disk for the non-resident \"\n\t\t\t\t\t\"attribute value.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\telse /* if (err == -EPERM) */\n\t\t\tntfs_error(vol->sb, \"This attribute type may not be \"\n\t\t\t\t\t\"non-resident.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t}\n\terr = -EOPNOTSUPP;\n\tgoto conv_err_out;\n#if 0\n\t// TODO: Attempt to make other attributes non-resident.\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/*\n\t * Both the attribute list attribute and the standard information\n\t * attribute must remain in the base inode.  Thus, if this is one of\n\t * these attributes, we have to try to move other attributes out into\n\t * extent mft records instead.\n\t */\n\tif (ni->type == AT_ATTRIBUTE_LIST ||\n\t\t\tni->type == AT_STANDARD_INFORMATION) {\n\t\t// TODO: Attempt to move other attributes into extent mft\n\t\t// records.\n\t\terr = -EOPNOTSUPP;\n\t\tif (!err)\n\t\t\tgoto do_resident_extend;\n\t\tgoto err_out;\n\t}\n\t// TODO: Attempt to move this attribute to an extent mft record, but\n\t// only if it is not already the only attribute in an mft record in\n\t// which case there would be nothing to gain.\n\terr = -EOPNOTSUPP;\n\tif (!err)\n\t\tgoto do_resident_extend;\n\t/* There is nothing we can do to make enough space. )-: */\n\tgoto err_out;\n#endif\ndo_non_resident_extend:\n\tBUG_ON(!NInoNonResident(ni));\n\tif (new_alloc_size == allocated_size) {\n\t\tBUG_ON(vcn);\n\t\tgoto alloc_done;\n\t}\n\t/*\n\t * If the data starts after the end of the old allocation, this is a\n\t * $DATA attribute and sparse attributes are enabled on the volume and\n\t * for this inode, then create a sparse region between the old\n\t * allocated size and the start of the data.  Otherwise simply proceed\n\t * with filling the whole space between the old allocated size and the\n\t * new allocated size with clusters.\n\t */\n\tif ((start >= 0 && start <= allocated_size) || ni->type != AT_DATA ||\n\t\t\t!NVolSparseEnabled(vol) || NInoSparseDisabled(ni))\n\t\tgoto skip_sparse;\n\t// TODO: This is not implemented yet.  We just fill in with real\n\t// clusters for now...\n\tntfs_debug(\"Inserting holes is not-implemented yet.  Falling back to \"\n\t\t\t\"allocating real clusters instead.\");\nskip_sparse:\n\trl = ni->runlist.rl;\n\tif (likely(rl)) {\n\t\t/* Seek to the end of the runlist. */\n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t/* If this attribute extent is not mapped, map it now. */\n\tif (unlikely(!rl || rl->lcn == LCN_RL_NOT_MAPPED ||\n\t\t\t(rl->lcn == LCN_ENOENT && rl > ni->runlist.rl &&\n\t\t\t(rl-1)->lcn == LCN_RL_NOT_MAPPED))) {\n\t\tif (!rl && !allocated_size)\n\t\t\tgoto first_alloc;\n\t\trl = ntfs_mapping_pairs_decompress(vol, a, ni->runlist.rl);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tif (start < 0 || start >= allocated_size)\n\t\t\t\tntfs_error(vol->sb, \"Cannot extend allocation \"\n\t\t\t\t\t\t\"of inode 0x%lx, attribute \"\n\t\t\t\t\t\t\"type 0x%x, because the \"\n\t\t\t\t\t\t\"mapping of a runlist \"\n\t\t\t\t\t\t\"fragment failed with error \"\n\t\t\t\t\t\t\"code %i.\", vi->i_ino,\n\t\t\t\t\t\t(unsigned)le32_to_cpu(ni->type),\n\t\t\t\t\t\terr);\n\t\t\tif (err != -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tni->runlist.rl = rl;\n\t\t/* Seek to the end of the runlist. */\n\t\twhile (rl->length)\n\t\t\trl++;\n\t}\n\t/*\n\t * We now know the runlist of the last extent is mapped and @rl is at\n\t * the end of the runlist.  We want to begin allocating clusters\n\t * starting at the last allocated cluster to reduce fragmentation.  If\n\t * there are no valid LCNs in the attribute we let the cluster\n\t * allocator choose the starting cluster.\n\t */\n\t/* If the last LCN is a hole or simillar seek back to last real LCN. */\n\twhile (rl->lcn < 0 && rl > ni->runlist.rl)\n\t\trl--;\nfirst_alloc:\n\t// FIXME: Need to implement partial allocations so at least part of the\n\t// write can be performed when start >= 0.  (Needed for POSIX write(2)\n\t// conformance.)\n\trl2 = ntfs_cluster_alloc(vol, allocated_size >> vol->cluster_size_bits,\n\t\t\t(new_alloc_size - allocated_size) >>\n\t\t\tvol->cluster_size_bits, (rl && (rl->lcn >= 0)) ?\n\t\t\trl->lcn + rl->length : -1, DATA_ZONE, true);\n\tif (IS_ERR(rl2)) {\n\t\terr = PTR_ERR(rl2);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the allocation of clusters \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM && err != -ENOSPC)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_runlists_merge(ni->runlist.rl, rl2);\n\tif (IS_ERR(rl)) {\n\t\terr = PTR_ERR(rl);\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because the runlist merge failed \"\n\t\t\t\t\t\"with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\tif (err != -ENOMEM)\n\t\t\terr = -EIO;\n\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\tntfs_error(vol->sb, \"Failed to release allocated \"\n\t\t\t\t\t\"cluster(s) in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover the lost \"\n\t\t\t\t\t\"cluster(s).\");\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\tntfs_free(rl2);\n\t\tgoto err_out;\n\t}\n\tni->runlist.rl = rl;\n\tntfs_debug(\"Allocated 0x%llx clusters.\", (long long)(new_alloc_size -\n\t\t\tallocated_size) >> vol->cluster_size_bits);\n\t/* Find the runlist element with which the attribute extent starts. */\n\tll = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\trl2 = ntfs_rl_find_vcn_nolock(rl, ll);\n\tBUG_ON(!rl2);\n\tBUG_ON(!rl2->length);\n\tBUG_ON(rl2->lcn < LCN_HOLE);\n\tmp_rebuilt = false;\n\t/* Get the size for the new mapping pairs array for this extent. */\n\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, ll, -1);\n\tif (unlikely(mp_size <= 0)) {\n\t\terr = mp_size;\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because determining the size for the \"\n\t\t\t\t\t\"mapping pairs failed with error code \"\n\t\t\t\t\t\"%i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Extend the attribute record to fit the bigger mapping pairs array. */\n\tattr_len = le32_to_cpu(a->length);\n\terr = ntfs_attr_record_resize(m, a, mp_size +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset));\n\tif (unlikely(err)) {\n\t\tBUG_ON(err != -ENOSPC);\n\t\t// TODO: Deal with this by moving this extent to a new mft\n\t\t// record or by starting a new extent in a new mft record,\n\t\t// possibly by extending this extent partially and filling it\n\t\t// and creating a new extent for the remainder, or by making\n\t\t// other attributes non-resident and/or by moving other\n\t\t// attributes out of this mft record.\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto undo_alloc;\n\t}\n\tmp_rebuilt = true;\n\t/* Generate the mapping pairs array directly into the attr record. */\n\terr = ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\tle16_to_cpu(a->data.non_resident.mapping_pairs_offset),\n\t\t\tmp_size, rl2, ll, -1, NULL);\n\tif (unlikely(err)) {\n\t\tif (start < 0 || start >= allocated_size)\n\t\t\tntfs_error(vol->sb, \"Cannot extend allocation of \"\n\t\t\t\t\t\"inode 0x%lx, attribute type 0x%x, \"\n\t\t\t\t\t\"because building the mapping pairs \"\n\t\t\t\t\t\"failed with error code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\terr = -EIO;\n\t\tgoto undo_alloc;\n\t}\n\t/* Update the highest_vcn. */\n\ta->data.non_resident.highest_vcn = cpu_to_sle64((new_alloc_size >>\n\t\t\tvol->cluster_size_bits) - 1);\n\t/*\n\t * We now have extended the allocated size of the attribute.  Reflect\n\t * this in the ntfs_inode structure and the attribute record.\n\t */\n\tif (a->data.non_resident.lowest_vcn) {\n\t\t/*\n\t\t * We are not in the first attribute extent, switch to it, but\n\t\t * first ensure the changes will make it to disk later.\n\t\t */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err))\n\t\t\tgoto restore_undo_alloc;\n\t\t/* @m is not used any more so no need to set it. */\n\t\ta = ctx->attr;\n\t}\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->allocated_size = new_alloc_size;\n\ta->data.non_resident.allocated_size = cpu_to_sle64(new_alloc_size);\n\t/*\n\t * FIXME: This would fail if @ni is a directory, $MFT, or an index,\n\t * since those can have sparse/compressed set.  For example can be\n\t * set compressed even though it is not compressed itself and in that\n\t * case the bit means that files are to be created compressed in the\n\t * directory...  At present this is ok as this code is only called for\n\t * regular files, and only for their $DATA attribute(s).\n\t * FIXME: The calculation is wrong if we created a hole above.  For now\n\t * it does not matter as we never create holes.\n\t */\n\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\tni->itype.compressed.size += new_alloc_size - allocated_size;\n\t\ta->data.non_resident.compressed_size =\n\t\t\t\tcpu_to_sle64(ni->itype.compressed.size);\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t} else\n\t\tvi->i_blocks = new_alloc_size >> 9;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\nalloc_done:\n\tif (new_data_size >= 0) {\n\t\tBUG_ON(new_data_size <\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size));\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_data_size);\n\t}\nflush_done:\n\t/* Ensure the changes make it to disk. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\ndone:\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\n\tntfs_debug(\"Done, new_allocated_size 0x%llx.\",\n\t\t\t(unsigned long long)new_alloc_size);\n\treturn new_alloc_size;\nrestore_undo_alloc:\n\tif (start < 0 || start >= allocated_size)\n\t\tntfs_error(vol->sb, \"Cannot complete extension of allocation \"\n\t\t\t\t\"of inode 0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\"lookup of first attribute extent failed with \"\n\t\t\t\t\"error code %i.\", vi->i_ino,\n\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\tif (err == -ENOENT)\n\t\terr = -EIO;\n\tntfs_attr_reinit_search_ctx(ctx);\n\tif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len, CASE_SENSITIVE,\n\t\t\tallocated_size >> vol->cluster_size_bits, NULL, 0,\n\t\t\tctx)) {\n\t\tntfs_error(vol->sb, \"Failed to find last attribute extent of \"\n\t\t\t\t\"attribute in error code path.  Run chkdsk to \"\n\t\t\t\t\"recover.\");\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->allocated_size = new_alloc_size;\n\t\t/*\n\t\t * FIXME: This would fail if @ni is a directory...  See above.\n\t\t * FIXME: The calculation is wrong if we created a hole above.\n\t\t * For now it does not matter as we never create holes.\n\t\t */\n\t\tif (NInoSparse(ni) || NInoCompressed(ni)) {\n\t\t\tni->itype.compressed.size += new_alloc_size -\n\t\t\t\t\tallocated_size;\n\t\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\t\t} else\n\t\t\tvi->i_blocks = new_alloc_size >> 9;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\tup_write(&ni->runlist.lock);\n\t\t/*\n\t\t * The only thing that is now wrong is the allocated size of the\n\t\t * base attribute extent which chkdsk should be able to fix.\n\t\t */\n\t\tNVolSetErrors(vol);\n\t\treturn err;\n\t}\n\tctx->attr->data.non_resident.highest_vcn = cpu_to_sle64(\n\t\t\t(allocated_size >> vol->cluster_size_bits) - 1);\nundo_alloc:\n\tll = allocated_size >> vol->cluster_size_bits;\n\tif (ntfs_cluster_free(ni, ll, -1, ctx) < 0) {\n\t\tntfs_error(vol->sb, \"Failed to release allocated cluster(s) \"\n\t\t\t\t\"in error code path.  Run chkdsk to recover \"\n\t\t\t\t\"the lost cluster(s).\");\n\t\tNVolSetErrors(vol);\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\t/*\n\t * If the runlist truncation fails and/or the search context is no\n\t * longer valid, we cannot resize the attribute record or build the\n\t * mapping pairs array thus we mark the inode bad so that no access to\n\t * the freed clusters can happen.\n\t */\n\tif (ntfs_rl_truncate_nolock(vol, &ni->runlist, ll) || IS_ERR(m)) {\n\t\tntfs_error(vol->sb, \"Failed to %s in error code path.  Run \"\n\t\t\t\t\"chkdsk to recover.\", IS_ERR(m) ?\n\t\t\t\t\"restore attribute search context\" :\n\t\t\t\t\"truncate attribute runlist\");\n\t\tNVolSetErrors(vol);\n\t} else if (mp_rebuilt) {\n\t\tif (ntfs_attr_record_resize(m, a, attr_len)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), attr_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), rl2, ll, -1,\n\t\t\t\t\tNULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t}\n\t}\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tup_write(&ni->runlist.lock);\nconv_err_out:\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoTruncateFailed",
          "args": [
            "ni"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_truncate",
          "args": [
            "vi"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_truncate_vfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2872-2874",
          "snippet": "void ntfs_truncate_vfs(struct inode *vi) {\n\tntfs_truncate(vi);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nvoid ntfs_truncate_vfs(struct inode *vi) {\n\tntfs_truncate(vi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_dio_wait",
          "args": [
            "vi"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1941-1945",
          "snippet": "void inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_wait(struct inode *inode)\n{\n\tif (atomic_read(&inode->i_dio_count))\n\t\t__inode_dio_wait(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "NInoTruncateFailed(ni)"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoTruncateFailed",
          "args": [
            "ni"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Writing to compressed files is \"\n\t\t\t\t\t\"not implemented yet.  Sorry.\""
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->name_len"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->type != AT_DATA"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Denying write access to encrypted file.\""
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoEncrypted",
          "args": [
            "ni"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoMstProtected(ni)"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoMstProtected",
          "args": [
            "ni"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!count"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic ssize_t ntfs_file_buffered_write(struct kiocb *iocb,\n\t\tconst struct iovec *iov, unsigned long nr_segs,\n\t\tloff_t pos, loff_t *ppos, size_t count)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *vi = mapping->host;\n\tntfs_inode *ni = NTFS_I(vi);\n\tntfs_volume *vol = ni->vol;\n\tstruct page *pages[NTFS_MAX_PAGES_PER_CLUSTER];\n\tstruct page *cached_page = NULL;\n\tchar __user *buf = NULL;\n\ts64 end, ll;\n\tVCN last_vcn;\n\tLCN lcn;\n\tunsigned long flags;\n\tsize_t bytes, iov_ofs = 0;\t/* Offset in the current iovec. */\n\tssize_t status, written;\n\tunsigned nr_pages;\n\tint err;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"pos 0x%llx, count 0x%lx.\",\n\t\t\tvi->i_ino, (unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)pos, (unsigned long)count);\n\tif (unlikely(!count))\n\t\treturn 0;\n\tBUG_ON(NInoMstProtected(ni));\n\t/*\n\t * If the attribute is not an index root and it is encrypted or\n\t * compressed, we cannot write to it yet.  Note we need to check for\n\t * AT_INDEX_ALLOCATION since this is the type of both directory and\n\t * index inodes.\n\t */\n\tif (ni->type != AT_INDEX_ALLOCATION) {\n\t\t/* If file is encrypted, deny access, just like NT4. */\n\t\tif (NInoEncrypted(ni)) {\n\t\t\t/*\n\t\t\t * Reminder for later: Encrypted files are _always_\n\t\t\t * non-resident so that the content can always be\n\t\t\t * encrypted.\n\t\t\t */\n\t\t\tntfs_debug(\"Denying write access to encrypted file.\");\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (NInoCompressed(ni)) {\n\t\t\t/* Only unnamed $DATA attribute can be compressed. */\n\t\t\tBUG_ON(ni->type != AT_DATA);\n\t\t\tBUG_ON(ni->name_len);\n\t\t\t/*\n\t\t\t * Reminder for later: If resident, the data is not\n\t\t\t * actually compressed.  Only on the switch to non-\n\t\t\t * resident does compression kick in.  This is in\n\t\t\t * contrast to encrypted files (see above).\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"Writing to compressed files is \"\n\t\t\t\t\t\"not implemented yet.  Sorry.\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\t/*\n\t * If a previous ntfs_truncate() failed, repeat it and abort if it\n\t * fails again.\n\t */\n\tif (unlikely(NInoTruncateFailed(ni))) {\n\t\tinode_dio_wait(vi);\n\t\terr = ntfs_truncate(vi);\n\t\tif (err || NInoTruncateFailed(ni)) {\n\t\t\tif (!err)\n\t\t\t\terr = -EIO;\n\t\t\tntfs_error(vol->sb, \"Cannot perform write to inode \"\n\t\t\t\t\t\"0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\t\"ntfs_truncate() failed (error code \"\n\t\t\t\t\t\"%i).\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\treturn err;\n\t\t}\n\t}\n\t/* The first byte after the write. */\n\tend = pos + count;\n\t/*\n\t * If the write goes beyond the allocated size, extend the allocation\n\t * to cover the whole of the write, rounded up to the nearest cluster.\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tll = ni->allocated_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (end > ll) {\n\t\t/* Extend the allocation without changing the data size. */\n\t\tll = ntfs_attr_extend_allocation(ni, end, -1, pos);\n\t\tif (likely(ll >= 0)) {\n\t\t\tBUG_ON(pos >= ll);\n\t\t\t/* If the extension was partial truncate the write. */\n\t\t\tif (end > ll) {\n\t\t\t\tntfs_debug(\"Truncating write to inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x, because \"\n\t\t\t\t\t\t\"the allocation was only \"\n\t\t\t\t\t\t\"partially extended.\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\tend = ll;\n\t\t\t\tcount = ll - pos;\n\t\t\t}\n\t\t} else {\n\t\t\terr = ll;\n\t\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\t\tll = ni->allocated_size;\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\t/* Perform a partial write if possible or fail. */\n\t\t\tif (pos < ll) {\n\t\t\t\tntfs_debug(\"Truncating write to inode 0x%lx, \"\n\t\t\t\t\t\t\"attribute type 0x%x, because \"\n\t\t\t\t\t\t\"extending the allocation \"\n\t\t\t\t\t\t\"failed (error code %i).\",\n\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type), err);\n\t\t\t\tend = ll;\n\t\t\t\tcount = ll - pos;\n\t\t\t} else {\n\t\t\t\tntfs_error(vol->sb, \"Cannot perform write to \"\n\t\t\t\t\t\t\"inode 0x%lx, attribute type \"\n\t\t\t\t\t\t\"0x%x, because extending the \"\n\t\t\t\t\t\t\"allocation failed (error \"\n\t\t\t\t\t\t\"code %i).\", vi->i_ino,\n\t\t\t\t\t\t(unsigned)\n\t\t\t\t\t\tle32_to_cpu(ni->type), err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\twritten = 0;\n\t/*\n\t * If the write starts beyond the initialized size, extend it up to the\n\t * beginning of the write and initialize all non-sparse space between\n\t * the old initialized size and the new one.  This automatically also\n\t * increments the vfs inode->i_size to keep it above or equal to the\n\t * initialized_size.\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tll = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (pos > ll) {\n\t\terr = ntfs_attr_extend_initialized(ni, pos);\n\t\tif (err < 0) {\n\t\t\tntfs_error(vol->sb, \"Cannot perform write to inode \"\n\t\t\t\t\t\"0x%lx, attribute type 0x%x, because \"\n\t\t\t\t\t\"extending the initialized size \"\n\t\t\t\t\t\"failed (error code %i).\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\tstatus = err;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\t/*\n\t * Determine the number of pages per cluster for non-resident\n\t * attributes.\n\t */\n\tnr_pages = 1;\n\tif (vol->cluster_size > PAGE_CACHE_SIZE && NInoNonResident(ni))\n\t\tnr_pages = vol->cluster_size >> PAGE_CACHE_SHIFT;\n\t/* Finally, perform the actual write. */\n\tlast_vcn = -1;\n\tif (likely(nr_segs == 1))\n\t\tbuf = iov->iov_base;\n\tdo {\n\t\tVCN vcn;\n\t\tpgoff_t idx, start_idx;\n\t\tunsigned ofs, do_pages, u;\n\t\tsize_t copied;\n\n\t\tstart_idx = idx = pos >> PAGE_CACHE_SHIFT;\n\t\tofs = pos & ~PAGE_CACHE_MASK;\n\t\tbytes = PAGE_CACHE_SIZE - ofs;\n\t\tdo_pages = 1;\n\t\tif (nr_pages > 1) {\n\t\t\tvcn = pos >> vol->cluster_size_bits;\n\t\t\tif (vcn != last_vcn) {\n\t\t\t\tlast_vcn = vcn;\n\t\t\t\t/*\n\t\t\t\t * Get the lcn of the vcn the write is in.  If\n\t\t\t\t * it is a hole, need to lock down all pages in\n\t\t\t\t * the cluster.\n\t\t\t\t */\n\t\t\t\tdown_read(&ni->runlist.lock);\n\t\t\t\tlcn = ntfs_attr_vcn_to_lcn_nolock(ni, pos >>\n\t\t\t\t\t\tvol->cluster_size_bits, false);\n\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\tif (unlikely(lcn < LCN_HOLE)) {\n\t\t\t\t\tstatus = -EIO;\n\t\t\t\t\tif (lcn == LCN_ENOMEM)\n\t\t\t\t\t\tstatus = -ENOMEM;\n\t\t\t\t\telse\n\t\t\t\t\t\tntfs_error(vol->sb, \"Cannot \"\n\t\t\t\t\t\t\t\"perform write to \"\n\t\t\t\t\t\t\t\"inode 0x%lx, \"\n\t\t\t\t\t\t\t\"attribute type 0x%x, \"\n\t\t\t\t\t\t\t\"because the attribute \"\n\t\t\t\t\t\t\t\"is corrupt.\",\n\t\t\t\t\t\t\tvi->i_ino, (unsigned)\n\t\t\t\t\t\t\tle32_to_cpu(ni->type));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (lcn == LCN_HOLE) {\n\t\t\t\t\tstart_idx = (pos & ~(s64)\n\t\t\t\t\t\t\tvol->cluster_size_mask)\n\t\t\t\t\t\t\t>> PAGE_CACHE_SHIFT;\n\t\t\t\t\tbytes = vol->cluster_size - (pos &\n\t\t\t\t\t\t\tvol->cluster_size_mask);\n\t\t\t\t\tdo_pages = nr_pages;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bytes > count)\n\t\t\tbytes = count;\n\t\t/*\n\t\t * Bring in the user page(s) that we will copy from _first_.\n\t\t * Otherwise there is a nasty deadlock on copying from the same\n\t\t * page(s) as we are writing to, without it/them being marked\n\t\t * up-to-date.  Note, at present there is nothing to stop the\n\t\t * pages being swapped out between us bringing them into memory\n\t\t * and doing the actual copying.\n\t\t */\n\t\tif (likely(nr_segs == 1))\n\t\t\tntfs_fault_in_pages_readable(buf, bytes);\n\t\telse\n\t\t\tntfs_fault_in_pages_readable_iovec(iov, iov_ofs, bytes);\n\t\t/* Get and lock @do_pages starting at index @start_idx. */\n\t\tstatus = __ntfs_grab_cache_pages(mapping, start_idx, do_pages,\n\t\t\t\tpages, &cached_page);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\t/*\n\t\t * For non-resident attributes, we need to fill any holes with\n\t\t * actual clusters and ensure all bufferes are mapped.  We also\n\t\t * need to bring uptodate any buffers that are only partially\n\t\t * being written to.\n\t\t */\n\t\tif (NInoNonResident(ni)) {\n\t\t\tstatus = ntfs_prepare_pages_for_non_resident_write(\n\t\t\t\t\tpages, do_pages, pos, bytes);\n\t\t\tif (unlikely(status)) {\n\t\t\t\tloff_t i_size;\n\n\t\t\t\tdo {\n\t\t\t\t\tunlock_page(pages[--do_pages]);\n\t\t\t\t\tpage_cache_release(pages[do_pages]);\n\t\t\t\t} while (do_pages);\n\t\t\t\t/*\n\t\t\t\t * The write preparation may have instantiated\n\t\t\t\t * allocated space outside i_size.  Trim this\n\t\t\t\t * off again.  We can ignore any errors in this\n\t\t\t\t * case as we will just be waisting a bit of\n\t\t\t\t * allocated space, which is not a disaster.\n\t\t\t\t */\n\t\t\t\ti_size = i_size_read(vi);\n\t\t\t\tif (pos + bytes > i_size) {\n\t\t\t\t\tntfs_write_failed(mapping, pos + bytes);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tu = (pos >> PAGE_CACHE_SHIFT) - pages[0]->index;\n\t\tif (likely(nr_segs == 1)) {\n\t\t\tcopied = ntfs_copy_from_user(pages + u, do_pages - u,\n\t\t\t\t\tofs, buf, bytes);\n\t\t\tbuf += copied;\n\t\t} else\n\t\t\tcopied = ntfs_copy_from_user_iovec(pages + u,\n\t\t\t\t\tdo_pages - u, ofs, &iov, &iov_ofs,\n\t\t\t\t\tbytes);\n\t\tntfs_flush_dcache_pages(pages + u, do_pages - u);\n\t\tstatus = ntfs_commit_pages_after_write(pages, do_pages, pos,\n\t\t\t\tbytes);\n\t\tif (likely(!status)) {\n\t\t\twritten += copied;\n\t\t\tcount -= copied;\n\t\t\tpos += copied;\n\t\t\tif (unlikely(copied != bytes))\n\t\t\t\tstatus = -EFAULT;\n\t\t}\n\t\tdo {\n\t\t\tunlock_page(pages[--do_pages]);\n\t\t\tpage_cache_release(pages[do_pages]);\n\t\t} while (do_pages);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t} while (count);\nerr_out:\n\t*ppos = pos;\n\tif (cached_page)\n\t\tpage_cache_release(cached_page);\n\tntfs_debug(\"Done.  Returning %s (written 0x%lx, status %li).\",\n\t\t\twritten ? \"written\" : \"status\", (unsigned long)written,\n\t\t\t(long)status);\n\treturn written ? written : status;\n}"
  },
  {
    "function_name": "ntfs_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "1765-1773",
    "snippet": "static void ntfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tntfs_truncate_vfs(inode);\n\t}\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_truncate_vfs",
          "args": [
            "inode"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_truncate_vfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "2872-2874",
          "snippet": "void ntfs_truncate_vfs(struct inode *vi) {\n\tntfs_truncate(vi);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nvoid ntfs_truncate_vfs(struct inode *vi) {\n\tntfs_truncate(vi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic void ntfs_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tntfs_truncate_vfs(inode);\n\t}\n}"
  },
  {
    "function_name": "ntfs_commit_pages_after_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "1624-1763",
    "snippet": "static int ntfs_commit_pages_after_write(struct page **pages,\n\t\tconst unsigned nr_pages, s64 pos, size_t bytes)\n{\n\ts64 end, initialized_size;\n\tloff_t i_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tstruct page *page;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tchar *kattr, *kaddr;\n\tunsigned long flags;\n\tu32 attr_len;\n\tint err;\n\n\tBUG_ON(!nr_pages);\n\tBUG_ON(!pages);\n\tpage = pages[0];\n\tBUG_ON(!page);\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, start page \"\n\t\t\t\"index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.\",\n\t\t\tvi->i_ino, ni->type, page->index, nr_pages,\n\t\t\t(long long)pos, bytes);\n\tif (NInoNonResident(ni))\n\t\treturn ntfs_commit_pages_after_non_resident_write(pages,\n\t\t\t\tnr_pages, pos, bytes);\n\tBUG_ON(nr_pages > 1);\n\t/*\n\t * Attribute is resident, implying it is not compressed, encrypted, or\n\t * sparse.\n\t */\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tBUG_ON(NInoNonResident(ni));\n\t/* Map, pin, and lock the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\tBUG_ON(a->non_resident);\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\ti_size = i_size_read(vi);\n\tBUG_ON(attr_len != i_size);\n\tBUG_ON(pos > attr_len);\n\tend = pos + bytes;\n\tBUG_ON(end > le32_to_cpu(a->length) -\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\tkattr = (u8*)a + le16_to_cpu(a->data.resident.value_offset);\n\tkaddr = kmap_atomic(page);\n\t/* Copy the received data from the page to the mft record. */\n\tmemcpy(kattr + pos, kaddr + pos, bytes);\n\t/* Update the attribute length if necessary. */\n\tif (end > attr_len) {\n\t\tattr_len = end;\n\t\ta->data.resident.value_length = cpu_to_le32(attr_len);\n\t}\n\t/*\n\t * If the page is not uptodate, bring the out of bounds area(s)\n\t * uptodate by copying data from the mft record to the page.\n\t */\n\tif (!PageUptodate(page)) {\n\t\tif (pos > 0)\n\t\t\tmemcpy(kaddr, kattr, pos);\n\t\tif (end < attr_len)\n\t\t\tmemcpy(kaddr + end, kattr + end, attr_len - end);\n\t\t/* Zero the region outside the end of the attribute value. */\n\t\tmemset(kaddr + attr_len, 0, PAGE_CACHE_SIZE - attr_len);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap_atomic(kaddr);\n\t/* Update initialized_size/i_size if necessary. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tBUG_ON(end > ni->allocated_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tBUG_ON(initialized_size != i_size);\n\tif (end > initialized_size) {\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->initialized_size = end;\n\t\ti_size_write(vi, end);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t}\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Error allocating memory required to \"\n\t\t\t\t\"commit the write.\");\n\t\tif (PageUptodate(page)) {\n\t\t\tntfs_warning(vi->i_sb, \"Page is uptodate, setting \"\n\t\t\t\t\t\"dirty so the write will be retried \"\n\t\t\t\t\t\"later on by the VM.\");\n\t\t\t/*\n\t\t\t * Put the page on mapping->dirty_pages, but leave its\n\t\t\t * buffers' dirty state as-is.\n\t\t\t */\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tntfs_error(vi->i_sb, \"Page is not uptodate.  Written \"\n\t\t\t\t\t\"data has been lost.\");\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Resident attribute commit write failed \"\n\t\t\t\t\"with error %i.\", err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "base_ni"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "ni->vol"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Resident attribute commit write failed \"\n\t\t\t\t\"with error %i.\"",
            "err"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Page is not uptodate.  Written \"\n\t\t\t\t\t\"data has been lost.\""
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_page_dirty_nobuffers",
          "args": [
            "page"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vi->i_sb",
            "\"Page is uptodate, setting \"\n\t\t\t\t\t\"dirty so the write will be retried \"\n\t\t\t\t\t\"later on by the VM.\""
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_warning",
          "args": [
            "vi->i_sb",
            "\"Error allocating memory required to \"\n\t\t\t\t\"commit the write.\""
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "vi",
            "end"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "initialized_size != i_size"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "end > ni->allocated_size"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + attr_len",
            "0",
            "PAGE_CACHE_SIZE - attr_len"
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr + end",
            "kattr + end",
            "attr_len - end"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kaddr",
            "kattr",
            "pos"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "attr_len"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kattr + pos",
            "kaddr + pos",
            "bytes"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->data.resident.value_offset"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "end > le32_to_cpu(a->length) -\n\t\t\tle16_to_cpu(a->data.resident.value_offset)"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "a->length"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pos > attr_len"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "attr_len != i_size"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "a->non_resident"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "ni->type",
            "ni->name",
            "ni->name_len",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 1672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "m"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "NInoNonResident(ni)"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nr_pages > 1"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_commit_pages_after_non_resident_write",
          "args": [
            "pages",
            "nr_pages",
            "pos",
            "bytes"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_commit_pages_after_non_resident_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "1469-1586",
          "snippet": "static inline int ntfs_commit_pages_after_non_resident_write(\n\t\tstruct page **pages, const unsigned nr_pages,\n\t\ts64 pos, size_t bytes)\n{\n\ts64 end, initialized_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tstruct buffer_head *bh, *head;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tunsigned long flags;\n\tunsigned blocksize, u;\n\tint err;\n\n\tvi = pages[0]->mapping->host;\n\tni = NTFS_I(vi);\n\tblocksize = vi->i_sb->s_blocksize;\n\tend = pos + bytes;\n\tu = 0;\n\tdo {\n\t\ts64 bh_pos;\n\t\tstruct page *page;\n\t\tbool partial;\n\n\t\tpage = pages[u];\n\t\tbh_pos = (s64)page->index << PAGE_CACHE_SHIFT;\n\t\tbh = head = page_buffers(page);\n\t\tpartial = false;\n\t\tdo {\n\t\t\ts64 bh_end;\n\n\t\t\tbh_end = bh_pos + blocksize;\n\t\t\tif (bh_end <= pos || bh_pos >= end) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tpartial = true;\n\t\t\t} else {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t} while (bh_pos += blocksize, (bh = bh->b_this_page) != head);\n\t\t/*\n\t\t * If all buffers are now uptodate but the page is not, set the\n\t\t * page uptodate.\n\t\t */\n\t\tif (!partial && !PageUptodate(page))\n\t\t\tSetPageUptodate(page);\n\t} while (++u < nr_pages);\n\t/*\n\t * Finally, if we do not need to update initialized_size or i_size we\n\t * are finished.\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (end <= initialized_size) {\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/*\n\t * Update initialized_size/i_size as appropriate, both in the inode and\n\t * the mft record.\n\t */\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/* Map, pin, and lock the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tBUG_ON(!NInoNonResident(ni));\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\tBUG_ON(!a->non_resident);\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tBUG_ON(end > ni->allocated_size);\n\tni->initialized_size = end;\n\ta->data.non_resident.initialized_size = cpu_to_sle64(end);\n\tif (end > i_size_read(vi)) {\n\t\ti_size_write(vi, end);\n\t\ta->data.non_resident.data_size =\n\t\t\t\ta->data.non_resident.initialized_size;\n\t}\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_error(vi->i_sb, \"Failed to update initialized_size/i_size (error \"\n\t\t\t\"code %i).\", err);\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(ni->vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline int ntfs_commit_pages_after_non_resident_write(\n\t\tstruct page **pages, const unsigned nr_pages,\n\t\ts64 pos, size_t bytes)\n{\n\ts64 end, initialized_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tstruct buffer_head *bh, *head;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tunsigned long flags;\n\tunsigned blocksize, u;\n\tint err;\n\n\tvi = pages[0]->mapping->host;\n\tni = NTFS_I(vi);\n\tblocksize = vi->i_sb->s_blocksize;\n\tend = pos + bytes;\n\tu = 0;\n\tdo {\n\t\ts64 bh_pos;\n\t\tstruct page *page;\n\t\tbool partial;\n\n\t\tpage = pages[u];\n\t\tbh_pos = (s64)page->index << PAGE_CACHE_SHIFT;\n\t\tbh = head = page_buffers(page);\n\t\tpartial = false;\n\t\tdo {\n\t\t\ts64 bh_end;\n\n\t\t\tbh_end = bh_pos + blocksize;\n\t\t\tif (bh_end <= pos || bh_pos >= end) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tpartial = true;\n\t\t\t} else {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t} while (bh_pos += blocksize, (bh = bh->b_this_page) != head);\n\t\t/*\n\t\t * If all buffers are now uptodate but the page is not, set the\n\t\t * page uptodate.\n\t\t */\n\t\tif (!partial && !PageUptodate(page))\n\t\t\tSetPageUptodate(page);\n\t} while (++u < nr_pages);\n\t/*\n\t * Finally, if we do not need to update initialized_size or i_size we\n\t * are finished.\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (end <= initialized_size) {\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/*\n\t * Update initialized_size/i_size as appropriate, both in the inode and\n\t * the mft record.\n\t */\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/* Map, pin, and lock the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tBUG_ON(!NInoNonResident(ni));\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\tBUG_ON(!a->non_resident);\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tBUG_ON(end > ni->allocated_size);\n\tni->initialized_size = end;\n\ta->data.non_resident.initialized_size = cpu_to_sle64(end);\n\tif (end > i_size_read(vi)) {\n\t\ti_size_write(vi, end);\n\t\ta->data.non_resident.data_size =\n\t\t\t\ta->data.non_resident.initialized_size;\n\t}\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_error(vi->i_sb, \"Failed to update initialized_size/i_size (error \"\n\t\t\t\"code %i).\", err);\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(ni->vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx, attribute type 0x%x, start page \"\n\t\t\t\"index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.\"",
            "vi->i_ino",
            "ni->type",
            "page->index",
            "nr_pages",
            "(long long)pos",
            "bytes"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!pages"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!nr_pages"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic int ntfs_commit_pages_after_write(struct page **pages,\n\t\tconst unsigned nr_pages, s64 pos, size_t bytes)\n{\n\ts64 end, initialized_size;\n\tloff_t i_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tstruct page *page;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tchar *kattr, *kaddr;\n\tunsigned long flags;\n\tu32 attr_len;\n\tint err;\n\n\tBUG_ON(!nr_pages);\n\tBUG_ON(!pages);\n\tpage = pages[0];\n\tBUG_ON(!page);\n\tvi = page->mapping->host;\n\tni = NTFS_I(vi);\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, start page \"\n\t\t\t\"index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.\",\n\t\t\tvi->i_ino, ni->type, page->index, nr_pages,\n\t\t\t(long long)pos, bytes);\n\tif (NInoNonResident(ni))\n\t\treturn ntfs_commit_pages_after_non_resident_write(pages,\n\t\t\t\tnr_pages, pos, bytes);\n\tBUG_ON(nr_pages > 1);\n\t/*\n\t * Attribute is resident, implying it is not compressed, encrypted, or\n\t * sparse.\n\t */\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tBUG_ON(NInoNonResident(ni));\n\t/* Map, pin, and lock the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\tBUG_ON(a->non_resident);\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\ti_size = i_size_read(vi);\n\tBUG_ON(attr_len != i_size);\n\tBUG_ON(pos > attr_len);\n\tend = pos + bytes;\n\tBUG_ON(end > le32_to_cpu(a->length) -\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\tkattr = (u8*)a + le16_to_cpu(a->data.resident.value_offset);\n\tkaddr = kmap_atomic(page);\n\t/* Copy the received data from the page to the mft record. */\n\tmemcpy(kattr + pos, kaddr + pos, bytes);\n\t/* Update the attribute length if necessary. */\n\tif (end > attr_len) {\n\t\tattr_len = end;\n\t\ta->data.resident.value_length = cpu_to_le32(attr_len);\n\t}\n\t/*\n\t * If the page is not uptodate, bring the out of bounds area(s)\n\t * uptodate by copying data from the mft record to the page.\n\t */\n\tif (!PageUptodate(page)) {\n\t\tif (pos > 0)\n\t\t\tmemcpy(kaddr, kattr, pos);\n\t\tif (end < attr_len)\n\t\t\tmemcpy(kaddr + end, kattr + end, attr_len - end);\n\t\t/* Zero the region outside the end of the attribute value. */\n\t\tmemset(kaddr + attr_len, 0, PAGE_CACHE_SIZE - attr_len);\n\t\tflush_dcache_page(page);\n\t\tSetPageUptodate(page);\n\t}\n\tkunmap_atomic(kaddr);\n\t/* Update initialized_size/i_size if necessary. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tBUG_ON(end > ni->allocated_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tBUG_ON(initialized_size != i_size);\n\tif (end > initialized_size) {\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->initialized_size = end;\n\t\ti_size_write(vi, end);\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t}\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nerr_out:\n\tif (err == -ENOMEM) {\n\t\tntfs_warning(vi->i_sb, \"Error allocating memory required to \"\n\t\t\t\t\"commit the write.\");\n\t\tif (PageUptodate(page)) {\n\t\t\tntfs_warning(vi->i_sb, \"Page is uptodate, setting \"\n\t\t\t\t\t\"dirty so the write will be retried \"\n\t\t\t\t\t\"later on by the VM.\");\n\t\t\t/*\n\t\t\t * Put the page on mapping->dirty_pages, but leave its\n\t\t\t * buffers' dirty state as-is.\n\t\t\t */\n\t\t\t__set_page_dirty_nobuffers(page);\n\t\t\terr = 0;\n\t\t} else\n\t\t\tntfs_error(vi->i_sb, \"Page is not uptodate.  Written \"\n\t\t\t\t\t\"data has been lost.\");\n\t} else {\n\t\tntfs_error(vi->i_sb, \"Resident attribute commit write failed \"\n\t\t\t\t\"with error %i.\", err);\n\t\tNVolSetErrors(ni->vol);\n\t}\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_commit_pages_after_non_resident_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "1469-1586",
    "snippet": "static inline int ntfs_commit_pages_after_non_resident_write(\n\t\tstruct page **pages, const unsigned nr_pages,\n\t\ts64 pos, size_t bytes)\n{\n\ts64 end, initialized_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tstruct buffer_head *bh, *head;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tunsigned long flags;\n\tunsigned blocksize, u;\n\tint err;\n\n\tvi = pages[0]->mapping->host;\n\tni = NTFS_I(vi);\n\tblocksize = vi->i_sb->s_blocksize;\n\tend = pos + bytes;\n\tu = 0;\n\tdo {\n\t\ts64 bh_pos;\n\t\tstruct page *page;\n\t\tbool partial;\n\n\t\tpage = pages[u];\n\t\tbh_pos = (s64)page->index << PAGE_CACHE_SHIFT;\n\t\tbh = head = page_buffers(page);\n\t\tpartial = false;\n\t\tdo {\n\t\t\ts64 bh_end;\n\n\t\t\tbh_end = bh_pos + blocksize;\n\t\t\tif (bh_end <= pos || bh_pos >= end) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tpartial = true;\n\t\t\t} else {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t} while (bh_pos += blocksize, (bh = bh->b_this_page) != head);\n\t\t/*\n\t\t * If all buffers are now uptodate but the page is not, set the\n\t\t * page uptodate.\n\t\t */\n\t\tif (!partial && !PageUptodate(page))\n\t\t\tSetPageUptodate(page);\n\t} while (++u < nr_pages);\n\t/*\n\t * Finally, if we do not need to update initialized_size or i_size we\n\t * are finished.\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (end <= initialized_size) {\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/*\n\t * Update initialized_size/i_size as appropriate, both in the inode and\n\t * the mft record.\n\t */\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/* Map, pin, and lock the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tBUG_ON(!NInoNonResident(ni));\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\tBUG_ON(!a->non_resident);\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tBUG_ON(end > ni->allocated_size);\n\tni->initialized_size = end;\n\ta->data.non_resident.initialized_size = cpu_to_sle64(end);\n\tif (end > i_size_read(vi)) {\n\t\ti_size_write(vi, end);\n\t\ta->data.non_resident.data_size =\n\t\t\t\ta->data.non_resident.initialized_size;\n\t}\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_error(vi->i_sb, \"Failed to update initialized_size/i_size (error \"\n\t\t\t\"code %i).\", err);\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(ni->vol);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "ni->vol"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vi->i_sb",
            "\"Failed to update initialized_size/i_size (error \"\n\t\t\t\"code %i).\"",
            "err"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "base_ni"
          ],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "vi",
            "end"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_sle64",
          "args": [
            "end"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_sle64p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "88-91",
          "snippet": "static inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "end > ni->allocated_size"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!a->non_resident"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "ni->type",
            "ni->name",
            "ni->name_len",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "m"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!NInoNonResident(ni)"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1507
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline int ntfs_commit_pages_after_non_resident_write(\n\t\tstruct page **pages, const unsigned nr_pages,\n\t\ts64 pos, size_t bytes)\n{\n\ts64 end, initialized_size;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni;\n\tstruct buffer_head *bh, *head;\n\tntfs_attr_search_ctx *ctx;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tunsigned long flags;\n\tunsigned blocksize, u;\n\tint err;\n\n\tvi = pages[0]->mapping->host;\n\tni = NTFS_I(vi);\n\tblocksize = vi->i_sb->s_blocksize;\n\tend = pos + bytes;\n\tu = 0;\n\tdo {\n\t\ts64 bh_pos;\n\t\tstruct page *page;\n\t\tbool partial;\n\n\t\tpage = pages[u];\n\t\tbh_pos = (s64)page->index << PAGE_CACHE_SHIFT;\n\t\tbh = head = page_buffers(page);\n\t\tpartial = false;\n\t\tdo {\n\t\t\ts64 bh_end;\n\n\t\t\tbh_end = bh_pos + blocksize;\n\t\t\tif (bh_end <= pos || bh_pos >= end) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tpartial = true;\n\t\t\t} else {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t}\n\t\t} while (bh_pos += blocksize, (bh = bh->b_this_page) != head);\n\t\t/*\n\t\t * If all buffers are now uptodate but the page is not, set the\n\t\t * page uptodate.\n\t\t */\n\t\tif (!partial && !PageUptodate(page))\n\t\t\tSetPageUptodate(page);\n\t} while (++u < nr_pages);\n\t/*\n\t * Finally, if we do not need to update initialized_size or i_size we\n\t * are finished.\n\t */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tif (end <= initialized_size) {\n\t\tntfs_debug(\"Done.\");\n\t\treturn 0;\n\t}\n\t/*\n\t * Update initialized_size/i_size as appropriate, both in the inode and\n\t * the mft record.\n\t */\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/* Map, pin, and lock the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\tgoto err_out;\n\t}\n\tBUG_ON(!NInoNonResident(ni));\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\ta = ctx->attr;\n\tBUG_ON(!a->non_resident);\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tBUG_ON(end > ni->allocated_size);\n\tni->initialized_size = end;\n\ta->data.non_resident.initialized_size = cpu_to_sle64(end);\n\tif (end > i_size_read(vi)) {\n\t\ti_size_write(vi, end);\n\t\ta->data.non_resident.data_size =\n\t\t\t\ta->data.non_resident.initialized_size;\n\t}\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Mark the mft record dirty, so it gets written back. */\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tntfs_attr_put_search_ctx(ctx);\n\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done.\");\n\treturn 0;\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_error(vi->i_sb, \"Failed to update initialized_size/i_size (error \"\n\t\t\t\"code %i).\", err);\n\tif (err != -ENOMEM)\n\t\tNVolSetErrors(ni->vol);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_flush_dcache_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "1445-1458",
    "snippet": "static inline void ntfs_flush_dcache_pages(struct page **pages,\n\t\tunsigned nr_pages)\n{\n\tBUG_ON(!nr_pages);\n\t/*\n\t * Warning: Do not do the decrement at the same time as the call to\n\t * flush_dcache_page() because it is a NULL macro on i386 and hence the\n\t * decrement never happens so the loop never terminates.\n\t */\n\tdo {\n\t\t--nr_pages;\n\t\tflush_dcache_page(pages[nr_pages]);\n\t} while (nr_pages > 0);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "pages[nr_pages]"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!nr_pages"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline void ntfs_flush_dcache_pages(struct page **pages,\n\t\tunsigned nr_pages)\n{\n\tBUG_ON(!nr_pages);\n\t/*\n\t * Warning: Do not do the decrement at the same time as the call to\n\t * flush_dcache_page() because it is a NULL macro on i386 and hence the\n\t * decrement never happens so the loop never terminates.\n\t */\n\tdo {\n\t\t--nr_pages;\n\t\tflush_dcache_page(pages[nr_pages]);\n\t} while (nr_pages > 0);\n}"
  },
  {
    "function_name": "ntfs_copy_from_user_iovec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "1392-1443",
    "snippet": "static inline size_t ntfs_copy_from_user_iovec(struct page **pages,\n\t\tunsigned nr_pages, unsigned ofs, const struct iovec **iov,\n\t\tsize_t *iov_ofs, size_t bytes)\n{\n\tstruct page **last_page = pages + nr_pages;\n\tchar *addr;\n\tsize_t copied, len, total = 0;\n\n\tdo {\n\t\tlen = PAGE_CACHE_SIZE - ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\taddr = kmap_atomic(*pages);\n\t\tcopied = __ntfs_copy_from_user_iovec_inatomic(addr + ofs,\n\t\t\t\t*iov, *iov_ofs, len);\n\t\tkunmap_atomic(addr);\n\t\tif (unlikely(copied != len)) {\n\t\t\t/* Do it the slow way. */\n\t\t\taddr = kmap(*pages);\n\t\t\tcopied = __ntfs_copy_from_user_iovec_inatomic(addr +\n\t\t\t\t\tofs, *iov, *iov_ofs, len);\n\t\t\tif (unlikely(copied != len))\n\t\t\t\tgoto err_out;\n\t\t\tkunmap(*pages);\n\t\t}\n\t\ttotal += len;\n\t\tntfs_set_next_iovec(iov, iov_ofs, len);\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tofs = 0;\n\t} while (++pages < last_page);\nout:\n\treturn total;\nerr_out:\n\tBUG_ON(copied > len);\n\t/* Zero the rest of the target like __copy_from_user(). */\n\tmemset(addr + ofs + copied, 0, len - copied);\n\tkunmap(*pages);\n\ttotal += copied;\n\tntfs_set_next_iovec(iov, iov_ofs, copied);\n\twhile (++pages < last_page) {\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tlen = PAGE_CACHE_SIZE;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tzero_user(*pages, 0, len);\n\t}\n\tgoto out;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "*pages",
            "0",
            "len"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_set_next_iovec",
          "args": [
            "iov",
            "iov_ofs",
            "copied"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_set_next_iovec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "1354-1375",
          "snippet": "static inline void ntfs_set_next_iovec(const struct iovec **iovp,\n\t\tsize_t *iov_ofsp, size_t bytes)\n{\n\tconst struct iovec *iov = *iovp;\n\tsize_t iov_ofs = *iov_ofsp;\n\n\twhile (bytes) {\n\t\tunsigned len;\n\n\t\tlen = iov->iov_len - iov_ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tbytes -= len;\n\t\tiov_ofs += len;\n\t\tif (iov->iov_len == iov_ofs) {\n\t\t\tiov++;\n\t\t\tiov_ofs = 0;\n\t\t}\n\t}\n\t*iovp = iov;\n\t*iov_ofsp = iov_ofs;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline void ntfs_set_next_iovec(const struct iovec **iovp,\n\t\tsize_t *iov_ofsp, size_t bytes)\n{\n\tconst struct iovec *iov = *iovp;\n\tsize_t iov_ofs = *iov_ofsp;\n\n\twhile (bytes) {\n\t\tunsigned len;\n\n\t\tlen = iov->iov_len - iov_ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tbytes -= len;\n\t\tiov_ofs += len;\n\t\tif (iov->iov_len == iov_ofs) {\n\t\t\tiov++;\n\t\t\tiov_ofs = 0;\n\t\t}\n\t}\n\t*iovp = iov;\n\t*iov_ofsp = iov_ofs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pages"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr + ofs + copied",
            "0",
            "len - copied"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "copied > len"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pages"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied != len"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ntfs_copy_from_user_iovec_inatomic",
          "args": [
            "addr +\n\t\t\t\t\tofs",
            "*iov",
            "*iov_ofs",
            "len"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_copy_from_user_iovec_inatomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "1325-1352",
          "snippet": "static size_t __ntfs_copy_from_user_iovec_inatomic(char *vaddr,\n\t\tconst struct iovec *iov, size_t iov_ofs, size_t bytes)\n{\n\tsize_t total = 0;\n\n\twhile (1) {\n\t\tconst char __user *buf = iov->iov_base + iov_ofs;\n\t\tunsigned len;\n\t\tsize_t left;\n\n\t\tlen = iov->iov_len - iov_ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tleft = __copy_from_user_inatomic(vaddr, buf, len);\n\t\ttotal += len;\n\t\tbytes -= len;\n\t\tvaddr += len;\n\t\tif (unlikely(left)) {\n\t\t\ttotal -= left;\n\t\t\tbreak;\n\t\t}\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tiov++;\n\t\tiov_ofs = 0;\n\t}\n\treturn total;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic size_t __ntfs_copy_from_user_iovec_inatomic(char *vaddr,\n\t\tconst struct iovec *iov, size_t iov_ofs, size_t bytes)\n{\n\tsize_t total = 0;\n\n\twhile (1) {\n\t\tconst char __user *buf = iov->iov_base + iov_ofs;\n\t\tunsigned len;\n\t\tsize_t left;\n\n\t\tlen = iov->iov_len - iov_ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tleft = __copy_from_user_inatomic(vaddr, buf, len);\n\t\ttotal += len;\n\t\tbytes -= len;\n\t\tvaddr += len;\n\t\tif (unlikely(left)) {\n\t\t\ttotal -= left;\n\t\t\tbreak;\n\t\t}\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tiov++;\n\t\tiov_ofs = 0;\n\t}\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*pages"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "copied != len"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "*pages"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline size_t ntfs_copy_from_user_iovec(struct page **pages,\n\t\tunsigned nr_pages, unsigned ofs, const struct iovec **iov,\n\t\tsize_t *iov_ofs, size_t bytes)\n{\n\tstruct page **last_page = pages + nr_pages;\n\tchar *addr;\n\tsize_t copied, len, total = 0;\n\n\tdo {\n\t\tlen = PAGE_CACHE_SIZE - ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\taddr = kmap_atomic(*pages);\n\t\tcopied = __ntfs_copy_from_user_iovec_inatomic(addr + ofs,\n\t\t\t\t*iov, *iov_ofs, len);\n\t\tkunmap_atomic(addr);\n\t\tif (unlikely(copied != len)) {\n\t\t\t/* Do it the slow way. */\n\t\t\taddr = kmap(*pages);\n\t\t\tcopied = __ntfs_copy_from_user_iovec_inatomic(addr +\n\t\t\t\t\tofs, *iov, *iov_ofs, len);\n\t\t\tif (unlikely(copied != len))\n\t\t\t\tgoto err_out;\n\t\t\tkunmap(*pages);\n\t\t}\n\t\ttotal += len;\n\t\tntfs_set_next_iovec(iov, iov_ofs, len);\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tofs = 0;\n\t} while (++pages < last_page);\nout:\n\treturn total;\nerr_out:\n\tBUG_ON(copied > len);\n\t/* Zero the rest of the target like __copy_from_user(). */\n\tmemset(addr + ofs + copied, 0, len - copied);\n\tkunmap(*pages);\n\ttotal += copied;\n\tntfs_set_next_iovec(iov, iov_ofs, copied);\n\twhile (++pages < last_page) {\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tlen = PAGE_CACHE_SIZE;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tzero_user(*pages, 0, len);\n\t}\n\tgoto out;\n}"
  },
  {
    "function_name": "ntfs_set_next_iovec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "1354-1375",
    "snippet": "static inline void ntfs_set_next_iovec(const struct iovec **iovp,\n\t\tsize_t *iov_ofsp, size_t bytes)\n{\n\tconst struct iovec *iov = *iovp;\n\tsize_t iov_ofs = *iov_ofsp;\n\n\twhile (bytes) {\n\t\tunsigned len;\n\n\t\tlen = iov->iov_len - iov_ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tbytes -= len;\n\t\tiov_ofs += len;\n\t\tif (iov->iov_len == iov_ofs) {\n\t\t\tiov++;\n\t\t\tiov_ofs = 0;\n\t\t}\n\t}\n\t*iovp = iov;\n\t*iov_ofsp = iov_ofs;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline void ntfs_set_next_iovec(const struct iovec **iovp,\n\t\tsize_t *iov_ofsp, size_t bytes)\n{\n\tconst struct iovec *iov = *iovp;\n\tsize_t iov_ofs = *iov_ofsp;\n\n\twhile (bytes) {\n\t\tunsigned len;\n\n\t\tlen = iov->iov_len - iov_ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tbytes -= len;\n\t\tiov_ofs += len;\n\t\tif (iov->iov_len == iov_ofs) {\n\t\t\tiov++;\n\t\t\tiov_ofs = 0;\n\t\t}\n\t}\n\t*iovp = iov;\n\t*iov_ofsp = iov_ofs;\n}"
  },
  {
    "function_name": "__ntfs_copy_from_user_iovec_inatomic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "1325-1352",
    "snippet": "static size_t __ntfs_copy_from_user_iovec_inatomic(char *vaddr,\n\t\tconst struct iovec *iov, size_t iov_ofs, size_t bytes)\n{\n\tsize_t total = 0;\n\n\twhile (1) {\n\t\tconst char __user *buf = iov->iov_base + iov_ofs;\n\t\tunsigned len;\n\t\tsize_t left;\n\n\t\tlen = iov->iov_len - iov_ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tleft = __copy_from_user_inatomic(vaddr, buf, len);\n\t\ttotal += len;\n\t\tbytes -= len;\n\t\tvaddr += len;\n\t\tif (unlikely(left)) {\n\t\t\ttotal -= left;\n\t\t\tbreak;\n\t\t}\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tiov++;\n\t\tiov_ofs = 0;\n\t}\n\treturn total;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "left"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user_inatomic",
          "args": [
            "vaddr",
            "buf",
            "len"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic size_t __ntfs_copy_from_user_iovec_inatomic(char *vaddr,\n\t\tconst struct iovec *iov, size_t iov_ofs, size_t bytes)\n{\n\tsize_t total = 0;\n\n\twhile (1) {\n\t\tconst char __user *buf = iov->iov_base + iov_ofs;\n\t\tunsigned len;\n\t\tsize_t left;\n\n\t\tlen = iov->iov_len - iov_ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tleft = __copy_from_user_inatomic(vaddr, buf, len);\n\t\ttotal += len;\n\t\tbytes -= len;\n\t\tvaddr += len;\n\t\tif (unlikely(left)) {\n\t\t\ttotal -= left;\n\t\t\tbreak;\n\t\t}\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tiov++;\n\t\tiov_ofs = 0;\n\t}\n\treturn total;\n}"
  },
  {
    "function_name": "ntfs_copy_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "1276-1323",
    "snippet": "static inline size_t ntfs_copy_from_user(struct page **pages,\n\t\tunsigned nr_pages, unsigned ofs, const char __user *buf,\n\t\tsize_t bytes)\n{\n\tstruct page **last_page = pages + nr_pages;\n\tchar *addr;\n\tsize_t total = 0;\n\tunsigned len;\n\tint left;\n\n\tdo {\n\t\tlen = PAGE_CACHE_SIZE - ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\taddr = kmap_atomic(*pages);\n\t\tleft = __copy_from_user_inatomic(addr + ofs, buf, len);\n\t\tkunmap_atomic(addr);\n\t\tif (unlikely(left)) {\n\t\t\t/* Do it the slow way. */\n\t\t\taddr = kmap(*pages);\n\t\t\tleft = __copy_from_user(addr + ofs, buf, len);\n\t\t\tkunmap(*pages);\n\t\t\tif (unlikely(left))\n\t\t\t\tgoto err_out;\n\t\t}\n\t\ttotal += len;\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tbuf += len;\n\t\tofs = 0;\n\t} while (++pages < last_page);\nout:\n\treturn total;\nerr_out:\n\ttotal += len - left;\n\t/* Zero the rest of the target like __copy_from_user(). */\n\twhile (++pages < last_page) {\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tlen = PAGE_CACHE_SIZE;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tzero_user(*pages, 0, len);\n\t}\n\tgoto out;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "*pages",
            "0",
            "len"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "left"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "*pages"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user",
          "args": [
            "addr + ofs",
            "buf",
            "len"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "*pages"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "left"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "addr"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_from_user_inatomic",
          "args": [
            "addr + ofs",
            "buf",
            "len"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "*pages"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline size_t ntfs_copy_from_user(struct page **pages,\n\t\tunsigned nr_pages, unsigned ofs, const char __user *buf,\n\t\tsize_t bytes)\n{\n\tstruct page **last_page = pages + nr_pages;\n\tchar *addr;\n\tsize_t total = 0;\n\tunsigned len;\n\tint left;\n\n\tdo {\n\t\tlen = PAGE_CACHE_SIZE - ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\taddr = kmap_atomic(*pages);\n\t\tleft = __copy_from_user_inatomic(addr + ofs, buf, len);\n\t\tkunmap_atomic(addr);\n\t\tif (unlikely(left)) {\n\t\t\t/* Do it the slow way. */\n\t\t\taddr = kmap(*pages);\n\t\t\tleft = __copy_from_user(addr + ofs, buf, len);\n\t\t\tkunmap(*pages);\n\t\t\tif (unlikely(left))\n\t\t\t\tgoto err_out;\n\t\t}\n\t\ttotal += len;\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tbuf += len;\n\t\tofs = 0;\n\t} while (++pages < last_page);\nout:\n\treturn total;\nerr_out:\n\ttotal += len - left;\n\t/* Zero the rest of the target like __copy_from_user(). */\n\twhile (++pages < last_page) {\n\t\tbytes -= len;\n\t\tif (!bytes)\n\t\t\tbreak;\n\t\tlen = PAGE_CACHE_SIZE;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tzero_user(*pages, 0, len);\n\t}\n\tgoto out;\n}"
  },
  {
    "function_name": "ntfs_prepare_pages_for_non_resident_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "480-1269",
    "snippet": "static int ntfs_prepare_pages_for_non_resident_write(struct page **pages,\n\t\tunsigned nr_pages, s64 pos, size_t bytes)\n{\n\tVCN vcn, highest_vcn = 0, cpos, cend, bh_cpos, bh_cend;\n\tLCN lcn;\n\ts64 bh_pos, vcn_len, end, initialized_size;\n\tsector_t lcn_block;\n\tstruct page *page;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni = NULL;\n\tntfs_volume *vol;\n\trunlist_element *rl, *rl2;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh = wait;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a = NULL;\n\tunsigned long flags;\n\tu32 attr_rec_len = 0;\n\tunsigned blocksize, u;\n\tint err, mp_size;\n\tbool rl_write_locked, was_hole, is_retry;\n\tunsigned char blocksize_bits;\n\tstruct {\n\t\tu8 runlist_merged:1;\n\t\tu8 mft_attr_mapped:1;\n\t\tu8 mp_rebuilt:1;\n\t\tu8 attr_switched:1;\n\t} status = { 0, 0, 0, 0 };\n\n\tBUG_ON(!nr_pages);\n\tBUG_ON(!pages);\n\tBUG_ON(!*pages);\n\tvi = pages[0]->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, start page \"\n\t\t\t\"index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.\",\n\t\t\tvi->i_ino, ni->type, pages[0]->index, nr_pages,\n\t\t\t(long long)pos, bytes);\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tu = 0;\n\tdo {\n\t\tpage = pages[u];\n\t\tBUG_ON(!page);\n\t\t/*\n\t\t * create_empty_buffers() will create uptodate/dirty buffers if\n\t\t * the page is uptodate/dirty.\n\t\t */\n\t\tif (!page_has_buffers(page)) {\n\t\t\tcreate_empty_buffers(page, blocksize, 0);\n\t\t\tif (unlikely(!page_has_buffers(page)))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t} while (++u < nr_pages);\n\trl_write_locked = false;\n\trl = NULL;\n\terr = 0;\n\tvcn = lcn = -1;\n\tvcn_len = 0;\n\tlcn_block = -1;\n\twas_hole = false;\n\tcpos = pos >> vol->cluster_size_bits;\n\tend = pos + bytes;\n\tcend = (end + vol->cluster_size - 1) >> vol->cluster_size_bits;\n\t/*\n\t * Loop over each page and for each page over each buffer.  Use goto to\n\t * reduce indentation.\n\t */\n\tu = 0;\ndo_next_page:\n\tpage = pages[u];\n\tbh_pos = (s64)page->index << PAGE_CACHE_SHIFT;\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tVCN cdelta;\n\t\ts64 bh_end;\n\t\tunsigned bh_cofs;\n\n\t\t/* Clear buffer_new on all buffers to reinitialise state. */\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tbh_end = bh_pos + blocksize;\n\t\tbh_cpos = bh_pos >> vol->cluster_size_bits;\n\t\tbh_cofs = bh_pos & vol->cluster_size_mask;\n\t\tif (buffer_mapped(bh)) {\n\t\t\t/*\n\t\t\t * The buffer is already mapped.  If it is uptodate,\n\t\t\t * ignore it.\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The buffer is not uptodate.  If the page is uptodate\n\t\t\t * set the buffer uptodate and otherwise ignore it.\n\t\t\t */\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Neither the page nor the buffer are uptodate.  If\n\t\t\t * the buffer is only partially being written to, we\n\t\t\t * need to read it in before the write, i.e. now.\n\t\t\t */\n\t\t\tif ((bh_pos < pos && bh_end > pos) ||\n\t\t\t\t\t(bh_pos < end && bh_end > end)) {\n\t\t\t\t/*\n\t\t\t\t * If the buffer is fully or partially within\n\t\t\t\t * the initialized size, do an actual read.\n\t\t\t\t * Otherwise, simply zero the buffer.\n\t\t\t\t */\n\t\t\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\t\t\tinitialized_size = ni->initialized_size;\n\t\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\t\tif (bh_pos < initialized_size) {\n\t\t\t\t\tntfs_submit_bh_for_read(bh);\n\t\t\t\t\t*wait_bh++ = bh;\n\t\t\t\t} else {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/* Unmapped buffer.  Need to map it. */\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t/*\n\t\t * If the current buffer is in the same clusters as the map\n\t\t * cache, there is no need to check the runlist again.  The\n\t\t * map cache is made up of @vcn, which is the first cached file\n\t\t * cluster, @vcn_len which is the number of cached file\n\t\t * clusters, @lcn is the device cluster corresponding to @vcn,\n\t\t * and @lcn_block is the block number corresponding to @lcn.\n\t\t */\n\t\tcdelta = bh_cpos - vcn;\n\t\tif (likely(!cdelta || (cdelta > 0 && cdelta < vcn_len))) {\nmap_buffer_cached:\n\t\t\tBUG_ON(lcn < 0);\n\t\t\tbh->b_blocknr = lcn_block +\n\t\t\t\t\t(cdelta << (vol->cluster_size_bits -\n\t\t\t\t\tblocksize_bits)) +\n\t\t\t\t\t(bh_cofs >> blocksize_bits);\n\t\t\tset_buffer_mapped(bh);\n\t\t\t/*\n\t\t\t * If the page is uptodate so is the buffer.  If the\n\t\t\t * buffer is fully outside the write, we ignore it if\n\t\t\t * it was already allocated and we mark it dirty so it\n\t\t\t * gets written out if we allocated it.  On the other\n\t\t\t * hand, if we allocated the buffer but we are not\n\t\t\t * marking it dirty we set buffer_new so we can do\n\t\t\t * error recovery.\n\t\t\t */\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tif (unlikely(was_hole)) {\n\t\t\t\t\t/* We allocated the buffer. */\n\t\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\t\tif (bh_end <= pos || bh_pos >= end)\n\t\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_buffer_new(bh);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Page is _not_ uptodate. */\n\t\t\tif (likely(!was_hole)) {\n\t\t\t\t/*\n\t\t\t\t * Buffer was already allocated.  If it is not\n\t\t\t\t * uptodate and is only partially being written\n\t\t\t\t * to, we need to read it in before the write,\n\t\t\t\t * i.e. now.\n\t\t\t\t */\n\t\t\t\tif (!buffer_uptodate(bh) && bh_pos < end &&\n\t\t\t\t\t\tbh_end > pos &&\n\t\t\t\t\t\t(bh_pos < pos ||\n\t\t\t\t\t\tbh_end > end)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If the buffer is fully or partially\n\t\t\t\t\t * within the initialized size, do an\n\t\t\t\t\t * actual read.  Otherwise, simply zero\n\t\t\t\t\t * the buffer.\n\t\t\t\t\t */\n\t\t\t\t\tread_lock_irqsave(&ni->size_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\t\tinitialized_size = ni->initialized_size;\n\t\t\t\t\tread_unlock_irqrestore(&ni->size_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\t\tif (bh_pos < initialized_size) {\n\t\t\t\t\t\tntfs_submit_bh_for_read(bh);\n\t\t\t\t\t\t*wait_bh++ = bh;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* We allocated the buffer. */\n\t\t\tunmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t\t/*\n\t\t\t * If the buffer is fully outside the write, zero it,\n\t\t\t * set it uptodate, and mark it dirty so it gets\n\t\t\t * written out.  If it is partially being written to,\n\t\t\t * zero region surrounding the write but leave it to\n\t\t\t * commit write to do anything else.  Finally, if the\n\t\t\t * buffer is fully being overwritten, do nothing.\n\t\t\t */\n\t\t\tif (bh_end <= pos || bh_pos >= end) {\n\t\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tset_buffer_new(bh);\n\t\t\tif (!buffer_uptodate(bh) &&\n\t\t\t\t\t(bh_pos < pos || bh_end > end)) {\n\t\t\t\tu8 *kaddr;\n\t\t\t\tunsigned pofs;\n\t\t\t\t\t\n\t\t\t\tkaddr = kmap_atomic(page);\n\t\t\t\tif (bh_pos < pos) {\n\t\t\t\t\tpofs = bh_pos & ~PAGE_CACHE_MASK;\n\t\t\t\t\tmemset(kaddr + pofs, 0, pos - bh_pos);\n\t\t\t\t}\n\t\t\t\tif (bh_end > end) {\n\t\t\t\t\tpofs = end & ~PAGE_CACHE_MASK;\n\t\t\t\t\tmemset(kaddr + pofs, 0, bh_end - end);\n\t\t\t\t}\n\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Slow path: this is the first buffer in the cluster.  If it\n\t\t * is outside allocated size and is not uptodate, zero it and\n\t\t * set it uptodate.\n\t\t */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tinitialized_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (bh_pos > initialized_size) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t} else if (!buffer_uptodate(bh)) {\n\t\t\t\tzero_user(page, bh_offset(bh), blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tis_retry = false;\n\t\tif (!rl) {\n\t\t\tdown_read(&ni->runlist.lock);\nretry_remap:\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t/* Seek to element containing target cluster. */\n\t\t\twhile (rl->length && rl[1].vcn <= bh_cpos)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, bh_cpos);\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/*\n\t\t\t\t * Successful remap, setup the map cache and\n\t\t\t\t * use that to deal with the buffer.\n\t\t\t\t */\n\t\t\t\twas_hole = false;\n\t\t\t\tvcn = bh_cpos;\n\t\t\t\tvcn_len = rl[1].vcn - vcn;\n\t\t\t\tlcn_block = lcn << (vol->cluster_size_bits -\n\t\t\t\t\t\tblocksize_bits);\n\t\t\t\tcdelta = 0;\n\t\t\t\t/*\n\t\t\t\t * If the number of remaining clusters touched\n\t\t\t\t * by the write is smaller or equal to the\n\t\t\t\t * number of cached clusters, unlock the\n\t\t\t\t * runlist as the map cache will be used from\n\t\t\t\t * now on.\n\t\t\t\t */\n\t\t\t\tif (likely(vcn + vcn_len >= cend)) {\n\t\t\t\t\tif (rl_write_locked) {\n\t\t\t\t\t\tup_write(&ni->runlist.lock);\n\t\t\t\t\t\trl_write_locked = false;\n\t\t\t\t\t} else\n\t\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\trl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto map_buffer_cached;\n\t\t\t}\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t/*\n\t\t * If it is not a hole and not out of bounds, the runlist is\n\t\t * probably unmapped so try to map it now.\n\t\t */\n\t\tif (unlikely(lcn != LCN_HOLE && lcn != LCN_ENOENT)) {\n\t\t\tif (likely(!is_retry && lcn == LCN_RL_NOT_MAPPED)) {\n\t\t\t\t/* Attempt to map runlist. */\n\t\t\t\tif (!rl_write_locked) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We need the runlist locked for\n\t\t\t\t\t * writing, so if it is locked for\n\t\t\t\t\t * reading relock it now and retry in\n\t\t\t\t\t * case it changed whilst we dropped\n\t\t\t\t\t * the lock.\n\t\t\t\t\t */\n\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\tdown_write(&ni->runlist.lock);\n\t\t\t\t\trl_write_locked = true;\n\t\t\t\t\tgoto retry_remap;\n\t\t\t\t}\n\t\t\t\terr = ntfs_map_runlist_nolock(ni, bh_cpos,\n\t\t\t\t\t\tNULL);\n\t\t\t\tif (likely(!err)) {\n\t\t\t\t\tis_retry = true;\n\t\t\t\t\tgoto retry_remap;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If @vcn is out of bounds, pretend @lcn is\n\t\t\t\t * LCN_ENOENT.  As long as the buffer is out\n\t\t\t\t * of bounds this will work fine.\n\t\t\t\t */\n\t\t\t\tif (err == -ENOENT) {\n\t\t\t\t\tlcn = LCN_ENOENT;\n\t\t\t\t\terr = 0;\n\t\t\t\t\tgoto rl_not_mapped_enoent;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\terr = -EIO;\n\t\t\t/* Failed to map the buffer, even after retrying. */\n\t\t\tbh->b_blocknr = -1;\n\t\t\tntfs_error(vol->sb, \"Failed to write to inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, \"\n\t\t\t\t\t\"vcn offset 0x%x, because its \"\n\t\t\t\t\t\"location on disk could not be \"\n\t\t\t\t\t\"determined%s (error code %i).\",\n\t\t\t\t\tni->mft_no, ni->type,\n\t\t\t\t\t(unsigned long long)bh_cpos,\n\t\t\t\t\t(unsigned)bh_pos &\n\t\t\t\t\tvol->cluster_size_mask,\n\t\t\t\t\tis_retry ? \" even after retrying\" : \"\",\n\t\t\t\t\terr);\n\t\t\tbreak;\n\t\t}\nrl_not_mapped_enoent:\n\t\t/*\n\t\t * The buffer is in a hole or out of bounds.  We need to fill\n\t\t * the hole, unless the buffer is in a cluster which is not\n\t\t * touched by the write, in which case we just leave the buffer\n\t\t * unmapped.  This can only happen when the cluster size is\n\t\t * less than the page cache size.\n\t\t */\n\t\tif (unlikely(vol->cluster_size < PAGE_CACHE_SIZE)) {\n\t\t\tbh_cend = (bh_end + vol->cluster_size - 1) >>\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tif ((bh_cend <= cpos || bh_cpos >= cend)) {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\t/*\n\t\t\t\t * If the buffer is uptodate we skip it.  If it\n\t\t\t\t * is not but the page is uptodate, we can set\n\t\t\t\t * the buffer uptodate.  If the page is not\n\t\t\t\t * uptodate, we can clear the buffer and set it\n\t\t\t\t * uptodate.  Whether this is worthwhile is\n\t\t\t\t * debatable and this could be removed.\n\t\t\t\t */\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t} else if (!buffer_uptodate(bh)) {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Out of bounds buffer is invalid if it was not really out of\n\t\t * bounds.\n\t\t */\n\t\tBUG_ON(lcn != LCN_HOLE);\n\t\t/*\n\t\t * We need the runlist locked for writing, so if it is locked\n\t\t * for reading relock it now and retry in case it changed\n\t\t * whilst we dropped the lock.\n\t\t */\n\t\tBUG_ON(!rl);\n\t\tif (!rl_write_locked) {\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tdown_write(&ni->runlist.lock);\n\t\t\trl_write_locked = true;\n\t\t\tgoto retry_remap;\n\t\t}\n\t\t/* Find the previous last allocated cluster. */\n\t\tBUG_ON(rl->lcn != LCN_HOLE);\n\t\tlcn = -1;\n\t\trl2 = rl;\n\t\twhile (--rl2 >= ni->runlist.rl) {\n\t\t\tif (rl2->lcn >= 0) {\n\t\t\t\tlcn = rl2->lcn + rl2->length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trl2 = ntfs_cluster_alloc(vol, bh_cpos, 1, lcn, DATA_ZONE,\n\t\t\t\tfalse);\n\t\tif (IS_ERR(rl2)) {\n\t\t\terr = PTR_ERR(rl2);\n\t\t\tntfs_debug(\"Failed to allocate cluster, error code %i.\",\n\t\t\t\t\terr);\n\t\t\tbreak;\n\t\t}\n\t\tlcn = rl2->lcn;\n\t\trl = ntfs_runlists_merge(ni->runlist.rl, rl2);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tif (err != -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to release \"\n\t\t\t\t\t\t\"allocated cluster in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover the lost cluster.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tntfs_free(rl2);\n\t\t\tbreak;\n\t\t}\n\t\tni->runlist.rl = rl;\n\t\tstatus.runlist_merged = 1;\n\t\tntfs_debug(\"Allocated cluster, lcn 0x%llx.\",\n\t\t\t\t(unsigned long long)lcn);\n\t\t/* Map and lock the mft record and get the attribute record. */\n\t\tif (!NInoAttr(ni))\n\t\t\tbase_ni = ni;\n\t\telse\n\t\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tbreak;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tunmap_mft_record(base_ni);\n\t\t\tbreak;\n\t\t}\n\t\tstatus.mft_attr_mapped = 1;\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, bh_cpos, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tm = ctx->mrec;\n\t\ta = ctx->attr;\n\t\t/*\n\t\t * Find the runlist element with which the attribute extent\n\t\t * starts.  Note, we cannot use the _attr_ version because we\n\t\t * have mapped the mft record.  That is ok because we know the\n\t\t * runlist fragment must be mapped already to have ever gotten\n\t\t * here, so we can just use the _rl_ version.\n\t\t */\n\t\tvcn = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t\trl2 = ntfs_rl_find_vcn_nolock(rl, vcn);\n\t\tBUG_ON(!rl2);\n\t\tBUG_ON(!rl2->length);\n\t\tBUG_ON(rl2->lcn < LCN_HOLE);\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\t/*\n\t\t * If @highest_vcn is zero, calculate the real highest_vcn\n\t\t * (which can really be zero).\n\t\t */\n\t\tif (!highest_vcn)\n\t\t\thighest_vcn = (sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size) >>\n\t\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * Determine the size of the mapping pairs array for the new\n\t\t * extent, i.e. the old extent with the hole filled.\n\t\t */\n\t\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, vcn,\n\t\t\t\thighest_vcn);\n\t\tif (unlikely(mp_size <= 0)) {\n\t\t\tif (!(err = mp_size))\n\t\t\t\terr = -EIO;\n\t\t\tntfs_debug(\"Failed to get size for mapping pairs \"\n\t\t\t\t\t\"array, error code %i.\", err);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Resize the attribute record to fit the new mapping pairs\n\t\t * array.\n\t\t */\n\t\tattr_rec_len = le32_to_cpu(a->length);\n\t\terr = ntfs_attr_record_resize(m, a, mp_size + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset));\n\t\tif (unlikely(err)) {\n\t\t\tBUG_ON(err != -ENOSPC);\n\t\t\t// TODO: Deal with this by using the current attribute\n\t\t\t// and fill it with as much of the mapping pairs\n\t\t\t// array as possible.  Then loop over each attribute\n\t\t\t// extent rewriting the mapping pairs arrays as we go\n\t\t\t// along and if when we reach the end we have not\n\t\t\t// enough space, try to resize the last attribute\n\t\t\t// extent and if even that fails, add a new attribute\n\t\t\t// extent.\n\t\t\t// We could also try to resize at each step in the hope\n\t\t\t// that we will not need to rewrite every single extent.\n\t\t\t// Note, we may need to decompress some extents to fill\n\t\t\t// the runlist as we are walking the extents...\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak ;\n\t\t}\n\t\tstatus.mp_rebuilt = 1;\n\t\t/*\n\t\t * Generate the mapping pairs array directly into the attribute\n\t\t * record.\n\t\t */\n\t\terr = ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\tmp_size, rl2, vcn, highest_vcn, NULL);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Cannot fill hole in inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, because building \"\n\t\t\t\t\t\"the mapping pairs failed with error \"\n\t\t\t\t\t\"code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\t/* Update the highest_vcn but only if it was not set. */\n\t\tif (unlikely(!a->data.non_resident.highest_vcn))\n\t\t\ta->data.non_resident.highest_vcn =\n\t\t\t\t\tcpu_to_sle64(highest_vcn);\n\t\t/*\n\t\t * If the attribute is sparse/compressed, update the compressed\n\t\t * size in the ntfs_inode structure and the attribute record.\n\t\t */\n\t\tif (likely(NInoSparse(ni) || NInoCompressed(ni))) {\n\t\t\t/*\n\t\t\t * If we are not in the first attribute extent, switch\n\t\t\t * to it, but first ensure the changes will make it to\n\t\t\t * disk later.\n\t\t\t */\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\t\terr = ntfs_attr_lookup(ni->type, ni->name,\n\t\t\t\t\t\tni->name_len, CASE_SENSITIVE,\n\t\t\t\t\t\t0, NULL, 0, ctx);\n\t\t\t\tif (unlikely(err)) {\n\t\t\t\t\tstatus.attr_switched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* @m is not used any more so do not set it. */\n\t\t\t\ta = ctx->attr;\n\t\t\t}\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->itype.compressed.size += vol->cluster_size;\n\t\t\ta->data.non_resident.compressed_size =\n\t\t\t\t\tcpu_to_sle64(ni->itype.compressed.size);\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t}\n\t\t/* Ensure the changes make it to disk. */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\t/* Successfully filled the hole. */\n\t\tstatus.runlist_merged = 0;\n\t\tstatus.mft_attr_mapped = 0;\n\t\tstatus.mp_rebuilt = 0;\n\t\t/* Setup the map cache and use that to deal with the buffer. */\n\t\twas_hole = true;\n\t\tvcn = bh_cpos;\n\t\tvcn_len = 1;\n\t\tlcn_block = lcn << (vol->cluster_size_bits - blocksize_bits);\n\t\tcdelta = 0;\n\t\t/*\n\t\t * If the number of remaining clusters in the @pages is smaller\n\t\t * or equal to the number of cached clusters, unlock the\n\t\t * runlist as the map cache will be used from now on.\n\t\t */\n\t\tif (likely(vcn + vcn_len >= cend)) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\trl_write_locked = false;\n\t\t\trl = NULL;\n\t\t}\n\t\tgoto map_buffer_cached;\n\t} while (bh_pos += blocksize, (bh = bh->b_this_page) != head);\n\t/* If there are no errors, do the next page. */\n\tif (likely(!err && ++u < nr_pages))\n\t\tgoto do_next_page;\n\t/* If there are no errors, release the runlist lock if we took it. */\n\tif (likely(!err)) {\n\t\tif (unlikely(rl_write_locked)) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\trl_write_locked = false;\n\t\t} else if (unlikely(rl))\n\t\t\tup_read(&ni->runlist.lock);\n\t\trl = NULL;\n\t}\n\t/* If we issued read requests, let them complete. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\twhile (wait_bh > wait) {\n\t\tbh = *--wait_bh;\n\t\twait_on_buffer(bh);\n\t\tif (likely(buffer_uptodate(bh))) {\n\t\t\tpage = bh->b_page;\n\t\t\tbh_pos = ((s64)page->index << PAGE_CACHE_SHIFT) +\n\t\t\t\t\tbh_offset(bh);\n\t\t\t/*\n\t\t\t * If the buffer overflows the initialized size, need\n\t\t\t * to zero the overflowing region.\n\t\t\t */\n\t\t\tif (unlikely(bh_pos + blocksize > initialized_size)) {\n\t\t\t\tint ofs = 0;\n\n\t\t\t\tif (likely(bh_pos < initialized_size))\n\t\t\t\t\tofs = initialized_size - bh_pos;\n\t\t\t\tzero_user_segment(page, bh_offset(bh) + ofs,\n\t\t\t\t\t\tblocksize);\n\t\t\t}\n\t\t} else /* if (unlikely(!buffer_uptodate(bh))) */\n\t\t\terr = -EIO;\n\t}\n\tif (likely(!err)) {\n\t\t/* Clear buffer_new on all buffers. */\n\t\tu = 0;\n\t\tdo {\n\t\t\tbh = head = page_buffers(pages[u]);\n\t\t\tdo {\n\t\t\t\tif (buffer_new(bh))\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t} while (++u < nr_pages);\n\t\tntfs_debug(\"Done.\");\n\t\treturn err;\n\t}\n\tif (status.attr_switched) {\n\t\t/* Get back to the attribute extent we modified. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, bh_cpos, NULL, 0, ctx)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find required \"\n\t\t\t\t\t\"attribute extent of attribute in \"\n\t\t\t\t\t\"error code path.  Run chkdsk to \"\n\t\t\t\t\t\"recover.\");\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->itype.compressed.size += vol->cluster_size;\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t\t/*\n\t\t\t * The only thing that is now wrong is the compressed\n\t\t\t * size of the base attribute extent which chkdsk\n\t\t\t * should be able to fix.\n\t\t\t */\n\t\t\tNVolSetErrors(vol);\n\t\t} else {\n\t\t\tm = ctx->mrec;\n\t\t\ta = ctx->attr;\n\t\t\tstatus.attr_switched = 0;\n\t\t}\n\t}\n\t/*\n\t * If the runlist has been modified, need to restore it by punching a\n\t * hole into it and we then need to deallocate the on-disk cluster as\n\t * well.  Note, we only modify the runlist if we are able to generate a\n\t * new mapping pairs array, i.e. only when the mapped attribute extent\n\t * is not switched.\n\t */\n\tif (status.runlist_merged && !status.attr_switched) {\n\t\tBUG_ON(!rl_write_locked);\n\t\t/* Make the file cluster we allocated sparse in the runlist. */\n\t\tif (ntfs_rl_punch_nolock(vol, &ni->runlist, bh_cpos, 1)) {\n\t\t\tntfs_error(vol->sb, \"Failed to punch hole into \"\n\t\t\t\t\t\"attribute runlist in error code \"\n\t\t\t\t\t\"path.  Run chkdsk to recover the \"\n\t\t\t\t\t\"lost cluster.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tstatus.runlist_merged = 0;\n\t\t\t/*\n\t\t\t * Deallocate the on-disk cluster we allocated but only\n\t\t\t * if we succeeded in punching its vcn out of the\n\t\t\t * runlist.\n\t\t\t */\n\t\t\tdown_write(&vol->lcnbmp_lock);\n\t\t\tif (ntfs_bitmap_clear_bit(vol->lcnbmp_ino, lcn)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to release \"\n\t\t\t\t\t\t\"allocated cluster in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover the lost cluster.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tup_write(&vol->lcnbmp_lock);\n\t\t}\n\t}\n\t/*\n\t * Resize the attribute record to its old size and rebuild the mapping\n\t * pairs array.  Note, we only can do this if the runlist has been\n\t * restored to its old state which also implies that the mapped\n\t * attribute extent is not switched.\n\t */\n\tif (status.mp_rebuilt && !status.runlist_merged) {\n\t\tif (ntfs_attr_record_resize(m, a, attr_rec_len)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), attr_rec_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), ni->runlist.rl,\n\t\t\t\t\tvcn, highest_vcn, NULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t}\n\t}\n\t/* Release the mft record and the attribute. */\n\tif (status.mft_attr_mapped) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t}\n\t/* Release the runlist lock. */\n\tif (rl_write_locked)\n\t\tup_write(&ni->runlist.lock);\n\telse if (rl)\n\t\tup_read(&ni->runlist.lock);\n\t/*\n\t * Zero out any newly allocated blocks to avoid exposing stale data.\n\t * If BH_New is set, we know that the block was newly allocated above\n\t * and that it has not been fully zeroed and marked dirty yet.\n\t */\n\tnr_pages = u;\n\tu = 0;\n\tend = bh_cpos << vol->cluster_size_bits;\n\tdo {\n\t\tpage = pages[u];\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (u == nr_pages &&\n\t\t\t\t\t((s64)page->index << PAGE_CACHE_SHIFT) +\n\t\t\t\t\tbh_offset(bh) >= end)\n\t\t\t\tbreak;\n\t\t\tif (!buffer_new(bh))\n\t\t\t\tcontinue;\n\t\t\tclear_buffer_new(bh);\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tif (PageUptodate(page))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\telse {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmark_buffer_dirty(bh);\n\t\t} while ((bh = bh->b_this_page) != head);\n\t} while (++u <= nr_pages);\n\tntfs_error(vol->sb, \"Failed.  Returning error code %i.\", err);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed.  Returning error code %i.\"",
            "err"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "bh_offset(bh)",
            "blocksize"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "base_ni"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\""
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_mapping_pairs_build",
          "args": [
            "vol",
            "(u8*)a +\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset)",
            "attr_rec_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset)",
            "ni->runlist.rl",
            "vcn",
            "highest_vcn",
            "NULL"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_mapping_pairs_build",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1323-1473",
          "snippet": "int ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,\n\t\tconst int dst_len, const runlist_element *rl,\n\t\tconst VCN first_vcn, const VCN last_vcn, VCN *const stop_vcn)\n{\n\tLCN prev_lcn;\n\ts8 *dst_max, *dst_next;\n\tint err = -ENOSPC;\n\tbool the_end = false;\n\ts8 len_len, lcn_len;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tBUG_ON(dst_len < 1);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\tif (stop_vcn)\n\t\t\t*stop_vcn = 0;\n\t\t/* Terminator byte. */\n\t\t*dst = 0;\n\t\treturn 0;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\t/*\n\t * @dst_max is used for bounds checking in\n\t * ntfs_write_significant_bytes().\n\t */\n\tdst_max = dst + dst_len - 1;\n\tprev_lcn = 0;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength - delta);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Write length. */\n\t\tlen_len = ntfs_write_significant_bytes(dst + 1, dst_max,\n\t\t\t\tlength);\n\t\tif (unlikely(len_len < 0))\n\t\t\tgoto size_err;\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just write the lcn\n\t\t * change.  FIXME: Do we need to write the lcn change or just\n\t\t * the lcn in that case?  Not sure as I have never seen this\n\t\t * case on NT4. - We assume that we just need to write the lcn\n\t\t * change until someone tells us otherwise... (AIA)\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Write change in lcn. */\n\t\t\tlcn_len = ntfs_write_significant_bytes(dst + 1 +\n\t\t\t\t\tlen_len, dst_max, rl->lcn - prev_lcn);\n\t\t\tif (unlikely(lcn_len < 0))\n\t\t\t\tgoto size_err;\n\t\t\tprev_lcn = rl->lcn;\n\t\t} else\n\t\t\tlcn_len = 0;\n\t\tdst_next = dst + len_len + lcn_len + 1;\n\t\tif (unlikely(dst_next > dst_max))\n\t\t\tgoto size_err;\n\t\t/* Update header byte. */\n\t\t*dst = lcn_len << 4 | len_len;\n\t\t/* Position at next mapping pairs array element. */\n\t\tdst = dst_next;\n\t}\n\t/* Success. */\n\terr = 0;\nsize_err:\n\t/* Set stop vcn. */\n\tif (stop_vcn)\n\t\t*stop_vcn = rl->vcn;\n\t/* Add terminator byte. */\n\t*dst = 0;\n\treturn err;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\terr = -EINVAL;\n\telse\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\""
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_record_resize",
          "args": [
            "m",
            "a",
            "attr_rec_len"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_record_resize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1435-1459",
          "snippet": "int ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)\n{\n\tntfs_debug(\"Entering for new_size %u.\", new_size);\n\t/* Align to 8 bytes if it is not already done. */\n\tif (new_size & 7)\n\t\tnew_size = (new_size + 7) & ~7;\n\t/* If the actual attribute length has changed, move things around. */\n\tif (new_size != le32_to_cpu(a->length)) {\n\t\tu32 new_muse = le32_to_cpu(m->bytes_in_use) -\n\t\t\t\tle32_to_cpu(a->length) + new_size;\n\t\t/* Not enough space in this mft record. */\n\t\tif (new_muse > le32_to_cpu(m->bytes_allocated))\n\t\t\treturn -ENOSPC;\n\t\t/* Move attributes following @a to their new location. */\n\t\tmemmove((u8*)a + new_size, (u8*)a + le32_to_cpu(a->length),\n\t\t\t\tle32_to_cpu(m->bytes_in_use) - ((u8*)a -\n\t\t\t\t(u8*)m) - le32_to_cpu(a->length));\n\t\t/* Adjust @m to reflect the change in used space. */\n\t\tm->bytes_in_use = cpu_to_le32(new_muse);\n\t\t/* Adjust @a to reflect the new size. */\n\t\tif (new_size >= offsetof(ATTR_REC, length) + sizeof(a->length))\n\t\t\ta->length = cpu_to_le32(new_size);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to release \"\n\t\t\t\t\t\t\"allocated cluster in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover the lost cluster.\""
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_bitmap_clear_bit",
          "args": [
            "vol->lcnbmp_ino",
            "lcn"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "111-114",
          "snippet": "static inline int ntfs_bitmap_clear_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_clear_run(vi, bit, 1);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_clear_bit(struct inode *vi, const s64 bit)\n{\n\treturn ntfs_bitmap_clear_run(vi, bit, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to punch hole into \"\n\t\t\t\t\t\"attribute runlist in error code \"\n\t\t\t\t\t\"path.  Run chkdsk to recover the \"\n\t\t\t\t\t\"lost cluster.\""
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_punch_nolock",
          "args": [
            "vol",
            "&ni->runlist",
            "bh_cpos",
            "1"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_punch_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1644-1905",
          "snippet": "int ntfs_rl_punch_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst VCN start, const s64 length)\n{\n\tconst VCN end = start + length;\n\ts64 delta;\n\trunlist_element *rl, *rl_end, *rl_real_end, *trl;\n\tint old_size;\n\tbool lcn_fixup = false;\n\n\tntfs_debug(\"Entering for start 0x%llx, length 0x%llx.\",\n\t\t\t(long long)start, (long long)length);\n\tBUG_ON(!runlist);\n\tBUG_ON(start < 0);\n\tBUG_ON(length < 0);\n\tBUG_ON(end < 0);\n\trl = runlist->rl;\n\tif (unlikely(!rl)) {\n\t\tif (likely(!start && !length))\n\t\t\treturn 0;\n\t\treturn -ENOENT;\n\t}\n\t/* Find @start in the runlist. */\n\twhile (likely(rl->length && start >= rl[1].vcn))\n\t\trl++;\n\trl_end = rl;\n\t/* Find @end in the runlist. */\n\twhile (likely(rl_end->length && end >= rl_end[1].vcn)) {\n\t\t/* Verify there are no unmapped or error elements. */\n\t\tif (unlikely(rl_end->lcn < LCN_HOLE))\n\t\t\treturn -EINVAL;\n\t\trl_end++;\n\t}\n\t/* Check the last element. */\n\tif (unlikely(rl_end->length && rl_end->lcn < LCN_HOLE))\n\t\treturn -EINVAL;\n\t/* This covers @start being out of bounds, too. */\n\tif (!rl_end->length && end > rl_end->vcn)\n\t\treturn -ENOENT;\n\tif (!length)\n\t\treturn 0;\n\tif (!rl->length)\n\t\treturn -ENOENT;\n\trl_real_end = rl_end;\n\t/* Determine the runlist size. */\n\twhile (likely(rl_real_end->length))\n\t\trl_real_end++;\n\told_size = rl_real_end - runlist->rl + 1;\n\t/* If @start is in a hole simply extend the hole. */\n\tif (rl->lcn == LCN_HOLE) {\n\t\t/*\n\t\t * If both @start and @end are in the same sparse run, we are\n\t\t * done.\n\t\t */\n\t\tif (end <= rl[1].vcn) {\n\t\t\tntfs_debug(\"Done (requested hole is already sparse).\");\n\t\t\treturn 0;\n\t\t}\nextend_hole:\n\t\t/* Extend the hole. */\n\t\trl->length = end - rl->vcn;\n\t\t/* If @end is in a hole, merge it with the current one. */\n\t\tif (rl_end->lcn == LCN_HOLE) {\n\t\t\trl_end++;\n\t\t\trl->length = rl_end->vcn - rl->vcn;\n\t\t}\n\t\t/* We have done the hole.  Now deal with the remaining tail. */\n\t\trl++;\n\t\t/* Cut out all runlist elements up to @end. */\n\t\tif (rl < rl_end)\n\t\t\tmemmove(rl, rl_end, (rl_real_end - rl_end + 1) *\n\t\t\t\t\tsizeof(*rl));\n\t\t/* Adjust the beginning of the tail if necessary. */\n\t\tif (end > rl->vcn) {\n\t\t\tdelta = end - rl->vcn;\n\t\t\trl->vcn = end;\n\t\t\trl->length -= delta;\n\t\t\t/* Only adjust the lcn if it is real. */\n\t\t\tif (rl->lcn >= 0)\n\t\t\t\trl->lcn += delta;\n\t\t}\nshrink_allocation:\n\t\t/* Reallocate memory if the allocation changed. */\n\t\tif (rl < rl_end) {\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size - (rl_end - rl));\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t\tntfs_debug(\"Done (extend hole).\");\n\t\treturn 0;\n\t}\n\t/*\n\t * If @start is at the beginning of a run things are easier as there is\n\t * no need to split the first run.\n\t */\n\tif (start == rl->vcn) {\n\t\t/*\n\t\t * @start is at the beginning of a run.\n\t\t *\n\t\t * If the previous run is sparse, extend its hole.\n\t\t *\n\t\t * If @end is not in the same run, switch the run to be sparse\n\t\t * and extend the newly created hole.\n\t\t *\n\t\t * Thus both of these cases reduce the problem to the above\n\t\t * case of \"@start is in a hole\".\n\t\t */\n\t\tif (rl > runlist->rl && (rl - 1)->lcn == LCN_HOLE) {\n\t\t\trl--;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\tif (end >= rl[1].vcn) {\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\t/*\n\t\t * The final case is when @end is in the same run as @start.\n\t\t * For this need to split the run into two.  One run for the\n\t\t * sparse region between the beginning of the old run, i.e.\n\t\t * @start, and @end and one for the remaining non-sparse\n\t\t * region, i.e. between @end and the end of the old run.\n\t\t */\n\t\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 1);\n\t\tif (IS_ERR(trl))\n\t\t\tgoto enomem_out;\n\t\told_size++;\n\t\tif (runlist->rl != trl) {\n\t\t\trl = trl + (rl - runlist->rl);\n\t\t\trl_end = trl + (rl_end - runlist->rl);\n\t\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\t\trunlist->rl = trl;\n\t\t}\nsplit_end:\n\t\t/* Shift all the runs up by one. */\n\t\tmemmove(rl + 1, rl, (rl_real_end - rl + 1) * sizeof(*rl));\n\t\t/* Finally, setup the two split runs. */\n\t\trl->lcn = LCN_HOLE;\n\t\trl->length = length;\n\t\trl++;\n\t\trl->vcn += length;\n\t\t/* Only adjust the lcn if it is real. */\n\t\tif (rl->lcn >= 0 || lcn_fixup)\n\t\t\trl->lcn += length;\n\t\trl->length -= length;\n\t\tntfs_debug(\"Done (split one).\");\n\t\treturn 0;\n\t}\n\t/*\n\t * @start is neither in a hole nor at the beginning of a run.\n\t *\n\t * If @end is in a hole, things are easier as simply truncating the run\n\t * @start is in to end at @start - 1, deleting all runs after that up\n\t * to @end, and finally extending the beginning of the run @end is in\n\t * to be @start is all that is needed.\n\t */\n\tif (rl_end->lcn == LCN_HOLE) {\n\t\t/* Truncate the run containing @start. */\n\t\trl->length = start - rl->vcn;\n\t\trl++;\n\t\t/* Cut out all runlist elements up to @end. */\n\t\tif (rl < rl_end)\n\t\t\tmemmove(rl, rl_end, (rl_real_end - rl_end + 1) *\n\t\t\t\t\tsizeof(*rl));\n\t\t/* Extend the beginning of the run @end is in to be @start. */\n\t\trl->vcn = start;\n\t\trl->length = rl[1].vcn - start;\n\t\tgoto shrink_allocation;\n\t}\n\t/* \n\t * If @end is not in a hole there are still two cases to distinguish.\n\t * Either @end is or is not in the same run as @start.\n\t *\n\t * The second case is easier as it can be reduced to an already solved\n\t * problem by truncating the run @start is in to end at @start - 1.\n\t * Then, if @end is in the next run need to split the run into a sparse\n\t * run followed by a non-sparse run (already covered above) and if @end\n\t * is not in the next run switching it to be sparse, again reduces the\n\t * problem to the already covered case of \"@start is in a hole\".\n\t */\n\tif (end >= rl[1].vcn) {\n\t\t/*\n\t\t * If @end is not in the next run, reduce the problem to the\n\t\t * case of \"@start is in a hole\".\n\t\t */\n\t\tif (rl[1].length && end >= rl[2].vcn) {\n\t\t\t/* Truncate the run containing @start. */\n\t\t\trl->length = start - rl->vcn;\n\t\t\trl++;\n\t\t\trl->vcn = start;\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 1);\n\t\tif (IS_ERR(trl))\n\t\t\tgoto enomem_out;\n\t\told_size++;\n\t\tif (runlist->rl != trl) {\n\t\t\trl = trl + (rl - runlist->rl);\n\t\t\trl_end = trl + (rl_end - runlist->rl);\n\t\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\t\trunlist->rl = trl;\n\t\t}\n\t\t/* Truncate the run containing @start. */\n\t\trl->length = start - rl->vcn;\n\t\trl++;\n\t\t/*\n\t\t * @end is in the next run, reduce the problem to the case\n\t\t * where \"@start is at the beginning of a run and @end is in\n\t\t * the same run as @start\".\n\t\t */\n\t\tdelta = rl->vcn - start;\n\t\trl->vcn = start;\n\t\tif (rl->lcn >= 0) {\n\t\t\trl->lcn -= delta;\n\t\t\t/* Need this in case the lcn just became negative. */\n\t\t\tlcn_fixup = true;\n\t\t}\n\t\trl->length += delta;\n\t\tgoto split_end;\n\t}\n\t/*\n\t * The first case from above, i.e. @end is in the same run as @start.\n\t * We need to split the run into three.  One run for the non-sparse\n\t * region between the beginning of the old run and @start, one for the\n\t * sparse region between @start and @end, and one for the remaining\n\t * non-sparse region, i.e. between @end and the end of the old run.\n\t */\n\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 2);\n\tif (IS_ERR(trl))\n\t\tgoto enomem_out;\n\told_size += 2;\n\tif (runlist->rl != trl) {\n\t\trl = trl + (rl - runlist->rl);\n\t\trl_end = trl + (rl_end - runlist->rl);\n\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\trunlist->rl = trl;\n\t}\n\t/* Shift all the runs up by two. */\n\tmemmove(rl + 2, rl, (rl_real_end - rl + 1) * sizeof(*rl));\n\t/* Finally, setup the three split runs. */\n\trl->length = start - rl->vcn;\n\trl++;\n\trl->vcn = start;\n\trl->lcn = LCN_HOLE;\n\trl->length = length;\n\trl++;\n\tdelta = end - rl->vcn;\n\trl->vcn = end;\n\trl->lcn += delta;\n\trl->length -= delta;\n\tntfs_debug(\"Done (split both).\");\n\treturn 0;\nenomem_out:\n\tntfs_error(vol->sb, \"Not enough memory to extend runlist buffer.\");\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_rl_punch_nolock(const ntfs_volume *vol, runlist *const runlist,\n\t\tconst VCN start, const s64 length)\n{\n\tconst VCN end = start + length;\n\ts64 delta;\n\trunlist_element *rl, *rl_end, *rl_real_end, *trl;\n\tint old_size;\n\tbool lcn_fixup = false;\n\n\tntfs_debug(\"Entering for start 0x%llx, length 0x%llx.\",\n\t\t\t(long long)start, (long long)length);\n\tBUG_ON(!runlist);\n\tBUG_ON(start < 0);\n\tBUG_ON(length < 0);\n\tBUG_ON(end < 0);\n\trl = runlist->rl;\n\tif (unlikely(!rl)) {\n\t\tif (likely(!start && !length))\n\t\t\treturn 0;\n\t\treturn -ENOENT;\n\t}\n\t/* Find @start in the runlist. */\n\twhile (likely(rl->length && start >= rl[1].vcn))\n\t\trl++;\n\trl_end = rl;\n\t/* Find @end in the runlist. */\n\twhile (likely(rl_end->length && end >= rl_end[1].vcn)) {\n\t\t/* Verify there are no unmapped or error elements. */\n\t\tif (unlikely(rl_end->lcn < LCN_HOLE))\n\t\t\treturn -EINVAL;\n\t\trl_end++;\n\t}\n\t/* Check the last element. */\n\tif (unlikely(rl_end->length && rl_end->lcn < LCN_HOLE))\n\t\treturn -EINVAL;\n\t/* This covers @start being out of bounds, too. */\n\tif (!rl_end->length && end > rl_end->vcn)\n\t\treturn -ENOENT;\n\tif (!length)\n\t\treturn 0;\n\tif (!rl->length)\n\t\treturn -ENOENT;\n\trl_real_end = rl_end;\n\t/* Determine the runlist size. */\n\twhile (likely(rl_real_end->length))\n\t\trl_real_end++;\n\told_size = rl_real_end - runlist->rl + 1;\n\t/* If @start is in a hole simply extend the hole. */\n\tif (rl->lcn == LCN_HOLE) {\n\t\t/*\n\t\t * If both @start and @end are in the same sparse run, we are\n\t\t * done.\n\t\t */\n\t\tif (end <= rl[1].vcn) {\n\t\t\tntfs_debug(\"Done (requested hole is already sparse).\");\n\t\t\treturn 0;\n\t\t}\nextend_hole:\n\t\t/* Extend the hole. */\n\t\trl->length = end - rl->vcn;\n\t\t/* If @end is in a hole, merge it with the current one. */\n\t\tif (rl_end->lcn == LCN_HOLE) {\n\t\t\trl_end++;\n\t\t\trl->length = rl_end->vcn - rl->vcn;\n\t\t}\n\t\t/* We have done the hole.  Now deal with the remaining tail. */\n\t\trl++;\n\t\t/* Cut out all runlist elements up to @end. */\n\t\tif (rl < rl_end)\n\t\t\tmemmove(rl, rl_end, (rl_real_end - rl_end + 1) *\n\t\t\t\t\tsizeof(*rl));\n\t\t/* Adjust the beginning of the tail if necessary. */\n\t\tif (end > rl->vcn) {\n\t\t\tdelta = end - rl->vcn;\n\t\t\trl->vcn = end;\n\t\t\trl->length -= delta;\n\t\t\t/* Only adjust the lcn if it is real. */\n\t\t\tif (rl->lcn >= 0)\n\t\t\t\trl->lcn += delta;\n\t\t}\nshrink_allocation:\n\t\t/* Reallocate memory if the allocation changed. */\n\t\tif (rl < rl_end) {\n\t\t\trl = ntfs_rl_realloc(runlist->rl, old_size,\n\t\t\t\t\told_size - (rl_end - rl));\n\t\t\tif (IS_ERR(rl))\n\t\t\t\tntfs_warning(vol->sb, \"Failed to shrink \"\n\t\t\t\t\t\t\"runlist buffer.  This just \"\n\t\t\t\t\t\t\"wastes a bit of memory \"\n\t\t\t\t\t\t\"temporarily so we ignore it \"\n\t\t\t\t\t\t\"and return success.\");\n\t\t\telse\n\t\t\t\trunlist->rl = rl;\n\t\t}\n\t\tntfs_debug(\"Done (extend hole).\");\n\t\treturn 0;\n\t}\n\t/*\n\t * If @start is at the beginning of a run things are easier as there is\n\t * no need to split the first run.\n\t */\n\tif (start == rl->vcn) {\n\t\t/*\n\t\t * @start is at the beginning of a run.\n\t\t *\n\t\t * If the previous run is sparse, extend its hole.\n\t\t *\n\t\t * If @end is not in the same run, switch the run to be sparse\n\t\t * and extend the newly created hole.\n\t\t *\n\t\t * Thus both of these cases reduce the problem to the above\n\t\t * case of \"@start is in a hole\".\n\t\t */\n\t\tif (rl > runlist->rl && (rl - 1)->lcn == LCN_HOLE) {\n\t\t\trl--;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\tif (end >= rl[1].vcn) {\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\t/*\n\t\t * The final case is when @end is in the same run as @start.\n\t\t * For this need to split the run into two.  One run for the\n\t\t * sparse region between the beginning of the old run, i.e.\n\t\t * @start, and @end and one for the remaining non-sparse\n\t\t * region, i.e. between @end and the end of the old run.\n\t\t */\n\t\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 1);\n\t\tif (IS_ERR(trl))\n\t\t\tgoto enomem_out;\n\t\told_size++;\n\t\tif (runlist->rl != trl) {\n\t\t\trl = trl + (rl - runlist->rl);\n\t\t\trl_end = trl + (rl_end - runlist->rl);\n\t\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\t\trunlist->rl = trl;\n\t\t}\nsplit_end:\n\t\t/* Shift all the runs up by one. */\n\t\tmemmove(rl + 1, rl, (rl_real_end - rl + 1) * sizeof(*rl));\n\t\t/* Finally, setup the two split runs. */\n\t\trl->lcn = LCN_HOLE;\n\t\trl->length = length;\n\t\trl++;\n\t\trl->vcn += length;\n\t\t/* Only adjust the lcn if it is real. */\n\t\tif (rl->lcn >= 0 || lcn_fixup)\n\t\t\trl->lcn += length;\n\t\trl->length -= length;\n\t\tntfs_debug(\"Done (split one).\");\n\t\treturn 0;\n\t}\n\t/*\n\t * @start is neither in a hole nor at the beginning of a run.\n\t *\n\t * If @end is in a hole, things are easier as simply truncating the run\n\t * @start is in to end at @start - 1, deleting all runs after that up\n\t * to @end, and finally extending the beginning of the run @end is in\n\t * to be @start is all that is needed.\n\t */\n\tif (rl_end->lcn == LCN_HOLE) {\n\t\t/* Truncate the run containing @start. */\n\t\trl->length = start - rl->vcn;\n\t\trl++;\n\t\t/* Cut out all runlist elements up to @end. */\n\t\tif (rl < rl_end)\n\t\t\tmemmove(rl, rl_end, (rl_real_end - rl_end + 1) *\n\t\t\t\t\tsizeof(*rl));\n\t\t/* Extend the beginning of the run @end is in to be @start. */\n\t\trl->vcn = start;\n\t\trl->length = rl[1].vcn - start;\n\t\tgoto shrink_allocation;\n\t}\n\t/* \n\t * If @end is not in a hole there are still two cases to distinguish.\n\t * Either @end is or is not in the same run as @start.\n\t *\n\t * The second case is easier as it can be reduced to an already solved\n\t * problem by truncating the run @start is in to end at @start - 1.\n\t * Then, if @end is in the next run need to split the run into a sparse\n\t * run followed by a non-sparse run (already covered above) and if @end\n\t * is not in the next run switching it to be sparse, again reduces the\n\t * problem to the already covered case of \"@start is in a hole\".\n\t */\n\tif (end >= rl[1].vcn) {\n\t\t/*\n\t\t * If @end is not in the next run, reduce the problem to the\n\t\t * case of \"@start is in a hole\".\n\t\t */\n\t\tif (rl[1].length && end >= rl[2].vcn) {\n\t\t\t/* Truncate the run containing @start. */\n\t\t\trl->length = start - rl->vcn;\n\t\t\trl++;\n\t\t\trl->vcn = start;\n\t\t\trl->lcn = LCN_HOLE;\n\t\t\tgoto extend_hole;\n\t\t}\n\t\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 1);\n\t\tif (IS_ERR(trl))\n\t\t\tgoto enomem_out;\n\t\told_size++;\n\t\tif (runlist->rl != trl) {\n\t\t\trl = trl + (rl - runlist->rl);\n\t\t\trl_end = trl + (rl_end - runlist->rl);\n\t\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\t\trunlist->rl = trl;\n\t\t}\n\t\t/* Truncate the run containing @start. */\n\t\trl->length = start - rl->vcn;\n\t\trl++;\n\t\t/*\n\t\t * @end is in the next run, reduce the problem to the case\n\t\t * where \"@start is at the beginning of a run and @end is in\n\t\t * the same run as @start\".\n\t\t */\n\t\tdelta = rl->vcn - start;\n\t\trl->vcn = start;\n\t\tif (rl->lcn >= 0) {\n\t\t\trl->lcn -= delta;\n\t\t\t/* Need this in case the lcn just became negative. */\n\t\t\tlcn_fixup = true;\n\t\t}\n\t\trl->length += delta;\n\t\tgoto split_end;\n\t}\n\t/*\n\t * The first case from above, i.e. @end is in the same run as @start.\n\t * We need to split the run into three.  One run for the non-sparse\n\t * region between the beginning of the old run and @start, one for the\n\t * sparse region between @start and @end, and one for the remaining\n\t * non-sparse region, i.e. between @end and the end of the old run.\n\t */\n\ttrl = ntfs_rl_realloc(runlist->rl, old_size, old_size + 2);\n\tif (IS_ERR(trl))\n\t\tgoto enomem_out;\n\told_size += 2;\n\tif (runlist->rl != trl) {\n\t\trl = trl + (rl - runlist->rl);\n\t\trl_end = trl + (rl_end - runlist->rl);\n\t\trl_real_end = trl + (rl_real_end - runlist->rl);\n\t\trunlist->rl = trl;\n\t}\n\t/* Shift all the runs up by two. */\n\tmemmove(rl + 2, rl, (rl_real_end - rl + 1) * sizeof(*rl));\n\t/* Finally, setup the three split runs. */\n\trl->length = start - rl->vcn;\n\trl++;\n\trl->vcn = start;\n\trl->lcn = LCN_HOLE;\n\trl->length = length;\n\trl++;\n\tdelta = end - rl->vcn;\n\trl->vcn = end;\n\trl->lcn += delta;\n\trl->length -= delta;\n\tntfs_debug(\"Done (split both).\");\n\treturn 0;\nenomem_out:\n\tntfs_error(vol->sb, \"Not enough memory to extend runlist buffer.\");\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rl_write_locked"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to find required \"\n\t\t\t\t\t\"attribute extent of attribute in \"\n\t\t\t\t\t\"error code path.  Run chkdsk to \"\n\t\t\t\t\t\"recover.\""
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "ni->type",
            "ni->name",
            "ni->name_len",
            "CASE_SENSITIVE",
            "bh_cpos",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_reinit_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_reinit_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1240-1259",
          "snippet": "void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (likely(!ctx->base_ntfs_ino)) {\n\t\t/* No attribute list. */\n\t\tctx->is_first = true;\n\t\t/* Sanity checks are performed elsewhere. */\n\t\tctx->attr = (ATTR_RECORD*)((u8*)ctx->mrec +\n\t\t\t\tle16_to_cpu(ctx->mrec->attrs_offset));\n\t\t/*\n\t\t * This needs resetting due to ntfs_external_attr_find() which\n\t\t * can leave it set despite having zeroed ctx->base_ntfs_ino.\n\t\t */\n\t\tctx->al_entry = NULL;\n\t\treturn;\n\t} /* Attribute list. */\n\tif (ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tntfs_attr_init_search_ctx(ctx, ctx->base_ntfs_ino, ctx->base_mrec);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user_segment",
          "args": [
            "page",
            "bh_offset(bh) + ofs",
            "blocksize"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "bh_pos < initialized_size"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "bh_pos + blocksize > initialized_size"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "buffer_uptodate(bh)"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl_write_locked"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err && ++u < nr_pages"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "vcn + vcn_len >= cend"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_sle64",
          "args": [
            "ni->itype.compressed.size"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_sle64p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "88-91",
          "snippet": "static inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "NInoSparse(ni) || NInoCompressed(ni)"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoCompressed",
          "args": [
            "ni"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoSparse",
          "args": [
            "ni"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!a->data.non_resident.highest_vcn"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ni->type"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\""
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "err != -ENOSPC"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Failed to get size for mapping pairs \"\n\t\t\t\t\t\"array, error code %i.\"",
            "err"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "mp_size <= 0"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_get_size_for_mapping_pairs",
          "args": [
            "vol",
            "rl2",
            "vcn",
            "highest_vcn"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_get_size_for_mapping_pairs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1131-1232",
          "snippet": "int ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nint ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,\n\t\tconst runlist_element *rl, const VCN first_vcn,\n\t\tconst VCN last_vcn)\n{\n\tLCN prev_lcn;\n\tint rls;\n\tbool the_end = false;\n\n\tBUG_ON(first_vcn < 0);\n\tBUG_ON(last_vcn < -1);\n\tBUG_ON(last_vcn >= 0 && first_vcn > last_vcn);\n\tif (!rl) {\n\t\tBUG_ON(first_vcn);\n\t\tBUG_ON(last_vcn > 0);\n\t\treturn 1;\n\t}\n\t/* Skip to runlist element containing @first_vcn. */\n\twhile (rl->length && first_vcn >= rl[1].vcn)\n\t\trl++;\n\tif (unlikely((!rl->length && first_vcn > rl->vcn) ||\n\t\t\tfirst_vcn < rl->vcn))\n\t\treturn -EINVAL;\n\tprev_lcn = 0;\n\t/* Always need the termining zero byte. */\n\trls = 1;\n\t/* Do the first partial run if present. */\n\tif (first_vcn > rl->vcn) {\n\t\ts64 delta, length = rl->length;\n\n\t\t/* We know rl->length != 0 already. */\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\tdelta = first_vcn - rl->vcn;\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length - delta);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\tprev_lcn = rl->lcn;\n\t\t\tif (likely(rl->lcn >= 0))\n\t\t\t\tprev_lcn += delta;\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(prev_lcn);\n\t\t}\n\t\t/* Go to next runlist element. */\n\t\trl++;\n\t}\n\t/* Do the full runs. */\n\tfor (; rl->length && !the_end; rl++) {\n\t\ts64 length = rl->length;\n\n\t\tif (unlikely(length < 0 || rl->lcn < LCN_HOLE))\n\t\t\tgoto err_out;\n\t\t/*\n\t\t * If @stop_vcn is given and finishes inside this run, cap the\n\t\t * run length.\n\t\t */\n\t\tif (unlikely(last_vcn >= 0 && rl[1].vcn > last_vcn)) {\n\t\t\ts64 s1 = last_vcn + 1;\n\t\t\tif (unlikely(rl[1].vcn > s1))\n\t\t\t\tlength = s1 - rl->vcn;\n\t\t\tthe_end = true;\n\t\t}\n\t\t/* Header byte + length. */\n\t\trls += 1 + ntfs_get_nr_significant_bytes(length);\n\t\t/*\n\t\t * If the logical cluster number (lcn) denotes a hole and we\n\t\t * are on NTFS 3.0+, we don't store it at all, i.e. we need\n\t\t * zero space.  On earlier NTFS versions we just store the lcn.\n\t\t * Note: this assumes that on NTFS 1.2-, holes are stored with\n\t\t * an lcn of -1 and not a delta_lcn of -1 (unless both are -1).\n\t\t */\n\t\tif (likely(rl->lcn >= 0 || vol->major_ver < 3)) {\n\t\t\t/* Change in lcn. */\n\t\t\trls += ntfs_get_nr_significant_bytes(rl->lcn -\n\t\t\t\t\tprev_lcn);\n\t\t\tprev_lcn = rl->lcn;\n\t\t}\n\t}\n\treturn rls;\nerr_out:\n\tif (rl->lcn == LCN_RL_NOT_MAPPED)\n\t\trls = -EINVAL;\n\telse\n\t\trls = -EIO;\n\treturn rls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "a->data.non_resident.allocated_size"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rl2->lcn < LCN_HOLE"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rl2->length"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rl2"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_find_vcn_nolock",
          "args": [
            "rl",
            "vcn"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_find_vcn_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1053-1069",
          "snippet": "runlist_element *ntfs_rl_find_vcn_nolock(runlist_element *rl, const VCN vcn)\n{\n\tBUG_ON(vcn < 0);\n\tif (unlikely(!rl || vcn < rl[0].vcn))\n\t\treturn NULL;\n\twhile (likely(rl->length)) {\n\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\tif (likely(rl->lcn >= LCN_HOLE))\n\t\t\t\treturn rl;\n\t\t\treturn NULL;\n\t\t}\n\t\trl++;\n\t}\n\tif (likely(rl->lcn == LCN_ENOENT))\n\t\treturn rl;\n\treturn NULL;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_rl_find_vcn_nolock(runlist_element *rl, const VCN vcn)\n{\n\tBUG_ON(vcn < 0);\n\tif (unlikely(!rl || vcn < rl[0].vcn))\n\t\treturn NULL;\n\twhile (likely(rl->length)) {\n\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\tif (likely(rl->lcn >= LCN_HOLE))\n\t\t\t\treturn rl;\n\t\t\treturn NULL;\n\t\t}\n\t\trl++;\n\t}\n\tif (likely(rl->lcn == LCN_ENOENT))\n\t\treturn rl;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "m"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Allocated cluster, lcn 0x%llx.\"",
            "(unsigned long long)lcn"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "rl2"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to release \"\n\t\t\t\t\t\t\"allocated cluster in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover the lost cluster.\""
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_free_from_rl",
          "args": [
            "vol",
            "rl2"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_free_from_rl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.h",
          "lines": "132-141",
          "snippet": "static inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tint ret;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tret = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"volume.h\"",
            "#include \"runlist.h\"",
            "#include \"inode.h\"",
            "#include \"types.h\"",
            "#include \"attrib.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"volume.h\"\n#include \"runlist.h\"\n#include \"inode.h\"\n#include \"types.h\"\n#include \"attrib.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tint ret;\n\n\tdown_write(&vol->lcnbmp_lock);\n\tret = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_runlists_merge",
          "args": [
            "ni->runlist.rl",
            "rl2"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_runlists_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "531-719",
          "snippet": "runlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t/* Current index into @[ds]rl. */\n\tint sstart;\t\t/* First index with lcn > LCN_RL_NOT_MAPPED. */\n\tint dins;\t\t/* Index into @drl at which to insert @srl. */\n\tint dend, send;\t\t/* Last index into @[ds]rl. */\n\tint dfinal, sfinal;\t/* The last index into @[ds]rl with\n\t\t\t\t   lcn >= LCN_HOLE. */\n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t/* Check for silly calling... */\n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check for the case where the first mapping is being done now. */\n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t/* Complete the source runlist if necessary. */\n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t/* Scan to the end of the source runlist. */\n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t/* Insert start element at the front of the runlist. */\n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t/* Skip any unmapped start element(s) in the source runlist. */\n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t/* Can't have an entirely unmapped source runlist. */\n\tBUG_ON(!srl[si].length);\n\n\t/* Record the starting points. */\n\tsstart = si;\n\n\t/*\n\t * Skip forward in @drl until we reach the position where @srl needs to\n\t * be inserted. If we reach the end of @drl, @srl just needs to be\n\t * appended to @drl.\n\t */\n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t/* Sanity check for illegal overlaps. */\n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t/* Scan to the end of both runlists in order to know their sizes. */\n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t/* Scan to the last element with lcn >= LCN_HOLE. */\n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t/* Number of elements in drl & srl */\n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */\n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t     /* Start of hole */\n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */\n\t\t ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */\n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t/* Or we will lose an end marker. */\n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t/* We only need to care if @srl ended after @drl. */\n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to create an unmapped runlist element in\n\t\t\t * @drl or extend an existing one before adding the\n\t\t\t * ENOENT terminator.\n\t\t\t */\n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t/* Add an unmapped runlist element. */\n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t/* Need to set vcn if it isn't set already. */\n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t/* We now used up a slot. */\n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t/* Finally add the ENOENT terminator. */\n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t/* The merge was completed successfully. */\n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nrunlist_element *ntfs_runlists_merge(runlist_element *drl,\n\t\trunlist_element *srl)\n{\n\tint di, si;\t\t/* Current index into @[ds]rl. */\n\tint sstart;\t\t/* First index with lcn > LCN_RL_NOT_MAPPED. */\n\tint dins;\t\t/* Index into @drl at which to insert @srl. */\n\tint dend, send;\t\t/* Last index into @[ds]rl. */\n\tint dfinal, sfinal;\t/* The last index into @[ds]rl with\n\t\t\t\t   lcn >= LCN_HOLE. */\n\tint marker = 0;\n\tVCN marker_vcn = 0;\n\n#ifdef DEBUG\n\tntfs_debug(\"dst:\");\n\tntfs_debug_dump_runlist(drl);\n\tntfs_debug(\"src:\");\n\tntfs_debug_dump_runlist(srl);\n#endif\n\n\t/* Check for silly calling... */\n\tif (unlikely(!srl))\n\t\treturn drl;\n\tif (IS_ERR(srl) || IS_ERR(drl))\n\t\treturn ERR_PTR(-EINVAL);\n\n\t/* Check for the case where the first mapping is being done now. */\n\tif (unlikely(!drl)) {\n\t\tdrl = srl;\n\t\t/* Complete the source runlist if necessary. */\n\t\tif (unlikely(drl[0].vcn)) {\n\t\t\t/* Scan to the end of the source runlist. */\n\t\t\tfor (dend = 0; likely(drl[dend].length); dend++)\n\t\t\t\t;\n\t\t\tdend++;\n\t\t\tdrl = ntfs_rl_realloc(drl, dend, dend + 1);\n\t\t\tif (IS_ERR(drl))\n\t\t\t\treturn drl;\n\t\t\t/* Insert start element at the front of the runlist. */\n\t\t\tntfs_rl_mm(drl, 1, 0, dend);\n\t\t\tdrl[0].vcn = 0;\n\t\t\tdrl[0].lcn = LCN_RL_NOT_MAPPED;\n\t\t\tdrl[0].length = drl[1].vcn;\n\t\t}\n\t\tgoto finished;\n\t}\n\n\tsi = di = 0;\n\n\t/* Skip any unmapped start element(s) in the source runlist. */\n\twhile (srl[si].length && srl[si].lcn < LCN_HOLE)\n\t\tsi++;\n\n\t/* Can't have an entirely unmapped source runlist. */\n\tBUG_ON(!srl[si].length);\n\n\t/* Record the starting points. */\n\tsstart = si;\n\n\t/*\n\t * Skip forward in @drl until we reach the position where @srl needs to\n\t * be inserted. If we reach the end of @drl, @srl just needs to be\n\t * appended to @drl.\n\t */\n\tfor (; drl[di].length; di++) {\n\t\tif (drl[di].vcn + drl[di].length > srl[sstart].vcn)\n\t\t\tbreak;\n\t}\n\tdins = di;\n\n\t/* Sanity check for illegal overlaps. */\n\tif ((drl[di].vcn == srl[si].vcn) && (drl[di].lcn >= 0) &&\n\t\t\t(srl[si].lcn >= 0)) {\n\t\tntfs_error(NULL, \"Run lists overlap. Cannot merge!\");\n\t\treturn ERR_PTR(-ERANGE);\n\t}\n\n\t/* Scan to the end of both runlists in order to know their sizes. */\n\tfor (send = si; srl[send].length; send++)\n\t\t;\n\tfor (dend = di; drl[dend].length; dend++)\n\t\t;\n\n\tif (srl[send].lcn == LCN_ENOENT)\n\t\tmarker_vcn = srl[marker = send].vcn;\n\n\t/* Scan to the last element with lcn >= LCN_HOLE. */\n\tfor (sfinal = send; sfinal >= 0 && srl[sfinal].lcn < LCN_HOLE; sfinal--)\n\t\t;\n\tfor (dfinal = dend; dfinal >= 0 && drl[dfinal].lcn < LCN_HOLE; dfinal--)\n\t\t;\n\n\t{\n\tbool start;\n\tbool finish;\n\tint ds = dend + 1;\t\t/* Number of elements in drl & srl */\n\tint ss = sfinal - sstart + 1;\n\n\tstart  = ((drl[dins].lcn <  LCN_RL_NOT_MAPPED) ||    /* End of file   */\n\t\t  (drl[dins].vcn == srl[sstart].vcn));\t     /* Start of hole */\n\tfinish = ((drl[dins].lcn >= LCN_RL_NOT_MAPPED) &&    /* End of file   */\n\t\t ((drl[dins].vcn + drl[dins].length) <=      /* End of hole   */\n\t\t  (srl[send - 1].vcn + srl[send - 1].length)));\n\n\t/* Or we will lose an end marker. */\n\tif (finish && !drl[dins].length)\n\t\tss++;\n\tif (marker && (drl[dins].vcn + drl[dins].length > srl[send - 1].vcn))\n\t\tfinish = false;\n#if 0\n\tntfs_debug(\"dfinal = %i, dend = %i\", dfinal, dend);\n\tntfs_debug(\"sstart = %i, sfinal = %i, send = %i\", sstart, sfinal, send);\n\tntfs_debug(\"start = %i, finish = %i\", start, finish);\n\tntfs_debug(\"ds = %i, ss = %i, dins = %i\", ds, ss, dins);\n#endif\n\tif (start) {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_replace(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_insert(drl, ds, srl + sstart, ss, dins);\n\t} else {\n\t\tif (finish)\n\t\t\tdrl = ntfs_rl_append(drl, ds, srl + sstart, ss, dins);\n\t\telse\n\t\t\tdrl = ntfs_rl_split(drl, ds, srl + sstart, ss, dins);\n\t}\n\tif (IS_ERR(drl)) {\n\t\tntfs_error(NULL, \"Merge failed.\");\n\t\treturn drl;\n\t}\n\tntfs_free(srl);\n\tif (marker) {\n\t\tntfs_debug(\"Triggering marker code.\");\n\t\tfor (ds = dend; drl[ds].length; ds++)\n\t\t\t;\n\t\t/* We only need to care if @srl ended after @drl. */\n\t\tif (drl[ds].vcn <= marker_vcn) {\n\t\t\tint slots = 0;\n\n\t\t\tif (drl[ds].vcn == marker_vcn) {\n\t\t\t\tntfs_debug(\"Old marker = 0x%llx, replacing \"\n\t\t\t\t\t\t\"with LCN_ENOENT.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tdrl[ds].lcn);\n\t\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\t\tgoto finished;\n\t\t\t}\n\t\t\t/*\n\t\t\t * We need to create an unmapped runlist element in\n\t\t\t * @drl or extend an existing one before adding the\n\t\t\t * ENOENT terminator.\n\t\t\t */\n\t\t\tif (drl[ds].lcn == LCN_ENOENT) {\n\t\t\t\tds--;\n\t\t\t\tslots = 1;\n\t\t\t}\n\t\t\tif (drl[ds].lcn != LCN_RL_NOT_MAPPED) {\n\t\t\t\t/* Add an unmapped runlist element. */\n\t\t\t\tif (!slots) {\n\t\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds,\n\t\t\t\t\t\t\tds + 2);\n\t\t\t\t\tslots = 2;\n\t\t\t\t}\n\t\t\t\tds++;\n\t\t\t\t/* Need to set vcn if it isn't set already. */\n\t\t\t\tif (slots != 1)\n\t\t\t\t\tdrl[ds].vcn = drl[ds - 1].vcn +\n\t\t\t\t\t\t\tdrl[ds - 1].length;\n\t\t\t\tdrl[ds].lcn = LCN_RL_NOT_MAPPED;\n\t\t\t\t/* We now used up a slot. */\n\t\t\t\tslots--;\n\t\t\t}\n\t\t\tdrl[ds].length = marker_vcn - drl[ds].vcn;\n\t\t\t/* Finally add the ENOENT terminator. */\n\t\t\tds++;\n\t\t\tif (!slots)\n\t\t\t\tdrl = ntfs_rl_realloc_nofail(drl, ds, ds + 1);\n\t\t\tdrl[ds].vcn = marker_vcn;\n\t\t\tdrl[ds].lcn = LCN_ENOENT;\n\t\t\tdrl[ds].length = (s64)0;\n\t\t}\n\t}\n\t}\n\nfinished:\n\t/* The merge was completed successfully. */\n\tntfs_debug(\"Merged runlist:\");\n\tntfs_debug_dump_runlist(drl);\n\treturn drl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Failed to allocate cluster, error code %i.\"",
            "err"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl2"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl2"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_alloc",
          "args": [
            "vol",
            "bh_cpos",
            "1",
            "lcn",
            "DATA_ZONE",
            "false"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.c",
          "lines": "146-787",
          "snippet": "runlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,\n\t\tconst s64 count, const LCN start_lcn,\n\t\tconst NTFS_CLUSTER_ALLOCATION_ZONES zone,\n\t\tconst bool is_extension)\n{\n\tLCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;\n\tLCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;\n\ts64 clusters;\n\tloff_t i_size;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *buf, *byte;\n\tint err = 0, rlpos, rlsize, buf_size;\n\tu8 pass, done_zones, search_zone, need_writeback = 0, bit;\n\n\tntfs_debug(\"Entering for start_vcn 0x%llx, count 0x%llx, start_lcn \"\n\t\t\t\"0x%llx, zone %s_ZONE.\", (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\t(unsigned long long)start_lcn,\n\t\t\tzone == MFT_ZONE ? \"MFT\" : \"DATA\");\n\tBUG_ON(!vol);\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < 0);\n\tBUG_ON(start_lcn < -1);\n\tBUG_ON(zone < FIRST_ZONE);\n\tBUG_ON(zone > LAST_ZONE);\n\n\t/* Return NULL if @count is zero. */\n\tif (!count)\n\t\treturn NULL;\n\t/* Take the lcnbmp lock for writing. */\n\tdown_write(&vol->lcnbmp_lock);\n\t/*\n\t * If no specific @start_lcn was requested, use the current data zone\n\t * position, otherwise use the requested @start_lcn but make sure it\n\t * lies outside the mft zone.  Also set done_zones to 0 (no zones done)\n\t * and pass depending on whether we are starting inside a zone (1) or\n\t * at the beginning of a zone (2).  If requesting from the MFT_ZONE,\n\t * we either start at the current position within the mft zone or at\n\t * the specified position.  If the latter is out of bounds then we start\n\t * at the beginning of the MFT_ZONE.\n\t */\n\tdone_zones = 0;\n\tpass = 1;\n\t/*\n\t * zone_start and zone_end are the current search range.  search_zone\n\t * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of\n\t * volume) and 4 for data zone 2 (start of volume till start of mft\n\t * zone).\n\t */\n\tzone_start = start_lcn;\n\tif (zone_start < 0) {\n\t\tif (zone == DATA_ZONE)\n\t\t\tzone_start = vol->data1_zone_pos;\n\t\telse\n\t\t\tzone_start = vol->mft_zone_pos;\n\t\tif (!zone_start) {\n\t\t\t/*\n\t\t\t * Zone starts at beginning of volume which means a\n\t\t\t * single pass is sufficient.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t}\n\t} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&\n\t\t\tzone_start < vol->mft_zone_end) {\n\t\tzone_start = vol->mft_zone_end;\n\t\t/*\n\t\t * Starting at beginning of data1_zone which means a single\n\t\t * pass in this zone is sufficient.\n\t\t */\n\t\tpass = 2;\n\t} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||\n\t\t\tzone_start >= vol->mft_zone_end)) {\n\t\tzone_start = vol->mft_lcn;\n\t\tif (!vol->mft_zone_end)\n\t\t\tzone_start = 0;\n\t\t/*\n\t\t * Starting at beginning of volume which means a single pass\n\t\t * is sufficient.\n\t\t */\n\t\tpass = 2;\n\t}\n\tif (zone == MFT_ZONE) {\n\t\tzone_end = vol->mft_zone_end;\n\t\tsearch_zone = 1;\n\t} else /* if (zone == DATA_ZONE) */ {\n\t\t/* Skip searching the mft zone. */\n\t\tdone_zones |= 1;\n\t\tif (zone_start >= vol->mft_zone_end) {\n\t\t\tzone_end = vol->nr_clusters;\n\t\t\tsearch_zone = 2;\n\t\t} else {\n\t\t\tzone_end = vol->mft_zone_start;\n\t\t\tsearch_zone = 4;\n\t\t}\n\t}\n\t/*\n\t * bmp_pos is the current bit position inside the bitmap.  We use\n\t * bmp_initial_pos to determine whether or not to do a zone switch.\n\t */\n\tbmp_pos = bmp_initial_pos = zone_start;\n\n\t/* Loop until all clusters are allocated, i.e. clusters == 0. */\n\tclusters = count;\n\trlpos = rlsize = 0;\n\tmapping = lcnbmp_vi->i_mapping;\n\ti_size = i_size_read(lcnbmp_vi);\n\twhile (1) {\n\t\tntfs_debug(\"Start of outer while loop: done_zones 0x%x, \"\n\t\t\t\t\"search_zone %i, pass %i, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, rlpos %i, rlsize %i.\",\n\t\t\t\tdone_zones, search_zone, pass,\n\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t(unsigned long long)bmp_pos, rlpos, rlsize);\n\t\t/* Loop until we run out of free clusters. */\n\t\tlast_read_pos = bmp_pos >> 3;\n\t\tntfs_debug(\"last_read_pos 0x%llx.\",\n\t\t\t\t(unsigned long long)last_read_pos);\n\t\tif (last_read_pos > i_size) {\n\t\t\tntfs_debug(\"End of attribute reached.  \"\n\t\t\t\t\t\"Skipping to zone_pass_done.\");\n\t\t\tgoto zone_pass_done;\n\t\t}\n\t\tif (likely(page)) {\n\t\t\tif (need_writeback) {\n\t\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tneed_writeback = 0;\n\t\t\t}\n\t\t\tntfs_unmap_page(page);\n\t\t}\n\t\tpage = ntfs_map_page(mapping, last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_error(vol->sb, \"Failed to map page.\");\n\t\t\tgoto out;\n\t\t}\n\t\tbuf_size = last_read_pos & ~PAGE_CACHE_MASK;\n\t\tbuf = page_address(page) + buf_size;\n\t\tbuf_size = PAGE_CACHE_SIZE - buf_size;\n\t\tif (unlikely(last_read_pos + buf_size > i_size))\n\t\t\tbuf_size = i_size - last_read_pos;\n\t\tbuf_size <<= 3;\n\t\tlcn = bmp_pos & 7;\n\t\tbmp_pos &= ~(LCN)7;\n\t\tntfs_debug(\"Before inner while loop: buf_size %i, lcn 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, need_writeback %i.\", buf_size,\n\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\twhile (lcn < buf_size && lcn + bmp_pos < zone_end) {\n\t\t\tbyte = buf + (lcn >> 3);\n\t\t\tntfs_debug(\"In inner while loop: buf_size %i, \"\n\t\t\t\t\t\"lcn 0x%llx, bmp_pos 0x%llx, \"\n\t\t\t\t\t\"need_writeback %i, byte ofs 0x%x, \"\n\t\t\t\t\t\"*byte 0x%x.\", buf_size,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\tneed_writeback,\n\t\t\t\t\t(unsigned int)(lcn >> 3),\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/* Skip full bytes. */\n\t\t\tif (*byte == 0xff) {\n\t\t\t\tlcn = (lcn + 8) & ~(LCN)7;\n\t\t\t\tntfs_debug(\"Continuing while loop 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbit = 1 << (lcn & 7);\n\t\t\tntfs_debug(\"bit 0x%x.\", bit);\n\t\t\t/* If the bit is already set, go onto the next one. */\n\t\t\tif (*byte & bit) {\n\t\t\t\tlcn++;\n\t\t\t\tntfs_debug(\"Continuing while loop 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Allocate more memory if needed, including space for\n\t\t\t * the terminator element.\n\t\t\t * ntfs_malloc_nofs() operates on whole pages only.\n\t\t\t */\n\t\t\tif ((rlpos + 2) * sizeof(*rl) > rlsize) {\n\t\t\t\trunlist_element *rl2;\n\n\t\t\t\tntfs_debug(\"Reallocating memory.\");\n\t\t\t\tif (!rl)\n\t\t\t\t\tntfs_debug(\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos));\n\t\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\t\tif (unlikely(!rl2)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\t\tntfs_free(rl);\n\t\t\t\trl = rl2;\n\t\t\t\trlsize += PAGE_SIZE;\n\t\t\t\tntfs_debug(\"Reallocated memory, rlsize 0x%x.\",\n\t\t\t\t\t\trlsize);\n\t\t\t}\n\t\t\t/* Allocate the bitmap bit. */\n\t\t\t*byte |= bit;\n\t\t\t/* We need to write this bitmap page to disk. */\n\t\t\tneed_writeback = 1;\n\t\t\tntfs_debug(\"*byte 0x%x, need_writeback is set.\",\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/*\n\t\t\t * Coalesce with previous run if adjacent LCNs.\n\t\t\t * Otherwise, append a new run.\n\t\t\t */\n\t\t\tntfs_debug(\"Adding run (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\"prev_lcn 0x%llx, lcn 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, prev_run_len 0x%llx, \"\n\t\t\t\t\t\"rlpos %i.\",\n\t\t\t\t\t(unsigned long long)(lcn + bmp_pos),\n\t\t\t\t\t1ULL, (unsigned long long)prev_lcn,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)prev_run_len,\n\t\t\t\t\trlpos);\n\t\t\tif (prev_lcn == lcn + bmp_pos - prev_run_len && rlpos) {\n\t\t\t\tntfs_debug(\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\trl[rlpos - 1].length = ++prev_run_len;\n\t\t\t\tntfs_debug(\"Run now (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\t\"prev_run_len 0x%llx.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tprev_run_len);\n\t\t\t} else {\n\t\t\t\tif (likely(rlpos)) {\n\t\t\t\t\tntfs_debug(\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\t\trl[rlpos].vcn = rl[rlpos - 1].vcn +\n\t\t\t\t\t\t\tprev_run_len;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_debug(\"Adding new run, is first \"\n\t\t\t\t\t\t\t\"run.\");\n\t\t\t\t\trl[rlpos].vcn = start_vcn;\n\t\t\t\t}\n\t\t\t\trl[rlpos].lcn = prev_lcn = lcn + bmp_pos;\n\t\t\t\trl[rlpos].length = prev_run_len = 1;\n\t\t\t\trlpos++;\n\t\t\t}\n\t\t\t/* Done? */\n\t\t\tif (!--clusters) {\n\t\t\t\tLCN tc;\n\t\t\t\t/*\n\t\t\t\t * Update the current zone position.  Positions\n\t\t\t\t * of already scanned zones have been updated\n\t\t\t\t * during the respective zone switches.\n\t\t\t\t */\n\t\t\t\ttc = lcn + bmp_pos + 1;\n\t\t\t\tntfs_debug(\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\",\n\t\t\t\t\t\t(unsigned long long)tc,\n\t\t\t\t\t\tsearch_zone);\n\t\t\t\tswitch (search_zone) {\n\t\t\t\tcase 1:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tntfs_debug(\"Finished.  Going to out.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlcn++;\n\t\t}\n\t\tbmp_pos += buf_size;\n\t\tntfs_debug(\"After inner while loop: buf_size 0x%x, lcn \"\n\t\t\t\t\"0x%llx, bmp_pos 0x%llx, need_writeback %i.\",\n\t\t\t\tbuf_size, (unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\tif (bmp_pos < zone_end) {\n\t\t\tntfs_debug(\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tcontinue;\n\t\t}\nzone_pass_done:\t/* Finished with the current zone pass. */\n\t\tntfs_debug(\"At zone_pass_done, pass %i.\", pass);\n\t\tif (pass == 1) {\n\t\t\t/*\n\t\t\t * Now do pass 2, scanning the first part of the zone\n\t\t\t * we omitted in pass 1.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t\tzone_end = zone_start;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1: /* mft_zone */\n\t\t\t\tzone_start = vol->mft_zone_start;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* data1_zone */\n\t\t\t\tzone_start = vol->mft_zone_end;\n\t\t\t\tbreak;\n\t\t\tcase 4: /* data2_zone */\n\t\t\t\tzone_start = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* Sanity check. */\n\t\t\tif (zone_end < zone_start)\n\t\t\t\tzone_end = zone_start;\n\t\t\tbmp_pos = zone_start;\n\t\t\tntfs_debug(\"Continuing outer while loop, pass 2, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx.\",\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t\t(unsigned long long)bmp_pos);\n\t\t\tcontinue;\n\t\t} /* pass == 2 */\ndone_zones_check:\n\t\tntfs_debug(\"At done_zones_check, search_zone %i, done_zones \"\n\t\t\t\t\"before 0x%x, done_zones after 0x%x.\",\n\t\t\t\tsearch_zone, done_zones,\n\t\t\t\tdone_zones | search_zone);\n\t\tdone_zones |= search_zone;\n\t\tif (done_zones < 7) {\n\t\t\tntfs_debug(\"Switching zone.\");\n\t\t\t/* Now switch to the next zone we haven't done yet. */\n\t\t\tpass = 1;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1:\n\t\t\t\tntfs_debug(\"Switching from mft zone to data1 \"\n\t\t\t\t\t\t\"zone.\");\n\t\t\t\t/* Update mft zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from mft zone to data1 zone. */\nswitch_to_data1_zone:\t\tsearch_zone = 2;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data1_zone_pos;\n\t\t\t\tzone_end = vol->nr_clusters;\n\t\t\t\tif (zone_start == vol->mft_zone_end)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data1_zone_pos = zone_start =\n\t\t\t\t\t\t\tvol->mft_zone_end;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tntfs_debug(\"Switching from data1 zone to \"\n\t\t\t\t\t\t\"data2 zone.\");\n\t\t\t\t/* Update data1 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data1 zone to data2 zone. */\n\t\t\t\tsearch_zone = 4;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data2_zone_pos;\n\t\t\t\tzone_end = vol->mft_zone_start;\n\t\t\t\tif (!zone_start)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data2_zone_pos = zone_start =\n\t\t\t\t\t\t\tbmp_initial_pos = 0;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tntfs_debug(\"Switching from data2 zone to \"\n\t\t\t\t\t\t\"data1 zone.\");\n\t\t\t\t/* Update data2 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data2 zone to data1 zone. */\n\t\t\t\tgoto switch_to_data1_zone;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tntfs_debug(\"After zone switch, search_zone %i, \"\n\t\t\t\t\t\"pass %i, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\tsearch_zone, pass,\n\t\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tbmp_pos = zone_start;\n\t\t\tif (zone_start == zone_end) {\n\t\t\t\tntfs_debug(\"Empty zone, going to \"\n\t\t\t\t\t\t\"done_zones_check.\");\n\t\t\t\t/* Empty zone. Don't bother searching it. */\n\t\t\t\tgoto done_zones_check;\n\t\t\t}\n\t\t\tntfs_debug(\"Continuing outer while loop.\");\n\t\t\tcontinue;\n\t\t} /* done_zones == 7 */\n\t\tntfs_debug(\"All zones are finished.\");\n\t\t/*\n\t\t * All zones are finished!  If DATA_ZONE, shrink mft zone.  If\n\t\t * MFT_ZONE, we have really run out of space.\n\t\t */\n\t\tmft_zone_size = vol->mft_zone_end - vol->mft_zone_start;\n\t\tntfs_debug(\"vol->mft_zone_start 0x%llx, vol->mft_zone_end \"\n\t\t\t\t\"0x%llx, mft_zone_size 0x%llx.\",\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)mft_zone_size);\n\t\tif (zone == MFT_ZONE || mft_zone_size <= 0) {\n\t\t\tntfs_debug(\"No free clusters left, going to out.\");\n\t\t\t/* Really no more space left on device. */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t} /* zone == DATA_ZONE && mft_zone_size > 0 */\n\t\tntfs_debug(\"Shrinking mft zone.\");\n\t\tzone_end = vol->mft_zone_end;\n\t\tmft_zone_size >>= 1;\n\t\tif (mft_zone_size > 0)\n\t\t\tvol->mft_zone_end = vol->mft_zone_start + mft_zone_size;\n\t\telse /* mft zone and data2 zone no longer exist. */\n\t\t\tvol->data2_zone_pos = vol->mft_zone_start =\n\t\t\t\t\tvol->mft_zone_end = 0;\n\t\tif (vol->mft_zone_pos >= vol->mft_zone_end) {\n\t\t\tvol->mft_zone_pos = vol->mft_lcn;\n\t\t\tif (!vol->mft_zone_end)\n\t\t\t\tvol->mft_zone_pos = 0;\n\t\t}\n\t\tbmp_pos = zone_start = bmp_initial_pos =\n\t\t\t\tvol->data1_zone_pos = vol->mft_zone_end;\n\t\tsearch_zone = 2;\n\t\tpass = 2;\n\t\tdone_zones &= ~2;\n\t\tntfs_debug(\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\",\n\t\t\t\t(unsigned long long)mft_zone_size,\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)vol->mft_zone_pos,\n\t\t\t\tdone_zones, (unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)vol->data1_zone_pos);\n\t}\n\tntfs_debug(\"After outer while loop.\");\nout:\n\tntfs_debug(\"At out.\");\n\t/* Add runlist terminator element. */\n\tif (likely(rl)) {\n\t\trl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;\n\t\trl[rlpos].lcn = is_extension ? LCN_ENOENT : LCN_RL_NOT_MAPPED;\n\t\trl[rlpos].length = 0;\n\t}\n\tif (likely(page && !IS_ERR(page))) {\n\t\tif (need_writeback) {\n\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\tflush_dcache_page(page);\n\t\t\tset_page_dirty(page);\n\t\t\tneed_writeback = 0;\n\t\t}\n\t\tntfs_unmap_page(page);\n\t}\n\tif (likely(!err)) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_debug(\"Done.\");\n\t\treturn rl;\n\t}\n\tntfs_error(vol->sb, \"Failed to allocate clusters, aborting \"\n\t\t\t\"(error %i).\", err);\n\tif (rl) {\n\t\tint err2;\n\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_debug(\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\",\n\t\t\t\t\t(unsigned long long)rl[0].lcn,\n\t\t\t\t\t(unsigned long long)(count - clusters));\n\t\t/* Deallocate all allocated clusters. */\n\t\tntfs_debug(\"Attempting rollback...\");\n\t\terr2 = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\t\tif (err2) {\n\t\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\", err2);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\t/* Free the runlist. */\n\t\tntfs_free(rl);\n\t} else if (err == -ENOSPC)\n\t\tntfs_debug(\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\",\n\t\t\t\t(long long)vol->data1_zone_pos);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"aops.h\"",
            "#include \"malloc.h\"",
            "#include \"attrib.h\"",
            "#include \"volume.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"debug.h\"",
            "#include \"lcnalloc.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"malloc.h\"\n#include \"attrib.h\"\n#include \"volume.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"lcnalloc.h\"\n#include <linux/pagemap.h>\n\nrunlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,\n\t\tconst s64 count, const LCN start_lcn,\n\t\tconst NTFS_CLUSTER_ALLOCATION_ZONES zone,\n\t\tconst bool is_extension)\n{\n\tLCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;\n\tLCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;\n\ts64 clusters;\n\tloff_t i_size;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *buf, *byte;\n\tint err = 0, rlpos, rlsize, buf_size;\n\tu8 pass, done_zones, search_zone, need_writeback = 0, bit;\n\n\tntfs_debug(\"Entering for start_vcn 0x%llx, count 0x%llx, start_lcn \"\n\t\t\t\"0x%llx, zone %s_ZONE.\", (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\t(unsigned long long)start_lcn,\n\t\t\tzone == MFT_ZONE ? \"MFT\" : \"DATA\");\n\tBUG_ON(!vol);\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < 0);\n\tBUG_ON(start_lcn < -1);\n\tBUG_ON(zone < FIRST_ZONE);\n\tBUG_ON(zone > LAST_ZONE);\n\n\t/* Return NULL if @count is zero. */\n\tif (!count)\n\t\treturn NULL;\n\t/* Take the lcnbmp lock for writing. */\n\tdown_write(&vol->lcnbmp_lock);\n\t/*\n\t * If no specific @start_lcn was requested, use the current data zone\n\t * position, otherwise use the requested @start_lcn but make sure it\n\t * lies outside the mft zone.  Also set done_zones to 0 (no zones done)\n\t * and pass depending on whether we are starting inside a zone (1) or\n\t * at the beginning of a zone (2).  If requesting from the MFT_ZONE,\n\t * we either start at the current position within the mft zone or at\n\t * the specified position.  If the latter is out of bounds then we start\n\t * at the beginning of the MFT_ZONE.\n\t */\n\tdone_zones = 0;\n\tpass = 1;\n\t/*\n\t * zone_start and zone_end are the current search range.  search_zone\n\t * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of\n\t * volume) and 4 for data zone 2 (start of volume till start of mft\n\t * zone).\n\t */\n\tzone_start = start_lcn;\n\tif (zone_start < 0) {\n\t\tif (zone == DATA_ZONE)\n\t\t\tzone_start = vol->data1_zone_pos;\n\t\telse\n\t\t\tzone_start = vol->mft_zone_pos;\n\t\tif (!zone_start) {\n\t\t\t/*\n\t\t\t * Zone starts at beginning of volume which means a\n\t\t\t * single pass is sufficient.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t}\n\t} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&\n\t\t\tzone_start < vol->mft_zone_end) {\n\t\tzone_start = vol->mft_zone_end;\n\t\t/*\n\t\t * Starting at beginning of data1_zone which means a single\n\t\t * pass in this zone is sufficient.\n\t\t */\n\t\tpass = 2;\n\t} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||\n\t\t\tzone_start >= vol->mft_zone_end)) {\n\t\tzone_start = vol->mft_lcn;\n\t\tif (!vol->mft_zone_end)\n\t\t\tzone_start = 0;\n\t\t/*\n\t\t * Starting at beginning of volume which means a single pass\n\t\t * is sufficient.\n\t\t */\n\t\tpass = 2;\n\t}\n\tif (zone == MFT_ZONE) {\n\t\tzone_end = vol->mft_zone_end;\n\t\tsearch_zone = 1;\n\t} else /* if (zone == DATA_ZONE) */ {\n\t\t/* Skip searching the mft zone. */\n\t\tdone_zones |= 1;\n\t\tif (zone_start >= vol->mft_zone_end) {\n\t\t\tzone_end = vol->nr_clusters;\n\t\t\tsearch_zone = 2;\n\t\t} else {\n\t\t\tzone_end = vol->mft_zone_start;\n\t\t\tsearch_zone = 4;\n\t\t}\n\t}\n\t/*\n\t * bmp_pos is the current bit position inside the bitmap.  We use\n\t * bmp_initial_pos to determine whether or not to do a zone switch.\n\t */\n\tbmp_pos = bmp_initial_pos = zone_start;\n\n\t/* Loop until all clusters are allocated, i.e. clusters == 0. */\n\tclusters = count;\n\trlpos = rlsize = 0;\n\tmapping = lcnbmp_vi->i_mapping;\n\ti_size = i_size_read(lcnbmp_vi);\n\twhile (1) {\n\t\tntfs_debug(\"Start of outer while loop: done_zones 0x%x, \"\n\t\t\t\t\"search_zone %i, pass %i, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, rlpos %i, rlsize %i.\",\n\t\t\t\tdone_zones, search_zone, pass,\n\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t(unsigned long long)bmp_pos, rlpos, rlsize);\n\t\t/* Loop until we run out of free clusters. */\n\t\tlast_read_pos = bmp_pos >> 3;\n\t\tntfs_debug(\"last_read_pos 0x%llx.\",\n\t\t\t\t(unsigned long long)last_read_pos);\n\t\tif (last_read_pos > i_size) {\n\t\t\tntfs_debug(\"End of attribute reached.  \"\n\t\t\t\t\t\"Skipping to zone_pass_done.\");\n\t\t\tgoto zone_pass_done;\n\t\t}\n\t\tif (likely(page)) {\n\t\t\tif (need_writeback) {\n\t\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tneed_writeback = 0;\n\t\t\t}\n\t\t\tntfs_unmap_page(page);\n\t\t}\n\t\tpage = ntfs_map_page(mapping, last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_error(vol->sb, \"Failed to map page.\");\n\t\t\tgoto out;\n\t\t}\n\t\tbuf_size = last_read_pos & ~PAGE_CACHE_MASK;\n\t\tbuf = page_address(page) + buf_size;\n\t\tbuf_size = PAGE_CACHE_SIZE - buf_size;\n\t\tif (unlikely(last_read_pos + buf_size > i_size))\n\t\t\tbuf_size = i_size - last_read_pos;\n\t\tbuf_size <<= 3;\n\t\tlcn = bmp_pos & 7;\n\t\tbmp_pos &= ~(LCN)7;\n\t\tntfs_debug(\"Before inner while loop: buf_size %i, lcn 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, need_writeback %i.\", buf_size,\n\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\twhile (lcn < buf_size && lcn + bmp_pos < zone_end) {\n\t\t\tbyte = buf + (lcn >> 3);\n\t\t\tntfs_debug(\"In inner while loop: buf_size %i, \"\n\t\t\t\t\t\"lcn 0x%llx, bmp_pos 0x%llx, \"\n\t\t\t\t\t\"need_writeback %i, byte ofs 0x%x, \"\n\t\t\t\t\t\"*byte 0x%x.\", buf_size,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\tneed_writeback,\n\t\t\t\t\t(unsigned int)(lcn >> 3),\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/* Skip full bytes. */\n\t\t\tif (*byte == 0xff) {\n\t\t\t\tlcn = (lcn + 8) & ~(LCN)7;\n\t\t\t\tntfs_debug(\"Continuing while loop 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbit = 1 << (lcn & 7);\n\t\t\tntfs_debug(\"bit 0x%x.\", bit);\n\t\t\t/* If the bit is already set, go onto the next one. */\n\t\t\tif (*byte & bit) {\n\t\t\t\tlcn++;\n\t\t\t\tntfs_debug(\"Continuing while loop 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Allocate more memory if needed, including space for\n\t\t\t * the terminator element.\n\t\t\t * ntfs_malloc_nofs() operates on whole pages only.\n\t\t\t */\n\t\t\tif ((rlpos + 2) * sizeof(*rl) > rlsize) {\n\t\t\t\trunlist_element *rl2;\n\n\t\t\t\tntfs_debug(\"Reallocating memory.\");\n\t\t\t\tif (!rl)\n\t\t\t\t\tntfs_debug(\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos));\n\t\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\t\tif (unlikely(!rl2)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\t\tntfs_free(rl);\n\t\t\t\trl = rl2;\n\t\t\t\trlsize += PAGE_SIZE;\n\t\t\t\tntfs_debug(\"Reallocated memory, rlsize 0x%x.\",\n\t\t\t\t\t\trlsize);\n\t\t\t}\n\t\t\t/* Allocate the bitmap bit. */\n\t\t\t*byte |= bit;\n\t\t\t/* We need to write this bitmap page to disk. */\n\t\t\tneed_writeback = 1;\n\t\t\tntfs_debug(\"*byte 0x%x, need_writeback is set.\",\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/*\n\t\t\t * Coalesce with previous run if adjacent LCNs.\n\t\t\t * Otherwise, append a new run.\n\t\t\t */\n\t\t\tntfs_debug(\"Adding run (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\"prev_lcn 0x%llx, lcn 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, prev_run_len 0x%llx, \"\n\t\t\t\t\t\"rlpos %i.\",\n\t\t\t\t\t(unsigned long long)(lcn + bmp_pos),\n\t\t\t\t\t1ULL, (unsigned long long)prev_lcn,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)prev_run_len,\n\t\t\t\t\trlpos);\n\t\t\tif (prev_lcn == lcn + bmp_pos - prev_run_len && rlpos) {\n\t\t\t\tntfs_debug(\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\trl[rlpos - 1].length = ++prev_run_len;\n\t\t\t\tntfs_debug(\"Run now (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\t\"prev_run_len 0x%llx.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tprev_run_len);\n\t\t\t} else {\n\t\t\t\tif (likely(rlpos)) {\n\t\t\t\t\tntfs_debug(\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\t\trl[rlpos].vcn = rl[rlpos - 1].vcn +\n\t\t\t\t\t\t\tprev_run_len;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_debug(\"Adding new run, is first \"\n\t\t\t\t\t\t\t\"run.\");\n\t\t\t\t\trl[rlpos].vcn = start_vcn;\n\t\t\t\t}\n\t\t\t\trl[rlpos].lcn = prev_lcn = lcn + bmp_pos;\n\t\t\t\trl[rlpos].length = prev_run_len = 1;\n\t\t\t\trlpos++;\n\t\t\t}\n\t\t\t/* Done? */\n\t\t\tif (!--clusters) {\n\t\t\t\tLCN tc;\n\t\t\t\t/*\n\t\t\t\t * Update the current zone position.  Positions\n\t\t\t\t * of already scanned zones have been updated\n\t\t\t\t * during the respective zone switches.\n\t\t\t\t */\n\t\t\t\ttc = lcn + bmp_pos + 1;\n\t\t\t\tntfs_debug(\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\",\n\t\t\t\t\t\t(unsigned long long)tc,\n\t\t\t\t\t\tsearch_zone);\n\t\t\t\tswitch (search_zone) {\n\t\t\t\tcase 1:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tntfs_debug(\"Finished.  Going to out.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlcn++;\n\t\t}\n\t\tbmp_pos += buf_size;\n\t\tntfs_debug(\"After inner while loop: buf_size 0x%x, lcn \"\n\t\t\t\t\"0x%llx, bmp_pos 0x%llx, need_writeback %i.\",\n\t\t\t\tbuf_size, (unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\tif (bmp_pos < zone_end) {\n\t\t\tntfs_debug(\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tcontinue;\n\t\t}\nzone_pass_done:\t/* Finished with the current zone pass. */\n\t\tntfs_debug(\"At zone_pass_done, pass %i.\", pass);\n\t\tif (pass == 1) {\n\t\t\t/*\n\t\t\t * Now do pass 2, scanning the first part of the zone\n\t\t\t * we omitted in pass 1.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t\tzone_end = zone_start;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1: /* mft_zone */\n\t\t\t\tzone_start = vol->mft_zone_start;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* data1_zone */\n\t\t\t\tzone_start = vol->mft_zone_end;\n\t\t\t\tbreak;\n\t\t\tcase 4: /* data2_zone */\n\t\t\t\tzone_start = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* Sanity check. */\n\t\t\tif (zone_end < zone_start)\n\t\t\t\tzone_end = zone_start;\n\t\t\tbmp_pos = zone_start;\n\t\t\tntfs_debug(\"Continuing outer while loop, pass 2, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx.\",\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t\t(unsigned long long)bmp_pos);\n\t\t\tcontinue;\n\t\t} /* pass == 2 */\ndone_zones_check:\n\t\tntfs_debug(\"At done_zones_check, search_zone %i, done_zones \"\n\t\t\t\t\"before 0x%x, done_zones after 0x%x.\",\n\t\t\t\tsearch_zone, done_zones,\n\t\t\t\tdone_zones | search_zone);\n\t\tdone_zones |= search_zone;\n\t\tif (done_zones < 7) {\n\t\t\tntfs_debug(\"Switching zone.\");\n\t\t\t/* Now switch to the next zone we haven't done yet. */\n\t\t\tpass = 1;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1:\n\t\t\t\tntfs_debug(\"Switching from mft zone to data1 \"\n\t\t\t\t\t\t\"zone.\");\n\t\t\t\t/* Update mft zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from mft zone to data1 zone. */\nswitch_to_data1_zone:\t\tsearch_zone = 2;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data1_zone_pos;\n\t\t\t\tzone_end = vol->nr_clusters;\n\t\t\t\tif (zone_start == vol->mft_zone_end)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data1_zone_pos = zone_start =\n\t\t\t\t\t\t\tvol->mft_zone_end;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tntfs_debug(\"Switching from data1 zone to \"\n\t\t\t\t\t\t\"data2 zone.\");\n\t\t\t\t/* Update data1 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data1 zone to data2 zone. */\n\t\t\t\tsearch_zone = 4;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data2_zone_pos;\n\t\t\t\tzone_end = vol->mft_zone_start;\n\t\t\t\tif (!zone_start)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data2_zone_pos = zone_start =\n\t\t\t\t\t\t\tbmp_initial_pos = 0;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tntfs_debug(\"Switching from data2 zone to \"\n\t\t\t\t\t\t\"data1 zone.\");\n\t\t\t\t/* Update data2 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data2 zone to data1 zone. */\n\t\t\t\tgoto switch_to_data1_zone;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tntfs_debug(\"After zone switch, search_zone %i, \"\n\t\t\t\t\t\"pass %i, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\tsearch_zone, pass,\n\t\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tbmp_pos = zone_start;\n\t\t\tif (zone_start == zone_end) {\n\t\t\t\tntfs_debug(\"Empty zone, going to \"\n\t\t\t\t\t\t\"done_zones_check.\");\n\t\t\t\t/* Empty zone. Don't bother searching it. */\n\t\t\t\tgoto done_zones_check;\n\t\t\t}\n\t\t\tntfs_debug(\"Continuing outer while loop.\");\n\t\t\tcontinue;\n\t\t} /* done_zones == 7 */\n\t\tntfs_debug(\"All zones are finished.\");\n\t\t/*\n\t\t * All zones are finished!  If DATA_ZONE, shrink mft zone.  If\n\t\t * MFT_ZONE, we have really run out of space.\n\t\t */\n\t\tmft_zone_size = vol->mft_zone_end - vol->mft_zone_start;\n\t\tntfs_debug(\"vol->mft_zone_start 0x%llx, vol->mft_zone_end \"\n\t\t\t\t\"0x%llx, mft_zone_size 0x%llx.\",\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)mft_zone_size);\n\t\tif (zone == MFT_ZONE || mft_zone_size <= 0) {\n\t\t\tntfs_debug(\"No free clusters left, going to out.\");\n\t\t\t/* Really no more space left on device. */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t} /* zone == DATA_ZONE && mft_zone_size > 0 */\n\t\tntfs_debug(\"Shrinking mft zone.\");\n\t\tzone_end = vol->mft_zone_end;\n\t\tmft_zone_size >>= 1;\n\t\tif (mft_zone_size > 0)\n\t\t\tvol->mft_zone_end = vol->mft_zone_start + mft_zone_size;\n\t\telse /* mft zone and data2 zone no longer exist. */\n\t\t\tvol->data2_zone_pos = vol->mft_zone_start =\n\t\t\t\t\tvol->mft_zone_end = 0;\n\t\tif (vol->mft_zone_pos >= vol->mft_zone_end) {\n\t\t\tvol->mft_zone_pos = vol->mft_lcn;\n\t\t\tif (!vol->mft_zone_end)\n\t\t\t\tvol->mft_zone_pos = 0;\n\t\t}\n\t\tbmp_pos = zone_start = bmp_initial_pos =\n\t\t\t\tvol->data1_zone_pos = vol->mft_zone_end;\n\t\tsearch_zone = 2;\n\t\tpass = 2;\n\t\tdone_zones &= ~2;\n\t\tntfs_debug(\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\",\n\t\t\t\t(unsigned long long)mft_zone_size,\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)vol->mft_zone_pos,\n\t\t\t\tdone_zones, (unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)vol->data1_zone_pos);\n\t}\n\tntfs_debug(\"After outer while loop.\");\nout:\n\tntfs_debug(\"At out.\");\n\t/* Add runlist terminator element. */\n\tif (likely(rl)) {\n\t\trl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;\n\t\trl[rlpos].lcn = is_extension ? LCN_ENOENT : LCN_RL_NOT_MAPPED;\n\t\trl[rlpos].length = 0;\n\t}\n\tif (likely(page && !IS_ERR(page))) {\n\t\tif (need_writeback) {\n\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\tflush_dcache_page(page);\n\t\t\tset_page_dirty(page);\n\t\t\tneed_writeback = 0;\n\t\t}\n\t\tntfs_unmap_page(page);\n\t}\n\tif (likely(!err)) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_debug(\"Done.\");\n\t\treturn rl;\n\t}\n\tntfs_error(vol->sb, \"Failed to allocate clusters, aborting \"\n\t\t\t\"(error %i).\", err);\n\tif (rl) {\n\t\tint err2;\n\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_debug(\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\",\n\t\t\t\t\t(unsigned long long)rl[0].lcn,\n\t\t\t\t\t(unsigned long long)(count - clusters));\n\t\t/* Deallocate all allocated clusters. */\n\t\tntfs_debug(\"Attempting rollback...\");\n\t\terr2 = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\t\tif (err2) {\n\t\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\", err2);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\t/* Free the runlist. */\n\t\tntfs_free(rl);\n\t} else if (err == -ENOSPC)\n\t\tntfs_debug(\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\",\n\t\t\t\t(long long)vol->data1_zone_pos);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rl->lcn != LCN_HOLE"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rl"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lcn != LCN_HOLE"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "bh_offset(bh)",
            "blocksize"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vol->cluster_size < PAGE_CACHE_SIZE"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_runlist_nolock",
          "args": [
            "ni",
            "bh_cpos",
            "NULL"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_runlist_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "84-281",
          "snippet": "int ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t/*\n\t\t * If we already have the attribute extent containing @vcn in\n\t\t * @ctx, no need to look it up again.  We slightly cheat in\n\t\t * that if vcn exceeds the allocated size, we will refuse to\n\t\t * map the runlist below, so there is definitely no need to get\n\t\t * the right attribute extent.\n\t\t */\n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t/* Save the old search context. */\n\t\t\told_ctx = *ctx;\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * base inode we will unmap it when we reinitialize the\n\t\t\t * search context which means we need to get a\n\t\t\t * reference to the page containing the mapped mft\n\t\t\t * record so we do not accidentally drop changes to the\n\t\t\t * mft record when it has not been marked dirty yet.\n\t\t\t */\n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tpage_cache_get(put_this_page);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reinitialize the search context so we can lookup the\n\t\t\t * needed attribute extent.\n\t\t\t */\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t/*\n\t * Only decompress the mapping pairs if @vcn is inside it.  Otherwise\n\t * we get into problems when we try to map an out of bounds vcn because\n\t * we then try to map the already mapped runlist fragment and\n\t * ntfs_mapping_pairs_decompress() fails.\n\t */\n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t/*\n\t\t * If there is no attribute list, restoring the search context\n\t\t * is accomplished simply by copying the saved context back over\n\t\t * the caller supplied context.  If there is an attribute list,\n\t\t * things are more complicated as we need to deal with mapping\n\t\t * of mft records and resulting potential changes in pointers.\n\t\t */\n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * one we had before, we need to unmap it and map the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t/*\n\t\t\t\t * If the currently mapped inode is not the\n\t\t\t\t * base inode, unmap it.\n\t\t\t\t */\n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If the old mapped inode is not the base\n\t\t\t\t * inode, map it.\n\t\t\t\t */\n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t/*\n\t\t\t\t\t * Something bad has happened.  If out\n\t\t\t\t\t * of memory retry till it succeeds.\n\t\t\t\t\t * Any other errors are fatal and we\n\t\t\t\t\t * return the error code in ctx->mrec.\n\t\t\t\t\t * Let the caller deal with it...  We\n\t\t\t\t\t * just need to fudge things so the\n\t\t\t\t\t * caller can reinit and/or put the\n\t\t\t\t\t * search context safely.\n\t\t\t\t\t */\n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update the changed pointers in the saved context. */\n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t/* Restore the search context to the saved one. */\n\t\t*ctx = old_ctx;\n\t\t/*\n\t\t * We drop the reference on the page we took earlier.  In the\n\t\t * case that IS_ERR(ctx->mrec) is true this means we might lose\n\t\t * some changes to the mft record that had been made between\n\t\t * the last time it was marked dirty/written out and now.  This\n\t\t * at this stage is not a problem as the mapping error is fatal\n\t\t * enough that the mft record cannot be written out anyway and\n\t\t * the caller is very likely to shutdown the whole inode\n\t\t * immediately and mark the volume dirty for chkdsk to pick up\n\t\t * the pieces anyway.\n\t\t */\n\t\tif (put_this_page)\n\t\t\tpage_cache_release(put_this_page);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)\n{\n\tVCN end_vcn;\n\tunsigned long flags;\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\trunlist_element *rl;\n\tstruct page *put_this_page = NULL;\n\tint err = 0;\n\tbool ctx_is_temporary, ctx_needs_reset;\n\tntfs_attr_search_ctx old_ctx = { NULL, };\n\n\tntfs_debug(\"Mapping runlist part containing vcn 0x%llx.\",\n\t\t\t(unsigned long long)vcn);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tif (!ctx) {\n\t\tctx_is_temporary = ctx_needs_reset = true;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m))\n\t\t\treturn PTR_ERR(m);\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t} else {\n\t\tVCN allocated_size_vcn;\n\n\t\tBUG_ON(IS_ERR(ctx->mrec));\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tctx_is_temporary = false;\n\t\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tallocated_size_vcn = ni->allocated_size >>\n\t\t\t\tni->vol->cluster_size_bits;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (!a->data.non_resident.lowest_vcn && end_vcn <= 0)\n\t\t\tend_vcn = allocated_size_vcn - 1;\n\t\t/*\n\t\t * If we already have the attribute extent containing @vcn in\n\t\t * @ctx, no need to look it up again.  We slightly cheat in\n\t\t * that if vcn exceeds the allocated size, we will refuse to\n\t\t * map the runlist below, so there is definitely no need to get\n\t\t * the right attribute extent.\n\t\t */\n\t\tif (vcn >= allocated_size_vcn || (a->type == ni->type &&\n\t\t\t\ta->name_length == ni->name_len &&\n\t\t\t\t!memcmp((u8*)a + le16_to_cpu(a->name_offset),\n\t\t\t\tni->name, ni->name_len) &&\n\t\t\t\tsle64_to_cpu(a->data.non_resident.lowest_vcn)\n\t\t\t\t<= vcn && end_vcn >= vcn))\n\t\t\tctx_needs_reset = false;\n\t\telse {\n\t\t\t/* Save the old search context. */\n\t\t\told_ctx = *ctx;\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * base inode we will unmap it when we reinitialize the\n\t\t\t * search context which means we need to get a\n\t\t\t * reference to the page containing the mapped mft\n\t\t\t * record so we do not accidentally drop changes to the\n\t\t\t * mft record when it has not been marked dirty yet.\n\t\t\t */\n\t\t\tif (old_ctx.base_ntfs_ino && old_ctx.ntfs_ino !=\n\t\t\t\t\told_ctx.base_ntfs_ino) {\n\t\t\t\tput_this_page = old_ctx.ntfs_ino->page;\n\t\t\t\tpage_cache_get(put_this_page);\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reinitialize the search context so we can lookup the\n\t\t\t * needed attribute extent.\n\t\t\t */\n\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\tctx_needs_reset = true;\n\t\t}\n\t}\n\tif (ctx_needs_reset) {\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, vcn, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tBUG_ON(!ctx->attr->non_resident);\n\t}\n\ta = ctx->attr;\n\t/*\n\t * Only decompress the mapping pairs if @vcn is inside it.  Otherwise\n\t * we get into problems when we try to map an out of bounds vcn because\n\t * we then try to map the already mapped runlist fragment and\n\t * ntfs_mapping_pairs_decompress() fails.\n\t */\n\tend_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn) + 1;\n\tif (unlikely(vcn && vcn >= end_vcn)) {\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\trl = ntfs_mapping_pairs_decompress(ni->vol, a, ni->runlist.rl);\n\tif (IS_ERR(rl))\n\t\terr = PTR_ERR(rl);\n\telse\n\t\tni->runlist.rl = rl;\nerr_out:\n\tif (ctx_is_temporary) {\n\t\tif (likely(ctx))\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t} else if (ctx_needs_reset) {\n\t\t/*\n\t\t * If there is no attribute list, restoring the search context\n\t\t * is accomplished simply by copying the saved context back over\n\t\t * the caller supplied context.  If there is an attribute list,\n\t\t * things are more complicated as we need to deal with mapping\n\t\t * of mft records and resulting potential changes in pointers.\n\t\t */\n\t\tif (NInoAttrList(base_ni)) {\n\t\t\t/*\n\t\t\t * If the currently mapped (extent) inode is not the\n\t\t\t * one we had before, we need to unmap it and map the\n\t\t\t * old one.\n\t\t\t */\n\t\t\tif (ctx->ntfs_ino != old_ctx.ntfs_ino) {\n\t\t\t\t/*\n\t\t\t\t * If the currently mapped inode is not the\n\t\t\t\t * base inode, unmap it.\n\t\t\t\t */\n\t\t\t\tif (ctx->base_ntfs_ino && ctx->ntfs_ino !=\n\t\t\t\t\t\tctx->base_ntfs_ino) {\n\t\t\t\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\t\t\t\t\tctx->mrec = ctx->base_mrec;\n\t\t\t\t\tBUG_ON(!ctx->mrec);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If the old mapped inode is not the base\n\t\t\t\t * inode, map it.\n\t\t\t\t */\n\t\t\t\tif (old_ctx.base_ntfs_ino &&\n\t\t\t\t\t\told_ctx.ntfs_ino !=\n\t\t\t\t\t\told_ctx.base_ntfs_ino) {\nretry_map:\n\t\t\t\t\tctx->mrec = map_mft_record(\n\t\t\t\t\t\t\told_ctx.ntfs_ino);\n\t\t\t\t\t/*\n\t\t\t\t\t * Something bad has happened.  If out\n\t\t\t\t\t * of memory retry till it succeeds.\n\t\t\t\t\t * Any other errors are fatal and we\n\t\t\t\t\t * return the error code in ctx->mrec.\n\t\t\t\t\t * Let the caller deal with it...  We\n\t\t\t\t\t * just need to fudge things so the\n\t\t\t\t\t * caller can reinit and/or put the\n\t\t\t\t\t * search context safely.\n\t\t\t\t\t */\n\t\t\t\t\tif (IS_ERR(ctx->mrec)) {\n\t\t\t\t\t\tif (PTR_ERR(ctx->mrec) ==\n\t\t\t\t\t\t\t\t-ENOMEM) {\n\t\t\t\t\t\t\tschedule();\n\t\t\t\t\t\t\tgoto retry_map;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\told_ctx.ntfs_ino =\n\t\t\t\t\t\t\t\told_ctx.\n\t\t\t\t\t\t\t\tbase_ntfs_ino;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Update the changed pointers in the saved context. */\n\t\t\tif (ctx->mrec != old_ctx.mrec) {\n\t\t\t\tif (!IS_ERR(ctx->mrec))\n\t\t\t\t\told_ctx.attr = (ATTR_RECORD*)(\n\t\t\t\t\t\t\t(u8*)ctx->mrec +\n\t\t\t\t\t\t\t((u8*)old_ctx.attr -\n\t\t\t\t\t\t\t(u8*)old_ctx.mrec));\n\t\t\t\told_ctx.mrec = ctx->mrec;\n\t\t\t}\n\t\t}\n\t\t/* Restore the search context to the saved one. */\n\t\t*ctx = old_ctx;\n\t\t/*\n\t\t * We drop the reference on the page we took earlier.  In the\n\t\t * case that IS_ERR(ctx->mrec) is true this means we might lose\n\t\t * some changes to the mft record that had been made between\n\t\t * the last time it was marked dirty/written out and now.  This\n\t\t * at this stage is not a problem as the mapping error is fatal\n\t\t * enough that the mft record cannot be written out anyway and\n\t\t * the caller is very likely to shutdown the whole inode\n\t\t * immediately and mark the volume dirty for chkdsk to pick up\n\t\t * the pieces anyway.\n\t\t */\n\t\tif (put_this_page)\n\t\t\tpage_cache_release(put_this_page);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!is_retry && lcn == LCN_RL_NOT_MAPPED"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "lcn != LCN_HOLE && lcn != LCN_ENOENT"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "vcn + vcn_len >= cend"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "lcn >= 0"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_rl_vcn_to_lcn",
          "args": [
            "rl",
            "bh_cpos"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_rl_vcn_to_lcn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/runlist.c",
          "lines": "1004-1036",
          "snippet": "LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"malloc.h\"",
            "#include \"endian.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"malloc.h\"\n#include \"endian.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n\nLCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)\n{\n\tint i;\n\n\tBUG_ON(vcn < 0);\n\t/*\n\t * If rl is NULL, assume that we have found an unmapped runlist. The\n\t * caller can then attempt to map it and fail appropriately if\n\t * necessary.\n\t */\n\tif (unlikely(!rl))\n\t\treturn LCN_RL_NOT_MAPPED;\n\n\t/* Catch out of lower bounds vcn. */\n\tif (unlikely(vcn < rl[0].vcn))\n\t\treturn LCN_ENOENT;\n\n\tfor (i = 0; likely(rl[i].length); i++) {\n\t\tif (unlikely(vcn < rl[i+1].vcn)) {\n\t\t\tif (likely(rl[i].lcn >= (LCN)0))\n\t\t\t\treturn rl[i].lcn + (vcn - rl[i].vcn);\n\t\t\treturn rl[i].lcn;\n\t\t}\n\t}\n\t/*\n\t * The terminator element is setup to the correct value, i.e. one of\n\t * LCN_HOLE, LCN_RL_NOT_MAPPED, or LCN_ENOENT.\n\t */\n\tif (likely(rl[i].lcn < (LCN)0))\n\t\treturn rl[i].lcn;\n\t/* Just in case... We could replace this with BUG() some day. */\n\treturn LCN_ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl != NULL"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ni->runlist.lock"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "bh_offset(bh)",
            "blocksize"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + pofs",
            "0",
            "bh_end - end"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kaddr + pofs",
            "0",
            "pos - bh_pos"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "bh_offset(bh)",
            "blocksize"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_underlying_metadata",
          "args": [
            "bh->b_bdev",
            "bh->b_blocknr"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_underlying_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1610-1623",
          "snippet": "void unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "bh_offset(bh)",
            "blocksize"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_submit_bh_for_read",
          "args": [
            "bh"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_submit_bh_for_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "447-453",
          "snippet": "static inline int ntfs_submit_bh_for_read(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\treturn submit_bh(READ, bh);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline int ntfs_submit_bh_for_read(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\treturn submit_bh(READ, bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!was_hole"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_new",
          "args": [
            "bh"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "was_hole"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lcn < 0"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!cdelta || (cdelta > 0 && cdelta < vcn_len)"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zero_user",
          "args": [
            "page",
            "bh_offset(bh)",
            "blocksize"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh_offset",
          "args": [
            "bh"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_buffer_new",
          "args": [
            "bh"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!page_has_buffers(page)"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_empty_buffers",
          "args": [
            "page",
            "blocksize",
            "0"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "create_empty_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1564-1591",
          "snippet": "void create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid create_empty_buffers(struct page *page,\n\t\t\tunsigned long blocksize, unsigned long b_state)\n{\n\tstruct buffer_head *bh, *head, *tail;\n\n\thead = alloc_page_buffers(page, blocksize, 1);\n\tbh = head;\n\tdo {\n\t\tbh->b_state |= b_state;\n\t\ttail = bh;\n\t\tbh = bh->b_this_page;\n\t} while (bh);\n\ttail->b_this_page = head;\n\n\tspin_lock(&page->mapping->private_lock);\n\tif (PageUptodate(page) || PageDirty(page)) {\n\t\tbh = head;\n\t\tdo {\n\t\t\tif (PageDirty(page))\n\t\t\t\tset_buffer_dirty(bh);\n\t\t\tif (PageUptodate(page))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\t}\n\tattach_page_buffers(page, head);\n\tspin_unlock(&page->mapping->private_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for inode 0x%lx, attribute type 0x%x, start page \"\n\t\t\t\"index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.\"",
            "vi->i_ino",
            "ni->type",
            "pages[0]->index",
            "nr_pages",
            "(long long)pos",
            "bytes"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NTFS_I",
          "args": [
            "vi"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "NTFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "240-243",
          "snippet": "static inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline ntfs_inode *NTFS_I(struct inode *inode)\n{\n\treturn (ntfs_inode *)list_entry(inode, big_ntfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!*pages"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!pages"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!nr_pages"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic int ntfs_prepare_pages_for_non_resident_write(struct page **pages,\n\t\tunsigned nr_pages, s64 pos, size_t bytes)\n{\n\tVCN vcn, highest_vcn = 0, cpos, cend, bh_cpos, bh_cend;\n\tLCN lcn;\n\ts64 bh_pos, vcn_len, end, initialized_size;\n\tsector_t lcn_block;\n\tstruct page *page;\n\tstruct inode *vi;\n\tntfs_inode *ni, *base_ni = NULL;\n\tntfs_volume *vol;\n\trunlist_element *rl, *rl2;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh = wait;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a = NULL;\n\tunsigned long flags;\n\tu32 attr_rec_len = 0;\n\tunsigned blocksize, u;\n\tint err, mp_size;\n\tbool rl_write_locked, was_hole, is_retry;\n\tunsigned char blocksize_bits;\n\tstruct {\n\t\tu8 runlist_merged:1;\n\t\tu8 mft_attr_mapped:1;\n\t\tu8 mp_rebuilt:1;\n\t\tu8 attr_switched:1;\n\t} status = { 0, 0, 0, 0 };\n\n\tBUG_ON(!nr_pages);\n\tBUG_ON(!pages);\n\tBUG_ON(!*pages);\n\tvi = pages[0]->mapping->host;\n\tni = NTFS_I(vi);\n\tvol = ni->vol;\n\tntfs_debug(\"Entering for inode 0x%lx, attribute type 0x%x, start page \"\n\t\t\t\"index 0x%lx, nr_pages 0x%x, pos 0x%llx, bytes 0x%zx.\",\n\t\t\tvi->i_ino, ni->type, pages[0]->index, nr_pages,\n\t\t\t(long long)pos, bytes);\n\tblocksize = vol->sb->s_blocksize;\n\tblocksize_bits = vol->sb->s_blocksize_bits;\n\tu = 0;\n\tdo {\n\t\tpage = pages[u];\n\t\tBUG_ON(!page);\n\t\t/*\n\t\t * create_empty_buffers() will create uptodate/dirty buffers if\n\t\t * the page is uptodate/dirty.\n\t\t */\n\t\tif (!page_has_buffers(page)) {\n\t\t\tcreate_empty_buffers(page, blocksize, 0);\n\t\t\tif (unlikely(!page_has_buffers(page)))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t} while (++u < nr_pages);\n\trl_write_locked = false;\n\trl = NULL;\n\terr = 0;\n\tvcn = lcn = -1;\n\tvcn_len = 0;\n\tlcn_block = -1;\n\twas_hole = false;\n\tcpos = pos >> vol->cluster_size_bits;\n\tend = pos + bytes;\n\tcend = (end + vol->cluster_size - 1) >> vol->cluster_size_bits;\n\t/*\n\t * Loop over each page and for each page over each buffer.  Use goto to\n\t * reduce indentation.\n\t */\n\tu = 0;\ndo_next_page:\n\tpage = pages[u];\n\tbh_pos = (s64)page->index << PAGE_CACHE_SHIFT;\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tVCN cdelta;\n\t\ts64 bh_end;\n\t\tunsigned bh_cofs;\n\n\t\t/* Clear buffer_new on all buffers to reinitialise state. */\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tbh_end = bh_pos + blocksize;\n\t\tbh_cpos = bh_pos >> vol->cluster_size_bits;\n\t\tbh_cofs = bh_pos & vol->cluster_size_mask;\n\t\tif (buffer_mapped(bh)) {\n\t\t\t/*\n\t\t\t * The buffer is already mapped.  If it is uptodate,\n\t\t\t * ignore it.\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * The buffer is not uptodate.  If the page is uptodate\n\t\t\t * set the buffer uptodate and otherwise ignore it.\n\t\t\t */\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Neither the page nor the buffer are uptodate.  If\n\t\t\t * the buffer is only partially being written to, we\n\t\t\t * need to read it in before the write, i.e. now.\n\t\t\t */\n\t\t\tif ((bh_pos < pos && bh_end > pos) ||\n\t\t\t\t\t(bh_pos < end && bh_end > end)) {\n\t\t\t\t/*\n\t\t\t\t * If the buffer is fully or partially within\n\t\t\t\t * the initialized size, do an actual read.\n\t\t\t\t * Otherwise, simply zero the buffer.\n\t\t\t\t */\n\t\t\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\t\t\tinitialized_size = ni->initialized_size;\n\t\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\t\tif (bh_pos < initialized_size) {\n\t\t\t\t\tntfs_submit_bh_for_read(bh);\n\t\t\t\t\t*wait_bh++ = bh;\n\t\t\t\t} else {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/* Unmapped buffer.  Need to map it. */\n\t\tbh->b_bdev = vol->sb->s_bdev;\n\t\t/*\n\t\t * If the current buffer is in the same clusters as the map\n\t\t * cache, there is no need to check the runlist again.  The\n\t\t * map cache is made up of @vcn, which is the first cached file\n\t\t * cluster, @vcn_len which is the number of cached file\n\t\t * clusters, @lcn is the device cluster corresponding to @vcn,\n\t\t * and @lcn_block is the block number corresponding to @lcn.\n\t\t */\n\t\tcdelta = bh_cpos - vcn;\n\t\tif (likely(!cdelta || (cdelta > 0 && cdelta < vcn_len))) {\nmap_buffer_cached:\n\t\t\tBUG_ON(lcn < 0);\n\t\t\tbh->b_blocknr = lcn_block +\n\t\t\t\t\t(cdelta << (vol->cluster_size_bits -\n\t\t\t\t\tblocksize_bits)) +\n\t\t\t\t\t(bh_cofs >> blocksize_bits);\n\t\t\tset_buffer_mapped(bh);\n\t\t\t/*\n\t\t\t * If the page is uptodate so is the buffer.  If the\n\t\t\t * buffer is fully outside the write, we ignore it if\n\t\t\t * it was already allocated and we mark it dirty so it\n\t\t\t * gets written out if we allocated it.  On the other\n\t\t\t * hand, if we allocated the buffer but we are not\n\t\t\t * marking it dirty we set buffer_new so we can do\n\t\t\t * error recovery.\n\t\t\t */\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tif (unlikely(was_hole)) {\n\t\t\t\t\t/* We allocated the buffer. */\n\t\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\t\tif (bh_end <= pos || bh_pos >= end)\n\t\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\telse\n\t\t\t\t\t\tset_buffer_new(bh);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Page is _not_ uptodate. */\n\t\t\tif (likely(!was_hole)) {\n\t\t\t\t/*\n\t\t\t\t * Buffer was already allocated.  If it is not\n\t\t\t\t * uptodate and is only partially being written\n\t\t\t\t * to, we need to read it in before the write,\n\t\t\t\t * i.e. now.\n\t\t\t\t */\n\t\t\t\tif (!buffer_uptodate(bh) && bh_pos < end &&\n\t\t\t\t\t\tbh_end > pos &&\n\t\t\t\t\t\t(bh_pos < pos ||\n\t\t\t\t\t\tbh_end > end)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * If the buffer is fully or partially\n\t\t\t\t\t * within the initialized size, do an\n\t\t\t\t\t * actual read.  Otherwise, simply zero\n\t\t\t\t\t * the buffer.\n\t\t\t\t\t */\n\t\t\t\t\tread_lock_irqsave(&ni->size_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\t\tinitialized_size = ni->initialized_size;\n\t\t\t\t\tread_unlock_irqrestore(&ni->size_lock,\n\t\t\t\t\t\t\tflags);\n\t\t\t\t\tif (bh_pos < initialized_size) {\n\t\t\t\t\t\tntfs_submit_bh_for_read(bh);\n\t\t\t\t\t\t*wait_bh++ = bh;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* We allocated the buffer. */\n\t\t\tunmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);\n\t\t\t/*\n\t\t\t * If the buffer is fully outside the write, zero it,\n\t\t\t * set it uptodate, and mark it dirty so it gets\n\t\t\t * written out.  If it is partially being written to,\n\t\t\t * zero region surrounding the write but leave it to\n\t\t\t * commit write to do anything else.  Finally, if the\n\t\t\t * buffer is fully being overwritten, do nothing.\n\t\t\t */\n\t\t\tif (bh_end <= pos || bh_pos >= end) {\n\t\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tset_buffer_new(bh);\n\t\t\tif (!buffer_uptodate(bh) &&\n\t\t\t\t\t(bh_pos < pos || bh_end > end)) {\n\t\t\t\tu8 *kaddr;\n\t\t\t\tunsigned pofs;\n\t\t\t\t\t\n\t\t\t\tkaddr = kmap_atomic(page);\n\t\t\t\tif (bh_pos < pos) {\n\t\t\t\t\tpofs = bh_pos & ~PAGE_CACHE_MASK;\n\t\t\t\t\tmemset(kaddr + pofs, 0, pos - bh_pos);\n\t\t\t\t}\n\t\t\t\tif (bh_end > end) {\n\t\t\t\t\tpofs = end & ~PAGE_CACHE_MASK;\n\t\t\t\t\tmemset(kaddr + pofs, 0, bh_end - end);\n\t\t\t\t}\n\t\t\t\tkunmap_atomic(kaddr);\n\t\t\t\tflush_dcache_page(page);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Slow path: this is the first buffer in the cluster.  If it\n\t\t * is outside allocated size and is not uptodate, zero it and\n\t\t * set it uptodate.\n\t\t */\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tinitialized_size = ni->allocated_size;\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\tif (bh_pos > initialized_size) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t} else if (!buffer_uptodate(bh)) {\n\t\t\t\tzero_user(page, bh_offset(bh), blocksize);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tis_retry = false;\n\t\tif (!rl) {\n\t\t\tdown_read(&ni->runlist.lock);\nretry_remap:\n\t\t\trl = ni->runlist.rl;\n\t\t}\n\t\tif (likely(rl != NULL)) {\n\t\t\t/* Seek to element containing target cluster. */\n\t\t\twhile (rl->length && rl[1].vcn <= bh_cpos)\n\t\t\t\trl++;\n\t\t\tlcn = ntfs_rl_vcn_to_lcn(rl, bh_cpos);\n\t\t\tif (likely(lcn >= 0)) {\n\t\t\t\t/*\n\t\t\t\t * Successful remap, setup the map cache and\n\t\t\t\t * use that to deal with the buffer.\n\t\t\t\t */\n\t\t\t\twas_hole = false;\n\t\t\t\tvcn = bh_cpos;\n\t\t\t\tvcn_len = rl[1].vcn - vcn;\n\t\t\t\tlcn_block = lcn << (vol->cluster_size_bits -\n\t\t\t\t\t\tblocksize_bits);\n\t\t\t\tcdelta = 0;\n\t\t\t\t/*\n\t\t\t\t * If the number of remaining clusters touched\n\t\t\t\t * by the write is smaller or equal to the\n\t\t\t\t * number of cached clusters, unlock the\n\t\t\t\t * runlist as the map cache will be used from\n\t\t\t\t * now on.\n\t\t\t\t */\n\t\t\t\tif (likely(vcn + vcn_len >= cend)) {\n\t\t\t\t\tif (rl_write_locked) {\n\t\t\t\t\t\tup_write(&ni->runlist.lock);\n\t\t\t\t\t\trl_write_locked = false;\n\t\t\t\t\t} else\n\t\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\trl = NULL;\n\t\t\t\t}\n\t\t\t\tgoto map_buffer_cached;\n\t\t\t}\n\t\t} else\n\t\t\tlcn = LCN_RL_NOT_MAPPED;\n\t\t/*\n\t\t * If it is not a hole and not out of bounds, the runlist is\n\t\t * probably unmapped so try to map it now.\n\t\t */\n\t\tif (unlikely(lcn != LCN_HOLE && lcn != LCN_ENOENT)) {\n\t\t\tif (likely(!is_retry && lcn == LCN_RL_NOT_MAPPED)) {\n\t\t\t\t/* Attempt to map runlist. */\n\t\t\t\tif (!rl_write_locked) {\n\t\t\t\t\t/*\n\t\t\t\t\t * We need the runlist locked for\n\t\t\t\t\t * writing, so if it is locked for\n\t\t\t\t\t * reading relock it now and retry in\n\t\t\t\t\t * case it changed whilst we dropped\n\t\t\t\t\t * the lock.\n\t\t\t\t\t */\n\t\t\t\t\tup_read(&ni->runlist.lock);\n\t\t\t\t\tdown_write(&ni->runlist.lock);\n\t\t\t\t\trl_write_locked = true;\n\t\t\t\t\tgoto retry_remap;\n\t\t\t\t}\n\t\t\t\terr = ntfs_map_runlist_nolock(ni, bh_cpos,\n\t\t\t\t\t\tNULL);\n\t\t\t\tif (likely(!err)) {\n\t\t\t\t\tis_retry = true;\n\t\t\t\t\tgoto retry_remap;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * If @vcn is out of bounds, pretend @lcn is\n\t\t\t\t * LCN_ENOENT.  As long as the buffer is out\n\t\t\t\t * of bounds this will work fine.\n\t\t\t\t */\n\t\t\t\tif (err == -ENOENT) {\n\t\t\t\t\tlcn = LCN_ENOENT;\n\t\t\t\t\terr = 0;\n\t\t\t\t\tgoto rl_not_mapped_enoent;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\terr = -EIO;\n\t\t\t/* Failed to map the buffer, even after retrying. */\n\t\t\tbh->b_blocknr = -1;\n\t\t\tntfs_error(vol->sb, \"Failed to write to inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, vcn 0x%llx, \"\n\t\t\t\t\t\"vcn offset 0x%x, because its \"\n\t\t\t\t\t\"location on disk could not be \"\n\t\t\t\t\t\"determined%s (error code %i).\",\n\t\t\t\t\tni->mft_no, ni->type,\n\t\t\t\t\t(unsigned long long)bh_cpos,\n\t\t\t\t\t(unsigned)bh_pos &\n\t\t\t\t\tvol->cluster_size_mask,\n\t\t\t\t\tis_retry ? \" even after retrying\" : \"\",\n\t\t\t\t\terr);\n\t\t\tbreak;\n\t\t}\nrl_not_mapped_enoent:\n\t\t/*\n\t\t * The buffer is in a hole or out of bounds.  We need to fill\n\t\t * the hole, unless the buffer is in a cluster which is not\n\t\t * touched by the write, in which case we just leave the buffer\n\t\t * unmapped.  This can only happen when the cluster size is\n\t\t * less than the page cache size.\n\t\t */\n\t\tif (unlikely(vol->cluster_size < PAGE_CACHE_SIZE)) {\n\t\t\tbh_cend = (bh_end + vol->cluster_size - 1) >>\n\t\t\t\t\tvol->cluster_size_bits;\n\t\t\tif ((bh_cend <= cpos || bh_cpos >= cend)) {\n\t\t\t\tbh->b_blocknr = -1;\n\t\t\t\t/*\n\t\t\t\t * If the buffer is uptodate we skip it.  If it\n\t\t\t\t * is not but the page is uptodate, we can set\n\t\t\t\t * the buffer uptodate.  If the page is not\n\t\t\t\t * uptodate, we can clear the buffer and set it\n\t\t\t\t * uptodate.  Whether this is worthwhile is\n\t\t\t\t * debatable and this could be removed.\n\t\t\t\t */\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t} else if (!buffer_uptodate(bh)) {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Out of bounds buffer is invalid if it was not really out of\n\t\t * bounds.\n\t\t */\n\t\tBUG_ON(lcn != LCN_HOLE);\n\t\t/*\n\t\t * We need the runlist locked for writing, so if it is locked\n\t\t * for reading relock it now and retry in case it changed\n\t\t * whilst we dropped the lock.\n\t\t */\n\t\tBUG_ON(!rl);\n\t\tif (!rl_write_locked) {\n\t\t\tup_read(&ni->runlist.lock);\n\t\t\tdown_write(&ni->runlist.lock);\n\t\t\trl_write_locked = true;\n\t\t\tgoto retry_remap;\n\t\t}\n\t\t/* Find the previous last allocated cluster. */\n\t\tBUG_ON(rl->lcn != LCN_HOLE);\n\t\tlcn = -1;\n\t\trl2 = rl;\n\t\twhile (--rl2 >= ni->runlist.rl) {\n\t\t\tif (rl2->lcn >= 0) {\n\t\t\t\tlcn = rl2->lcn + rl2->length;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trl2 = ntfs_cluster_alloc(vol, bh_cpos, 1, lcn, DATA_ZONE,\n\t\t\t\tfalse);\n\t\tif (IS_ERR(rl2)) {\n\t\t\terr = PTR_ERR(rl2);\n\t\t\tntfs_debug(\"Failed to allocate cluster, error code %i.\",\n\t\t\t\t\terr);\n\t\t\tbreak;\n\t\t}\n\t\tlcn = rl2->lcn;\n\t\trl = ntfs_runlists_merge(ni->runlist.rl, rl2);\n\t\tif (IS_ERR(rl)) {\n\t\t\terr = PTR_ERR(rl);\n\t\t\tif (err != -ENOMEM)\n\t\t\t\terr = -EIO;\n\t\t\tif (ntfs_cluster_free_from_rl(vol, rl2)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to release \"\n\t\t\t\t\t\t\"allocated cluster in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover the lost cluster.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tntfs_free(rl2);\n\t\t\tbreak;\n\t\t}\n\t\tni->runlist.rl = rl;\n\t\tstatus.runlist_merged = 1;\n\t\tntfs_debug(\"Allocated cluster, lcn 0x%llx.\",\n\t\t\t\t(unsigned long long)lcn);\n\t\t/* Map and lock the mft record and get the attribute record. */\n\t\tif (!NInoAttr(ni))\n\t\t\tbase_ni = ni;\n\t\telse\n\t\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tbreak;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tunmap_mft_record(base_ni);\n\t\t\tbreak;\n\t\t}\n\t\tstatus.mft_attr_mapped = 1;\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, bh_cpos, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tm = ctx->mrec;\n\t\ta = ctx->attr;\n\t\t/*\n\t\t * Find the runlist element with which the attribute extent\n\t\t * starts.  Note, we cannot use the _attr_ version because we\n\t\t * have mapped the mft record.  That is ok because we know the\n\t\t * runlist fragment must be mapped already to have ever gotten\n\t\t * here, so we can just use the _rl_ version.\n\t\t */\n\t\tvcn = sle64_to_cpu(a->data.non_resident.lowest_vcn);\n\t\trl2 = ntfs_rl_find_vcn_nolock(rl, vcn);\n\t\tBUG_ON(!rl2);\n\t\tBUG_ON(!rl2->length);\n\t\tBUG_ON(rl2->lcn < LCN_HOLE);\n\t\thighest_vcn = sle64_to_cpu(a->data.non_resident.highest_vcn);\n\t\t/*\n\t\t * If @highest_vcn is zero, calculate the real highest_vcn\n\t\t * (which can really be zero).\n\t\t */\n\t\tif (!highest_vcn)\n\t\t\thighest_vcn = (sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size) >>\n\t\t\t\t\tvol->cluster_size_bits) - 1;\n\t\t/*\n\t\t * Determine the size of the mapping pairs array for the new\n\t\t * extent, i.e. the old extent with the hole filled.\n\t\t */\n\t\tmp_size = ntfs_get_size_for_mapping_pairs(vol, rl2, vcn,\n\t\t\t\thighest_vcn);\n\t\tif (unlikely(mp_size <= 0)) {\n\t\t\tif (!(err = mp_size))\n\t\t\t\terr = -EIO;\n\t\t\tntfs_debug(\"Failed to get size for mapping pairs \"\n\t\t\t\t\t\"array, error code %i.\", err);\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * Resize the attribute record to fit the new mapping pairs\n\t\t * array.\n\t\t */\n\t\tattr_rec_len = le32_to_cpu(a->length);\n\t\terr = ntfs_attr_record_resize(m, a, mp_size + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset));\n\t\tif (unlikely(err)) {\n\t\t\tBUG_ON(err != -ENOSPC);\n\t\t\t// TODO: Deal with this by using the current attribute\n\t\t\t// and fill it with as much of the mapping pairs\n\t\t\t// array as possible.  Then loop over each attribute\n\t\t\t// extent rewriting the mapping pairs arrays as we go\n\t\t\t// along and if when we reach the end we have not\n\t\t\t// enough space, try to resize the last attribute\n\t\t\t// extent and if even that fails, add a new attribute\n\t\t\t// extent.\n\t\t\t// We could also try to resize at each step in the hope\n\t\t\t// that we will not need to rewrite every single extent.\n\t\t\t// Note, we may need to decompress some extents to fill\n\t\t\t// the runlist as we are walking the extents...\n\t\t\tntfs_error(vol->sb, \"Not enough space in the mft \"\n\t\t\t\t\t\"record for the extended attribute \"\n\t\t\t\t\t\"record.  This case is not \"\n\t\t\t\t\t\"implemented yet.\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak ;\n\t\t}\n\t\tstatus.mp_rebuilt = 1;\n\t\t/*\n\t\t * Generate the mapping pairs array directly into the attribute\n\t\t * record.\n\t\t */\n\t\terr = ntfs_mapping_pairs_build(vol, (u8*)a + le16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset),\n\t\t\t\tmp_size, rl2, vcn, highest_vcn, NULL);\n\t\tif (unlikely(err)) {\n\t\t\tntfs_error(vol->sb, \"Cannot fill hole in inode 0x%lx, \"\n\t\t\t\t\t\"attribute type 0x%x, because building \"\n\t\t\t\t\t\"the mapping pairs failed with error \"\n\t\t\t\t\t\"code %i.\", vi->i_ino,\n\t\t\t\t\t(unsigned)le32_to_cpu(ni->type), err);\n\t\t\terr = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\t/* Update the highest_vcn but only if it was not set. */\n\t\tif (unlikely(!a->data.non_resident.highest_vcn))\n\t\t\ta->data.non_resident.highest_vcn =\n\t\t\t\t\tcpu_to_sle64(highest_vcn);\n\t\t/*\n\t\t * If the attribute is sparse/compressed, update the compressed\n\t\t * size in the ntfs_inode structure and the attribute record.\n\t\t */\n\t\tif (likely(NInoSparse(ni) || NInoCompressed(ni))) {\n\t\t\t/*\n\t\t\t * If we are not in the first attribute extent, switch\n\t\t\t * to it, but first ensure the changes will make it to\n\t\t\t * disk later.\n\t\t\t */\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\t\t\terr = ntfs_attr_lookup(ni->type, ni->name,\n\t\t\t\t\t\tni->name_len, CASE_SENSITIVE,\n\t\t\t\t\t\t0, NULL, 0, ctx);\n\t\t\t\tif (unlikely(err)) {\n\t\t\t\t\tstatus.attr_switched = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* @m is not used any more so do not set it. */\n\t\t\t\ta = ctx->attr;\n\t\t\t}\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->itype.compressed.size += vol->cluster_size;\n\t\t\ta->data.non_resident.compressed_size =\n\t\t\t\t\tcpu_to_sle64(ni->itype.compressed.size);\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t}\n\t\t/* Ensure the changes make it to disk. */\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t\t/* Successfully filled the hole. */\n\t\tstatus.runlist_merged = 0;\n\t\tstatus.mft_attr_mapped = 0;\n\t\tstatus.mp_rebuilt = 0;\n\t\t/* Setup the map cache and use that to deal with the buffer. */\n\t\twas_hole = true;\n\t\tvcn = bh_cpos;\n\t\tvcn_len = 1;\n\t\tlcn_block = lcn << (vol->cluster_size_bits - blocksize_bits);\n\t\tcdelta = 0;\n\t\t/*\n\t\t * If the number of remaining clusters in the @pages is smaller\n\t\t * or equal to the number of cached clusters, unlock the\n\t\t * runlist as the map cache will be used from now on.\n\t\t */\n\t\tif (likely(vcn + vcn_len >= cend)) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\trl_write_locked = false;\n\t\t\trl = NULL;\n\t\t}\n\t\tgoto map_buffer_cached;\n\t} while (bh_pos += blocksize, (bh = bh->b_this_page) != head);\n\t/* If there are no errors, do the next page. */\n\tif (likely(!err && ++u < nr_pages))\n\t\tgoto do_next_page;\n\t/* If there are no errors, release the runlist lock if we took it. */\n\tif (likely(!err)) {\n\t\tif (unlikely(rl_write_locked)) {\n\t\t\tup_write(&ni->runlist.lock);\n\t\t\trl_write_locked = false;\n\t\t} else if (unlikely(rl))\n\t\t\tup_read(&ni->runlist.lock);\n\t\trl = NULL;\n\t}\n\t/* If we issued read requests, let them complete. */\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tinitialized_size = ni->initialized_size;\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\twhile (wait_bh > wait) {\n\t\tbh = *--wait_bh;\n\t\twait_on_buffer(bh);\n\t\tif (likely(buffer_uptodate(bh))) {\n\t\t\tpage = bh->b_page;\n\t\t\tbh_pos = ((s64)page->index << PAGE_CACHE_SHIFT) +\n\t\t\t\t\tbh_offset(bh);\n\t\t\t/*\n\t\t\t * If the buffer overflows the initialized size, need\n\t\t\t * to zero the overflowing region.\n\t\t\t */\n\t\t\tif (unlikely(bh_pos + blocksize > initialized_size)) {\n\t\t\t\tint ofs = 0;\n\n\t\t\t\tif (likely(bh_pos < initialized_size))\n\t\t\t\t\tofs = initialized_size - bh_pos;\n\t\t\t\tzero_user_segment(page, bh_offset(bh) + ofs,\n\t\t\t\t\t\tblocksize);\n\t\t\t}\n\t\t} else /* if (unlikely(!buffer_uptodate(bh))) */\n\t\t\terr = -EIO;\n\t}\n\tif (likely(!err)) {\n\t\t/* Clear buffer_new on all buffers. */\n\t\tu = 0;\n\t\tdo {\n\t\t\tbh = head = page_buffers(pages[u]);\n\t\t\tdo {\n\t\t\t\tif (buffer_new(bh))\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t} while ((bh = bh->b_this_page) != head);\n\t\t} while (++u < nr_pages);\n\t\tntfs_debug(\"Done.\");\n\t\treturn err;\n\t}\n\tif (status.attr_switched) {\n\t\t/* Get back to the attribute extent we modified. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\tif (ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, bh_cpos, NULL, 0, ctx)) {\n\t\t\tntfs_error(vol->sb, \"Failed to find required \"\n\t\t\t\t\t\"attribute extent of attribute in \"\n\t\t\t\t\t\"error code path.  Run chkdsk to \"\n\t\t\t\t\t\"recover.\");\n\t\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\t\tni->itype.compressed.size += vol->cluster_size;\n\t\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t\t/*\n\t\t\t * The only thing that is now wrong is the compressed\n\t\t\t * size of the base attribute extent which chkdsk\n\t\t\t * should be able to fix.\n\t\t\t */\n\t\t\tNVolSetErrors(vol);\n\t\t} else {\n\t\t\tm = ctx->mrec;\n\t\t\ta = ctx->attr;\n\t\t\tstatus.attr_switched = 0;\n\t\t}\n\t}\n\t/*\n\t * If the runlist has been modified, need to restore it by punching a\n\t * hole into it and we then need to deallocate the on-disk cluster as\n\t * well.  Note, we only modify the runlist if we are able to generate a\n\t * new mapping pairs array, i.e. only when the mapped attribute extent\n\t * is not switched.\n\t */\n\tif (status.runlist_merged && !status.attr_switched) {\n\t\tBUG_ON(!rl_write_locked);\n\t\t/* Make the file cluster we allocated sparse in the runlist. */\n\t\tif (ntfs_rl_punch_nolock(vol, &ni->runlist, bh_cpos, 1)) {\n\t\t\tntfs_error(vol->sb, \"Failed to punch hole into \"\n\t\t\t\t\t\"attribute runlist in error code \"\n\t\t\t\t\t\"path.  Run chkdsk to recover the \"\n\t\t\t\t\t\"lost cluster.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tstatus.runlist_merged = 0;\n\t\t\t/*\n\t\t\t * Deallocate the on-disk cluster we allocated but only\n\t\t\t * if we succeeded in punching its vcn out of the\n\t\t\t * runlist.\n\t\t\t */\n\t\t\tdown_write(&vol->lcnbmp_lock);\n\t\t\tif (ntfs_bitmap_clear_bit(vol->lcnbmp_ino, lcn)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to release \"\n\t\t\t\t\t\t\"allocated cluster in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover the lost cluster.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tup_write(&vol->lcnbmp_lock);\n\t\t}\n\t}\n\t/*\n\t * Resize the attribute record to its old size and rebuild the mapping\n\t * pairs array.  Note, we only can do this if the runlist has been\n\t * restored to its old state which also implies that the mapped\n\t * attribute extent is not switched.\n\t */\n\tif (status.mp_rebuilt && !status.runlist_merged) {\n\t\tif (ntfs_attr_record_resize(m, a, attr_rec_len)) {\n\t\t\tntfs_error(vol->sb, \"Failed to restore attribute \"\n\t\t\t\t\t\"record in error code path.  Run \"\n\t\t\t\t\t\"chkdsk to recover.\");\n\t\t\tNVolSetErrors(vol);\n\t\t} else /* if (success) */ {\n\t\t\tif (ntfs_mapping_pairs_build(vol, (u8*)a +\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), attr_rec_len -\n\t\t\t\t\tle16_to_cpu(a->data.non_resident.\n\t\t\t\t\tmapping_pairs_offset), ni->runlist.rl,\n\t\t\t\t\tvcn, highest_vcn, NULL)) {\n\t\t\t\tntfs_error(vol->sb, \"Failed to restore \"\n\t\t\t\t\t\t\"mapping pairs array in error \"\n\t\t\t\t\t\t\"code path.  Run chkdsk to \"\n\t\t\t\t\t\t\"recover.\");\n\t\t\t\tNVolSetErrors(vol);\n\t\t\t}\n\t\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t}\n\t}\n\t/* Release the mft record and the attribute. */\n\tif (status.mft_attr_mapped) {\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(base_ni);\n\t}\n\t/* Release the runlist lock. */\n\tif (rl_write_locked)\n\t\tup_write(&ni->runlist.lock);\n\telse if (rl)\n\t\tup_read(&ni->runlist.lock);\n\t/*\n\t * Zero out any newly allocated blocks to avoid exposing stale data.\n\t * If BH_New is set, we know that the block was newly allocated above\n\t * and that it has not been fully zeroed and marked dirty yet.\n\t */\n\tnr_pages = u;\n\tu = 0;\n\tend = bh_cpos << vol->cluster_size_bits;\n\tdo {\n\t\tpage = pages[u];\n\t\tbh = head = page_buffers(page);\n\t\tdo {\n\t\t\tif (u == nr_pages &&\n\t\t\t\t\t((s64)page->index << PAGE_CACHE_SHIFT) +\n\t\t\t\t\tbh_offset(bh) >= end)\n\t\t\t\tbreak;\n\t\t\tif (!buffer_new(bh))\n\t\t\t\tcontinue;\n\t\t\tclear_buffer_new(bh);\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tif (PageUptodate(page))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\telse {\n\t\t\t\t\tzero_user(page, bh_offset(bh),\n\t\t\t\t\t\t\tblocksize);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmark_buffer_dirty(bh);\n\t\t} while ((bh = bh->b_this_page) != head);\n\t} while (++u <= nr_pages);\n\tntfs_error(vol->sb, \"Failed.  Returning error code %i.\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_submit_bh_for_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "447-453",
    "snippet": "static inline int ntfs_submit_bh_for_read(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\treturn submit_bh(READ, bh);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "READ",
            "bh"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline int ntfs_submit_bh_for_read(struct buffer_head *bh)\n{\n\tlock_buffer(bh);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_read_sync;\n\treturn submit_bh(READ, bh);\n}"
  },
  {
    "function_name": "__ntfs_grab_cache_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "405-445",
    "snippet": "static inline int __ntfs_grab_cache_pages(struct address_space *mapping,\n\t\tpgoff_t index, const unsigned nr_pages, struct page **pages,\n\t\tstruct page **cached_page)\n{\n\tint err, nr;\n\n\tBUG_ON(!nr_pages);\n\terr = nr = 0;\n\tdo {\n\t\tpages[nr] = find_get_page_flags(mapping, index, FGP_LOCK |\n\t\t\t\tFGP_ACCESSED);\n\t\tif (!pages[nr]) {\n\t\t\tif (!*cached_page) {\n\t\t\t\t*cached_page = page_cache_alloc(mapping);\n\t\t\t\tif (unlikely(!*cached_page)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = add_to_page_cache_lru(*cached_page, mapping, index,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tif (err == -EEXIST)\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tpages[nr] = *cached_page;\n\t\t\t*cached_page = NULL;\n\t\t}\n\t\tindex++;\n\t\tnr++;\n\t} while (nr < nr_pages);\nout:\n\treturn err;\nerr_out:\n\twhile (nr > 0) {\n\t\tunlock_page(pages[--nr]);\n\t\tpage_cache_release(pages[nr]);\n\t}\n\tgoto out;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "pages[nr]"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "pages[--nr]"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "*cached_page",
            "mapping",
            "index",
            "GFP_KERNEL"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!*cached_page"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_alloc",
          "args": [
            "mapping"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page_flags",
          "args": [
            "mapping",
            "index",
            "FGP_LOCK |\n\t\t\t\tFGP_ACCESSED"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!nr_pages"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline int __ntfs_grab_cache_pages(struct address_space *mapping,\n\t\tpgoff_t index, const unsigned nr_pages, struct page **pages,\n\t\tstruct page **cached_page)\n{\n\tint err, nr;\n\n\tBUG_ON(!nr_pages);\n\terr = nr = 0;\n\tdo {\n\t\tpages[nr] = find_get_page_flags(mapping, index, FGP_LOCK |\n\t\t\t\tFGP_ACCESSED);\n\t\tif (!pages[nr]) {\n\t\t\tif (!*cached_page) {\n\t\t\t\t*cached_page = page_cache_alloc(mapping);\n\t\t\t\tif (unlikely(!*cached_page)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tgoto err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = add_to_page_cache_lru(*cached_page, mapping, index,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tif (err == -EEXIST)\n\t\t\t\t\tcontinue;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tpages[nr] = *cached_page;\n\t\t\t*cached_page = NULL;\n\t\t}\n\t\tindex++;\n\t\tnr++;\n\t} while (nr < nr_pages);\nout:\n\treturn err;\nerr_out:\n\twhile (nr > 0) {\n\t\tunlock_page(pages[--nr]);\n\t\tpage_cache_release(pages[nr]);\n\t}\n\tgoto out;\n}"
  },
  {
    "function_name": "ntfs_fault_in_pages_readable_iovec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "372-388",
    "snippet": "static inline void ntfs_fault_in_pages_readable_iovec(const struct iovec *iov,\n\t\tsize_t iov_ofs, int bytes)\n{\n\tdo {\n\t\tconst char __user *buf;\n\t\tunsigned len;\n\n\t\tbuf = iov->iov_base + iov_ofs;\n\t\tlen = iov->iov_len - iov_ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tntfs_fault_in_pages_readable(buf, len);\n\t\tbytes -= len;\n\t\tiov++;\n\t\tiov_ofs = 0;\n\t} while (bytes);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_fault_in_pages_readable",
          "args": [
            "buf",
            "len"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_fault_in_pages_readable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
          "lines": "354-365",
          "snippet": "static inline void ntfs_fault_in_pages_readable(const char __user *uaddr,\n\t\tint bytes)\n{\n\tconst char __user *end;\n\tvolatile char c;\n\n\t/* Set @end to the first byte outside the last page we care about. */\n\tend = (const char __user*)PAGE_ALIGN((unsigned long)uaddr + bytes);\n\n\twhile (!__get_user(c, uaddr) && (uaddr += PAGE_SIZE, uaddr < end))\n\t\t;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"debug.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include <asm/uaccess.h>",
            "#include <asm/page.h>",
            "#include <linux/aio.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uio.h>",
            "#include <linux/swap.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline void ntfs_fault_in_pages_readable(const char __user *uaddr,\n\t\tint bytes)\n{\n\tconst char __user *end;\n\tvolatile char c;\n\n\t/* Set @end to the first byte outside the last page we care about. */\n\tend = (const char __user*)PAGE_ALIGN((unsigned long)uaddr + bytes);\n\n\twhile (!__get_user(c, uaddr) && (uaddr += PAGE_SIZE, uaddr < end))\n\t\t;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline void ntfs_fault_in_pages_readable_iovec(const struct iovec *iov,\n\t\tsize_t iov_ofs, int bytes)\n{\n\tdo {\n\t\tconst char __user *buf;\n\t\tunsigned len;\n\n\t\tbuf = iov->iov_base + iov_ofs;\n\t\tlen = iov->iov_len - iov_ofs;\n\t\tif (len > bytes)\n\t\t\tlen = bytes;\n\t\tntfs_fault_in_pages_readable(buf, len);\n\t\tbytes -= len;\n\t\tiov++;\n\t\tiov_ofs = 0;\n\t} while (bytes);\n}"
  },
  {
    "function_name": "ntfs_fault_in_pages_readable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "354-365",
    "snippet": "static inline void ntfs_fault_in_pages_readable(const char __user *uaddr,\n\t\tint bytes)\n{\n\tconst char __user *end;\n\tvolatile char c;\n\n\t/* Set @end to the first byte outside the last page we care about. */\n\tend = (const char __user*)PAGE_ALIGN((unsigned long)uaddr + bytes);\n\n\twhile (!__get_user(c, uaddr) && (uaddr += PAGE_SIZE, uaddr < end))\n\t\t;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "c",
            "uaddr"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "(unsigned long)uaddr + bytes"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic inline void ntfs_fault_in_pages_readable(const char __user *uaddr,\n\t\tint bytes)\n{\n\tconst char __user *end;\n\tvolatile char c;\n\n\t/* Set @end to the first byte outside the last page we care about. */\n\tend = (const char __user*)PAGE_ALIGN((unsigned long)uaddr + bytes);\n\n\twhile (!__get_user(c, uaddr) && (uaddr += PAGE_SIZE, uaddr < end))\n\t\t;\n}"
  },
  {
    "function_name": "ntfs_attr_extend_initialized",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "110-330",
    "snippet": "static int ntfs_attr_extend_initialized(ntfs_inode *ni, const s64 new_init_size)\n{\n\ts64 old_init_size;\n\tloff_t old_i_size;\n\tpgoff_t index, end_index;\n\tunsigned long flags;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *kattr;\n\tint err;\n\tu32 attr_len;\n\n\tread_lock_irqsave(&ni->size_lock, flags);\n\told_init_size = ni->initialized_size;\n\told_i_size = i_size_read(vi);\n\tBUG_ON(new_init_size > ni->allocated_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_initialized_size 0x%llx, \"\n\t\t\t\"new_initialized_size 0x%llx, i_size 0x%llx.\",\n\t\t\tvi->i_ino, (unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)old_init_size,\n\t\t\t(unsigned long long)new_init_size, old_i_size);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/* Use goto to reduce indentation and we need the label below anyway. */\n\tif (NInoNonResident(ni))\n\t\tgoto do_non_resident_extend;\n\tBUG_ON(old_init_size != old_i_size);\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(a->non_resident);\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\tBUG_ON(old_i_size != (loff_t)attr_len);\n\t/*\n\t * Do the zeroing in the mft record and update the attribute size in\n\t * the mft record.\n\t */\n\tkattr = (u8*)a + le16_to_cpu(a->data.resident.value_offset);\n\tmemset(kattr + attr_len, 0, new_init_size - attr_len);\n\ta->data.resident.value_length = cpu_to_le32((u32)new_init_size);\n\t/* Finally, update the sizes in the vfs and ntfs inodes. */\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\ti_size_write(vi, new_init_size);\n\tni->initialized_size = new_init_size;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\tgoto done;\ndo_non_resident_extend:\n\t/*\n\t * If the new initialized size @new_init_size exceeds the current file\n\t * size (vfs inode->i_size), we need to extend the file size to the\n\t * new initialized size.\n\t */\n\tif (new_init_size > old_i_size) {\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tm = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tm = ctx->mrec;\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tBUG_ON(old_i_size != (loff_t)\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size));\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_init_size);\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t/* Update the file size in the vfs inode. */\n\t\ti_size_write(vi, new_init_size);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tctx = NULL;\n\t\tunmap_mft_record(base_ni);\n\t\tm = NULL;\n\t}\n\tmapping = vi->i_mapping;\n\tindex = old_init_size >> PAGE_CACHE_SHIFT;\n\tend_index = (new_init_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\t/*\n\t\t * Read the page.  If the page is not present, this will zero\n\t\t * the uninitialized regions for us.\n\t\t */\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto init_err_out;\n\t\t}\n\t\tif (unlikely(PageError(page))) {\n\t\t\tpage_cache_release(page);\n\t\t\terr = -EIO;\n\t\t\tgoto init_err_out;\n\t\t}\n\t\t/*\n\t\t * Update the initialized size in the ntfs inode.  This is\n\t\t * enough to make ntfs_writepage() work.\n\t\t */\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->initialized_size = (s64)(index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (ni->initialized_size > new_init_size)\n\t\t\tni->initialized_size = new_init_size;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t/* Set the page dirty so it gets written out. */\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t\t/*\n\t\t * Play nice with the vm and the rest of the system.  This is\n\t\t * very much needed as we can potentially be modifying the\n\t\t * initialised size from a very small value to a really huge\n\t\t * value, e.g.\n\t\t *\tf = open(somefile, O_TRUNC);\n\t\t *\ttruncate(f, 10GiB);\n\t\t *\tseek(f, 10GiB);\n\t\t *\twrite(f, 1);\n\t\t * And this would mean we would be marking dirty hundreds of\n\t\t * thousands of pages or as in the above example more than\n\t\t * two and a half million pages!\n\t\t *\n\t\t * TODO: For sparse pages could optimize this workload by using\n\t\t * the FsMisc / MiscFs page bit as a \"PageIsSparse\" bit.  This\n\t\t * would be set in readpage for sparse pages and here we would\n\t\t * not need to mark dirty any pages which have this bit set.\n\t\t * The only caveat is that we have to clear the bit everywhere\n\t\t * where we allocate any clusters that lie in the page or that\n\t\t * contain the page.\n\t\t *\n\t\t * TODO: An even greater optimization would be for us to only\n\t\t * call readpage() on pages which are not in sparse regions as\n\t\t * determined from the runlist.  This would greatly reduce the\n\t\t * number of pages we read and make dirty in the case of sparse\n\t\t * files.\n\t\t */\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t} while (++index < end_index);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tBUG_ON(ni->initialized_size != new_init_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Now bring in sync the initialized_size in the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto init_err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto init_err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto init_err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(!a->non_resident);\n\ta->data.non_resident.initialized_size = cpu_to_sle64(new_init_size);\ndone:\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done, initialized_size 0x%llx, i_size 0x%llx.\",\n\t\t\t(unsigned long long)new_init_size, i_size_read(vi));\n\treturn 0;\ninit_err_out:\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->initialized_size = old_init_size;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Failed.  Returning error code %i.\"",
            "err"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mft_record",
          "args": [
            "base_ni"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_mft_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "213-231",
          "snippet": "void unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid unmap_mft_record(ntfs_inode *ni)\n{\n\tstruct page *page = ni->page;\n\n\tBUG_ON(!page);\n\n\tntfs_debug(\"Entering for mft_no 0x%lx.\", ni->mft_no);\n\n\tunmap_mft_record_page(ni);\n\tmutex_unlock(&ni->mrec_lock);\n\tatomic_dec(&ni->count);\n\t/*\n\t * If pure ntfs_inode, i.e. no vfs inode attached, we leave it to\n\t * ntfs_clear_extent_inode() in the extent inode case, and to the\n\t * caller in the non-extent, yet pure ntfs inode case, to do the actual\n\t * tear down of all structures and freeing of all allocated memory.\n\t */\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_attr_put_search_ctx",
          "args": [
            "ctx"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_put_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1286-1292",
          "snippet": "void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nvoid ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)\n{\n\tif (ctx->base_ntfs_ino && ctx->ntfs_ino != ctx->base_ntfs_ino)\n\t\tunmap_extent_mft_record(ctx->ntfs_ino);\n\tkmem_cache_free(ntfs_attr_ctx_cache, ctx);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done, initialized_size 0x%llx, i_size 0x%llx.\"",
            "(unsigned long long)new_init_size",
            "i_size_read(vi)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_mft_record_dirty",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "__mark_mft_record_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.c",
          "lines": "395-410",
          "snippet": "void __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"dir.h\"",
            "#include \"debug.h\"",
            "#include \"bitmap.h\"",
            "#include \"aops.h\"",
            "#include \"attrib.h\"",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"dir.h\"\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"aops.h\"\n#include \"attrib.h\"\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid __mark_mft_record_dirty(ntfs_inode *ni)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering for inode 0x%lx.\", ni->mft_no);\n\tBUG_ON(NInoAttr(ni));\n\tmark_ntfs_record_dirty(ni->page, ni->page_ofs);\n\t/* Determine the base vfs inode and mark it dirty, too. */\n\tmutex_lock(&ni->extent_lock);\n\tif (likely(ni->nr_extents >= 0))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\tmutex_unlock(&ni->extent_lock);\n\t__mark_inode_dirty(VFS_I(base_ni), I_DIRTY_SYNC | I_DIRTY_DATASYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_mft_record_page",
          "args": [
            "ctx->ntfs_ino"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "flush_dcache_mft_record_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/mft.h",
          "lines": "55-58",
          "snippet": "static inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/fs.h>\n\nstatic inline void flush_dcache_mft_record_page(ntfs_inode *ni)\n{\n\tflush_dcache_page(ni->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_sle64",
          "args": [
            "new_init_size"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_sle64p",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "88-91",
          "snippet": "static inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline sle64 cpu_to_sle64p(s64 *x)\n{\n\treturn (__force sle64)cpu_to_le64(*x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!a->non_resident"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_lookup",
          "args": [
            "ni->type",
            "ni->name",
            "ni->name_len",
            "CASE_SENSITIVE",
            "0",
            "NULL",
            "0",
            "ctx"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1187-1207",
          "snippet": "int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nint ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,\n\t\tconst u32 name_len, const IGNORE_CASE_BOOL ic,\n\t\tconst VCN lowest_vcn, const u8 *val, const u32 val_len,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tntfs_inode *base_ni;\n\n\tntfs_debug(\"Entering.\");\n\tBUG_ON(IS_ERR(ctx->mrec));\n\tif (ctx->base_ntfs_ino)\n\t\tbase_ni = ctx->base_ntfs_ino;\n\telse\n\t\tbase_ni = ctx->ntfs_ino;\n\t/* Sanity check, just for debugging really. */\n\tBUG_ON(!base_ni);\n\tif (!NInoAttrList(base_ni) || type == AT_ATTRIBUTE_LIST)\n\t\treturn ntfs_attr_find(type, name, name_len, ic, val, val_len,\n\t\t\t\tctx);\n\treturn ntfs_external_attr_find(type, name, name_len, ic, lowest_vcn,\n\t\t\tval, val_len, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_get_search_ctx",
          "args": [
            "base_ni",
            "m"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_get_search_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "1269-1277",
          "snippet": "ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)\n{\n\tntfs_attr_search_ctx *ctx;\n\n\tctx = kmem_cache_alloc(ntfs_attr_ctx_cache, GFP_NOFS);\n\tif (ctx)\n\t\tntfs_attr_init_search_ctx(ctx, ni, mrec);\n\treturn ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ni->initialized_size != new_init_size"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "balance_dirty_pages_ratelimited",
          "args": [
            "mapping"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "index + 1"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "PageError(page)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "index",
            "NULL"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "vi",
            "new_init_size"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "old_i_size != (loff_t)\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sle64_to_cpu",
          "args": [
            "a->data.non_resident.data_size"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!a->non_resident"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "(u32)new_init_size"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kattr + attr_len",
            "0",
            "new_init_size - attr_len"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "a->data.resident.value_offset"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "old_i_size != (loff_t)attr_len"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "a->data.resident.value_length"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "a->non_resident"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "m"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "m"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "old_init_size != old_i_size"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoNonResident",
          "args": [
            "ni"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NInoAttr",
          "args": [
            "ni"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_initialized_size 0x%llx, \"\n\t\t\t\"new_initialized_size 0x%llx, i_size 0x%llx.\"",
            "vi->i_ino",
            "(unsigned)le32_to_cpu(ni->type)",
            "(unsigned long long)old_init_size",
            "(unsigned long long)new_init_size",
            "old_i_size"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock_irqrestore",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_init_size > ni->allocated_size"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock_irqsave",
          "args": [
            "&ni->size_lock",
            "flags"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VFS_I",
          "args": [
            "ni"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "VFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.h",
          "lines": "245-248",
          "snippet": "static inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}",
          "includes": [
            "#include \"debug.h\"",
            "#include \"runlist.h\"",
            "#include \"types.h\"",
            "#include \"volume.h\"",
            "#include \"layout.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n#include \"runlist.h\"\n#include \"types.h\"\n#include \"volume.h\"\n#include \"layout.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n\nstatic inline struct inode *VFS_I(ntfs_inode *ni)\n{\n\treturn &((big_ntfs_inode *)ni)->vfs_inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic int ntfs_attr_extend_initialized(ntfs_inode *ni, const s64 new_init_size)\n{\n\ts64 old_init_size;\n\tloff_t old_i_size;\n\tpgoff_t index, end_index;\n\tunsigned long flags;\n\tstruct inode *vi = VFS_I(ni);\n\tntfs_inode *base_ni;\n\tMFT_RECORD *m = NULL;\n\tATTR_RECORD *a;\n\tntfs_attr_search_ctx *ctx = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *kattr;\n\tint err;\n\tu32 attr_len;\n\n\tread_lock_irqsave(&ni->size_lock, flags);\n\told_init_size = ni->initialized_size;\n\told_i_size = i_size_read(vi);\n\tBUG_ON(new_init_size > ni->allocated_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\tntfs_debug(\"Entering for i_ino 0x%lx, attribute type 0x%x, \"\n\t\t\t\"old_initialized_size 0x%llx, \"\n\t\t\t\"new_initialized_size 0x%llx, i_size 0x%llx.\",\n\t\t\tvi->i_ino, (unsigned)le32_to_cpu(ni->type),\n\t\t\t(unsigned long long)old_init_size,\n\t\t\t(unsigned long long)new_init_size, old_i_size);\n\tif (!NInoAttr(ni))\n\t\tbase_ni = ni;\n\telse\n\t\tbase_ni = ni->ext.base_ntfs_ino;\n\t/* Use goto to reduce indentation and we need the label below anyway. */\n\tif (NInoNonResident(ni))\n\t\tgoto do_non_resident_extend;\n\tBUG_ON(old_init_size != old_i_size);\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(a->non_resident);\n\t/* The total length of the attribute value. */\n\tattr_len = le32_to_cpu(a->data.resident.value_length);\n\tBUG_ON(old_i_size != (loff_t)attr_len);\n\t/*\n\t * Do the zeroing in the mft record and update the attribute size in\n\t * the mft record.\n\t */\n\tkattr = (u8*)a + le16_to_cpu(a->data.resident.value_offset);\n\tmemset(kattr + attr_len, 0, new_init_size - attr_len);\n\ta->data.resident.value_length = cpu_to_le32((u32)new_init_size);\n\t/* Finally, update the sizes in the vfs and ntfs inodes. */\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\ti_size_write(vi, new_init_size);\n\tni->initialized_size = new_init_size;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\tgoto done;\ndo_non_resident_extend:\n\t/*\n\t * If the new initialized size @new_init_size exceeds the current file\n\t * size (vfs inode->i_size), we need to extend the file size to the\n\t * new initialized size.\n\t */\n\tif (new_init_size > old_i_size) {\n\t\tm = map_mft_record(base_ni);\n\t\tif (IS_ERR(m)) {\n\t\t\terr = PTR_ERR(m);\n\t\t\tm = NULL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\t\tif (unlikely(!ctx)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\t\tm = ctx->mrec;\n\t\ta = ctx->attr;\n\t\tBUG_ON(!a->non_resident);\n\t\tBUG_ON(old_i_size != (loff_t)\n\t\t\t\tsle64_to_cpu(a->data.non_resident.data_size));\n\t\ta->data.non_resident.data_size = cpu_to_sle64(new_init_size);\n\t\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\t\tmark_mft_record_dirty(ctx->ntfs_ino);\n\t\t/* Update the file size in the vfs inode. */\n\t\ti_size_write(vi, new_init_size);\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tctx = NULL;\n\t\tunmap_mft_record(base_ni);\n\t\tm = NULL;\n\t}\n\tmapping = vi->i_mapping;\n\tindex = old_init_size >> PAGE_CACHE_SHIFT;\n\tend_index = (new_init_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tdo {\n\t\t/*\n\t\t * Read the page.  If the page is not present, this will zero\n\t\t * the uninitialized regions for us.\n\t\t */\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto init_err_out;\n\t\t}\n\t\tif (unlikely(PageError(page))) {\n\t\t\tpage_cache_release(page);\n\t\t\terr = -EIO;\n\t\t\tgoto init_err_out;\n\t\t}\n\t\t/*\n\t\t * Update the initialized size in the ntfs inode.  This is\n\t\t * enough to make ntfs_writepage() work.\n\t\t */\n\t\twrite_lock_irqsave(&ni->size_lock, flags);\n\t\tni->initialized_size = (s64)(index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (ni->initialized_size > new_init_size)\n\t\t\tni->initialized_size = new_init_size;\n\t\twrite_unlock_irqrestore(&ni->size_lock, flags);\n\t\t/* Set the page dirty so it gets written out. */\n\t\tset_page_dirty(page);\n\t\tpage_cache_release(page);\n\t\t/*\n\t\t * Play nice with the vm and the rest of the system.  This is\n\t\t * very much needed as we can potentially be modifying the\n\t\t * initialised size from a very small value to a really huge\n\t\t * value, e.g.\n\t\t *\tf = open(somefile, O_TRUNC);\n\t\t *\ttruncate(f, 10GiB);\n\t\t *\tseek(f, 10GiB);\n\t\t *\twrite(f, 1);\n\t\t * And this would mean we would be marking dirty hundreds of\n\t\t * thousands of pages or as in the above example more than\n\t\t * two and a half million pages!\n\t\t *\n\t\t * TODO: For sparse pages could optimize this workload by using\n\t\t * the FsMisc / MiscFs page bit as a \"PageIsSparse\" bit.  This\n\t\t * would be set in readpage for sparse pages and here we would\n\t\t * not need to mark dirty any pages which have this bit set.\n\t\t * The only caveat is that we have to clear the bit everywhere\n\t\t * where we allocate any clusters that lie in the page or that\n\t\t * contain the page.\n\t\t *\n\t\t * TODO: An even greater optimization would be for us to only\n\t\t * call readpage() on pages which are not in sparse regions as\n\t\t * determined from the runlist.  This would greatly reduce the\n\t\t * number of pages we read and make dirty in the case of sparse\n\t\t * files.\n\t\t */\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t\tcond_resched();\n\t} while (++index < end_index);\n\tread_lock_irqsave(&ni->size_lock, flags);\n\tBUG_ON(ni->initialized_size != new_init_size);\n\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t/* Now bring in sync the initialized_size in the mft record. */\n\tm = map_mft_record(base_ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tm = NULL;\n\t\tgoto init_err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(base_ni, m);\n\tif (unlikely(!ctx)) {\n\t\terr = -ENOMEM;\n\t\tgoto init_err_out;\n\t}\n\terr = ntfs_attr_lookup(ni->type, ni->name, ni->name_len,\n\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT)\n\t\t\terr = -EIO;\n\t\tgoto init_err_out;\n\t}\n\tm = ctx->mrec;\n\ta = ctx->attr;\n\tBUG_ON(!a->non_resident);\n\ta->data.non_resident.initialized_size = cpu_to_sle64(new_init_size);\ndone:\n\tflush_dcache_mft_record_page(ctx->ntfs_ino);\n\tmark_mft_record_dirty(ctx->ntfs_ino);\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Done, initialized_size 0x%llx, i_size 0x%llx.\",\n\t\t\t(unsigned long long)new_init_size, i_size_read(vi));\n\treturn 0;\ninit_err_out:\n\twrite_lock_irqsave(&ni->size_lock, flags);\n\tni->initialized_size = old_init_size;\n\twrite_unlock_irqrestore(&ni->size_lock, flags);\nerr_out:\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(base_ni);\n\tntfs_debug(\"Failed.  Returning error code %i.\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/file.c",
    "lines": "63-70",
    "snippet": "static int ntfs_file_open(struct inode *vi, struct file *filp)\n{\n\tif (sizeof(unsigned long) < 8) {\n\t\tif (i_size_read(vi) > MAX_LFS_FILESIZE)\n\t\t\treturn -EOVERFLOW;\n\t}\n\treturn generic_file_open(vi, filp);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"mft.h\"",
      "#include \"malloc.h\"",
      "#include \"lcnalloc.h\"",
      "#include \"debug.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"attrib.h\"",
      "#include <asm/uaccess.h>",
      "#include <asm/page.h>",
      "#include <linux/aio.h>",
      "#include <linux/writeback.h>",
      "#include <linux/uio.h>",
      "#include <linux/swap.h>",
      "#include <linux/sched.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/gfp.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/backing-dev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_file_open",
          "args": [
            "vi",
            "filp"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "generic_file_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "1121-1126",
          "snippet": "int generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nint generic_file_open(struct inode * inode, struct file * filp)\n{\n\tif (!(filp->f_flags & O_LARGEFILE) && i_size_read(inode) > MAX_NON_LFS)\n\t\treturn -EOVERFLOW;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "vi"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"debug.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include <asm/uaccess.h>\n#include <asm/page.h>\n#include <linux/aio.h>\n#include <linux/writeback.h>\n#include <linux/uio.h>\n#include <linux/swap.h>\n#include <linux/sched.h>\n#include <linux/pagevec.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/buffer_head.h>\n#include <linux/backing-dev.h>\n\nstatic int ntfs_file_open(struct inode *vi, struct file *filp)\n{\n\tif (sizeof(unsigned long) < 8) {\n\t\tif (i_size_read(vi) > MAX_LFS_FILESIZE)\n\t\t\treturn -EOVERFLOW;\n\t}\n\treturn generic_file_open(vi, filp);\n}"
  }
]