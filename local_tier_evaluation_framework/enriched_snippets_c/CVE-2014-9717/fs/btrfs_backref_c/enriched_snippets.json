[
  {
    "function_name": "free_ipath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1955-1961",
    "snippet": "void free_ipath(struct inode_fs_paths *ipath)\n{\n\tif (!ipath)\n\t\treturn;\n\tvfree(ipath->fspath);\n\tkfree(ipath);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ipath"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "ipath->fspath"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nvoid free_ipath(struct inode_fs_paths *ipath)\n{\n\tif (!ipath)\n\t\treturn;\n\tvfree(ipath->fspath);\n\tkfree(ipath);\n}"
  },
  {
    "function_name": "init_ipath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1932-1953",
    "snippet": "struct inode_fs_paths *init_ipath(s32 total_bytes, struct btrfs_root *fs_root,\n\t\t\t\t\tstruct btrfs_path *path)\n{\n\tstruct inode_fs_paths *ifp;\n\tstruct btrfs_data_container *fspath;\n\n\tfspath = init_data_container(total_bytes);\n\tif (IS_ERR(fspath))\n\t\treturn (void *)fspath;\n\n\tifp = kmalloc(sizeof(*ifp), GFP_NOFS);\n\tif (!ifp) {\n\t\tkfree(fspath);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tifp->btrfs_path = path;\n\tifp->fspath = fspath;\n\tifp->fs_root = fs_root;\n\n\treturn ifp;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fspath"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ifp)",
            "GFP_NOFS"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fspath"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_data_container",
          "args": [
            "total_bytes"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "init_data_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1902-1924",
          "snippet": "struct btrfs_data_container *init_data_container(u32 total_bytes)\n{\n\tstruct btrfs_data_container *data;\n\tsize_t alloc_bytes;\n\n\talloc_bytes = max_t(size_t, total_bytes, sizeof(*data));\n\tdata = vmalloc(alloc_bytes);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (total_bytes >= sizeof(*data)) {\n\t\tdata->bytes_left = total_bytes - sizeof(*data);\n\t\tdata->bytes_missing = 0;\n\t} else {\n\t\tdata->bytes_missing = sizeof(*data) - total_bytes;\n\t\tdata->bytes_left = 0;\n\t}\n\n\tdata->elem_cnt = 0;\n\tdata->elem_missed = 0;\n\n\treturn data;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstruct btrfs_data_container *init_data_container(u32 total_bytes)\n{\n\tstruct btrfs_data_container *data;\n\tsize_t alloc_bytes;\n\n\talloc_bytes = max_t(size_t, total_bytes, sizeof(*data));\n\tdata = vmalloc(alloc_bytes);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (total_bytes >= sizeof(*data)) {\n\t\tdata->bytes_left = total_bytes - sizeof(*data);\n\t\tdata->bytes_missing = 0;\n\t} else {\n\t\tdata->bytes_missing = sizeof(*data) - total_bytes;\n\t\tdata->bytes_left = 0;\n\t}\n\n\tdata->elem_cnt = 0;\n\tdata->elem_missed = 0;\n\n\treturn data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstruct inode_fs_paths *init_ipath(s32 total_bytes, struct btrfs_root *fs_root,\n\t\t\t\t\tstruct btrfs_path *path)\n{\n\tstruct inode_fs_paths *ifp;\n\tstruct btrfs_data_container *fspath;\n\n\tfspath = init_data_container(total_bytes);\n\tif (IS_ERR(fspath))\n\t\treturn (void *)fspath;\n\n\tifp = kmalloc(sizeof(*ifp), GFP_NOFS);\n\tif (!ifp) {\n\t\tkfree(fspath);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tifp->btrfs_path = path;\n\tifp->fspath = fspath;\n\tifp->fs_root = fs_root;\n\n\treturn ifp;\n}"
  },
  {
    "function_name": "init_data_container",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1902-1924",
    "snippet": "struct btrfs_data_container *init_data_container(u32 total_bytes)\n{\n\tstruct btrfs_data_container *data;\n\tsize_t alloc_bytes;\n\n\talloc_bytes = max_t(size_t, total_bytes, sizeof(*data));\n\tdata = vmalloc(alloc_bytes);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (total_bytes >= sizeof(*data)) {\n\t\tdata->bytes_left = total_bytes - sizeof(*data);\n\t\tdata->bytes_missing = 0;\n\t} else {\n\t\tdata->bytes_missing = sizeof(*data) - total_bytes;\n\t\tdata->bytes_left = 0;\n\t}\n\n\tdata->elem_cnt = 0;\n\tdata->elem_missed = 0;\n\n\treturn data;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "alloc_bytes"
          ],
          "line": 1908
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max_t",
          "args": [
            "size_t",
            "total_bytes",
            "sizeof(*data)"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstruct btrfs_data_container *init_data_container(u32 total_bytes)\n{\n\tstruct btrfs_data_container *data;\n\tsize_t alloc_bytes;\n\n\talloc_bytes = max_t(size_t, total_bytes, sizeof(*data));\n\tdata = vmalloc(alloc_bytes);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (total_bytes >= sizeof(*data)) {\n\t\tdata->bytes_left = total_bytes - sizeof(*data);\n\t\tdata->bytes_missing = 0;\n\t} else {\n\t\tdata->bytes_missing = sizeof(*data) - total_bytes;\n\t\tdata->bytes_left = 0;\n\t}\n\n\tdata->elem_cnt = 0;\n\tdata->elem_missed = 0;\n\n\treturn data;\n}"
  },
  {
    "function_name": "paths_from_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1896-1900",
    "snippet": "int paths_from_inode(u64 inum, struct inode_fs_paths *ipath)\n{\n\treturn iterate_irefs(inum, ipath->fs_root, ipath->btrfs_path,\n\t\t\t     inode_to_path, ipath);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_irefs",
          "args": [
            "inum",
            "ipath->fs_root",
            "ipath->btrfs_path",
            "inode_to_path",
            "ipath"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_irefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1830-1848",
          "snippet": "static int iterate_irefs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t struct btrfs_path *path, iterate_irefs_t *iterate,\n\t\t\t void *ctx)\n{\n\tint ret;\n\tint found_refs = 0;\n\n\tret = iterate_inode_refs(inum, fs_root, path, iterate, ctx);\n\tif (!ret)\n\t\t++found_refs;\n\telse if (ret != -ENOENT)\n\t\treturn ret;\n\n\tret = iterate_inode_extrefs(inum, fs_root, path, iterate, ctx);\n\tif (ret == -ENOENT && found_refs)\n\t\treturn 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int iterate_irefs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t struct btrfs_path *path, iterate_irefs_t *iterate,\n\t\t\t void *ctx)\n{\n\tint ret;\n\tint found_refs = 0;\n\n\tret = iterate_inode_refs(inum, fs_root, path, iterate, ctx);\n\tif (!ret)\n\t\t++found_refs;\n\telse if (ret != -ENOENT)\n\t\treturn ret;\n\n\tret = iterate_inode_extrefs(inum, fs_root, path, iterate, ctx);\n\tif (ret == -ENOENT && found_refs)\n\t\treturn 0;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint paths_from_inode(u64 inum, struct inode_fs_paths *ipath)\n{\n\treturn iterate_irefs(inum, ipath->fs_root, ipath->btrfs_path,\n\t\t\t     inode_to_path, ipath);\n}"
  },
  {
    "function_name": "inode_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1854-1884",
    "snippet": "static int inode_to_path(u64 inum, u32 name_len, unsigned long name_off,\n\t\t\t struct extent_buffer *eb, void *ctx)\n{\n\tstruct inode_fs_paths *ipath = ctx;\n\tchar *fspath;\n\tchar *fspath_min;\n\tint i = ipath->fspath->elem_cnt;\n\tconst int s_ptr = sizeof(char *);\n\tu32 bytes_left;\n\n\tbytes_left = ipath->fspath->bytes_left > s_ptr ?\n\t\t\t\t\tipath->fspath->bytes_left - s_ptr : 0;\n\n\tfspath_min = (char *)ipath->fspath->val + (i + 1) * s_ptr;\n\tfspath = btrfs_ref_to_path(ipath->fs_root, ipath->btrfs_path, name_len,\n\t\t\t\t   name_off, eb, inum, fspath_min, bytes_left);\n\tif (IS_ERR(fspath))\n\t\treturn PTR_ERR(fspath);\n\n\tif (fspath > fspath_min) {\n\t\tipath->fspath->val[i] = (u64)(unsigned long)fspath;\n\t\t++ipath->fspath->elem_cnt;\n\t\tipath->fspath->bytes_left = fspath - fspath_min;\n\t} else {\n\t\t++ipath->fspath->elem_missed;\n\t\tipath->fspath->bytes_missing += fspath_min - fspath;\n\t\tipath->fspath->bytes_left = 0;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fspath"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fspath"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_ref_to_path",
          "args": [
            "ipath->fs_root",
            "ipath->btrfs_path",
            "name_len",
            "name_off",
            "eb",
            "inum",
            "fspath_min",
            "bytes_left"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_ref_to_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1331-1398",
          "snippet": "char *btrfs_ref_to_path(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\t\tu32 name_len, unsigned long name_off,\n\t\t\tstruct extent_buffer *eb_in, u64 parent,\n\t\t\tchar *dest, u32 size)\n{\n\tint slot;\n\tu64 next_inum;\n\tint ret;\n\ts64 bytes_left = ((s64)size) - 1;\n\tstruct extent_buffer *eb = eb_in;\n\tstruct btrfs_key found_key;\n\tint leave_spinning = path->leave_spinning;\n\tstruct btrfs_inode_ref *iref;\n\n\tif (bytes_left >= 0)\n\t\tdest[bytes_left] = '\\0';\n\n\tpath->leave_spinning = 1;\n\twhile (1) {\n\t\tbytes_left -= name_len;\n\t\tif (bytes_left >= 0)\n\t\t\tread_extent_buffer(eb, dest + bytes_left,\n\t\t\t\t\t   name_off, name_len);\n\t\tif (eb != eb_in) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t}\n\t\tret = btrfs_find_item(fs_root, path, parent, 0,\n\t\t\t\tBTRFS_INODE_REF_KEY, &found_key);\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnext_inum = found_key.offset;\n\n\t\t/* regular exit ahead */\n\t\tif (parent == next_inum)\n\t\t\tbreak;\n\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\t/* make sure we can use eb after releasing the path */\n\t\tif (eb != eb_in) {\n\t\t\tatomic_inc(&eb->refs);\n\t\t\tbtrfs_tree_read_lock(eb);\n\t\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tiref = btrfs_item_ptr(eb, slot, struct btrfs_inode_ref);\n\n\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\tname_off = (unsigned long)(iref + 1);\n\n\t\tparent = next_inum;\n\t\t--bytes_left;\n\t\tif (bytes_left >= 0)\n\t\t\tdest[bytes_left] = '/';\n\t}\n\n\tbtrfs_release_path(path);\n\tpath->leave_spinning = leave_spinning;\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn dest + bytes_left;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nchar *btrfs_ref_to_path(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\t\tu32 name_len, unsigned long name_off,\n\t\t\tstruct extent_buffer *eb_in, u64 parent,\n\t\t\tchar *dest, u32 size)\n{\n\tint slot;\n\tu64 next_inum;\n\tint ret;\n\ts64 bytes_left = ((s64)size) - 1;\n\tstruct extent_buffer *eb = eb_in;\n\tstruct btrfs_key found_key;\n\tint leave_spinning = path->leave_spinning;\n\tstruct btrfs_inode_ref *iref;\n\n\tif (bytes_left >= 0)\n\t\tdest[bytes_left] = '\\0';\n\n\tpath->leave_spinning = 1;\n\twhile (1) {\n\t\tbytes_left -= name_len;\n\t\tif (bytes_left >= 0)\n\t\t\tread_extent_buffer(eb, dest + bytes_left,\n\t\t\t\t\t   name_off, name_len);\n\t\tif (eb != eb_in) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t}\n\t\tret = btrfs_find_item(fs_root, path, parent, 0,\n\t\t\t\tBTRFS_INODE_REF_KEY, &found_key);\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnext_inum = found_key.offset;\n\n\t\t/* regular exit ahead */\n\t\tif (parent == next_inum)\n\t\t\tbreak;\n\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\t/* make sure we can use eb after releasing the path */\n\t\tif (eb != eb_in) {\n\t\t\tatomic_inc(&eb->refs);\n\t\t\tbtrfs_tree_read_lock(eb);\n\t\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tiref = btrfs_item_ptr(eb, slot, struct btrfs_inode_ref);\n\n\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\tname_off = (unsigned long)(iref + 1);\n\n\t\tparent = next_inum;\n\t\t--bytes_left;\n\t\tif (bytes_left >= 0)\n\t\t\tdest[bytes_left] = '/';\n\t}\n\n\tbtrfs_release_path(path);\n\tpath->leave_spinning = leave_spinning;\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn dest + bytes_left;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int inode_to_path(u64 inum, u32 name_len, unsigned long name_off,\n\t\t\t struct extent_buffer *eb, void *ctx)\n{\n\tstruct inode_fs_paths *ipath = ctx;\n\tchar *fspath;\n\tchar *fspath_min;\n\tint i = ipath->fspath->elem_cnt;\n\tconst int s_ptr = sizeof(char *);\n\tu32 bytes_left;\n\n\tbytes_left = ipath->fspath->bytes_left > s_ptr ?\n\t\t\t\t\tipath->fspath->bytes_left - s_ptr : 0;\n\n\tfspath_min = (char *)ipath->fspath->val + (i + 1) * s_ptr;\n\tfspath = btrfs_ref_to_path(ipath->fs_root, ipath->btrfs_path, name_len,\n\t\t\t\t   name_off, eb, inum, fspath_min, bytes_left);\n\tif (IS_ERR(fspath))\n\t\treturn PTR_ERR(fspath);\n\n\tif (fspath > fspath_min) {\n\t\tipath->fspath->val[i] = (u64)(unsigned long)fspath;\n\t\t++ipath->fspath->elem_cnt;\n\t\tipath->fspath->bytes_left = fspath - fspath_min;\n\t} else {\n\t\t++ipath->fspath->elem_missed;\n\t\tipath->fspath->bytes_missing += fspath_min - fspath;\n\t\tipath->fspath->bytes_left = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "iterate_irefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1830-1848",
    "snippet": "static int iterate_irefs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t struct btrfs_path *path, iterate_irefs_t *iterate,\n\t\t\t void *ctx)\n{\n\tint ret;\n\tint found_refs = 0;\n\n\tret = iterate_inode_refs(inum, fs_root, path, iterate, ctx);\n\tif (!ret)\n\t\t++found_refs;\n\telse if (ret != -ENOENT)\n\t\treturn ret;\n\n\tret = iterate_inode_extrefs(inum, fs_root, path, iterate, ctx);\n\tif (ret == -ENOENT && found_refs)\n\t\treturn 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_inode_extrefs",
          "args": [
            "inum",
            "fs_root",
            "path",
            "iterate",
            "ctx"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_inode_extrefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1761-1828",
          "snippet": "static int iterate_inode_extrefs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t iterate_irefs_t *iterate, void *ctx)\n{\n\tint ret;\n\tint slot;\n\tu64 offset = 0;\n\tu64 parent;\n\tint found = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tu32 item_size;\n\tu32 cur_offset;\n\tunsigned long ptr;\n\n\twhile (1) {\n\t\tret = btrfs_find_one_extref(fs_root, inum, offset, path, &extref,\n\t\t\t\t\t    &offset);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\tret = found ? 0 : -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\t++found;\n\n\t\tslot = path->slots[0];\n\t\teb = btrfs_clone_extent_buffer(path->nodes[0]);\n\t\tif (!eb) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\textent_buffer_get(eb);\n\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\tbtrfs_release_path(path);\n\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, slot);\n\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\tcur_offset = 0;\n\n\t\twhile (cur_offset < item_size) {\n\t\t\tu32 name_len;\n\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur_offset);\n\t\t\tparent = btrfs_inode_extref_parent(eb, extref);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tret = iterate(parent, name_len,\n\t\t\t\t      (unsigned long)&extref->name, eb, ctx);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tcur_offset += btrfs_inode_extref_name_len(leaf, extref);\n\t\t\tcur_offset += sizeof(*extref);\n\t\t}\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\tfree_extent_buffer(eb);\n\n\t\toffset++;\n\t}\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int iterate_inode_extrefs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t iterate_irefs_t *iterate, void *ctx)\n{\n\tint ret;\n\tint slot;\n\tu64 offset = 0;\n\tu64 parent;\n\tint found = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tu32 item_size;\n\tu32 cur_offset;\n\tunsigned long ptr;\n\n\twhile (1) {\n\t\tret = btrfs_find_one_extref(fs_root, inum, offset, path, &extref,\n\t\t\t\t\t    &offset);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\tret = found ? 0 : -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\t++found;\n\n\t\tslot = path->slots[0];\n\t\teb = btrfs_clone_extent_buffer(path->nodes[0]);\n\t\tif (!eb) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\textent_buffer_get(eb);\n\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\tbtrfs_release_path(path);\n\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, slot);\n\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\tcur_offset = 0;\n\n\t\twhile (cur_offset < item_size) {\n\t\t\tu32 name_len;\n\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur_offset);\n\t\t\tparent = btrfs_inode_extref_parent(eb, extref);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tret = iterate(parent, name_len,\n\t\t\t\t      (unsigned long)&extref->name, eb, ctx);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tcur_offset += btrfs_inode_extref_name_len(leaf, extref);\n\t\t\tcur_offset += sizeof(*extref);\n\t\t}\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\tfree_extent_buffer(eb);\n\n\t\toffset++;\n\t}\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_inode_refs",
          "args": [
            "inum",
            "fs_root",
            "path",
            "iterate",
            "ctx"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_inode_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1695-1759",
          "snippet": "static int iterate_inode_refs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      iterate_irefs_t *iterate, void *ctx)\n{\n\tint ret = 0;\n\tint slot;\n\tu32 cur;\n\tu32 len;\n\tu32 name_len;\n\tu64 parent = 0;\n\tint found = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_key found_key;\n\n\twhile (!ret) {\n\t\tret = btrfs_find_item(fs_root, path, inum,\n\t\t\t\tparent ? parent + 1 : 0, BTRFS_INODE_REF_KEY,\n\t\t\t\t&found_key);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\tret = found ? 0 : -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\t++found;\n\n\t\tparent = found_key.offset;\n\t\tslot = path->slots[0];\n\t\teb = btrfs_clone_extent_buffer(path->nodes[0]);\n\t\tif (!eb) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\textent_buffer_get(eb);\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\tbtrfs_release_path(path);\n\n\t\titem = btrfs_item_nr(slot);\n\t\tiref = btrfs_item_ptr(eb, slot, struct btrfs_inode_ref);\n\n\t\tfor (cur = 0; cur < btrfs_item_size(eb, item); cur += len) {\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\t/* path must be released before calling iterate()! */\n\t\t\tpr_debug(\"following ref at offset %u for inode %llu in \"\n\t\t\t\t \"tree %llu\\n\", cur, found_key.objectid,\n\t\t\t\t fs_root->objectid);\n\t\t\tret = iterate(parent, name_len,\n\t\t\t\t      (unsigned long)(iref + 1), eb, ctx);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tlen = sizeof(*iref) + name_len;\n\t\t\tiref = (struct btrfs_inode_ref *)((char *)iref + len);\n\t\t}\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int iterate_inode_refs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      iterate_irefs_t *iterate, void *ctx)\n{\n\tint ret = 0;\n\tint slot;\n\tu32 cur;\n\tu32 len;\n\tu32 name_len;\n\tu64 parent = 0;\n\tint found = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_key found_key;\n\n\twhile (!ret) {\n\t\tret = btrfs_find_item(fs_root, path, inum,\n\t\t\t\tparent ? parent + 1 : 0, BTRFS_INODE_REF_KEY,\n\t\t\t\t&found_key);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\tret = found ? 0 : -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\t++found;\n\n\t\tparent = found_key.offset;\n\t\tslot = path->slots[0];\n\t\teb = btrfs_clone_extent_buffer(path->nodes[0]);\n\t\tif (!eb) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\textent_buffer_get(eb);\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\tbtrfs_release_path(path);\n\n\t\titem = btrfs_item_nr(slot);\n\t\tiref = btrfs_item_ptr(eb, slot, struct btrfs_inode_ref);\n\n\t\tfor (cur = 0; cur < btrfs_item_size(eb, item); cur += len) {\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\t/* path must be released before calling iterate()! */\n\t\t\tpr_debug(\"following ref at offset %u for inode %llu in \"\n\t\t\t\t \"tree %llu\\n\", cur, found_key.objectid,\n\t\t\t\t fs_root->objectid);\n\t\t\tret = iterate(parent, name_len,\n\t\t\t\t      (unsigned long)(iref + 1), eb, ctx);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tlen = sizeof(*iref) + name_len;\n\t\t\tiref = (struct btrfs_inode_ref *)((char *)iref + len);\n\t\t}\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int iterate_irefs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t struct btrfs_path *path, iterate_irefs_t *iterate,\n\t\t\t void *ctx)\n{\n\tint ret;\n\tint found_refs = 0;\n\n\tret = iterate_inode_refs(inum, fs_root, path, iterate, ctx);\n\tif (!ret)\n\t\t++found_refs;\n\telse if (ret != -ENOENT)\n\t\treturn ret;\n\n\tret = iterate_inode_extrefs(inum, fs_root, path, iterate, ctx);\n\tif (ret == -ENOENT && found_refs)\n\t\treturn 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iterate_inode_extrefs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1761-1828",
    "snippet": "static int iterate_inode_extrefs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t iterate_irefs_t *iterate, void *ctx)\n{\n\tint ret;\n\tint slot;\n\tu64 offset = 0;\n\tu64 parent;\n\tint found = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tu32 item_size;\n\tu32 cur_offset;\n\tunsigned long ptr;\n\n\twhile (1) {\n\t\tret = btrfs_find_one_extref(fs_root, inum, offset, path, &extref,\n\t\t\t\t\t    &offset);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\tret = found ? 0 : -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\t++found;\n\n\t\tslot = path->slots[0];\n\t\teb = btrfs_clone_extent_buffer(path->nodes[0]);\n\t\tif (!eb) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\textent_buffer_get(eb);\n\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\tbtrfs_release_path(path);\n\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, slot);\n\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\tcur_offset = 0;\n\n\t\twhile (cur_offset < item_size) {\n\t\t\tu32 name_len;\n\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur_offset);\n\t\t\tparent = btrfs_inode_extref_parent(eb, extref);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tret = iterate(parent, name_len,\n\t\t\t\t      (unsigned long)&extref->name, eb, ctx);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tcur_offset += btrfs_inode_extref_name_len(leaf, extref);\n\t\t\tcur_offset += sizeof(*extref);\n\t\t}\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\tfree_extent_buffer(eb);\n\n\t\toffset++;\n\t}\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_unlock_blocking",
          "args": [
            "eb"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_name_len",
          "args": [
            "leaf",
            "extref"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate",
          "args": [
            "parent",
            "name_len",
            "(unsigned long)&extref->name",
            "eb",
            "ctx"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_irefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1830-1848",
          "snippet": "static int iterate_irefs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t struct btrfs_path *path, iterate_irefs_t *iterate,\n\t\t\t void *ctx)\n{\n\tint ret;\n\tint found_refs = 0;\n\n\tret = iterate_inode_refs(inum, fs_root, path, iterate, ctx);\n\tif (!ret)\n\t\t++found_refs;\n\telse if (ret != -ENOENT)\n\t\treturn ret;\n\n\tret = iterate_inode_extrefs(inum, fs_root, path, iterate, ctx);\n\tif (ret == -ENOENT && found_refs)\n\t\treturn 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int iterate_irefs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t struct btrfs_path *path, iterate_irefs_t *iterate,\n\t\t\t void *ctx)\n{\n\tint ret;\n\tint found_refs = 0;\n\n\tret = iterate_inode_refs(inum, fs_root, path, iterate, ctx);\n\tif (!ret)\n\t\t++found_refs;\n\telse if (ret != -ENOENT)\n\t\treturn ret;\n\n\tret = iterate_inode_extrefs(inum, fs_root, path, iterate, ctx);\n\tif (ret == -ENOENT && found_refs)\n\t\treturn 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_name_len",
          "args": [
            "eb",
            "extref"
          ],
          "line": 1810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_extref_parent",
          "args": [
            "eb",
            "extref"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking_rw",
          "args": [
            "eb",
            "BTRFS_READ_LOCK"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "34-60",
          "snippet": "void btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_lock",
          "args": [
            "eb"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_lock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "135-148",
          "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "eb"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clone_extent_buffer",
          "args": [
            "path->nodes[0]"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clone_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4642-4670",
          "snippet": "struct extent_buffer *btrfs_clone_extent_buffer(struct extent_buffer *src)\n{\n\tunsigned long i;\n\tstruct page *p;\n\tstruct extent_buffer *new;\n\tunsigned long num_pages = num_extent_pages(src->start, src->len);\n\n\tnew = __alloc_extent_buffer(src->fs_info, src->start, src->len);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tp = alloc_page(GFP_NOFS);\n\t\tif (!p) {\n\t\t\tbtrfs_release_extent_buffer(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tattach_extent_buffer_page(new, p);\n\t\tWARN_ON(PageDirty(p));\n\t\tSetPageUptodate(p);\n\t\tnew->pages[i] = p;\n\t}\n\n\tcopy_extent_buffer(new, src, 0, 0, src->len);\n\tset_bit(EXTENT_BUFFER_UPTODATE, &new->bflags);\n\tset_bit(EXTENT_BUFFER_DUMMY, &new->bflags);\n\n\treturn new;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *btrfs_clone_extent_buffer(struct extent_buffer *src)\n{\n\tunsigned long i;\n\tstruct page *p;\n\tstruct extent_buffer *new;\n\tunsigned long num_pages = num_extent_pages(src->start, src->len);\n\n\tnew = __alloc_extent_buffer(src->fs_info, src->start, src->len);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tp = alloc_page(GFP_NOFS);\n\t\tif (!p) {\n\t\t\tbtrfs_release_extent_buffer(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tattach_extent_buffer_page(new, p);\n\t\tWARN_ON(PageDirty(p));\n\t\tSetPageUptodate(p);\n\t\tnew->pages[i] = p;\n\t}\n\n\tcopy_extent_buffer(new, src, 0, 0, src->len);\n\tset_bit(EXTENT_BUFFER_UPTODATE, &new->bflags);\n\tset_bit(EXTENT_BUFFER_DUMMY, &new->bflags);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_one_extref",
          "args": [
            "fs_root",
            "inum",
            "offset",
            "path",
            "&extref",
            "&offset"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_one_extref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1249-1315",
          "snippet": "int btrfs_find_one_extref(struct btrfs_root *root, u64 inode_objectid,\n\t\t\t  u64 start_off, struct btrfs_path *path,\n\t\t\t  struct btrfs_inode_extref **ret_extref,\n\t\t\t  u64 *found_off)\n{\n\tint ret, slot;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tkey.objectid = inode_objectid;\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = start_off;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\t/*\n\t\t\t * If the item at offset is not found,\n\t\t\t * btrfs_search_slot will point us to the slot\n\t\t\t * where it should be inserted. In our case\n\t\t\t * that will be the slot directly before the\n\t\t\t * next INODE_REF_KEY_V2 item. In the case\n\t\t\t * that we're pointing to the last slot in a\n\t\t\t * leaf, we must move one leaf over.\n\t\t\t */\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret) {\n\t\t\t\tif (ret >= 1)\n\t\t\t\t\tret = -ENOENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\t/*\n\t\t * Check that we're still looking at an extended ref key for\n\t\t * this particular objectid. If we have different\n\t\t * objectid or type then there are no more to be found\n\t\t * in the tree and we can exit.\n\t\t */\n\t\tret = -ENOENT;\n\t\tif (found_key.objectid != inode_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\tret = 0;\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\textref = (struct btrfs_inode_extref *)ptr;\n\t\t*ret_extref = extref;\n\t\tif (found_off)\n\t\t\t*found_off = found_key.offset;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint btrfs_find_one_extref(struct btrfs_root *root, u64 inode_objectid,\n\t\t\t  u64 start_off, struct btrfs_path *path,\n\t\t\t  struct btrfs_inode_extref **ret_extref,\n\t\t\t  u64 *found_off)\n{\n\tint ret, slot;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tkey.objectid = inode_objectid;\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = start_off;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\t/*\n\t\t\t * If the item at offset is not found,\n\t\t\t * btrfs_search_slot will point us to the slot\n\t\t\t * where it should be inserted. In our case\n\t\t\t * that will be the slot directly before the\n\t\t\t * next INODE_REF_KEY_V2 item. In the case\n\t\t\t * that we're pointing to the last slot in a\n\t\t\t * leaf, we must move one leaf over.\n\t\t\t */\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret) {\n\t\t\t\tif (ret >= 1)\n\t\t\t\t\tret = -ENOENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\t/*\n\t\t * Check that we're still looking at an extended ref key for\n\t\t * this particular objectid. If we have different\n\t\t * objectid or type then there are no more to be found\n\t\t * in the tree and we can exit.\n\t\t */\n\t\tret = -ENOENT;\n\t\tif (found_key.objectid != inode_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\tret = 0;\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\textref = (struct btrfs_inode_extref *)ptr;\n\t\t*ret_extref = extref;\n\t\tif (found_off)\n\t\t\t*found_off = found_key.offset;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int iterate_inode_extrefs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t\t struct btrfs_path *path,\n\t\t\t\t iterate_irefs_t *iterate, void *ctx)\n{\n\tint ret;\n\tint slot;\n\tu64 offset = 0;\n\tu64 parent;\n\tint found = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tu32 item_size;\n\tu32 cur_offset;\n\tunsigned long ptr;\n\n\twhile (1) {\n\t\tret = btrfs_find_one_extref(fs_root, inum, offset, path, &extref,\n\t\t\t\t\t    &offset);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\tret = found ? 0 : -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\t++found;\n\n\t\tslot = path->slots[0];\n\t\teb = btrfs_clone_extent_buffer(path->nodes[0]);\n\t\tif (!eb) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\textent_buffer_get(eb);\n\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\tbtrfs_release_path(path);\n\n\t\tleaf = path->nodes[0];\n\t\titem_size = btrfs_item_size_nr(leaf, slot);\n\t\tptr = btrfs_item_ptr_offset(leaf, slot);\n\t\tcur_offset = 0;\n\n\t\twhile (cur_offset < item_size) {\n\t\t\tu32 name_len;\n\n\t\t\textref = (struct btrfs_inode_extref *)(ptr + cur_offset);\n\t\t\tparent = btrfs_inode_extref_parent(eb, extref);\n\t\t\tname_len = btrfs_inode_extref_name_len(eb, extref);\n\t\t\tret = iterate(parent, name_len,\n\t\t\t\t      (unsigned long)&extref->name, eb, ctx);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tcur_offset += btrfs_inode_extref_name_len(leaf, extref);\n\t\t\tcur_offset += sizeof(*extref);\n\t\t}\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\tfree_extent_buffer(eb);\n\n\t\toffset++;\n\t}\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iterate_inode_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1695-1759",
    "snippet": "static int iterate_inode_refs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      iterate_irefs_t *iterate, void *ctx)\n{\n\tint ret = 0;\n\tint slot;\n\tu32 cur;\n\tu32 len;\n\tu32 name_len;\n\tu64 parent = 0;\n\tint found = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_key found_key;\n\n\twhile (!ret) {\n\t\tret = btrfs_find_item(fs_root, path, inum,\n\t\t\t\tparent ? parent + 1 : 0, BTRFS_INODE_REF_KEY,\n\t\t\t\t&found_key);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\tret = found ? 0 : -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\t++found;\n\n\t\tparent = found_key.offset;\n\t\tslot = path->slots[0];\n\t\teb = btrfs_clone_extent_buffer(path->nodes[0]);\n\t\tif (!eb) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\textent_buffer_get(eb);\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\tbtrfs_release_path(path);\n\n\t\titem = btrfs_item_nr(slot);\n\t\tiref = btrfs_item_ptr(eb, slot, struct btrfs_inode_ref);\n\n\t\tfor (cur = 0; cur < btrfs_item_size(eb, item); cur += len) {\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\t/* path must be released before calling iterate()! */\n\t\t\tpr_debug(\"following ref at offset %u for inode %llu in \"\n\t\t\t\t \"tree %llu\\n\", cur, found_key.objectid,\n\t\t\t\t fs_root->objectid);\n\t\t\tret = iterate(parent, name_len,\n\t\t\t\t      (unsigned long)(iref + 1), eb, ctx);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tlen = sizeof(*iref) + name_len;\n\t\t\tiref = (struct btrfs_inode_ref *)((char *)iref + len);\n\t\t}\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_unlock_blocking",
          "args": [
            "eb"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate",
          "args": [
            "parent",
            "name_len",
            "(unsigned long)(iref + 1)",
            "eb",
            "ctx"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_irefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1830-1848",
          "snippet": "static int iterate_irefs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t struct btrfs_path *path, iterate_irefs_t *iterate,\n\t\t\t void *ctx)\n{\n\tint ret;\n\tint found_refs = 0;\n\n\tret = iterate_inode_refs(inum, fs_root, path, iterate, ctx);\n\tif (!ret)\n\t\t++found_refs;\n\telse if (ret != -ENOENT)\n\t\treturn ret;\n\n\tret = iterate_inode_extrefs(inum, fs_root, path, iterate, ctx);\n\tif (ret == -ENOENT && found_refs)\n\t\treturn 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int iterate_irefs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t struct btrfs_path *path, iterate_irefs_t *iterate,\n\t\t\t void *ctx)\n{\n\tint ret;\n\tint found_refs = 0;\n\n\tret = iterate_inode_refs(inum, fs_root, path, iterate, ctx);\n\tif (!ret)\n\t\t++found_refs;\n\telse if (ret != -ENOENT)\n\t\treturn ret;\n\n\tret = iterate_inode_extrefs(inum, fs_root, path, iterate, ctx);\n\tif (ret == -ENOENT && found_refs)\n\t\treturn 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"following ref at offset %u for inode %llu in \"\n\t\t\t\t \"tree %llu\\n\"",
            "cur",
            "found_key.objectid",
            "fs_root->objectid"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_inode_ref_name_len",
          "args": [
            "eb",
            "iref"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size",
          "args": [
            "eb",
            "item"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_inode_ref"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_nr",
          "args": [
            "slot"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2628-2631",
          "snippet": "static inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_item *btrfs_item_nr(int nr)\n{\n\treturn (struct btrfs_item *)btrfs_item_nr_offset(nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking_rw",
          "args": [
            "eb",
            "BTRFS_READ_LOCK"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "34-60",
          "snippet": "void btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_lock",
          "args": [
            "eb"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_lock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "135-148",
          "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_get",
          "args": [
            "eb"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.h",
          "lines": "287-290",
          "snippet": "static inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}",
          "includes": [
            "#include <linux/rbtree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n\nstatic inline void extent_buffer_get(struct extent_buffer *eb)\n{\n\tatomic_inc(&eb->refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clone_extent_buffer",
          "args": [
            "path->nodes[0]"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_clone_extent_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "4642-4670",
          "snippet": "struct extent_buffer *btrfs_clone_extent_buffer(struct extent_buffer *src)\n{\n\tunsigned long i;\n\tstruct page *p;\n\tstruct extent_buffer *new;\n\tunsigned long num_pages = num_extent_pages(src->start, src->len);\n\n\tnew = __alloc_extent_buffer(src->fs_info, src->start, src->len);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tp = alloc_page(GFP_NOFS);\n\t\tif (!p) {\n\t\t\tbtrfs_release_extent_buffer(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tattach_extent_buffer_page(new, p);\n\t\tWARN_ON(PageDirty(p));\n\t\tSetPageUptodate(p);\n\t\tnew->pages[i] = p;\n\t}\n\n\tcopy_extent_buffer(new, src, 0, 0, src->len);\n\tset_bit(EXTENT_BUFFER_UPTODATE, &new->bflags);\n\tset_bit(EXTENT_BUFFER_DUMMY, &new->bflags);\n\n\treturn new;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstruct extent_buffer *btrfs_clone_extent_buffer(struct extent_buffer *src)\n{\n\tunsigned long i;\n\tstruct page *p;\n\tstruct extent_buffer *new;\n\tunsigned long num_pages = num_extent_pages(src->start, src->len);\n\n\tnew = __alloc_extent_buffer(src->fs_info, src->start, src->len);\n\tif (new == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_pages; i++) {\n\t\tp = alloc_page(GFP_NOFS);\n\t\tif (!p) {\n\t\t\tbtrfs_release_extent_buffer(new);\n\t\t\treturn NULL;\n\t\t}\n\t\tattach_extent_buffer_page(new, p);\n\t\tWARN_ON(PageDirty(p));\n\t\tSetPageUptodate(p);\n\t\tnew->pages[i] = p;\n\t}\n\n\tcopy_extent_buffer(new, src, 0, 0, src->len);\n\tset_bit(EXTENT_BUFFER_UPTODATE, &new->bflags);\n\tset_bit(EXTENT_BUFFER_DUMMY, &new->bflags);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_find_item",
          "args": [
            "fs_root",
            "path",
            "inum",
            "parent ? parent + 1 : 0",
            "BTRFS_INODE_REF_KEY",
            "&found_key"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2617-2650",
          "snippet": "int btrfs_find_item(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\tu64 iobjectid, u64 ioff, u8 key_type,\n\t\tstruct btrfs_key *found_key)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\n\tASSERT(path);\n\tASSERT(found_key);\n\n\tkey.type = key_type;\n\tkey.objectid = iobjectid;\n\tkey.offset = ioff;\n\n\tret = btrfs_search_slot(NULL, fs_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\teb = path->nodes[0];\n\tif (ret && path->slots[0] >= btrfs_header_nritems(eb)) {\n\t\tret = btrfs_next_leaf(fs_root, path);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\teb = path->nodes[0];\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, found_key, path->slots[0]);\n\tif (found_key->type != key.type ||\n\t\t\tfound_key->objectid != key.objectid)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nint btrfs_find_item(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\tu64 iobjectid, u64 ioff, u8 key_type,\n\t\tstruct btrfs_key *found_key)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\n\tASSERT(path);\n\tASSERT(found_key);\n\n\tkey.type = key_type;\n\tkey.objectid = iobjectid;\n\tkey.offset = ioff;\n\n\tret = btrfs_search_slot(NULL, fs_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\teb = path->nodes[0];\n\tif (ret && path->slots[0] >= btrfs_header_nritems(eb)) {\n\t\tret = btrfs_next_leaf(fs_root, path);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\teb = path->nodes[0];\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, found_key, path->slots[0]);\n\tif (found_key->type != key.type ||\n\t\t\tfound_key->objectid != key.objectid)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int iterate_inode_refs(u64 inum, struct btrfs_root *fs_root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      iterate_irefs_t *iterate, void *ctx)\n{\n\tint ret = 0;\n\tint slot;\n\tu32 cur;\n\tu32 len;\n\tu32 name_len;\n\tu64 parent = 0;\n\tint found = 0;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_item *item;\n\tstruct btrfs_inode_ref *iref;\n\tstruct btrfs_key found_key;\n\n\twhile (!ret) {\n\t\tret = btrfs_find_item(fs_root, path, inum,\n\t\t\t\tparent ? parent + 1 : 0, BTRFS_INODE_REF_KEY,\n\t\t\t\t&found_key);\n\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\tret = found ? 0 : -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\t++found;\n\n\t\tparent = found_key.offset;\n\t\tslot = path->slots[0];\n\t\teb = btrfs_clone_extent_buffer(path->nodes[0]);\n\t\tif (!eb) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\textent_buffer_get(eb);\n\t\tbtrfs_tree_read_lock(eb);\n\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\tbtrfs_release_path(path);\n\n\t\titem = btrfs_item_nr(slot);\n\t\tiref = btrfs_item_ptr(eb, slot, struct btrfs_inode_ref);\n\n\t\tfor (cur = 0; cur < btrfs_item_size(eb, item); cur += len) {\n\t\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\t\t/* path must be released before calling iterate()! */\n\t\t\tpr_debug(\"following ref at offset %u for inode %llu in \"\n\t\t\t\t \"tree %llu\\n\", cur, found_key.objectid,\n\t\t\t\t fs_root->objectid);\n\t\t\tret = iterate(parent, name_len,\n\t\t\t\t      (unsigned long)(iref + 1), eb, ctx);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tlen = sizeof(*iref) + name_len;\n\t\t\tiref = (struct btrfs_inode_ref *)((char *)iref + len);\n\t\t}\n\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\n\tbtrfs_release_path(path);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iterate_inodes_from_logical",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1667-1690",
    "snippet": "int iterate_inodes_from_logical(u64 logical, struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_key found_key;\n\tint search_commit_root = path->search_commit_root;\n\n\tret = extent_from_logical(fs_info, logical, path, &found_key, &flags);\n\tbtrfs_release_path(path);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\treturn -EINVAL;\n\n\textent_item_pos = logical - found_key.objectid;\n\tret = iterate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t\textent_item_pos, search_commit_root,\n\t\t\t\t\titerate, ctx);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iterate_extent_inodes",
          "args": [
            "fs_info",
            "found_key.objectid",
            "extent_item_pos",
            "search_commit_root",
            "iterate",
            "ctx"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_extent_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1602-1665",
          "snippet": "int iterate_extent_inodes(struct btrfs_fs_info *fs_info,\n\t\t\t\tu64 extent_item_objectid, u64 extent_item_pos,\n\t\t\t\tint search_commit_root,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct ulist *refs = NULL;\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *ref_node = NULL;\n\tstruct ulist_node *root_node = NULL;\n\tstruct seq_list tree_mod_seq_elem = {};\n\tstruct ulist_iterator ref_uiter;\n\tstruct ulist_iterator root_uiter;\n\n\tpr_debug(\"resolving all inodes for extent %llu\\n\",\n\t\t\textent_item_objectid);\n\n\tif (!search_commit_root) {\n\t\ttrans = btrfs_join_transaction(fs_info->extent_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t} else {\n\t\tdown_read(&fs_info->commit_root_sem);\n\t}\n\n\tret = btrfs_find_all_leafs(trans, fs_info, extent_item_objectid,\n\t\t\t\t   tree_mod_seq_elem.seq, &refs,\n\t\t\t\t   &extent_item_pos);\n\tif (ret)\n\t\tgoto out;\n\n\tULIST_ITER_INIT(&ref_uiter);\n\twhile (!ret && (ref_node = ulist_next(refs, &ref_uiter))) {\n\t\tret = __btrfs_find_all_roots(trans, fs_info, ref_node->val,\n\t\t\t\t\t     tree_mod_seq_elem.seq, &roots);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tULIST_ITER_INIT(&root_uiter);\n\t\twhile (!ret && (root_node = ulist_next(roots, &root_uiter))) {\n\t\t\tpr_debug(\"root %llu references leaf %llu, data list \"\n\t\t\t\t \"%#llx\\n\", root_node->val, ref_node->val,\n\t\t\t\t ref_node->aux);\n\t\t\tret = iterate_leaf_refs((struct extent_inode_elem *)\n\t\t\t\t\t\t(uintptr_t)ref_node->aux,\n\t\t\t\t\t\troot_node->val,\n\t\t\t\t\t\textent_item_objectid,\n\t\t\t\t\t\titerate, ctx);\n\t\t}\n\t\tulist_free(roots);\n\t}\n\n\tfree_leaf_list(refs);\nout:\n\tif (!search_commit_root) {\n\t\tbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t\tbtrfs_end_transaction(trans, fs_info->extent_root);\n\t} else {\n\t\tup_read(&fs_info->commit_root_sem);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint iterate_extent_inodes(struct btrfs_fs_info *fs_info,\n\t\t\t\tu64 extent_item_objectid, u64 extent_item_pos,\n\t\t\t\tint search_commit_root,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct ulist *refs = NULL;\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *ref_node = NULL;\n\tstruct ulist_node *root_node = NULL;\n\tstruct seq_list tree_mod_seq_elem = {};\n\tstruct ulist_iterator ref_uiter;\n\tstruct ulist_iterator root_uiter;\n\n\tpr_debug(\"resolving all inodes for extent %llu\\n\",\n\t\t\textent_item_objectid);\n\n\tif (!search_commit_root) {\n\t\ttrans = btrfs_join_transaction(fs_info->extent_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t} else {\n\t\tdown_read(&fs_info->commit_root_sem);\n\t}\n\n\tret = btrfs_find_all_leafs(trans, fs_info, extent_item_objectid,\n\t\t\t\t   tree_mod_seq_elem.seq, &refs,\n\t\t\t\t   &extent_item_pos);\n\tif (ret)\n\t\tgoto out;\n\n\tULIST_ITER_INIT(&ref_uiter);\n\twhile (!ret && (ref_node = ulist_next(refs, &ref_uiter))) {\n\t\tret = __btrfs_find_all_roots(trans, fs_info, ref_node->val,\n\t\t\t\t\t     tree_mod_seq_elem.seq, &roots);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tULIST_ITER_INIT(&root_uiter);\n\t\twhile (!ret && (root_node = ulist_next(roots, &root_uiter))) {\n\t\t\tpr_debug(\"root %llu references leaf %llu, data list \"\n\t\t\t\t \"%#llx\\n\", root_node->val, ref_node->val,\n\t\t\t\t ref_node->aux);\n\t\t\tret = iterate_leaf_refs((struct extent_inode_elem *)\n\t\t\t\t\t\t(uintptr_t)ref_node->aux,\n\t\t\t\t\t\troot_node->val,\n\t\t\t\t\t\textent_item_objectid,\n\t\t\t\t\t\titerate, ctx);\n\t\t}\n\t\tulist_free(roots);\n\t}\n\n\tfree_leaf_list(refs);\nout:\n\tif (!search_commit_root) {\n\t\tbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t\tbtrfs_end_transaction(trans, fs_info->extent_root);\n\t} else {\n\t\tup_read(&fs_info->commit_root_sem);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_from_logical",
          "args": [
            "fs_info",
            "logical",
            "path",
            "&found_key",
            "&flags"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "extent_from_logical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1405-1470",
          "snippet": "int extent_from_logical(struct btrfs_fs_info *fs_info, u64 logical,\n\t\t\tstruct btrfs_path *path, struct btrfs_key *found_key,\n\t\t\tu64 *flags_ret)\n{\n\tint ret;\n\tu64 flags;\n\tu64 size = 0;\n\tu32 item_size;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_key key;\n\n\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.objectid = logical;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_previous_extent_item(fs_info->extent_root, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\tbtrfs_item_key_to_cpu(path->nodes[0], found_key, path->slots[0]);\n\tif (found_key->type == BTRFS_METADATA_ITEM_KEY)\n\t\tsize = fs_info->extent_root->nodesize;\n\telse if (found_key->type == BTRFS_EXTENT_ITEM_KEY)\n\t\tsize = found_key->offset;\n\n\tif (found_key->objectid > logical ||\n\t    found_key->objectid + size <= logical) {\n\t\tpr_debug(\"logical %llu is not within any extent\\n\", logical);\n\t\treturn -ENOENT;\n\t}\n\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\tBUG_ON(item_size < sizeof(*ei));\n\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(eb, ei);\n\n\tpr_debug(\"logical %llu is at position %llu within the extent (%llu \"\n\t\t \"EXTENT_ITEM %llu) flags %#llx size %u\\n\",\n\t\t logical, logical - found_key->objectid, found_key->objectid,\n\t\t found_key->offset, flags, item_size);\n\n\tWARN_ON(!flags_ret);\n\tif (flags_ret) {\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\telse if (flags & BTRFS_EXTENT_FLAG_DATA)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_DATA;\n\t\telse\n\t\t\tBUG_ON(1);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint extent_from_logical(struct btrfs_fs_info *fs_info, u64 logical,\n\t\t\tstruct btrfs_path *path, struct btrfs_key *found_key,\n\t\t\tu64 *flags_ret)\n{\n\tint ret;\n\tu64 flags;\n\tu64 size = 0;\n\tu32 item_size;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_key key;\n\n\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.objectid = logical;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_previous_extent_item(fs_info->extent_root, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\tbtrfs_item_key_to_cpu(path->nodes[0], found_key, path->slots[0]);\n\tif (found_key->type == BTRFS_METADATA_ITEM_KEY)\n\t\tsize = fs_info->extent_root->nodesize;\n\telse if (found_key->type == BTRFS_EXTENT_ITEM_KEY)\n\t\tsize = found_key->offset;\n\n\tif (found_key->objectid > logical ||\n\t    found_key->objectid + size <= logical) {\n\t\tpr_debug(\"logical %llu is not within any extent\\n\", logical);\n\t\treturn -ENOENT;\n\t}\n\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\tBUG_ON(item_size < sizeof(*ei));\n\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(eb, ei);\n\n\tpr_debug(\"logical %llu is at position %llu within the extent (%llu \"\n\t\t \"EXTENT_ITEM %llu) flags %#llx size %u\\n\",\n\t\t logical, logical - found_key->objectid, found_key->objectid,\n\t\t found_key->offset, flags, item_size);\n\n\tWARN_ON(!flags_ret);\n\tif (flags_ret) {\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\telse if (flags & BTRFS_EXTENT_FLAG_DATA)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_DATA;\n\t\telse\n\t\t\tBUG_ON(1);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint iterate_inodes_from_logical(u64 logical, struct btrfs_fs_info *fs_info,\n\t\t\t\tstruct btrfs_path *path,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tu64 extent_item_pos;\n\tu64 flags = 0;\n\tstruct btrfs_key found_key;\n\tint search_commit_root = path->search_commit_root;\n\n\tret = extent_from_logical(fs_info, logical, path, &found_key, &flags);\n\tbtrfs_release_path(path);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\treturn -EINVAL;\n\n\textent_item_pos = logical - found_key.objectid;\n\tret = iterate_extent_inodes(fs_info, found_key.objectid,\n\t\t\t\t\textent_item_pos, search_commit_root,\n\t\t\t\t\titerate, ctx);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iterate_extent_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1602-1665",
    "snippet": "int iterate_extent_inodes(struct btrfs_fs_info *fs_info,\n\t\t\t\tu64 extent_item_objectid, u64 extent_item_pos,\n\t\t\t\tint search_commit_root,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct ulist *refs = NULL;\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *ref_node = NULL;\n\tstruct ulist_node *root_node = NULL;\n\tstruct seq_list tree_mod_seq_elem = {};\n\tstruct ulist_iterator ref_uiter;\n\tstruct ulist_iterator root_uiter;\n\n\tpr_debug(\"resolving all inodes for extent %llu\\n\",\n\t\t\textent_item_objectid);\n\n\tif (!search_commit_root) {\n\t\ttrans = btrfs_join_transaction(fs_info->extent_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t} else {\n\t\tdown_read(&fs_info->commit_root_sem);\n\t}\n\n\tret = btrfs_find_all_leafs(trans, fs_info, extent_item_objectid,\n\t\t\t\t   tree_mod_seq_elem.seq, &refs,\n\t\t\t\t   &extent_item_pos);\n\tif (ret)\n\t\tgoto out;\n\n\tULIST_ITER_INIT(&ref_uiter);\n\twhile (!ret && (ref_node = ulist_next(refs, &ref_uiter))) {\n\t\tret = __btrfs_find_all_roots(trans, fs_info, ref_node->val,\n\t\t\t\t\t     tree_mod_seq_elem.seq, &roots);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tULIST_ITER_INIT(&root_uiter);\n\t\twhile (!ret && (root_node = ulist_next(roots, &root_uiter))) {\n\t\t\tpr_debug(\"root %llu references leaf %llu, data list \"\n\t\t\t\t \"%#llx\\n\", root_node->val, ref_node->val,\n\t\t\t\t ref_node->aux);\n\t\t\tret = iterate_leaf_refs((struct extent_inode_elem *)\n\t\t\t\t\t\t(uintptr_t)ref_node->aux,\n\t\t\t\t\t\troot_node->val,\n\t\t\t\t\t\textent_item_objectid,\n\t\t\t\t\t\titerate, ctx);\n\t\t}\n\t\tulist_free(roots);\n\t}\n\n\tfree_leaf_list(refs);\nout:\n\tif (!search_commit_root) {\n\t\tbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t\tbtrfs_end_transaction(trans, fs_info->extent_root);\n\t} else {\n\t\tup_read(&fs_info->commit_root_sem);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fs_info->commit_root_sem"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_end_transaction",
          "args": [
            "trans",
            "fs_info->extent_root"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_transaction_throttle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "846-850",
          "snippet": "int btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_end_transaction_throttle(struct btrfs_trans_handle *trans,\n\t\t\t\t   struct btrfs_root *root)\n{\n\treturn __btrfs_end_transaction(trans, root, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_put_tree_mod_seq",
          "args": [
            "fs_info",
            "&tree_mod_seq_elem"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "386-434",
          "snippet": "void btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_leaf_list",
          "args": [
            "refs"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "free_leaf_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1089-1105",
          "snippet": "static void free_leaf_list(struct ulist *blocks)\n{\n\tstruct ulist_node *node = NULL;\n\tstruct extent_inode_elem *eie;\n\tstruct ulist_iterator uiter;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((node = ulist_next(blocks, &uiter))) {\n\t\tif (!node->aux)\n\t\t\tcontinue;\n\t\teie = (struct extent_inode_elem *)(uintptr_t)node->aux;\n\t\tfree_inode_elem_list(eie);\n\t\tnode->aux = 0;\n\t}\n\n\tulist_free(blocks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic void free_leaf_list(struct ulist *blocks)\n{\n\tstruct ulist_node *node = NULL;\n\tstruct extent_inode_elem *eie;\n\tstruct ulist_iterator uiter;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((node = ulist_next(blocks, &uiter))) {\n\t\tif (!node->aux)\n\t\t\tcontinue;\n\t\teie = (struct extent_inode_elem *)(uintptr_t)node->aux;\n\t\tfree_inode_elem_list(eie);\n\t\tnode->aux = 0;\n\t}\n\n\tulist_free(blocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "roots"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterate_leaf_refs",
          "args": [
            "(struct extent_inode_elem *)\n\t\t\t\t\t\t(uintptr_t)ref_node->aux",
            "root_node->val",
            "extent_item_objectid",
            "iterate",
            "ctx"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_leaf_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1575-1595",
          "snippet": "static int iterate_leaf_refs(struct extent_inode_elem *inode_list,\n\t\t\t\tu64 root, u64 extent_item_objectid,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tstruct extent_inode_elem *eie;\n\tint ret = 0;\n\n\tfor (eie = inode_list; eie; eie = eie->next) {\n\t\tpr_debug(\"ref for %llu resolved, key (%llu EXTEND_DATA %llu), \"\n\t\t\t \"root %llu\\n\", extent_item_objectid,\n\t\t\t eie->inum, eie->offset, root);\n\t\tret = iterate(eie->inum, eie->offset, root, ctx);\n\t\tif (ret) {\n\t\t\tpr_debug(\"stopping iteration for %llu due to ret=%d\\n\",\n\t\t\t\t extent_item_objectid, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int iterate_leaf_refs(struct extent_inode_elem *inode_list,\n\t\t\t\tu64 root, u64 extent_item_objectid,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tstruct extent_inode_elem *eie;\n\tint ret = 0;\n\n\tfor (eie = inode_list; eie; eie = eie->next) {\n\t\tpr_debug(\"ref for %llu resolved, key (%llu EXTEND_DATA %llu), \"\n\t\t\t \"root %llu\\n\", extent_item_objectid,\n\t\t\t eie->inum, eie->offset, root);\n\t\tret = iterate(eie->inum, eie->offset, root, ctx);\n\t\tif (ret) {\n\t\t\tpr_debug(\"stopping iteration for %llu due to ret=%d\\n\",\n\t\t\t\t extent_item_objectid, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"root %llu references leaf %llu, data list \"\n\t\t\t\t \"%#llx\\n\"",
            "root_node->val",
            "ref_node->val",
            "ref_node->aux"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "roots",
            "&root_uiter"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&root_uiter"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_find_all_roots",
          "args": [
            "trans",
            "fs_info",
            "ref_node->val",
            "tree_mod_seq_elem.seq",
            "&roots"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_find_all_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1149-1185",
          "snippet": "static int __btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t\t  u64 time_seq, struct ulist **roots)\n{\n\tstruct ulist *tmp;\n\tstruct ulist_node *node = NULL;\n\tstruct ulist_iterator uiter;\n\tint ret;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\t*roots = ulist_alloc(GFP_NOFS);\n\tif (!*roots) {\n\t\tulist_free(tmp);\n\t\treturn -ENOMEM;\n\t}\n\n\tULIST_ITER_INIT(&uiter);\n\twhile (1) {\n\t\tret = find_parent_nodes(trans, fs_info, bytenr,\n\t\t\t\t\ttime_seq, tmp, *roots, NULL, 0, 0);\n\t\tif (ret < 0 && ret != -ENOENT) {\n\t\t\tulist_free(tmp);\n\t\t\tulist_free(*roots);\n\t\t\treturn ret;\n\t\t}\n\t\tnode = ulist_next(tmp, &uiter);\n\t\tif (!node)\n\t\t\tbreak;\n\t\tbytenr = node->val;\n\t\tcond_resched();\n\t}\n\n\tulist_free(tmp);\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int __btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t\t  u64 time_seq, struct ulist **roots)\n{\n\tstruct ulist *tmp;\n\tstruct ulist_node *node = NULL;\n\tstruct ulist_iterator uiter;\n\tint ret;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\t*roots = ulist_alloc(GFP_NOFS);\n\tif (!*roots) {\n\t\tulist_free(tmp);\n\t\treturn -ENOMEM;\n\t}\n\n\tULIST_ITER_INIT(&uiter);\n\twhile (1) {\n\t\tret = find_parent_nodes(trans, fs_info, bytenr,\n\t\t\t\t\ttime_seq, tmp, *roots, NULL, 0, 0);\n\t\tif (ret < 0 && ret != -ENOENT) {\n\t\t\tulist_free(tmp);\n\t\t\tulist_free(*roots);\n\t\t\treturn ret;\n\t\t}\n\t\tnode = ulist_next(tmp, &uiter);\n\t\tif (!node)\n\t\t\tbreak;\n\t\tbytenr = node->val;\n\t\tcond_resched();\n\t}\n\n\tulist_free(tmp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&ref_uiter"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_all_leafs",
          "args": [
            "trans",
            "fs_info",
            "extent_item_objectid",
            "tree_mod_seq_elem.seq",
            "&refs",
            "&extent_item_pos"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_all_leafs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1115-1134",
          "snippet": "static int btrfs_find_all_leafs(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t\tu64 time_seq, struct ulist **leafs,\n\t\t\t\tconst u64 *extent_item_pos)\n{\n\tint ret;\n\n\t*leafs = ulist_alloc(GFP_NOFS);\n\tif (!*leafs)\n\t\treturn -ENOMEM;\n\n\tret = find_parent_nodes(trans, fs_info, bytenr,\n\t\t\t\ttime_seq, *leafs, NULL, extent_item_pos, 0, 0);\n\tif (ret < 0 && ret != -ENOENT) {\n\t\tfree_leaf_list(*leafs);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int btrfs_find_all_leafs(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t\tu64 time_seq, struct ulist **leafs,\n\t\t\t\tconst u64 *extent_item_pos)\n{\n\tint ret;\n\n\t*leafs = ulist_alloc(GFP_NOFS);\n\tif (!*leafs)\n\t\treturn -ENOMEM;\n\n\tret = find_parent_nodes(trans, fs_info, bytenr,\n\t\t\t\ttime_seq, *leafs, NULL, extent_item_pos, 0, 0);\n\tif (ret < 0 && ret != -ENOENT) {\n\t\tfree_leaf_list(*leafs);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fs_info->commit_root_sem"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_tree_mod_seq",
          "args": [
            "fs_info",
            "&tree_mod_seq_elem"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "371-384",
          "snippet": "u64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nu64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_join_transaction",
          "args": [
            "fs_info->extent_root"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_join_transaction_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "581-584",
          "snippet": "struct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_join_transaction_nolock(struct btrfs_root *root)\n{\n\treturn start_transaction(root, 0, TRANS_JOIN_NOLOCK, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"resolving all inodes for extent %llu\\n\"",
            "extent_item_objectid"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint iterate_extent_inodes(struct btrfs_fs_info *fs_info,\n\t\t\t\tu64 extent_item_objectid, u64 extent_item_pos,\n\t\t\t\tint search_commit_root,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tint ret;\n\tstruct btrfs_trans_handle *trans = NULL;\n\tstruct ulist *refs = NULL;\n\tstruct ulist *roots = NULL;\n\tstruct ulist_node *ref_node = NULL;\n\tstruct ulist_node *root_node = NULL;\n\tstruct seq_list tree_mod_seq_elem = {};\n\tstruct ulist_iterator ref_uiter;\n\tstruct ulist_iterator root_uiter;\n\n\tpr_debug(\"resolving all inodes for extent %llu\\n\",\n\t\t\textent_item_objectid);\n\n\tif (!search_commit_root) {\n\t\ttrans = btrfs_join_transaction(fs_info->extent_root);\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t\tbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t} else {\n\t\tdown_read(&fs_info->commit_root_sem);\n\t}\n\n\tret = btrfs_find_all_leafs(trans, fs_info, extent_item_objectid,\n\t\t\t\t   tree_mod_seq_elem.seq, &refs,\n\t\t\t\t   &extent_item_pos);\n\tif (ret)\n\t\tgoto out;\n\n\tULIST_ITER_INIT(&ref_uiter);\n\twhile (!ret && (ref_node = ulist_next(refs, &ref_uiter))) {\n\t\tret = __btrfs_find_all_roots(trans, fs_info, ref_node->val,\n\t\t\t\t\t     tree_mod_seq_elem.seq, &roots);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tULIST_ITER_INIT(&root_uiter);\n\t\twhile (!ret && (root_node = ulist_next(roots, &root_uiter))) {\n\t\t\tpr_debug(\"root %llu references leaf %llu, data list \"\n\t\t\t\t \"%#llx\\n\", root_node->val, ref_node->val,\n\t\t\t\t ref_node->aux);\n\t\t\tret = iterate_leaf_refs((struct extent_inode_elem *)\n\t\t\t\t\t\t(uintptr_t)ref_node->aux,\n\t\t\t\t\t\troot_node->val,\n\t\t\t\t\t\textent_item_objectid,\n\t\t\t\t\t\titerate, ctx);\n\t\t}\n\t\tulist_free(roots);\n\t}\n\n\tfree_leaf_list(refs);\nout:\n\tif (!search_commit_root) {\n\t\tbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\n\t\tbtrfs_end_transaction(trans, fs_info->extent_root);\n\t} else {\n\t\tup_read(&fs_info->commit_root_sem);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iterate_leaf_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1575-1595",
    "snippet": "static int iterate_leaf_refs(struct extent_inode_elem *inode_list,\n\t\t\t\tu64 root, u64 extent_item_objectid,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tstruct extent_inode_elem *eie;\n\tint ret = 0;\n\n\tfor (eie = inode_list; eie; eie = eie->next) {\n\t\tpr_debug(\"ref for %llu resolved, key (%llu EXTEND_DATA %llu), \"\n\t\t\t \"root %llu\\n\", extent_item_objectid,\n\t\t\t eie->inum, eie->offset, root);\n\t\tret = iterate(eie->inum, eie->offset, root, ctx);\n\t\tif (ret) {\n\t\t\tpr_debug(\"stopping iteration for %llu due to ret=%d\\n\",\n\t\t\t\t extent_item_objectid, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"stopping iteration for %llu due to ret=%d\\n\"",
            "extent_item_objectid",
            "ret"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate",
          "args": [
            "eie->inum",
            "eie->offset",
            "root",
            "ctx"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "__iterate_backrefs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/send.c",
          "lines": "1193-1262",
          "snippet": "static int __iterate_backrefs(u64 ino, u64 offset, u64 root, void *ctx_)\n{\n\tstruct backref_ctx *bctx = ctx_;\n\tstruct clone_root *found;\n\tint ret;\n\tu64 i_size;\n\n\t/* First check if the root is in the list of accepted clone sources */\n\tfound = bsearch((void *)(uintptr_t)root, bctx->sctx->clone_roots,\n\t\t\tbctx->sctx->clone_roots_cnt,\n\t\t\tsizeof(struct clone_root),\n\t\t\t__clone_root_cmp_bsearch);\n\tif (!found)\n\t\treturn 0;\n\n\tif (found->root == bctx->sctx->send_root &&\n\t    ino == bctx->cur_objectid &&\n\t    offset == bctx->cur_offset) {\n\t\tbctx->found_itself = 1;\n\t}\n\n\t/*\n\t * There are inodes that have extents that lie behind its i_size. Don't\n\t * accept clones from these extents.\n\t */\n\tret = __get_inode_info(found->root, bctx->path, ino, &i_size, NULL, NULL,\n\t\t\t       NULL, NULL, NULL);\n\tbtrfs_release_path(bctx->path);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (offset + bctx->extent_len > i_size)\n\t\treturn 0;\n\n\t/*\n\t * Make sure we don't consider clones from send_root that are\n\t * behind the current inode/offset.\n\t */\n\tif (found->root == bctx->sctx->send_root) {\n\t\t/*\n\t\t * TODO for the moment we don't accept clones from the inode\n\t\t * that is currently send. We may change this when\n\t\t * BTRFS_IOC_CLONE_RANGE supports cloning from and to the same\n\t\t * file.\n\t\t */\n\t\tif (ino >= bctx->cur_objectid)\n\t\t\treturn 0;\n#if 0\n\t\tif (ino > bctx->cur_objectid)\n\t\t\treturn 0;\n\t\tif (offset + bctx->extent_len > bctx->cur_offset)\n\t\t\treturn 0;\n#endif\n\t}\n\n\tbctx->found++;\n\tfound->found_refs++;\n\tif (ino < found->ino) {\n\t\tfound->ino = ino;\n\t\tfound->offset = offset;\n\t} else if (found->ino == ino) {\n\t\t/*\n\t\t * same extent found more then once in the same file.\n\t\t */\n\t\tif (found->offset > offset + bctx->extent_len)\n\t\t\tfound->offset = offset;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"disk-io.h\"",
            "#include \"locking.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"send.h\"",
            "#include <linux/string.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/mount.h>",
            "#include <linux/sort.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/bsearch.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int is_waiting_for_move(struct send_ctx *sctx, u64 ino);",
            "static struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"btrfs_inode.h\"\n#include \"disk-io.h\"\n#include \"locking.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"send.h\"\n#include <linux/string.h>\n#include <linux/vmalloc.h>\n#include <linux/radix-tree.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/mount.h>\n#include <linux/sort.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/bsearch.h>\n\nstatic int is_waiting_for_move(struct send_ctx *sctx, u64 ino);\nstatic struct waiting_dir_move *\nget_waiting_dir_move(struct send_ctx *sctx, u64 ino);\n\nstatic int __iterate_backrefs(u64 ino, u64 offset, u64 root, void *ctx_)\n{\n\tstruct backref_ctx *bctx = ctx_;\n\tstruct clone_root *found;\n\tint ret;\n\tu64 i_size;\n\n\t/* First check if the root is in the list of accepted clone sources */\n\tfound = bsearch((void *)(uintptr_t)root, bctx->sctx->clone_roots,\n\t\t\tbctx->sctx->clone_roots_cnt,\n\t\t\tsizeof(struct clone_root),\n\t\t\t__clone_root_cmp_bsearch);\n\tif (!found)\n\t\treturn 0;\n\n\tif (found->root == bctx->sctx->send_root &&\n\t    ino == bctx->cur_objectid &&\n\t    offset == bctx->cur_offset) {\n\t\tbctx->found_itself = 1;\n\t}\n\n\t/*\n\t * There are inodes that have extents that lie behind its i_size. Don't\n\t * accept clones from these extents.\n\t */\n\tret = __get_inode_info(found->root, bctx->path, ino, &i_size, NULL, NULL,\n\t\t\t       NULL, NULL, NULL);\n\tbtrfs_release_path(bctx->path);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (offset + bctx->extent_len > i_size)\n\t\treturn 0;\n\n\t/*\n\t * Make sure we don't consider clones from send_root that are\n\t * behind the current inode/offset.\n\t */\n\tif (found->root == bctx->sctx->send_root) {\n\t\t/*\n\t\t * TODO for the moment we don't accept clones from the inode\n\t\t * that is currently send. We may change this when\n\t\t * BTRFS_IOC_CLONE_RANGE supports cloning from and to the same\n\t\t * file.\n\t\t */\n\t\tif (ino >= bctx->cur_objectid)\n\t\t\treturn 0;\n#if 0\n\t\tif (ino > bctx->cur_objectid)\n\t\t\treturn 0;\n\t\tif (offset + bctx->extent_len > bctx->cur_offset)\n\t\t\treturn 0;\n#endif\n\t}\n\n\tbctx->found++;\n\tfound->found_refs++;\n\tif (ino < found->ino) {\n\t\tfound->ino = ino;\n\t\tfound->offset = offset;\n\t} else if (found->ino == ino) {\n\t\t/*\n\t\t * same extent found more then once in the same file.\n\t\t */\n\t\tif (found->offset > offset + bctx->extent_len)\n\t\t\tfound->offset = offset;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"ref for %llu resolved, key (%llu EXTEND_DATA %llu), \"\n\t\t\t \"root %llu\\n\"",
            "extent_item_objectid",
            "eie->inum",
            "eie->offset",
            "root"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int iterate_leaf_refs(struct extent_inode_elem *inode_list,\n\t\t\t\tu64 root, u64 extent_item_objectid,\n\t\t\t\titerate_extent_inodes_t *iterate, void *ctx)\n{\n\tstruct extent_inode_elem *eie;\n\tint ret = 0;\n\n\tfor (eie = inode_list; eie; eie = eie->next) {\n\t\tpr_debug(\"ref for %llu resolved, key (%llu EXTEND_DATA %llu), \"\n\t\t\t \"root %llu\\n\", extent_item_objectid,\n\t\t\t eie->inum, eie->offset, root);\n\t\tret = iterate(eie->inum, eie->offset, root, ctx);\n\t\tif (ret) {\n\t\t\tpr_debug(\"stopping iteration for %llu due to ret=%d\\n\",\n\t\t\t\t extent_item_objectid, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tree_backref_for_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1531-1573",
    "snippet": "int tree_backref_for_extent(unsigned long *ptr, struct extent_buffer *eb,\n\t\t\t    struct btrfs_key *key, struct btrfs_extent_item *ei,\n\t\t\t    u32 item_size, u64 *out_root, u8 *out_level)\n{\n\tint ret;\n\tint type;\n\tstruct btrfs_extent_inline_ref *eiref;\n\n\tif (*ptr == (unsigned long)-1)\n\t\treturn 1;\n\n\twhile (1) {\n\t\tret = __get_extent_inline_ref(ptr, eb, key, ei, item_size,\n\t\t\t\t\t      &eiref, &type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t    type == BTRFS_SHARED_BLOCK_REF_KEY)\n\t\t\tbreak;\n\n\t\tif (ret == 1)\n\t\t\treturn 1;\n\t}\n\n\t/* we can treat both ref types equally here */\n\t*out_root = btrfs_extent_inline_ref_offset(eb, eiref);\n\n\tif (key->type == BTRFS_EXTENT_ITEM_KEY) {\n\t\tstruct btrfs_tree_block_info *info;\n\n\t\tinfo = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t*out_level = btrfs_tree_block_level(eb, info);\n\t} else {\n\t\tASSERT(key->type == BTRFS_METADATA_ITEM_KEY);\n\t\t*out_level = (u8)key->offset;\n\t}\n\n\tif (ret == 1)\n\t\t*ptr = (unsigned long)-1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "key->type == BTRFS_METADATA_ITEM_KEY"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_tree_block_level",
          "args": [
            "eb",
            "info"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_inline_ref_offset",
          "args": [
            "eb",
            "eiref"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_extent_inline_ref",
          "args": [
            "ptr",
            "eb",
            "key",
            "ei",
            "item_size",
            "&eiref",
            "&type"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "__get_extent_inline_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1480-1522",
          "snippet": "static int __get_extent_inline_ref(unsigned long *ptr, struct extent_buffer *eb,\n\t\t\t\t   struct btrfs_key *key,\n\t\t\t\t   struct btrfs_extent_item *ei, u32 item_size,\n\t\t\t\t   struct btrfs_extent_inline_ref **out_eiref,\n\t\t\t\t   int *out_type)\n{\n\tunsigned long end;\n\tu64 flags;\n\tstruct btrfs_tree_block_info *info;\n\n\tif (!*ptr) {\n\t\t/* first call */\n\t\tflags = btrfs_extent_flags(eb, ei);\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\t\tif (key->type == BTRFS_METADATA_ITEM_KEY) {\n\t\t\t\t/* a skinny metadata extent */\n\t\t\t\t*out_eiref =\n\t\t\t\t     (struct btrfs_extent_inline_ref *)(ei + 1);\n\t\t\t} else {\n\t\t\t\tWARN_ON(key->type != BTRFS_EXTENT_ITEM_KEY);\n\t\t\t\tinfo = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t\t\t*out_eiref =\n\t\t\t\t   (struct btrfs_extent_inline_ref *)(info + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t*out_eiref = (struct btrfs_extent_inline_ref *)(ei + 1);\n\t\t}\n\t\t*ptr = (unsigned long)*out_eiref;\n\t\tif ((unsigned long)(*ptr) >= (unsigned long)ei + item_size)\n\t\t\treturn -ENOENT;\n\t}\n\n\tend = (unsigned long)ei + item_size;\n\t*out_eiref = (struct btrfs_extent_inline_ref *)(*ptr);\n\t*out_type = btrfs_extent_inline_ref_type(eb, *out_eiref);\n\n\t*ptr += btrfs_extent_inline_ref_size(*out_type);\n\tWARN_ON(*ptr > end);\n\tif (*ptr == end)\n\t\treturn 1; /* last */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int __get_extent_inline_ref(unsigned long *ptr, struct extent_buffer *eb,\n\t\t\t\t   struct btrfs_key *key,\n\t\t\t\t   struct btrfs_extent_item *ei, u32 item_size,\n\t\t\t\t   struct btrfs_extent_inline_ref **out_eiref,\n\t\t\t\t   int *out_type)\n{\n\tunsigned long end;\n\tu64 flags;\n\tstruct btrfs_tree_block_info *info;\n\n\tif (!*ptr) {\n\t\t/* first call */\n\t\tflags = btrfs_extent_flags(eb, ei);\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\t\tif (key->type == BTRFS_METADATA_ITEM_KEY) {\n\t\t\t\t/* a skinny metadata extent */\n\t\t\t\t*out_eiref =\n\t\t\t\t     (struct btrfs_extent_inline_ref *)(ei + 1);\n\t\t\t} else {\n\t\t\t\tWARN_ON(key->type != BTRFS_EXTENT_ITEM_KEY);\n\t\t\t\tinfo = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t\t\t*out_eiref =\n\t\t\t\t   (struct btrfs_extent_inline_ref *)(info + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t*out_eiref = (struct btrfs_extent_inline_ref *)(ei + 1);\n\t\t}\n\t\t*ptr = (unsigned long)*out_eiref;\n\t\tif ((unsigned long)(*ptr) >= (unsigned long)ei + item_size)\n\t\t\treturn -ENOENT;\n\t}\n\n\tend = (unsigned long)ei + item_size;\n\t*out_eiref = (struct btrfs_extent_inline_ref *)(*ptr);\n\t*out_type = btrfs_extent_inline_ref_type(eb, *out_eiref);\n\n\t*ptr += btrfs_extent_inline_ref_size(*out_type);\n\tWARN_ON(*ptr > end);\n\tif (*ptr == end)\n\t\treturn 1; /* last */\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint tree_backref_for_extent(unsigned long *ptr, struct extent_buffer *eb,\n\t\t\t    struct btrfs_key *key, struct btrfs_extent_item *ei,\n\t\t\t    u32 item_size, u64 *out_root, u8 *out_level)\n{\n\tint ret;\n\tint type;\n\tstruct btrfs_extent_inline_ref *eiref;\n\n\tif (*ptr == (unsigned long)-1)\n\t\treturn 1;\n\n\twhile (1) {\n\t\tret = __get_extent_inline_ref(ptr, eb, key, ei, item_size,\n\t\t\t\t\t      &eiref, &type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t\t    type == BTRFS_SHARED_BLOCK_REF_KEY)\n\t\t\tbreak;\n\n\t\tif (ret == 1)\n\t\t\treturn 1;\n\t}\n\n\t/* we can treat both ref types equally here */\n\t*out_root = btrfs_extent_inline_ref_offset(eb, eiref);\n\n\tif (key->type == BTRFS_EXTENT_ITEM_KEY) {\n\t\tstruct btrfs_tree_block_info *info;\n\n\t\tinfo = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t*out_level = btrfs_tree_block_level(eb, info);\n\t} else {\n\t\tASSERT(key->type == BTRFS_METADATA_ITEM_KEY);\n\t\t*out_level = (u8)key->offset;\n\t}\n\n\tif (ret == 1)\n\t\t*ptr = (unsigned long)-1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__get_extent_inline_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1480-1522",
    "snippet": "static int __get_extent_inline_ref(unsigned long *ptr, struct extent_buffer *eb,\n\t\t\t\t   struct btrfs_key *key,\n\t\t\t\t   struct btrfs_extent_item *ei, u32 item_size,\n\t\t\t\t   struct btrfs_extent_inline_ref **out_eiref,\n\t\t\t\t   int *out_type)\n{\n\tunsigned long end;\n\tu64 flags;\n\tstruct btrfs_tree_block_info *info;\n\n\tif (!*ptr) {\n\t\t/* first call */\n\t\tflags = btrfs_extent_flags(eb, ei);\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\t\tif (key->type == BTRFS_METADATA_ITEM_KEY) {\n\t\t\t\t/* a skinny metadata extent */\n\t\t\t\t*out_eiref =\n\t\t\t\t     (struct btrfs_extent_inline_ref *)(ei + 1);\n\t\t\t} else {\n\t\t\t\tWARN_ON(key->type != BTRFS_EXTENT_ITEM_KEY);\n\t\t\t\tinfo = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t\t\t*out_eiref =\n\t\t\t\t   (struct btrfs_extent_inline_ref *)(info + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t*out_eiref = (struct btrfs_extent_inline_ref *)(ei + 1);\n\t\t}\n\t\t*ptr = (unsigned long)*out_eiref;\n\t\tif ((unsigned long)(*ptr) >= (unsigned long)ei + item_size)\n\t\t\treturn -ENOENT;\n\t}\n\n\tend = (unsigned long)ei + item_size;\n\t*out_eiref = (struct btrfs_extent_inline_ref *)(*ptr);\n\t*out_type = btrfs_extent_inline_ref_type(eb, *out_eiref);\n\n\t*ptr += btrfs_extent_inline_ref_size(*out_type);\n\tWARN_ON(*ptr > end);\n\tif (*ptr == end)\n\t\treturn 1; /* last */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "*ptr > end"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_inline_ref_size",
          "args": [
            "*out_type"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_extent_inline_ref_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2535-2548",
          "snippet": "static inline u32 btrfs_extent_inline_ref_size(int type)\n{\n\tif (type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t    type == BTRFS_SHARED_BLOCK_REF_KEY)\n\t\treturn sizeof(struct btrfs_extent_inline_ref);\n\tif (type == BTRFS_SHARED_DATA_REF_KEY)\n\t\treturn sizeof(struct btrfs_shared_data_ref) +\n\t\t       sizeof(struct btrfs_extent_inline_ref);\n\tif (type == BTRFS_EXTENT_DATA_REF_KEY)\n\t\treturn sizeof(struct btrfs_extent_data_ref) +\n\t\t       offsetof(struct btrfs_extent_inline_ref, offset);\n\tBUG();\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_SHARED_DATA_REF_KEY\t184",
            "#define BTRFS_SHARED_BLOCK_REF_KEY\t182",
            "#define BTRFS_EXTENT_DATA_REF_KEY\t178",
            "#define BTRFS_TREE_BLOCK_REF_KEY\t176"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_SHARED_DATA_REF_KEY\t184\n#define BTRFS_SHARED_BLOCK_REF_KEY\t182\n#define BTRFS_EXTENT_DATA_REF_KEY\t178\n#define BTRFS_TREE_BLOCK_REF_KEY\t176\n\nstatic inline u32 btrfs_extent_inline_ref_size(int type)\n{\n\tif (type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t    type == BTRFS_SHARED_BLOCK_REF_KEY)\n\t\treturn sizeof(struct btrfs_extent_inline_ref);\n\tif (type == BTRFS_SHARED_DATA_REF_KEY)\n\t\treturn sizeof(struct btrfs_shared_data_ref) +\n\t\t       sizeof(struct btrfs_extent_inline_ref);\n\tif (type == BTRFS_EXTENT_DATA_REF_KEY)\n\t\treturn sizeof(struct btrfs_extent_data_ref) +\n\t\t       offsetof(struct btrfs_extent_inline_ref, offset);\n\tBUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_extent_inline_ref_type",
          "args": [
            "eb",
            "*out_eiref"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "key->type != BTRFS_EXTENT_ITEM_KEY"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_flags",
          "args": [
            "eb",
            "ei"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int __get_extent_inline_ref(unsigned long *ptr, struct extent_buffer *eb,\n\t\t\t\t   struct btrfs_key *key,\n\t\t\t\t   struct btrfs_extent_item *ei, u32 item_size,\n\t\t\t\t   struct btrfs_extent_inline_ref **out_eiref,\n\t\t\t\t   int *out_type)\n{\n\tunsigned long end;\n\tu64 flags;\n\tstruct btrfs_tree_block_info *info;\n\n\tif (!*ptr) {\n\t\t/* first call */\n\t\tflags = btrfs_extent_flags(eb, ei);\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\t\tif (key->type == BTRFS_METADATA_ITEM_KEY) {\n\t\t\t\t/* a skinny metadata extent */\n\t\t\t\t*out_eiref =\n\t\t\t\t     (struct btrfs_extent_inline_ref *)(ei + 1);\n\t\t\t} else {\n\t\t\t\tWARN_ON(key->type != BTRFS_EXTENT_ITEM_KEY);\n\t\t\t\tinfo = (struct btrfs_tree_block_info *)(ei + 1);\n\t\t\t\t*out_eiref =\n\t\t\t\t   (struct btrfs_extent_inline_ref *)(info + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t*out_eiref = (struct btrfs_extent_inline_ref *)(ei + 1);\n\t\t}\n\t\t*ptr = (unsigned long)*out_eiref;\n\t\tif ((unsigned long)(*ptr) >= (unsigned long)ei + item_size)\n\t\t\treturn -ENOENT;\n\t}\n\n\tend = (unsigned long)ei + item_size;\n\t*out_eiref = (struct btrfs_extent_inline_ref *)(*ptr);\n\t*out_type = btrfs_extent_inline_ref_type(eb, *out_eiref);\n\n\t*ptr += btrfs_extent_inline_ref_size(*out_type);\n\tWARN_ON(*ptr > end);\n\tif (*ptr == end)\n\t\treturn 1; /* last */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "extent_from_logical",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1405-1470",
    "snippet": "int extent_from_logical(struct btrfs_fs_info *fs_info, u64 logical,\n\t\t\tstruct btrfs_path *path, struct btrfs_key *found_key,\n\t\t\tu64 *flags_ret)\n{\n\tint ret;\n\tu64 flags;\n\tu64 size = 0;\n\tu32 item_size;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_key key;\n\n\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.objectid = logical;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_previous_extent_item(fs_info->extent_root, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\tbtrfs_item_key_to_cpu(path->nodes[0], found_key, path->slots[0]);\n\tif (found_key->type == BTRFS_METADATA_ITEM_KEY)\n\t\tsize = fs_info->extent_root->nodesize;\n\telse if (found_key->type == BTRFS_EXTENT_ITEM_KEY)\n\t\tsize = found_key->offset;\n\n\tif (found_key->objectid > logical ||\n\t    found_key->objectid + size <= logical) {\n\t\tpr_debug(\"logical %llu is not within any extent\\n\", logical);\n\t\treturn -ENOENT;\n\t}\n\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\tBUG_ON(item_size < sizeof(*ei));\n\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(eb, ei);\n\n\tpr_debug(\"logical %llu is at position %llu within the extent (%llu \"\n\t\t \"EXTENT_ITEM %llu) flags %#llx size %u\\n\",\n\t\t logical, logical - found_key->objectid, found_key->objectid,\n\t\t found_key->offset, flags, item_size);\n\n\tWARN_ON(!flags_ret);\n\tif (flags_ret) {\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\telse if (flags & BTRFS_EXTENT_FLAG_DATA)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_DATA;\n\t\telse\n\t\t\tBUG_ON(1);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!flags_ret"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"logical %llu is at position %llu within the extent (%llu \"\n\t\t \"EXTENT_ITEM %llu) flags %#llx size %u\\n\"",
            "logical",
            "logical - found_key->objectid",
            "found_key->objectid",
            "found_key->offset",
            "flags",
            "item_size"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_flags",
          "args": [
            "eb",
            "ei"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "path->slots[0]",
            "structbtrfs_extent_item"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "item_size < sizeof(*ei)"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "eb",
            "path->slots[0]"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"logical %llu is not within any extent\\n\"",
            "logical"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "found_key",
            "path->slots[0]"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_previous_extent_item",
          "args": [
            "fs_info->extent_root",
            "path",
            "0"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_previous_extent_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5873-5908",
          "snippet": "int btrfs_previous_extent_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t\t    found_key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < BTRFS_EXTENT_ITEM_KEY)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_previous_extent_item(struct btrfs_root *root,\n\t\t\tstruct btrfs_path *path, u64 min_objectid)\n{\n\tstruct btrfs_key found_key;\n\tstruct extent_buffer *leaf;\n\tu32 nritems;\n\tint ret;\n\n\twhile (1) {\n\t\tif (path->slots[0] == 0) {\n\t\t\tbtrfs_set_path_blocking(path);\n\t\t\tret = btrfs_prev_leaf(root, path);\n\t\t\tif (ret != 0)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tnritems = btrfs_header_nritems(leaf);\n\t\tif (nritems == 0)\n\t\t\treturn 1;\n\t\tif (path->slots[0] == nritems)\n\t\t\tpath->slots[0]--;\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tif (found_key.objectid < min_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type == BTRFS_EXTENT_ITEM_KEY ||\n\t\t    found_key.type == BTRFS_METADATA_ITEM_KEY)\n\t\t\treturn 0;\n\t\tif (found_key.objectid == min_objectid &&\n\t\t    found_key.type < BTRFS_EXTENT_ITEM_KEY)\n\t\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "fs_info->extent_root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_fs_incompat",
          "args": [
            "fs_info",
            "SKINNY_METADATA"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_fs_incompat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4064-4069",
          "snippet": "static inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int __btrfs_fs_incompat(struct btrfs_fs_info *fs_info, u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tdisk_super = fs_info->super_copy;\n\treturn !!(btrfs_super_incompat_flags(disk_super) & flag);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint extent_from_logical(struct btrfs_fs_info *fs_info, u64 logical,\n\t\t\tstruct btrfs_path *path, struct btrfs_key *found_key,\n\t\t\tu64 *flags_ret)\n{\n\tint ret;\n\tu64 flags;\n\tu64 size = 0;\n\tu32 item_size;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_extent_item *ei;\n\tstruct btrfs_key key;\n\n\tif (btrfs_fs_incompat(fs_info, SKINNY_METADATA))\n\t\tkey.type = BTRFS_METADATA_ITEM_KEY;\n\telse\n\t\tkey.type = BTRFS_EXTENT_ITEM_KEY;\n\tkey.objectid = logical;\n\tkey.offset = (u64)-1;\n\n\tret = btrfs_search_slot(NULL, fs_info->extent_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = btrfs_previous_extent_item(fs_info->extent_root, path, 0);\n\tif (ret) {\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\treturn ret;\n\t}\n\tbtrfs_item_key_to_cpu(path->nodes[0], found_key, path->slots[0]);\n\tif (found_key->type == BTRFS_METADATA_ITEM_KEY)\n\t\tsize = fs_info->extent_root->nodesize;\n\telse if (found_key->type == BTRFS_EXTENT_ITEM_KEY)\n\t\tsize = found_key->offset;\n\n\tif (found_key->objectid > logical ||\n\t    found_key->objectid + size <= logical) {\n\t\tpr_debug(\"logical %llu is not within any extent\\n\", logical);\n\t\treturn -ENOENT;\n\t}\n\n\teb = path->nodes[0];\n\titem_size = btrfs_item_size_nr(eb, path->slots[0]);\n\tBUG_ON(item_size < sizeof(*ei));\n\n\tei = btrfs_item_ptr(eb, path->slots[0], struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(eb, ei);\n\n\tpr_debug(\"logical %llu is at position %llu within the extent (%llu \"\n\t\t \"EXTENT_ITEM %llu) flags %#llx size %u\\n\",\n\t\t logical, logical - found_key->objectid, found_key->objectid,\n\t\t found_key->offset, flags, item_size);\n\n\tWARN_ON(!flags_ret);\n\tif (flags_ret) {\n\t\tif (flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_TREE_BLOCK;\n\t\telse if (flags & BTRFS_EXTENT_FLAG_DATA)\n\t\t\t*flags_ret = BTRFS_EXTENT_FLAG_DATA;\n\t\telse\n\t\t\tBUG_ON(1);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}"
  },
  {
    "function_name": "btrfs_ref_to_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1331-1398",
    "snippet": "char *btrfs_ref_to_path(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\t\tu32 name_len, unsigned long name_off,\n\t\t\tstruct extent_buffer *eb_in, u64 parent,\n\t\t\tchar *dest, u32 size)\n{\n\tint slot;\n\tu64 next_inum;\n\tint ret;\n\ts64 bytes_left = ((s64)size) - 1;\n\tstruct extent_buffer *eb = eb_in;\n\tstruct btrfs_key found_key;\n\tint leave_spinning = path->leave_spinning;\n\tstruct btrfs_inode_ref *iref;\n\n\tif (bytes_left >= 0)\n\t\tdest[bytes_left] = '\\0';\n\n\tpath->leave_spinning = 1;\n\twhile (1) {\n\t\tbytes_left -= name_len;\n\t\tif (bytes_left >= 0)\n\t\t\tread_extent_buffer(eb, dest + bytes_left,\n\t\t\t\t\t   name_off, name_len);\n\t\tif (eb != eb_in) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t}\n\t\tret = btrfs_find_item(fs_root, path, parent, 0,\n\t\t\t\tBTRFS_INODE_REF_KEY, &found_key);\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnext_inum = found_key.offset;\n\n\t\t/* regular exit ahead */\n\t\tif (parent == next_inum)\n\t\t\tbreak;\n\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\t/* make sure we can use eb after releasing the path */\n\t\tif (eb != eb_in) {\n\t\t\tatomic_inc(&eb->refs);\n\t\t\tbtrfs_tree_read_lock(eb);\n\t\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tiref = btrfs_item_ptr(eb, slot, struct btrfs_inode_ref);\n\n\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\tname_off = (unsigned long)(iref + 1);\n\n\t\tparent = next_inum;\n\t\t--bytes_left;\n\t\tif (bytes_left >= 0)\n\t\t\tdest[bytes_left] = '/';\n\t}\n\n\tbtrfs_release_path(path);\n\tpath->leave_spinning = leave_spinning;\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn dest + bytes_left;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_inode_ref_name_len",
          "args": [
            "eb",
            "iref"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_inode_ref"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_lock_blocking_rw",
          "args": [
            "eb",
            "BTRFS_READ_LOCK"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_lock_blocking_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "34-60",
          "snippet": "void btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_set_lock_blocking_rw(struct extent_buffer *eb, int rw)\n{\n\t/*\n\t * no lock is required.  The lock owner may change if\n\t * we have a read lock, but it won't change to or away\n\t * from us.  If we have the write lock, we are the owner\n\t * and it'll never change.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner)\n\t\treturn;\n\tif (rw == BTRFS_WRITE_LOCK) {\n\t\tif (atomic_read(&eb->blocking_writers) == 0) {\n\t\t\tWARN_ON(atomic_read(&eb->spinning_writers) != 1);\n\t\t\tatomic_dec(&eb->spinning_writers);\n\t\t\tbtrfs_assert_tree_locked(eb);\n\t\t\tatomic_inc(&eb->blocking_writers);\n\t\t\twrite_unlock(&eb->lock);\n\t\t}\n\t} else if (rw == BTRFS_READ_LOCK) {\n\t\tbtrfs_assert_tree_read_locked(eb);\n\t\tatomic_inc(&eb->blocking_readers);\n\t\tWARN_ON(atomic_read(&eb->spinning_readers) == 0);\n\t\tatomic_dec(&eb->spinning_readers);\n\t\tread_unlock(&eb->lock);\n\t}\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_lock",
          "args": [
            "eb"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_lock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "135-148",
          "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&eb->refs"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_find_item",
          "args": [
            "fs_root",
            "path",
            "parent",
            "0",
            "BTRFS_INODE_REF_KEY",
            "&found_key"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_find_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2617-2650",
          "snippet": "int btrfs_find_item(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\tu64 iobjectid, u64 ioff, u8 key_type,\n\t\tstruct btrfs_key *found_key)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\n\tASSERT(path);\n\tASSERT(found_key);\n\n\tkey.type = key_type;\n\tkey.objectid = iobjectid;\n\tkey.offset = ioff;\n\n\tret = btrfs_search_slot(NULL, fs_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\teb = path->nodes[0];\n\tif (ret && path->slots[0] >= btrfs_header_nritems(eb)) {\n\t\tret = btrfs_next_leaf(fs_root, path);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\teb = path->nodes[0];\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, found_key, path->slots[0]);\n\tif (found_key->type != key.type ||\n\t\t\tfound_key->objectid != key.objectid)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nint btrfs_find_item(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\tu64 iobjectid, u64 ioff, u8 key_type,\n\t\tstruct btrfs_key *found_key)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct extent_buffer *eb;\n\n\tASSERT(path);\n\tASSERT(found_key);\n\n\tkey.type = key_type;\n\tkey.objectid = iobjectid;\n\tkey.offset = ioff;\n\n\tret = btrfs_search_slot(NULL, fs_root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\teb = path->nodes[0];\n\tif (ret && path->slots[0] >= btrfs_header_nritems(eb)) {\n\t\tret = btrfs_next_leaf(fs_root, path);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\teb = path->nodes[0];\n\t}\n\n\tbtrfs_item_key_to_cpu(eb, found_key, path->slots[0]);\n\tif (found_key->type != key.type ||\n\t\t\tfound_key->objectid != key.objectid)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_unlock_blocking",
          "args": [
            "eb"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_extent_buffer",
          "args": [
            "eb",
            "dest + bytes_left",
            "name_off",
            "name_len"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "btree_read_extent_buffer_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "442-497",
          "snippet": "static int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstatic int btree_read_extent_buffer_pages(struct btrfs_root *root,\n\t\t\t\t\t  struct extent_buffer *eb,\n\t\t\t\t\t  u64 start, u64 parent_transid)\n{\n\tstruct extent_io_tree *io_tree;\n\tint failed = 0;\n\tint ret;\n\tint num_copies = 0;\n\tint mirror_num = 0;\n\tint failed_mirror = 0;\n\n\tclear_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags);\n\tio_tree = &BTRFS_I(root->fs_info->btree_inode)->io_tree;\n\twhile (1) {\n\t\tret = read_extent_buffer_pages(io_tree, eb, start,\n\t\t\t\t\t       WAIT_COMPLETE,\n\t\t\t\t\t       btree_get_extent, mirror_num);\n\t\tif (!ret) {\n\t\t\tif (!verify_parent_transid(io_tree, eb,\n\t\t\t\t\t\t   parent_transid, 0))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tret = -EIO;\n\t\t}\n\n\t\t/*\n\t\t * This buffer's crc is fine, but its contents are corrupted, so\n\t\t * there is no reason to read the other copies, they won't be\n\t\t * any less wrong.\n\t\t */\n\t\tif (test_bit(EXTENT_BUFFER_CORRUPT, &eb->bflags))\n\t\t\tbreak;\n\n\t\tnum_copies = btrfs_num_copies(root->fs_info,\n\t\t\t\t\t      eb->start, eb->len);\n\t\tif (num_copies == 1)\n\t\t\tbreak;\n\n\t\tif (!failed_mirror) {\n\t\t\tfailed = 1;\n\t\t\tfailed_mirror = eb->read_mirror;\n\t\t}\n\n\t\tmirror_num++;\n\t\tif (mirror_num == failed_mirror)\n\t\t\tmirror_num++;\n\n\t\tif (mirror_num > num_copies)\n\t\t\tbreak;\n\t}\n\n\tif (failed && !ret && failed_mirror)\n\t\trepair_eb_io_failure(root, eb, failed_mirror);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nchar *btrfs_ref_to_path(struct btrfs_root *fs_root, struct btrfs_path *path,\n\t\t\tu32 name_len, unsigned long name_off,\n\t\t\tstruct extent_buffer *eb_in, u64 parent,\n\t\t\tchar *dest, u32 size)\n{\n\tint slot;\n\tu64 next_inum;\n\tint ret;\n\ts64 bytes_left = ((s64)size) - 1;\n\tstruct extent_buffer *eb = eb_in;\n\tstruct btrfs_key found_key;\n\tint leave_spinning = path->leave_spinning;\n\tstruct btrfs_inode_ref *iref;\n\n\tif (bytes_left >= 0)\n\t\tdest[bytes_left] = '\\0';\n\n\tpath->leave_spinning = 1;\n\twhile (1) {\n\t\tbytes_left -= name_len;\n\t\tif (bytes_left >= 0)\n\t\t\tread_extent_buffer(eb, dest + bytes_left,\n\t\t\t\t\t   name_off, name_len);\n\t\tif (eb != eb_in) {\n\t\t\tbtrfs_tree_read_unlock_blocking(eb);\n\t\t\tfree_extent_buffer(eb);\n\t\t}\n\t\tret = btrfs_find_item(fs_root, path, parent, 0,\n\t\t\t\tBTRFS_INODE_REF_KEY, &found_key);\n\t\tif (ret > 0)\n\t\t\tret = -ENOENT;\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tnext_inum = found_key.offset;\n\n\t\t/* regular exit ahead */\n\t\tif (parent == next_inum)\n\t\t\tbreak;\n\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\t/* make sure we can use eb after releasing the path */\n\t\tif (eb != eb_in) {\n\t\t\tatomic_inc(&eb->refs);\n\t\t\tbtrfs_tree_read_lock(eb);\n\t\t\tbtrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);\n\t\t}\n\t\tbtrfs_release_path(path);\n\t\tiref = btrfs_item_ptr(eb, slot, struct btrfs_inode_ref);\n\n\t\tname_len = btrfs_inode_ref_name_len(eb, iref);\n\t\tname_off = (unsigned long)(iref + 1);\n\n\t\tparent = next_inum;\n\t\t--bytes_left;\n\t\tif (bytes_left >= 0)\n\t\t\tdest[bytes_left] = '/';\n\t}\n\n\tbtrfs_release_path(path);\n\tpath->leave_spinning = leave_spinning;\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn dest + bytes_left;\n}"
  },
  {
    "function_name": "btrfs_find_one_extref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1249-1315",
    "snippet": "int btrfs_find_one_extref(struct btrfs_root *root, u64 inode_objectid,\n\t\t\t  u64 start_off, struct btrfs_path *path,\n\t\t\t  struct btrfs_inode_extref **ret_extref,\n\t\t\t  u64 *found_off)\n{\n\tint ret, slot;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tkey.objectid = inode_objectid;\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = start_off;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\t/*\n\t\t\t * If the item at offset is not found,\n\t\t\t * btrfs_search_slot will point us to the slot\n\t\t\t * where it should be inserted. In our case\n\t\t\t * that will be the slot directly before the\n\t\t\t * next INODE_REF_KEY_V2 item. In the case\n\t\t\t * that we're pointing to the last slot in a\n\t\t\t * leaf, we must move one leaf over.\n\t\t\t */\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret) {\n\t\t\t\tif (ret >= 1)\n\t\t\t\t\tret = -ENOENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\t/*\n\t\t * Check that we're still looking at an extended ref key for\n\t\t * this particular objectid. If we have different\n\t\t * objectid or type then there are no more to be found\n\t\t * in the tree and we can exit.\n\t\t */\n\t\tret = -ENOENT;\n\t\tif (found_key.objectid != inode_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\tret = 0;\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\textref = (struct btrfs_inode_extref *)ptr;\n\t\t*ret_extref = extref;\n\t\tif (found_off)\n\t\t\t*found_off = found_key.offset;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_item_ptr_offset",
          "args": [
            "leaf",
            "path->slots[0]"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "slot"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_leaf",
          "args": [
            "root",
            "path"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5646-5649",
          "snippet": "int btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_next_leaf(struct btrfs_root *root, struct btrfs_path *path)\n{\n\treturn btrfs_next_old_leaf(root, path, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "leaf"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_slot",
          "args": [
            "NULL",
            "root",
            "&key",
            "path",
            "0",
            "0"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2665-2932",
          "snippet": "int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_key *key, struct btrfs_path *p, int\n\t\t      ins_len, int cow)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tint root_lock;\n\t/* everything at write_lock_level or lower must be write locked */\n\tint write_lock_level = 0;\n\tu8 lowest_level = 0;\n\tint min_write_lock_level;\n\tint prev_cmp;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(lowest_level && ins_len > 0);\n\tWARN_ON(p->nodes[0] != NULL);\n\tBUG_ON(!cow && ins_len);\n\n\tif (ins_len < 0) {\n\t\tlowest_unlock = 2;\n\n\t\t/* when we are removing items, we might have to go up to level\n\t\t * two as we update tree pointers  Make sure we keep write\n\t\t * for those levels as well\n\t\t */\n\t\twrite_lock_level = 2;\n\t} else if (ins_len > 0) {\n\t\t/*\n\t\t * for inserting items, make sure we have a write lock on\n\t\t * level 1 so we can update keys\n\t\t */\n\t\twrite_lock_level = 1;\n\t}\n\n\tif (!cow)\n\t\twrite_lock_level = -1;\n\n\tif (cow && (p->keep_locks || p->lowest_level))\n\t\twrite_lock_level = BTRFS_MAX_LEVEL;\n\n\tmin_write_lock_level = write_lock_level;\n\nagain:\n\tprev_cmp = -1;\n\t/*\n\t * we try very hard to do read locks on the root\n\t */\n\troot_lock = BTRFS_READ_LOCK;\n\tlevel = 0;\n\tif (p->search_commit_root) {\n\t\t/*\n\t\t * the commit roots are read only\n\t\t * so we always do read locks\n\t\t */\n\t\tif (p->need_commit_sem)\n\t\t\tdown_read(&root->fs_info->commit_root_sem);\n\t\tb = root->commit_root;\n\t\textent_buffer_get(b);\n\t\tlevel = btrfs_header_level(b);\n\t\tif (p->need_commit_sem)\n\t\t\tup_read(&root->fs_info->commit_root_sem);\n\t\tif (!p->skip_locking)\n\t\t\tbtrfs_tree_read_lock(b);\n\t} else {\n\t\tif (p->skip_locking) {\n\t\t\tb = btrfs_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t} else {\n\t\t\t/* we don't know the level of the root node\n\t\t\t * until we actually have it read locked\n\t\t\t */\n\t\t\tb = btrfs_read_lock_root_node(root);\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\tif (level <= write_lock_level) {\n\t\t\t\t/* whoops, must trade for write lock */\n\t\t\t\tbtrfs_tree_read_unlock(b);\n\t\t\t\tfree_extent_buffer(b);\n\t\t\t\tb = btrfs_lock_root_node(root);\n\t\t\t\troot_lock = BTRFS_WRITE_LOCK;\n\n\t\t\t\t/* the level might have changed, check again */\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t}\n\t\t}\n\t}\n\tp->nodes[level] = b;\n\tif (!p->skip_locking)\n\t\tp->locks[level] = root_lock;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\n\t\t/*\n\t\t * setup the path here so we can release it under lock\n\t\t * contention with the cow code\n\t\t */\n\t\tif (cow) {\n\t\t\t/*\n\t\t\t * if we don't really need to cow this block\n\t\t\t * then we don't want to set the path blocking,\n\t\t\t * so we test it here\n\t\t\t */\n\t\t\tif (!should_cow_block(trans, root, b))\n\t\t\t\tgoto cow_done;\n\n\t\t\t/*\n\t\t\t * must have write locks on this node and the\n\t\t\t * parent\n\t\t\t */\n\t\t\tif (level > write_lock_level ||\n\t\t\t    (level + 1 > write_lock_level &&\n\t\t\t    level + 1 < BTRFS_MAX_LEVEL &&\n\t\t\t    p->nodes[level + 1])) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tbtrfs_set_path_blocking(p);\n\t\t\terr = btrfs_cow_block(trans, root, b,\n\t\t\t\t\t      p->nodes[level + 1],\n\t\t\t\t\t      p->slots[level + 1], &b);\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\ncow_done:\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t *\n\t\t * If we're inserting or deleting (ins_len != 0), then we might\n\t\t * be changing slot zero, which may require changing the parent.\n\t\t * So, we can't drop the lock until after we know which slot\n\t\t * we're operating on.\n\t\t */\n\t\tif (!ins_len && !p->keep_locks) {\n\t\t\tint u = level + 1;\n\n\t\t\tif (u < BTRFS_MAX_LEVEL && p->locks[u]) {\n\t\t\t\tbtrfs_tree_unlock_rw(p->nodes[u], p->locks[u]);\n\t\t\t\tp->locks[u] = 0;\n\t\t\t}\n\t\t}\n\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\terr = setup_nodes_for_search(trans, root, p, b, level,\n\t\t\t\t\t     ins_len, &write_lock_level);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tb = p->nodes[level];\n\t\t\tslot = p->slots[level];\n\n\t\t\t/*\n\t\t\t * slot 0 is special, if we change the key\n\t\t\t * we have to update the parent pointer\n\t\t\t * which means we must have a write lock\n\t\t\t * on the parent\n\t\t\t */\n\t\t\tif (slot == 0 && ins_len &&\n\t\t\t    write_lock_level < level + 1) {\n\t\t\t\twrite_lock_level = level + 1;\n\t\t\t\tbtrfs_release_path(p);\n\t\t\t\tgoto again;\n\t\t\t}\n\n\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t  min_write_lock_level, &write_lock_level);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(trans, root, p,\n\t\t\t\t\t\t    &b, level, slot, key, 0);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (!p->skip_locking) {\n\t\t\t\tlevel = btrfs_header_level(b);\n\t\t\t\tif (level <= write_lock_level) {\n\t\t\t\t\terr = btrfs_try_tree_write_lock(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_WRITE_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_WRITE_LOCK;\n\t\t\t\t} else {\n\t\t\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t\t\t}\n\t\t\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\t\t}\n\t\t\t\tp->nodes[level] = b;\n\t\t\t}\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tif (ins_len > 0 &&\n\t\t\t    btrfs_leaf_free_space(root, b) < ins_len) {\n\t\t\t\tif (write_lock_level < 1) {\n\t\t\t\t\twrite_lock_level = 1;\n\t\t\t\t\tbtrfs_release_path(p);\n\t\t\t\t\tgoto again;\n\t\t\t\t}\n\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\terr = split_leaf(trans, root, key,\n\t\t\t\t\t\t p, ins_len, ret == 0);\n\t\t\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t\t\tBUG_ON(err > 0);\n\t\t\t\tif (err) {\n\t\t\t\t\tret = err;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!p->search_for_split)\n\t\t\t\tunlock_up(p, level, lowest_unlock,\n\t\t\t\t\t  min_write_lock_level, &write_lock_level);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\t/*\n\t * we don't really know what they plan on doing with the path\n\t * from here on, so for now just mark it as blocking\n\t */\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0 && !p->skip_release_on_error)\n\t\tbtrfs_release_path(p);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint btrfs_find_one_extref(struct btrfs_root *root, u64 inode_objectid,\n\t\t\t  u64 start_off, struct btrfs_path *path,\n\t\t\t  struct btrfs_inode_extref **ret_extref,\n\t\t\t  u64 *found_off)\n{\n\tint ret, slot;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_inode_extref *extref;\n\tstruct extent_buffer *leaf;\n\tunsigned long ptr;\n\n\tkey.objectid = inode_objectid;\n\tkey.type = BTRFS_INODE_EXTREF_KEY;\n\tkey.offset = start_off;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twhile (1) {\n\t\tleaf = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(leaf)) {\n\t\t\t/*\n\t\t\t * If the item at offset is not found,\n\t\t\t * btrfs_search_slot will point us to the slot\n\t\t\t * where it should be inserted. In our case\n\t\t\t * that will be the slot directly before the\n\t\t\t * next INODE_REF_KEY_V2 item. In the case\n\t\t\t * that we're pointing to the last slot in a\n\t\t\t * leaf, we must move one leaf over.\n\t\t\t */\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret) {\n\t\t\t\tif (ret >= 1)\n\t\t\t\t\tret = -ENOENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\t\t/*\n\t\t * Check that we're still looking at an extended ref key for\n\t\t * this particular objectid. If we have different\n\t\t * objectid or type then there are no more to be found\n\t\t * in the tree and we can exit.\n\t\t */\n\t\tret = -ENOENT;\n\t\tif (found_key.objectid != inode_objectid)\n\t\t\tbreak;\n\t\tif (found_key.type != BTRFS_INODE_EXTREF_KEY)\n\t\t\tbreak;\n\n\t\tret = 0;\n\t\tptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\n\t\textref = (struct btrfs_inode_extref *)ptr;\n\t\t*ret_extref = extref;\n\t\tif (found_off)\n\t\t\t*found_off = found_key.offset;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_check_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1201-1247",
    "snippet": "int btrfs_check_shared(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_fs_info *fs_info, u64 root_objectid,\n\t\t       u64 inum, u64 bytenr)\n{\n\tstruct ulist *tmp = NULL;\n\tstruct ulist *roots = NULL;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *node;\n\tstruct seq_list elem = {};\n\tint ret = 0;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\troots = ulist_alloc(GFP_NOFS);\n\tif (!tmp || !roots) {\n\t\tulist_free(tmp);\n\t\tulist_free(roots);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (trans)\n\t\tbtrfs_get_tree_mod_seq(fs_info, &elem);\n\telse\n\t\tdown_read(&fs_info->commit_root_sem);\n\tULIST_ITER_INIT(&uiter);\n\twhile (1) {\n\t\tret = find_parent_nodes(trans, fs_info, bytenr, elem.seq, tmp,\n\t\t\t\t\troots, NULL, root_objectid, inum);\n\t\tif (ret == BACKREF_FOUND_SHARED) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tbreak;\n\t\tnode = ulist_next(tmp, &uiter);\n\t\tif (!node)\n\t\t\tbreak;\n\t\tbytenr = node->val;\n\t\tcond_resched();\n\t}\n\tif (trans)\n\t\tbtrfs_put_tree_mod_seq(fs_info, &elem);\n\telse\n\t\tup_read(&fs_info->commit_root_sem);\n\tulist_free(tmp);\n\tulist_free(roots);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define BACKREF_FOUND_SHARED 6"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "roots"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fs_info->commit_root_sem"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_tree_mod_seq",
          "args": [
            "fs_info",
            "&elem"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "386-434",
          "snippet": "void btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_put_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t    struct seq_list *elem)\n{\n\tstruct rb_root *tm_root;\n\tstruct rb_node *node;\n\tstruct rb_node *next;\n\tstruct seq_list *cur_elem;\n\tstruct tree_mod_elem *tm;\n\tu64 min_seq = (u64)-1;\n\tu64 seq_putting = elem->seq;\n\n\tif (!seq_putting)\n\t\treturn;\n\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tlist_del(&elem->list);\n\telem->seq = 0;\n\n\tlist_for_each_entry(cur_elem, &fs_info->tree_mod_seq_list, list) {\n\t\tif (cur_elem->seq < min_seq) {\n\t\t\tif (seq_putting > cur_elem->seq) {\n\t\t\t\t/*\n\t\t\t\t * blocker with lower sequence number exists, we\n\t\t\t\t * cannot remove anything from the log\n\t\t\t\t */\n\t\t\t\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmin_seq = cur_elem->seq;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\n\t/*\n\t * anything that's lower than the lowest existing (read: blocked)\n\t * sequence number can be removed from the tree.\n\t */\n\ttree_mod_log_write_lock(fs_info);\n\ttm_root = &fs_info->tree_mod_log;\n\tfor (node = rb_first(tm_root); node; node = next) {\n\t\tnext = rb_next(node);\n\t\ttm = container_of(node, struct tree_mod_elem, node);\n\t\tif (tm->seq > min_seq)\n\t\t\tcontinue;\n\t\trb_erase(node, tm_root);\n\t\tkfree(tm);\n\t}\n\ttree_mod_log_write_unlock(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "tmp",
            "&uiter"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_parent_nodes",
          "args": [
            "trans",
            "fs_info",
            "bytenr",
            "elem.seq",
            "tmp",
            "roots",
            "NULL",
            "root_objectid",
            "inum"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fs_info->commit_root_sem"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_tree_mod_seq",
          "args": [
            "fs_info",
            "&elem"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_tree_mod_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "371-384",
          "snippet": "u64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nu64 btrfs_get_tree_mod_seq(struct btrfs_fs_info *fs_info,\n\t\t\t   struct seq_list *elem)\n{\n\ttree_mod_log_write_lock(fs_info);\n\tspin_lock(&fs_info->tree_mod_seq_lock);\n\tif (!elem->seq) {\n\t\telem->seq = btrfs_inc_tree_mod_seq(fs_info);\n\t\tlist_add_tail(&elem->list, &fs_info->tree_mod_seq_list);\n\t}\n\tspin_unlock(&fs_info->tree_mod_seq_lock);\n\ttree_mod_log_write_unlock(fs_info);\n\n\treturn elem->seq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "92-102",
          "snippet": "struct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\n#define BACKREF_FOUND_SHARED 6\n\nint btrfs_check_shared(struct btrfs_trans_handle *trans,\n\t\t       struct btrfs_fs_info *fs_info, u64 root_objectid,\n\t\t       u64 inum, u64 bytenr)\n{\n\tstruct ulist *tmp = NULL;\n\tstruct ulist *roots = NULL;\n\tstruct ulist_iterator uiter;\n\tstruct ulist_node *node;\n\tstruct seq_list elem = {};\n\tint ret = 0;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\troots = ulist_alloc(GFP_NOFS);\n\tif (!tmp || !roots) {\n\t\tulist_free(tmp);\n\t\tulist_free(roots);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (trans)\n\t\tbtrfs_get_tree_mod_seq(fs_info, &elem);\n\telse\n\t\tdown_read(&fs_info->commit_root_sem);\n\tULIST_ITER_INIT(&uiter);\n\twhile (1) {\n\t\tret = find_parent_nodes(trans, fs_info, bytenr, elem.seq, tmp,\n\t\t\t\t\troots, NULL, root_objectid, inum);\n\t\tif (ret == BACKREF_FOUND_SHARED) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret < 0 && ret != -ENOENT)\n\t\t\tbreak;\n\t\tnode = ulist_next(tmp, &uiter);\n\t\tif (!node)\n\t\t\tbreak;\n\t\tbytenr = node->val;\n\t\tcond_resched();\n\t}\n\tif (trans)\n\t\tbtrfs_put_tree_mod_seq(fs_info, &elem);\n\telse\n\t\tup_read(&fs_info->commit_root_sem);\n\tulist_free(tmp);\n\tulist_free(roots);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_find_all_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1187-1199",
    "snippet": "int btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 time_seq, struct ulist **roots)\n{\n\tint ret;\n\n\tif (!trans)\n\t\tdown_read(&fs_info->commit_root_sem);\n\tret = __btrfs_find_all_roots(trans, fs_info, bytenr, time_seq, roots);\n\tif (!trans)\n\t\tup_read(&fs_info->commit_root_sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&fs_info->commit_root_sem"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__btrfs_find_all_roots",
          "args": [
            "trans",
            "fs_info",
            "bytenr",
            "time_seq",
            "roots"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_find_all_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1149-1185",
          "snippet": "static int __btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t\t  u64 time_seq, struct ulist **roots)\n{\n\tstruct ulist *tmp;\n\tstruct ulist_node *node = NULL;\n\tstruct ulist_iterator uiter;\n\tint ret;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\t*roots = ulist_alloc(GFP_NOFS);\n\tif (!*roots) {\n\t\tulist_free(tmp);\n\t\treturn -ENOMEM;\n\t}\n\n\tULIST_ITER_INIT(&uiter);\n\twhile (1) {\n\t\tret = find_parent_nodes(trans, fs_info, bytenr,\n\t\t\t\t\ttime_seq, tmp, *roots, NULL, 0, 0);\n\t\tif (ret < 0 && ret != -ENOENT) {\n\t\t\tulist_free(tmp);\n\t\t\tulist_free(*roots);\n\t\t\treturn ret;\n\t\t}\n\t\tnode = ulist_next(tmp, &uiter);\n\t\tif (!node)\n\t\t\tbreak;\n\t\tbytenr = node->val;\n\t\tcond_resched();\n\t}\n\n\tulist_free(tmp);\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int __btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t\t  u64 time_seq, struct ulist **roots)\n{\n\tstruct ulist *tmp;\n\tstruct ulist_node *node = NULL;\n\tstruct ulist_iterator uiter;\n\tint ret;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\t*roots = ulist_alloc(GFP_NOFS);\n\tif (!*roots) {\n\t\tulist_free(tmp);\n\t\treturn -ENOMEM;\n\t}\n\n\tULIST_ITER_INIT(&uiter);\n\twhile (1) {\n\t\tret = find_parent_nodes(trans, fs_info, bytenr,\n\t\t\t\t\ttime_seq, tmp, *roots, NULL, 0, 0);\n\t\tif (ret < 0 && ret != -ENOENT) {\n\t\t\tulist_free(tmp);\n\t\t\tulist_free(*roots);\n\t\t\treturn ret;\n\t\t}\n\t\tnode = ulist_next(tmp, &uiter);\n\t\tif (!node)\n\t\t\tbreak;\n\t\tbytenr = node->val;\n\t\tcond_resched();\n\t}\n\n\tulist_free(tmp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&fs_info->commit_root_sem"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nint btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t u64 time_seq, struct ulist **roots)\n{\n\tint ret;\n\n\tif (!trans)\n\t\tdown_read(&fs_info->commit_root_sem);\n\tret = __btrfs_find_all_roots(trans, fs_info, bytenr, time_seq, roots);\n\tif (!trans)\n\t\tup_read(&fs_info->commit_root_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "__btrfs_find_all_roots",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1149-1185",
    "snippet": "static int __btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t\t  u64 time_seq, struct ulist **roots)\n{\n\tstruct ulist *tmp;\n\tstruct ulist_node *node = NULL;\n\tstruct ulist_iterator uiter;\n\tint ret;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\t*roots = ulist_alloc(GFP_NOFS);\n\tif (!*roots) {\n\t\tulist_free(tmp);\n\t\treturn -ENOMEM;\n\t}\n\n\tULIST_ITER_INIT(&uiter);\n\twhile (1) {\n\t\tret = find_parent_nodes(trans, fs_info, bytenr,\n\t\t\t\t\ttime_seq, tmp, *roots, NULL, 0, 0);\n\t\tif (ret < 0 && ret != -ENOENT) {\n\t\t\tulist_free(tmp);\n\t\t\tulist_free(*roots);\n\t\t\treturn ret;\n\t\t}\n\t\tnode = ulist_next(tmp, &uiter);\n\t\tif (!node)\n\t\t\tbreak;\n\t\tbytenr = node->val;\n\t\tcond_resched();\n\t}\n\n\tulist_free(tmp);\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "tmp"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "tmp",
            "&uiter"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_parent_nodes",
          "args": [
            "trans",
            "fs_info",
            "bytenr",
            "time_seq",
            "tmp",
            "*roots",
            "NULL",
            "0",
            "0"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "92-102",
          "snippet": "struct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int __btrfs_find_all_roots(struct btrfs_trans_handle *trans,\n\t\t\t\t  struct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t\t  u64 time_seq, struct ulist **roots)\n{\n\tstruct ulist *tmp;\n\tstruct ulist_node *node = NULL;\n\tstruct ulist_iterator uiter;\n\tint ret;\n\n\ttmp = ulist_alloc(GFP_NOFS);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\t*roots = ulist_alloc(GFP_NOFS);\n\tif (!*roots) {\n\t\tulist_free(tmp);\n\t\treturn -ENOMEM;\n\t}\n\n\tULIST_ITER_INIT(&uiter);\n\twhile (1) {\n\t\tret = find_parent_nodes(trans, fs_info, bytenr,\n\t\t\t\t\ttime_seq, tmp, *roots, NULL, 0, 0);\n\t\tif (ret < 0 && ret != -ENOENT) {\n\t\t\tulist_free(tmp);\n\t\t\tulist_free(*roots);\n\t\t\treturn ret;\n\t\t}\n\t\tnode = ulist_next(tmp, &uiter);\n\t\tif (!node)\n\t\t\tbreak;\n\t\tbytenr = node->val;\n\t\tcond_resched();\n\t}\n\n\tulist_free(tmp);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_find_all_leafs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1115-1134",
    "snippet": "static int btrfs_find_all_leafs(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t\tu64 time_seq, struct ulist **leafs,\n\t\t\t\tconst u64 *extent_item_pos)\n{\n\tint ret;\n\n\t*leafs = ulist_alloc(GFP_NOFS);\n\tif (!*leafs)\n\t\treturn -ENOMEM;\n\n\tret = find_parent_nodes(trans, fs_info, bytenr,\n\t\t\t\ttime_seq, *leafs, NULL, extent_item_pos, 0, 0);\n\tif (ret < 0 && ret != -ENOENT) {\n\t\tfree_leaf_list(*leafs);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_leaf_list",
          "args": [
            "*leafs"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "free_leaf_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "1089-1105",
          "snippet": "static void free_leaf_list(struct ulist *blocks)\n{\n\tstruct ulist_node *node = NULL;\n\tstruct extent_inode_elem *eie;\n\tstruct ulist_iterator uiter;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((node = ulist_next(blocks, &uiter))) {\n\t\tif (!node->aux)\n\t\t\tcontinue;\n\t\teie = (struct extent_inode_elem *)(uintptr_t)node->aux;\n\t\tfree_inode_elem_list(eie);\n\t\tnode->aux = 0;\n\t}\n\n\tulist_free(blocks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic void free_leaf_list(struct ulist *blocks)\n{\n\tstruct ulist_node *node = NULL;\n\tstruct extent_inode_elem *eie;\n\tstruct ulist_iterator uiter;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((node = ulist_next(blocks, &uiter))) {\n\t\tif (!node->aux)\n\t\t\tcontinue;\n\t\teie = (struct extent_inode_elem *)(uintptr_t)node->aux;\n\t\tfree_inode_elem_list(eie);\n\t\tnode->aux = 0;\n\t}\n\n\tulist_free(blocks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_parent_nodes",
          "args": [
            "trans",
            "fs_info",
            "bytenr",
            "time_seq",
            "*leafs",
            "NULL",
            "extent_item_pos",
            "0",
            "0"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "92-102",
          "snippet": "struct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int btrfs_find_all_leafs(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_fs_info *fs_info, u64 bytenr,\n\t\t\t\tu64 time_seq, struct ulist **leafs,\n\t\t\t\tconst u64 *extent_item_pos)\n{\n\tint ret;\n\n\t*leafs = ulist_alloc(GFP_NOFS);\n\tif (!*leafs)\n\t\treturn -ENOMEM;\n\n\tret = find_parent_nodes(trans, fs_info, bytenr,\n\t\t\t\ttime_seq, *leafs, NULL, extent_item_pos, 0, 0);\n\tif (ret < 0 && ret != -ENOENT) {\n\t\tfree_leaf_list(*leafs);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_leaf_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "1089-1105",
    "snippet": "static void free_leaf_list(struct ulist *blocks)\n{\n\tstruct ulist_node *node = NULL;\n\tstruct extent_inode_elem *eie;\n\tstruct ulist_iterator uiter;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((node = ulist_next(blocks, &uiter))) {\n\t\tif (!node->aux)\n\t\t\tcontinue;\n\t\teie = (struct extent_inode_elem *)(uintptr_t)node->aux;\n\t\tfree_inode_elem_list(eie);\n\t\tnode->aux = 0;\n\t}\n\n\tulist_free(blocks);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "blocks"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_inode_elem_list",
          "args": [
            "eie"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "free_inode_elem_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "72-80",
          "snippet": "static void free_inode_elem_list(struct extent_inode_elem *eie)\n{\n\tstruct extent_inode_elem *eie_next;\n\n\tfor (; eie; eie = eie_next) {\n\t\teie_next = eie->next;\n\t\tkfree(eie);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic void free_inode_elem_list(struct extent_inode_elem *eie)\n{\n\tstruct extent_inode_elem *eie_next;\n\n\tfor (; eie; eie = eie_next) {\n\t\teie_next = eie->next;\n\t\tkfree(eie);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "blocks",
            "&uiter"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic void free_leaf_list(struct ulist *blocks)\n{\n\tstruct ulist_node *node = NULL;\n\tstruct extent_inode_elem *eie;\n\tstruct ulist_iterator uiter;\n\n\tULIST_ITER_INIT(&uiter);\n\twhile ((node = ulist_next(blocks, &uiter))) {\n\t\tif (!node->aux)\n\t\t\tcontinue;\n\t\teie = (struct extent_inode_elem *)(uintptr_t)node->aux;\n\t\tfree_inode_elem_list(eie);\n\t\tnode->aux = 0;\n\t}\n\n\tulist_free(blocks);\n}"
  },
  {
    "function_name": "__add_keyed_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "791-875",
    "snippet": "static int __add_keyed_refs(struct btrfs_fs_info *fs_info,\n\t\t\t    struct btrfs_path *path, u64 bytenr,\n\t\t\t    int info_level, struct list_head *prefs, u64 inum)\n{\n\tstruct btrfs_root *extent_root = fs_info->extent_root;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\twhile (1) {\n\t\tret = btrfs_next_item(extent_root, path);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\tif (key.objectid != bytenr)\n\t\t\tbreak;\n\t\tif (key.type < BTRFS_TREE_BLOCK_REF_KEY)\n\t\t\tcontinue;\n\t\tif (key.type > BTRFS_SHARED_DATA_REF_KEY)\n\t\t\tbreak;\n\n\t\tswitch (key.type) {\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tret = __add_prelim_ref(prefs, 0, NULL,\n\t\t\t\t\t\tinfo_level + 1, key.offset,\n\t\t\t\t\t\tbytenr, 1, GFP_NOFS);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY: {\n\t\t\tstruct btrfs_shared_data_ref *sdref;\n\t\t\tint count;\n\n\t\t\tsdref = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t      struct btrfs_shared_data_ref);\n\t\t\tcount = btrfs_shared_data_ref_count(leaf, sdref);\n\t\t\tret = __add_prelim_ref(prefs, 0, NULL, 0, key.offset,\n\t\t\t\t\t\tbytenr, count, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tret = __add_prelim_ref(prefs, key.offset, NULL,\n\t\t\t\t\t       info_level + 1, 0,\n\t\t\t\t\t       bytenr, 1, GFP_NOFS);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY: {\n\t\t\tstruct btrfs_extent_data_ref *dref;\n\t\t\tint count;\n\t\t\tu64 root;\n\n\t\t\tdref = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t      struct btrfs_extent_data_ref);\n\t\t\tcount = btrfs_extent_data_ref_count(leaf, dref);\n\t\t\tkey.objectid = btrfs_extent_data_ref_objectid(leaf,\n\t\t\t\t\t\t\t\t      dref);\n\t\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\t\tkey.offset = btrfs_extent_data_ref_offset(leaf, dref);\n\n\t\t\tif (inum && key.objectid != inum) {\n\t\t\t\tret = BACKREF_FOUND_SHARED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\troot = btrfs_extent_data_ref_root(leaf, dref);\n\t\t\tret = __add_prelim_ref(prefs, root, &key, 0, 0,\n\t\t\t\t\t       bytenr, count, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define BACKREF_FOUND_SHARED 6"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_prelim_ref",
          "args": [
            "prefs",
            "root",
            "&key",
            "0",
            "0",
            "bytenr",
            "count",
            "GFP_NOFS"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "__add_prelim_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "194-222",
          "snippet": "static int __add_prelim_ref(struct list_head *head, u64 root_id,\n\t\t\t    struct btrfs_key *key, int level,\n\t\t\t    u64 parent, u64 wanted_disk_byte, int count,\n\t\t\t    gfp_t gfp_mask)\n{\n\tstruct __prelim_ref *ref;\n\n\tif (root_id == BTRFS_DATA_RELOC_TREE_OBJECTID)\n\t\treturn 0;\n\n\tref = kmem_cache_alloc(btrfs_prelim_ref_cache, gfp_mask);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->root_id = root_id;\n\tif (key)\n\t\tref->key_for_search = *key;\n\telse\n\t\tmemset(&ref->key_for_search, 0, sizeof(ref->key_for_search));\n\n\tref->inode_list = NULL;\n\tref->level = level;\n\tref->count = count;\n\tref->parent = parent;\n\tref->wanted_disk_byte = wanted_disk_byte;\n\tlist_add_tail(&ref->list, head);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_prelim_ref_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic struct kmem_cache *btrfs_prelim_ref_cache;\n\nstatic int __add_prelim_ref(struct list_head *head, u64 root_id,\n\t\t\t    struct btrfs_key *key, int level,\n\t\t\t    u64 parent, u64 wanted_disk_byte, int count,\n\t\t\t    gfp_t gfp_mask)\n{\n\tstruct __prelim_ref *ref;\n\n\tif (root_id == BTRFS_DATA_RELOC_TREE_OBJECTID)\n\t\treturn 0;\n\n\tref = kmem_cache_alloc(btrfs_prelim_ref_cache, gfp_mask);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->root_id = root_id;\n\tif (key)\n\t\tref->key_for_search = *key;\n\telse\n\t\tmemset(&ref->key_for_search, 0, sizeof(ref->key_for_search));\n\n\tref->inode_list = NULL;\n\tref->level = level;\n\tref->count = count;\n\tref->parent = parent;\n\tref->wanted_disk_byte = wanted_disk_byte;\n\tlist_add_tail(&ref->list, head);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_extent_data_ref_root",
          "args": [
            "leaf",
            "dref"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_data_ref_offset",
          "args": [
            "leaf",
            "dref"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_data_ref_objectid",
          "args": [
            "leaf",
            "dref"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_data_ref_count",
          "args": [
            "leaf",
            "dref"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_extent_data_ref"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_shared_data_ref_count",
          "args": [
            "leaf",
            "sdref"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_shared_data_ref"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&key",
            "slot"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_item",
          "args": [
            "extent_root",
            "path"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3600-3603",
          "snippet": "static inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_next_item(struct btrfs_root *root, struct btrfs_path *p)\n{\n\treturn btrfs_next_old_item(root, p, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\n#define BACKREF_FOUND_SHARED 6\n\nstatic int __add_keyed_refs(struct btrfs_fs_info *fs_info,\n\t\t\t    struct btrfs_path *path, u64 bytenr,\n\t\t\t    int info_level, struct list_head *prefs, u64 inum)\n{\n\tstruct btrfs_root *extent_root = fs_info->extent_root;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\n\twhile (1) {\n\t\tret = btrfs_next_item(extent_root, path);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (ret) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tslot = path->slots[0];\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, slot);\n\n\t\tif (key.objectid != bytenr)\n\t\t\tbreak;\n\t\tif (key.type < BTRFS_TREE_BLOCK_REF_KEY)\n\t\t\tcontinue;\n\t\tif (key.type > BTRFS_SHARED_DATA_REF_KEY)\n\t\t\tbreak;\n\n\t\tswitch (key.type) {\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tret = __add_prelim_ref(prefs, 0, NULL,\n\t\t\t\t\t\tinfo_level + 1, key.offset,\n\t\t\t\t\t\tbytenr, 1, GFP_NOFS);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY: {\n\t\t\tstruct btrfs_shared_data_ref *sdref;\n\t\t\tint count;\n\n\t\t\tsdref = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t      struct btrfs_shared_data_ref);\n\t\t\tcount = btrfs_shared_data_ref_count(leaf, sdref);\n\t\t\tret = __add_prelim_ref(prefs, 0, NULL, 0, key.offset,\n\t\t\t\t\t\tbytenr, count, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tret = __add_prelim_ref(prefs, key.offset, NULL,\n\t\t\t\t\t       info_level + 1, 0,\n\t\t\t\t\t       bytenr, 1, GFP_NOFS);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY: {\n\t\t\tstruct btrfs_extent_data_ref *dref;\n\t\t\tint count;\n\t\t\tu64 root;\n\n\t\t\tdref = btrfs_item_ptr(leaf, slot,\n\t\t\t\t\t      struct btrfs_extent_data_ref);\n\t\t\tcount = btrfs_extent_data_ref_count(leaf, dref);\n\t\t\tkey.objectid = btrfs_extent_data_ref_objectid(leaf,\n\t\t\t\t\t\t\t\t      dref);\n\t\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\t\tkey.offset = btrfs_extent_data_ref_offset(leaf, dref);\n\n\t\t\tif (inum && key.objectid != inum) {\n\t\t\t\tret = BACKREF_FOUND_SHARED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\troot = btrfs_extent_data_ref_root(leaf, dref);\n\t\t\tret = __add_prelim_ref(prefs, root, &key, 0, 0,\n\t\t\t\t\t       bytenr, count, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__add_inline_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "678-786",
    "snippet": "static int __add_inline_refs(struct btrfs_fs_info *fs_info,\n\t\t\t     struct btrfs_path *path, u64 bytenr,\n\t\t\t     int *info_level, struct list_head *prefs,\n\t\t\t     u64 *total_refs, u64 inum)\n{\n\tint ret = 0;\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tunsigned long ptr;\n\tunsigned long end;\n\tstruct btrfs_extent_item *ei;\n\tu64 flags;\n\tu64 item_size;\n\n\t/*\n\t * enumerate all inline refs\n\t */\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\titem_size = btrfs_item_size_nr(leaf, slot);\n\tBUG_ON(item_size < sizeof(*ei));\n\n\tei = btrfs_item_ptr(leaf, slot, struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(leaf, ei);\n\t*total_refs += btrfs_extent_refs(leaf, ei);\n\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\tptr = (unsigned long)(ei + 1);\n\tend = (unsigned long)ei + item_size;\n\n\tif (found_key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t    flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tstruct btrfs_tree_block_info *info;\n\n\t\tinfo = (struct btrfs_tree_block_info *)ptr;\n\t\t*info_level = btrfs_tree_block_level(leaf, info);\n\t\tptr += sizeof(struct btrfs_tree_block_info);\n\t\tBUG_ON(ptr > end);\n\t} else if (found_key.type == BTRFS_METADATA_ITEM_KEY) {\n\t\t*info_level = found_key.offset;\n\t} else {\n\t\tBUG_ON(!(flags & BTRFS_EXTENT_FLAG_DATA));\n\t}\n\n\twhile (ptr < end) {\n\t\tstruct btrfs_extent_inline_ref *iref;\n\t\tu64 offset;\n\t\tint type;\n\n\t\tiref = (struct btrfs_extent_inline_ref *)ptr;\n\t\ttype = btrfs_extent_inline_ref_type(leaf, iref);\n\t\toffset = btrfs_extent_inline_ref_offset(leaf, iref);\n\n\t\tswitch (type) {\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tret = __add_prelim_ref(prefs, 0, NULL,\n\t\t\t\t\t\t*info_level + 1, offset,\n\t\t\t\t\t\tbytenr, 1, GFP_NOFS);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY: {\n\t\t\tstruct btrfs_shared_data_ref *sdref;\n\t\t\tint count;\n\n\t\t\tsdref = (struct btrfs_shared_data_ref *)(iref + 1);\n\t\t\tcount = btrfs_shared_data_ref_count(leaf, sdref);\n\t\t\tret = __add_prelim_ref(prefs, 0, NULL, 0, offset,\n\t\t\t\t\t       bytenr, count, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tret = __add_prelim_ref(prefs, offset, NULL,\n\t\t\t\t\t       *info_level + 1, 0,\n\t\t\t\t\t       bytenr, 1, GFP_NOFS);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY: {\n\t\t\tstruct btrfs_extent_data_ref *dref;\n\t\t\tint count;\n\t\t\tu64 root;\n\n\t\t\tdref = (struct btrfs_extent_data_ref *)(&iref->offset);\n\t\t\tcount = btrfs_extent_data_ref_count(leaf, dref);\n\t\t\tkey.objectid = btrfs_extent_data_ref_objectid(leaf,\n\t\t\t\t\t\t\t\t      dref);\n\t\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\t\tkey.offset = btrfs_extent_data_ref_offset(leaf, dref);\n\n\t\t\tif (inum && key.objectid != inum) {\n\t\t\t\tret = BACKREF_FOUND_SHARED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\troot = btrfs_extent_data_ref_root(leaf, dref);\n\t\t\tret = __add_prelim_ref(prefs, root, &key, 0, 0,\n\t\t\t\t\t       bytenr, count, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tptr += btrfs_extent_inline_ref_size(type);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define BACKREF_FOUND_SHARED 6"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_extent_inline_ref_size",
          "args": [
            "type"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_extent_inline_ref_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2535-2548",
          "snippet": "static inline u32 btrfs_extent_inline_ref_size(int type)\n{\n\tif (type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t    type == BTRFS_SHARED_BLOCK_REF_KEY)\n\t\treturn sizeof(struct btrfs_extent_inline_ref);\n\tif (type == BTRFS_SHARED_DATA_REF_KEY)\n\t\treturn sizeof(struct btrfs_shared_data_ref) +\n\t\t       sizeof(struct btrfs_extent_inline_ref);\n\tif (type == BTRFS_EXTENT_DATA_REF_KEY)\n\t\treturn sizeof(struct btrfs_extent_data_ref) +\n\t\t       offsetof(struct btrfs_extent_inline_ref, offset);\n\tBUG();\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [
            "#define BTRFS_SHARED_DATA_REF_KEY\t184",
            "#define BTRFS_SHARED_BLOCK_REF_KEY\t182",
            "#define BTRFS_EXTENT_DATA_REF_KEY\t178",
            "#define BTRFS_TREE_BLOCK_REF_KEY\t176"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\n#define BTRFS_SHARED_DATA_REF_KEY\t184\n#define BTRFS_SHARED_BLOCK_REF_KEY\t182\n#define BTRFS_EXTENT_DATA_REF_KEY\t178\n#define BTRFS_TREE_BLOCK_REF_KEY\t176\n\nstatic inline u32 btrfs_extent_inline_ref_size(int type)\n{\n\tif (type == BTRFS_TREE_BLOCK_REF_KEY ||\n\t    type == BTRFS_SHARED_BLOCK_REF_KEY)\n\t\treturn sizeof(struct btrfs_extent_inline_ref);\n\tif (type == BTRFS_SHARED_DATA_REF_KEY)\n\t\treturn sizeof(struct btrfs_shared_data_ref) +\n\t\t       sizeof(struct btrfs_extent_inline_ref);\n\tif (type == BTRFS_EXTENT_DATA_REF_KEY)\n\t\treturn sizeof(struct btrfs_extent_data_ref) +\n\t\t       offsetof(struct btrfs_extent_inline_ref, offset);\n\tBUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_prelim_ref",
          "args": [
            "prefs",
            "root",
            "&key",
            "0",
            "0",
            "bytenr",
            "count",
            "GFP_NOFS"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "__add_prelim_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "194-222",
          "snippet": "static int __add_prelim_ref(struct list_head *head, u64 root_id,\n\t\t\t    struct btrfs_key *key, int level,\n\t\t\t    u64 parent, u64 wanted_disk_byte, int count,\n\t\t\t    gfp_t gfp_mask)\n{\n\tstruct __prelim_ref *ref;\n\n\tif (root_id == BTRFS_DATA_RELOC_TREE_OBJECTID)\n\t\treturn 0;\n\n\tref = kmem_cache_alloc(btrfs_prelim_ref_cache, gfp_mask);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->root_id = root_id;\n\tif (key)\n\t\tref->key_for_search = *key;\n\telse\n\t\tmemset(&ref->key_for_search, 0, sizeof(ref->key_for_search));\n\n\tref->inode_list = NULL;\n\tref->level = level;\n\tref->count = count;\n\tref->parent = parent;\n\tref->wanted_disk_byte = wanted_disk_byte;\n\tlist_add_tail(&ref->list, head);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_prelim_ref_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic struct kmem_cache *btrfs_prelim_ref_cache;\n\nstatic int __add_prelim_ref(struct list_head *head, u64 root_id,\n\t\t\t    struct btrfs_key *key, int level,\n\t\t\t    u64 parent, u64 wanted_disk_byte, int count,\n\t\t\t    gfp_t gfp_mask)\n{\n\tstruct __prelim_ref *ref;\n\n\tif (root_id == BTRFS_DATA_RELOC_TREE_OBJECTID)\n\t\treturn 0;\n\n\tref = kmem_cache_alloc(btrfs_prelim_ref_cache, gfp_mask);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->root_id = root_id;\n\tif (key)\n\t\tref->key_for_search = *key;\n\telse\n\t\tmemset(&ref->key_for_search, 0, sizeof(ref->key_for_search));\n\n\tref->inode_list = NULL;\n\tref->level = level;\n\tref->count = count;\n\tref->parent = parent;\n\tref->wanted_disk_byte = wanted_disk_byte;\n\tlist_add_tail(&ref->list, head);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_extent_data_ref_root",
          "args": [
            "leaf",
            "dref"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_data_ref_offset",
          "args": [
            "leaf",
            "dref"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_data_ref_objectid",
          "args": [
            "leaf",
            "dref"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_data_ref_count",
          "args": [
            "leaf",
            "dref"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_shared_data_ref_count",
          "args": [
            "leaf",
            "sdref"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_inline_ref_offset",
          "args": [
            "leaf",
            "iref"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_inline_ref_type",
          "args": [
            "leaf",
            "iref"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(flags & BTRFS_EXTENT_FLAG_DATA)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ptr > end"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_tree_block_level",
          "args": [
            "leaf",
            "info"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "leaf",
            "&found_key",
            "slot"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_extent_refs",
          "args": [
            "leaf",
            "ei"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_extent_flags",
          "args": [
            "leaf",
            "ei"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "leaf",
            "slot",
            "structbtrfs_extent_item"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "item_size < sizeof(*ei)"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_size_nr",
          "args": [
            "leaf",
            "slot"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_size_nr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2649-2652",
          "snippet": "static inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u32 btrfs_item_size_nr(struct extent_buffer *eb, int nr)\n{\n\treturn btrfs_item_size(eb, btrfs_item_nr(nr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\n#define BACKREF_FOUND_SHARED 6\n\nstatic int __add_inline_refs(struct btrfs_fs_info *fs_info,\n\t\t\t     struct btrfs_path *path, u64 bytenr,\n\t\t\t     int *info_level, struct list_head *prefs,\n\t\t\t     u64 *total_refs, u64 inum)\n{\n\tint ret = 0;\n\tint slot;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tunsigned long ptr;\n\tunsigned long end;\n\tstruct btrfs_extent_item *ei;\n\tu64 flags;\n\tu64 item_size;\n\n\t/*\n\t * enumerate all inline refs\n\t */\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\n\titem_size = btrfs_item_size_nr(leaf, slot);\n\tBUG_ON(item_size < sizeof(*ei));\n\n\tei = btrfs_item_ptr(leaf, slot, struct btrfs_extent_item);\n\tflags = btrfs_extent_flags(leaf, ei);\n\t*total_refs += btrfs_extent_refs(leaf, ei);\n\tbtrfs_item_key_to_cpu(leaf, &found_key, slot);\n\n\tptr = (unsigned long)(ei + 1);\n\tend = (unsigned long)ei + item_size;\n\n\tif (found_key.type == BTRFS_EXTENT_ITEM_KEY &&\n\t    flags & BTRFS_EXTENT_FLAG_TREE_BLOCK) {\n\t\tstruct btrfs_tree_block_info *info;\n\n\t\tinfo = (struct btrfs_tree_block_info *)ptr;\n\t\t*info_level = btrfs_tree_block_level(leaf, info);\n\t\tptr += sizeof(struct btrfs_tree_block_info);\n\t\tBUG_ON(ptr > end);\n\t} else if (found_key.type == BTRFS_METADATA_ITEM_KEY) {\n\t\t*info_level = found_key.offset;\n\t} else {\n\t\tBUG_ON(!(flags & BTRFS_EXTENT_FLAG_DATA));\n\t}\n\n\twhile (ptr < end) {\n\t\tstruct btrfs_extent_inline_ref *iref;\n\t\tu64 offset;\n\t\tint type;\n\n\t\tiref = (struct btrfs_extent_inline_ref *)ptr;\n\t\ttype = btrfs_extent_inline_ref_type(leaf, iref);\n\t\toffset = btrfs_extent_inline_ref_offset(leaf, iref);\n\n\t\tswitch (type) {\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY:\n\t\t\tret = __add_prelim_ref(prefs, 0, NULL,\n\t\t\t\t\t\t*info_level + 1, offset,\n\t\t\t\t\t\tbytenr, 1, GFP_NOFS);\n\t\t\tbreak;\n\t\tcase BTRFS_SHARED_DATA_REF_KEY: {\n\t\t\tstruct btrfs_shared_data_ref *sdref;\n\t\t\tint count;\n\n\t\t\tsdref = (struct btrfs_shared_data_ref *)(iref + 1);\n\t\t\tcount = btrfs_shared_data_ref_count(leaf, sdref);\n\t\t\tret = __add_prelim_ref(prefs, 0, NULL, 0, offset,\n\t\t\t\t\t       bytenr, count, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY:\n\t\t\tret = __add_prelim_ref(prefs, offset, NULL,\n\t\t\t\t\t       *info_level + 1, 0,\n\t\t\t\t\t       bytenr, 1, GFP_NOFS);\n\t\t\tbreak;\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY: {\n\t\t\tstruct btrfs_extent_data_ref *dref;\n\t\t\tint count;\n\t\t\tu64 root;\n\n\t\t\tdref = (struct btrfs_extent_data_ref *)(&iref->offset);\n\t\t\tcount = btrfs_extent_data_ref_count(leaf, dref);\n\t\t\tkey.objectid = btrfs_extent_data_ref_objectid(leaf,\n\t\t\t\t\t\t\t\t      dref);\n\t\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\t\tkey.offset = btrfs_extent_data_ref_offset(leaf, dref);\n\n\t\t\tif (inum && key.objectid != inum) {\n\t\t\t\tret = BACKREF_FOUND_SHARED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\troot = btrfs_extent_data_ref_root(leaf, dref);\n\t\t\tret = __add_prelim_ref(prefs, root, &key, 0, 0,\n\t\t\t\t\t       bytenr, count, GFP_NOFS);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tptr += btrfs_extent_inline_ref_size(type);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__add_delayed_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "571-673",
    "snippet": "static int __add_delayed_refs(struct btrfs_delayed_ref_head *head, u64 seq,\n\t\t\t      struct list_head *prefs, u64 *total_refs,\n\t\t\t      u64 inum)\n{\n\tstruct btrfs_delayed_extent_op *extent_op = head->extent_op;\n\tstruct rb_node *n = &head->node.rb_node;\n\tstruct btrfs_key key;\n\tstruct btrfs_key op_key = {0};\n\tint sgn;\n\tint ret = 0;\n\n\tif (extent_op && extent_op->update_key)\n\t\tbtrfs_disk_key_to_cpu(&op_key, &extent_op->key);\n\n\tspin_lock(&head->lock);\n\tn = rb_first(&head->ref_root);\n\twhile (n) {\n\t\tstruct btrfs_delayed_ref_node *node;\n\t\tnode = rb_entry(n, struct btrfs_delayed_ref_node,\n\t\t\t\trb_node);\n\t\tn = rb_next(n);\n\t\tif (node->seq > seq)\n\t\t\tcontinue;\n\n\t\tswitch (node->action) {\n\t\tcase BTRFS_ADD_DELAYED_EXTENT:\n\t\tcase BTRFS_UPDATE_DELAYED_HEAD:\n\t\t\tWARN_ON(1);\n\t\t\tcontinue;\n\t\tcase BTRFS_ADD_DELAYED_REF:\n\t\t\tsgn = 1;\n\t\t\tbreak;\n\t\tcase BTRFS_DROP_DELAYED_REF:\n\t\t\tsgn = -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t*total_refs += (node->ref_mod * sgn);\n\t\tswitch (node->type) {\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY: {\n\t\t\tstruct btrfs_delayed_tree_ref *ref;\n\n\t\t\tref = btrfs_delayed_node_to_tree_ref(node);\n\t\t\tret = __add_prelim_ref(prefs, ref->root, &op_key,\n\t\t\t\t\t       ref->level + 1, 0, node->bytenr,\n\t\t\t\t\t       node->ref_mod * sgn, GFP_ATOMIC);\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY: {\n\t\t\tstruct btrfs_delayed_tree_ref *ref;\n\n\t\t\tref = btrfs_delayed_node_to_tree_ref(node);\n\t\t\tret = __add_prelim_ref(prefs, ref->root, NULL,\n\t\t\t\t\t       ref->level + 1, ref->parent,\n\t\t\t\t\t       node->bytenr,\n\t\t\t\t\t       node->ref_mod * sgn, GFP_ATOMIC);\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY: {\n\t\t\tstruct btrfs_delayed_data_ref *ref;\n\t\t\tref = btrfs_delayed_node_to_data_ref(node);\n\n\t\t\tkey.objectid = ref->objectid;\n\t\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\t\tkey.offset = ref->offset;\n\n\t\t\t/*\n\t\t\t * Found a inum that doesn't match our known inum, we\n\t\t\t * know it's shared.\n\t\t\t */\n\t\t\tif (inum && ref->objectid != inum) {\n\t\t\t\tret = BACKREF_FOUND_SHARED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = __add_prelim_ref(prefs, ref->root, &key, 0, 0,\n\t\t\t\t\t       node->bytenr,\n\t\t\t\t\t       node->ref_mod * sgn, GFP_ATOMIC);\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_SHARED_DATA_REF_KEY: {\n\t\t\tstruct btrfs_delayed_data_ref *ref;\n\n\t\t\tref = btrfs_delayed_node_to_data_ref(node);\n\n\t\t\tkey.objectid = ref->objectid;\n\t\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\t\tkey.offset = ref->offset;\n\t\t\tret = __add_prelim_ref(prefs, ref->root, &key, 0,\n\t\t\t\t\t       ref->parent, node->bytenr,\n\t\t\t\t\t       node->ref_mod * sgn, GFP_ATOMIC);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&head->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define BACKREF_FOUND_SHARED 6"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&head->lock"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_prelim_ref",
          "args": [
            "prefs",
            "ref->root",
            "&key",
            "0",
            "ref->parent",
            "node->bytenr",
            "node->ref_mod * sgn",
            "GFP_ATOMIC"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "__add_prelim_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "194-222",
          "snippet": "static int __add_prelim_ref(struct list_head *head, u64 root_id,\n\t\t\t    struct btrfs_key *key, int level,\n\t\t\t    u64 parent, u64 wanted_disk_byte, int count,\n\t\t\t    gfp_t gfp_mask)\n{\n\tstruct __prelim_ref *ref;\n\n\tif (root_id == BTRFS_DATA_RELOC_TREE_OBJECTID)\n\t\treturn 0;\n\n\tref = kmem_cache_alloc(btrfs_prelim_ref_cache, gfp_mask);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->root_id = root_id;\n\tif (key)\n\t\tref->key_for_search = *key;\n\telse\n\t\tmemset(&ref->key_for_search, 0, sizeof(ref->key_for_search));\n\n\tref->inode_list = NULL;\n\tref->level = level;\n\tref->count = count;\n\tref->parent = parent;\n\tref->wanted_disk_byte = wanted_disk_byte;\n\tlist_add_tail(&ref->list, head);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_prelim_ref_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic struct kmem_cache *btrfs_prelim_ref_cache;\n\nstatic int __add_prelim_ref(struct list_head *head, u64 root_id,\n\t\t\t    struct btrfs_key *key, int level,\n\t\t\t    u64 parent, u64 wanted_disk_byte, int count,\n\t\t\t    gfp_t gfp_mask)\n{\n\tstruct __prelim_ref *ref;\n\n\tif (root_id == BTRFS_DATA_RELOC_TREE_OBJECTID)\n\t\treturn 0;\n\n\tref = kmem_cache_alloc(btrfs_prelim_ref_cache, gfp_mask);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->root_id = root_id;\n\tif (key)\n\t\tref->key_for_search = *key;\n\telse\n\t\tmemset(&ref->key_for_search, 0, sizeof(ref->key_for_search));\n\n\tref->inode_list = NULL;\n\tref->level = level;\n\tref->count = count;\n\tref->parent = parent;\n\tref->wanted_disk_byte = wanted_disk_byte;\n\tlist_add_tail(&ref->list, head);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_node_to_data_ref",
          "args": [
            "node"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_node_to_data_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "253-258",
          "snippet": "static inline struct btrfs_delayed_data_ref *\nbtrfs_delayed_node_to_data_ref(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_data_ref, node);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_delayed_data_ref *\nbtrfs_delayed_node_to_data_ref(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_data_ref, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_node_to_tree_ref",
          "args": [
            "node"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_node_to_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.h",
          "lines": "246-251",
          "snippet": "static inline struct btrfs_delayed_tree_ref *\nbtrfs_delayed_node_to_tree_ref(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_tree_ref, node);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_delayed_tree_ref *\nbtrfs_delayed_node_to_tree_ref(struct btrfs_delayed_ref_node *node)\n{\n\tWARN_ON(btrfs_delayed_ref_is_head(node));\n\treturn container_of(node, struct btrfs_delayed_tree_ref, node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "1"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structbtrfs_delayed_ref_node",
            "rb_node"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&head->ref_root"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&head->lock"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_disk_key_to_cpu",
          "args": [
            "&op_key",
            "&extent_op->key"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_disk_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2731-2737",
          "snippet": "static inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_disk_key_to_cpu(struct btrfs_key *cpu,\n\t\t\t\t\t struct btrfs_disk_key *disk)\n{\n\tcpu->offset = le64_to_cpu(disk->offset);\n\tcpu->type = disk->type;\n\tcpu->objectid = le64_to_cpu(disk->objectid);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\n#define BACKREF_FOUND_SHARED 6\n\nstatic int __add_delayed_refs(struct btrfs_delayed_ref_head *head, u64 seq,\n\t\t\t      struct list_head *prefs, u64 *total_refs,\n\t\t\t      u64 inum)\n{\n\tstruct btrfs_delayed_extent_op *extent_op = head->extent_op;\n\tstruct rb_node *n = &head->node.rb_node;\n\tstruct btrfs_key key;\n\tstruct btrfs_key op_key = {0};\n\tint sgn;\n\tint ret = 0;\n\n\tif (extent_op && extent_op->update_key)\n\t\tbtrfs_disk_key_to_cpu(&op_key, &extent_op->key);\n\n\tspin_lock(&head->lock);\n\tn = rb_first(&head->ref_root);\n\twhile (n) {\n\t\tstruct btrfs_delayed_ref_node *node;\n\t\tnode = rb_entry(n, struct btrfs_delayed_ref_node,\n\t\t\t\trb_node);\n\t\tn = rb_next(n);\n\t\tif (node->seq > seq)\n\t\t\tcontinue;\n\n\t\tswitch (node->action) {\n\t\tcase BTRFS_ADD_DELAYED_EXTENT:\n\t\tcase BTRFS_UPDATE_DELAYED_HEAD:\n\t\t\tWARN_ON(1);\n\t\t\tcontinue;\n\t\tcase BTRFS_ADD_DELAYED_REF:\n\t\t\tsgn = 1;\n\t\t\tbreak;\n\t\tcase BTRFS_DROP_DELAYED_REF:\n\t\t\tsgn = -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG_ON(1);\n\t\t}\n\t\t*total_refs += (node->ref_mod * sgn);\n\t\tswitch (node->type) {\n\t\tcase BTRFS_TREE_BLOCK_REF_KEY: {\n\t\t\tstruct btrfs_delayed_tree_ref *ref;\n\n\t\t\tref = btrfs_delayed_node_to_tree_ref(node);\n\t\t\tret = __add_prelim_ref(prefs, ref->root, &op_key,\n\t\t\t\t\t       ref->level + 1, 0, node->bytenr,\n\t\t\t\t\t       node->ref_mod * sgn, GFP_ATOMIC);\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_SHARED_BLOCK_REF_KEY: {\n\t\t\tstruct btrfs_delayed_tree_ref *ref;\n\n\t\t\tref = btrfs_delayed_node_to_tree_ref(node);\n\t\t\tret = __add_prelim_ref(prefs, ref->root, NULL,\n\t\t\t\t\t       ref->level + 1, ref->parent,\n\t\t\t\t\t       node->bytenr,\n\t\t\t\t\t       node->ref_mod * sgn, GFP_ATOMIC);\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_EXTENT_DATA_REF_KEY: {\n\t\t\tstruct btrfs_delayed_data_ref *ref;\n\t\t\tref = btrfs_delayed_node_to_data_ref(node);\n\n\t\t\tkey.objectid = ref->objectid;\n\t\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\t\tkey.offset = ref->offset;\n\n\t\t\t/*\n\t\t\t * Found a inum that doesn't match our known inum, we\n\t\t\t * know it's shared.\n\t\t\t */\n\t\t\tif (inum && ref->objectid != inum) {\n\t\t\t\tret = BACKREF_FOUND_SHARED;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = __add_prelim_ref(prefs, ref->root, &key, 0, 0,\n\t\t\t\t\t       node->bytenr,\n\t\t\t\t\t       node->ref_mod * sgn, GFP_ATOMIC);\n\t\t\tbreak;\n\t\t}\n\t\tcase BTRFS_SHARED_DATA_REF_KEY: {\n\t\t\tstruct btrfs_delayed_data_ref *ref;\n\n\t\t\tref = btrfs_delayed_node_to_data_ref(node);\n\n\t\t\tkey.objectid = ref->objectid;\n\t\t\tkey.type = BTRFS_EXTENT_DATA_KEY;\n\t\t\tkey.offset = ref->offset;\n\t\t\tret = __add_prelim_ref(prefs, ref->root, &key, 0,\n\t\t\t\t\t       ref->parent, node->bytenr,\n\t\t\t\t\t       node->ref_mod * sgn, GFP_ATOMIC);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&head->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "__merge_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "519-565",
    "snippet": "static void __merge_refs(struct list_head *head, int mode)\n{\n\tstruct list_head *pos1;\n\n\tlist_for_each(pos1, head) {\n\t\tstruct list_head *n2;\n\t\tstruct list_head *pos2;\n\t\tstruct __prelim_ref *ref1;\n\n\t\tref1 = list_entry(pos1, struct __prelim_ref, list);\n\n\t\tfor (pos2 = pos1->next, n2 = pos2->next; pos2 != head;\n\t\t     pos2 = n2, n2 = pos2->next) {\n\t\t\tstruct __prelim_ref *ref2;\n\t\t\tstruct __prelim_ref *xchg;\n\t\t\tstruct extent_inode_elem *eie;\n\n\t\t\tref2 = list_entry(pos2, struct __prelim_ref, list);\n\n\t\t\tif (mode == 1) {\n\t\t\t\tif (!ref_for_same_block(ref1, ref2))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!ref1->parent && ref2->parent) {\n\t\t\t\t\txchg = ref1;\n\t\t\t\t\tref1 = ref2;\n\t\t\t\t\tref2 = xchg;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ref1->parent != ref2->parent)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\teie = ref1->inode_list;\n\t\t\twhile (eie && eie->next)\n\t\t\t\teie = eie->next;\n\t\t\tif (eie)\n\t\t\t\teie->next = ref2->inode_list;\n\t\t\telse\n\t\t\t\tref1->inode_list = ref2->inode_list;\n\t\t\tref1->count += ref2->count;\n\n\t\t\tlist_del(&ref2->list);\n\t\t\tkmem_cache_free(btrfs_prelim_ref_cache, ref2);\n\t\t}\n\n\t}\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_prelim_ref_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "btrfs_prelim_ref_cache",
            "ref2"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ref2->list"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ref_for_same_block",
          "args": [
            "ref1",
            "ref2"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "ref_for_same_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "455-472",
          "snippet": "static inline int ref_for_same_block(struct __prelim_ref *ref1,\n\t\t\t\t     struct __prelim_ref *ref2)\n{\n\tif (ref1->level != ref2->level)\n\t\treturn 0;\n\tif (ref1->root_id != ref2->root_id)\n\t\treturn 0;\n\tif (ref1->key_for_search.type != ref2->key_for_search.type)\n\t\treturn 0;\n\tif (ref1->key_for_search.objectid != ref2->key_for_search.objectid)\n\t\treturn 0;\n\tif (ref1->key_for_search.offset != ref2->key_for_search.offset)\n\t\treturn 0;\n\tif (ref1->parent != ref2->parent)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic inline int ref_for_same_block(struct __prelim_ref *ref1,\n\t\t\t\t     struct __prelim_ref *ref2)\n{\n\tif (ref1->level != ref2->level)\n\t\treturn 0;\n\tif (ref1->root_id != ref2->root_id)\n\t\treturn 0;\n\tif (ref1->key_for_search.type != ref2->key_for_search.type)\n\t\treturn 0;\n\tif (ref1->key_for_search.objectid != ref2->key_for_search.objectid)\n\t\treturn 0;\n\tif (ref1->key_for_search.offset != ref2->key_for_search.offset)\n\t\treturn 0;\n\tif (ref1->parent != ref2->parent)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos2",
            "struct__prelim_ref",
            "list"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos1",
            "struct__prelim_ref",
            "list"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "pos1",
            "head"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic struct kmem_cache *btrfs_prelim_ref_cache;\n\nstatic void __merge_refs(struct list_head *head, int mode)\n{\n\tstruct list_head *pos1;\n\n\tlist_for_each(pos1, head) {\n\t\tstruct list_head *n2;\n\t\tstruct list_head *pos2;\n\t\tstruct __prelim_ref *ref1;\n\n\t\tref1 = list_entry(pos1, struct __prelim_ref, list);\n\n\t\tfor (pos2 = pos1->next, n2 = pos2->next; pos2 != head;\n\t\t     pos2 = n2, n2 = pos2->next) {\n\t\t\tstruct __prelim_ref *ref2;\n\t\t\tstruct __prelim_ref *xchg;\n\t\t\tstruct extent_inode_elem *eie;\n\n\t\t\tref2 = list_entry(pos2, struct __prelim_ref, list);\n\n\t\t\tif (mode == 1) {\n\t\t\t\tif (!ref_for_same_block(ref1, ref2))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!ref1->parent && ref2->parent) {\n\t\t\t\t\txchg = ref1;\n\t\t\t\t\tref1 = ref2;\n\t\t\t\t\tref2 = xchg;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ref1->parent != ref2->parent)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\teie = ref1->inode_list;\n\t\t\twhile (eie && eie->next)\n\t\t\t\teie = eie->next;\n\t\t\tif (eie)\n\t\t\t\teie->next = ref2->inode_list;\n\t\t\telse\n\t\t\t\tref1->inode_list = ref2->inode_list;\n\t\t\tref1->count += ref2->count;\n\n\t\t\tlist_del(&ref2->list);\n\t\t\tkmem_cache_free(btrfs_prelim_ref_cache, ref2);\n\t\t}\n\n\t}\n}"
  },
  {
    "function_name": "__add_missing_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "477-507",
    "snippet": "static int __add_missing_keys(struct btrfs_fs_info *fs_info,\n\t\t\t      struct list_head *head)\n{\n\tstruct list_head *pos;\n\tstruct extent_buffer *eb;\n\n\tlist_for_each(pos, head) {\n\t\tstruct __prelim_ref *ref;\n\t\tref = list_entry(pos, struct __prelim_ref, list);\n\n\t\tif (ref->parent)\n\t\t\tcontinue;\n\t\tif (ref->key_for_search.type)\n\t\t\tcontinue;\n\t\tBUG_ON(!ref->wanted_disk_byte);\n\t\teb = read_tree_block(fs_info->tree_root, ref->wanted_disk_byte,\n\t\t\t\t     0);\n\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbtrfs_tree_read_lock(eb);\n\t\tif (btrfs_header_level(eb) == 0)\n\t\t\tbtrfs_item_key_to_cpu(eb, &ref->key_for_search, 0);\n\t\telse\n\t\t\tbtrfs_node_key_to_cpu(eb, &ref->key_for_search, 0);\n\t\tbtrfs_tree_read_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_unlock",
          "args": [
            "eb"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_unlock_blocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "218-236",
          "snippet": "void btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nvoid btrfs_tree_read_unlock_blocking(struct extent_buffer *eb)\n{\n\t/*\n\t * if we're nested, we have the write lock.  No new locking\n\t * is needed as long as we are the lock owner.\n\t * The write unlock will do a barrier for us, and the lock_nested\n\t * field only matters to the lock owner.\n\t */\n\tif (eb->lock_nested && current->pid == eb->lock_owner) {\n\t\teb->lock_nested = 0;\n\t\treturn;\n\t}\n\tbtrfs_assert_tree_read_locked(eb);\n\tWARN_ON(atomic_read(&eb->blocking_readers) == 0);\n\tif (atomic_dec_and_test(&eb->blocking_readers) &&\n\t    waitqueue_active(&eb->read_lock_wq))\n\t\twake_up(&eb->read_lock_wq);\n\tatomic_dec(&eb->read_locks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_to_cpu",
          "args": [
            "eb",
            "&ref->key_for_search",
            "0"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&ref->key_for_search",
            "0"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_tree_read_lock",
          "args": [
            "eb"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_tree_read_lock_atomic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/locking.c",
          "lines": "135-148",
          "snippet": "int btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"extent_io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/bug.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_assert_tree_read_locked(struct extent_buffer *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"extent_io.h\"\n#include \"ctree.h\"\n#include <asm/bug.h>\n#include <linux/page-flags.h>\n#include <linux/spinlock.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void btrfs_assert_tree_read_locked(struct extent_buffer *eb);\n\nint btrfs_tree_read_lock_atomic(struct extent_buffer *eb)\n{\n\tif (atomic_read(&eb->blocking_writers))\n\t\treturn 0;\n\n\tread_lock(&eb->lock);\n\tif (atomic_read(&eb->blocking_writers)) {\n\t\tread_unlock(&eb->lock);\n\t\treturn 0;\n\t}\n\tatomic_inc(&eb->read_locks);\n\tatomic_inc(&eb->spinning_readers);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_buffer_uptodate",
          "args": [
            "eb"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "extent_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5113-5116",
          "snippet": "int extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nint extent_buffer_uptodate(struct extent_buffer *eb)\n{\n\treturn test_bit(EXTENT_BUFFER_UPTODATE, &eb->bflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_tree_block",
          "args": [
            "fs_info->tree_root",
            "ref->wanted_disk_byte",
            "0"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "read_tree_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1149-1166",
          "snippet": "struct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nstruct extent_buffer *read_tree_block(struct btrfs_root *root, u64 bytenr,\n\t\t\t\t      u64 parent_transid)\n{\n\tstruct extent_buffer *buf = NULL;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn NULL;\n\n\tret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ref->wanted_disk_byte"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "struct__prelim_ref",
            "list"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each",
          "args": [
            "pos",
            "head"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int __add_missing_keys(struct btrfs_fs_info *fs_info,\n\t\t\t      struct list_head *head)\n{\n\tstruct list_head *pos;\n\tstruct extent_buffer *eb;\n\n\tlist_for_each(pos, head) {\n\t\tstruct __prelim_ref *ref;\n\t\tref = list_entry(pos, struct __prelim_ref, list);\n\n\t\tif (ref->parent)\n\t\t\tcontinue;\n\t\tif (ref->key_for_search.type)\n\t\t\tcontinue;\n\t\tBUG_ON(!ref->wanted_disk_byte);\n\t\teb = read_tree_block(fs_info->tree_root, ref->wanted_disk_byte,\n\t\t\t\t     0);\n\t\tif (!eb || !extent_buffer_uptodate(eb)) {\n\t\t\tfree_extent_buffer(eb);\n\t\t\treturn -EIO;\n\t\t}\n\t\tbtrfs_tree_read_lock(eb);\n\t\tif (btrfs_header_level(eb) == 0)\n\t\t\tbtrfs_item_key_to_cpu(eb, &ref->key_for_search, 0);\n\t\telse\n\t\t\tbtrfs_node_key_to_cpu(eb, &ref->key_for_search, 0);\n\t\tbtrfs_tree_read_unlock(eb);\n\t\tfree_extent_buffer(eb);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ref_for_same_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "455-472",
    "snippet": "static inline int ref_for_same_block(struct __prelim_ref *ref1,\n\t\t\t\t     struct __prelim_ref *ref2)\n{\n\tif (ref1->level != ref2->level)\n\t\treturn 0;\n\tif (ref1->root_id != ref2->root_id)\n\t\treturn 0;\n\tif (ref1->key_for_search.type != ref2->key_for_search.type)\n\t\treturn 0;\n\tif (ref1->key_for_search.objectid != ref2->key_for_search.objectid)\n\t\treturn 0;\n\tif (ref1->key_for_search.offset != ref2->key_for_search.offset)\n\t\treturn 0;\n\tif (ref1->parent != ref2->parent)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic inline int ref_for_same_block(struct __prelim_ref *ref1,\n\t\t\t\t     struct __prelim_ref *ref2)\n{\n\tif (ref1->level != ref2->level)\n\t\treturn 0;\n\tif (ref1->root_id != ref2->root_id)\n\t\treturn 0;\n\tif (ref1->key_for_search.type != ref2->key_for_search.type)\n\t\treturn 0;\n\tif (ref1->key_for_search.objectid != ref2->key_for_search.objectid)\n\t\treturn 0;\n\tif (ref1->key_for_search.offset != ref2->key_for_search.offset)\n\t\treturn 0;\n\tif (ref1->parent != ref2->parent)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "__resolve_indirect_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "380-453",
    "snippet": "static int __resolve_indirect_refs(struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_path *path, u64 time_seq,\n\t\t\t\t   struct list_head *head,\n\t\t\t\t   const u64 *extent_item_pos, u64 total_refs,\n\t\t\t\t   u64 root_objectid)\n{\n\tint err;\n\tint ret = 0;\n\tstruct __prelim_ref *ref;\n\tstruct __prelim_ref *ref_safe;\n\tstruct __prelim_ref *new_ref;\n\tstruct ulist *parents;\n\tstruct ulist_node *node;\n\tstruct ulist_iterator uiter;\n\n\tparents = ulist_alloc(GFP_NOFS);\n\tif (!parents)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * _safe allows us to insert directly after the current item without\n\t * iterating over the newly inserted items.\n\t * we're also allowed to re-assign ref during iteration.\n\t */\n\tlist_for_each_entry_safe(ref, ref_safe, head, list) {\n\t\tif (ref->parent)\t/* already direct */\n\t\t\tcontinue;\n\t\tif (ref->count == 0)\n\t\t\tcontinue;\n\t\tif (root_objectid && ref->root_id != root_objectid) {\n\t\t\tret = BACKREF_FOUND_SHARED;\n\t\t\tgoto out;\n\t\t}\n\t\terr = __resolve_indirect_ref(fs_info, path, time_seq, ref,\n\t\t\t\t\t     parents, extent_item_pos,\n\t\t\t\t\t     total_refs);\n\t\t/*\n\t\t * we can only tolerate ENOENT,otherwise,we should catch error\n\t\t * and return directly.\n\t\t */\n\t\tif (err == -ENOENT) {\n\t\t\tcontinue;\n\t\t} else if (err) {\n\t\t\tret = err;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* we put the first parent into the ref at hand */\n\t\tULIST_ITER_INIT(&uiter);\n\t\tnode = ulist_next(parents, &uiter);\n\t\tref->parent = node ? node->val : 0;\n\t\tref->inode_list = node ?\n\t\t\t(struct extent_inode_elem *)(uintptr_t)node->aux : NULL;\n\n\t\t/* additional parents require new refs being added here */\n\t\twhile ((node = ulist_next(parents, &uiter))) {\n\t\t\tnew_ref = kmem_cache_alloc(btrfs_prelim_ref_cache,\n\t\t\t\t\t\t   GFP_NOFS);\n\t\t\tif (!new_ref) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(new_ref, ref, sizeof(*ref));\n\t\t\tnew_ref->parent = node->val;\n\t\t\tnew_ref->inode_list = (struct extent_inode_elem *)\n\t\t\t\t\t\t\t(uintptr_t)node->aux;\n\t\t\tlist_add(&new_ref->list, &ref->list);\n\t\t}\n\t\tulist_reinit(parents);\n\t}\nout:\n\tulist_free(parents);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [
      "#define BACKREF_FOUND_SHARED 6"
    ],
    "globals_used": [
      "static struct kmem_cache *btrfs_prelim_ref_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ulist_free",
          "args": [
            "parents"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "110-116",
          "snippet": "void ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_free(struct ulist *ulist)\n{\n\tif (!ulist)\n\t\treturn;\n\tulist_fini(ulist);\n\tkfree(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_reinit",
          "args": [
            "parents"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_reinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "80-84",
          "snippet": "void ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nvoid ulist_reinit(struct ulist *ulist)\n{\n\tulist_fini(ulist);\n\tulist_init(ulist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new_ref->list",
            "&ref->list"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_ref",
            "ref",
            "sizeof(*ref)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "btrfs_prelim_ref_cache",
            "GFP_NOFS"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_next",
          "args": [
            "parents",
            "&uiter"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "228-251",
          "snippet": "struct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist_node *ulist_next(struct ulist *ulist, struct ulist_iterator *uiter)\n{\n\tstruct ulist_node *node;\n\n\tif (list_empty(&ulist->nodes))\n\t\treturn NULL;\n\tif (uiter->cur_list && uiter->cur_list->next == &ulist->nodes)\n\t\treturn NULL;\n\tif (uiter->cur_list) {\n\t\tuiter->cur_list = uiter->cur_list->next;\n\t} else {\n\t\tuiter->cur_list = ulist->nodes.next;\n#ifdef CONFIG_BTRFS_DEBUG\n\t\tuiter->i = 0;\n#endif\n\t}\n\tnode = list_entry(uiter->cur_list, struct ulist_node, list);\n#ifdef CONFIG_BTRFS_DEBUG\n\tASSERT(node->seqnum == uiter->i);\n\tASSERT(uiter->i >= 0 && uiter->i < ulist->nnodes);\n\tuiter->i++;\n#endif\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ULIST_ITER_INIT",
          "args": [
            "&uiter"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__resolve_indirect_ref",
          "args": [
            "fs_info",
            "path",
            "time_seq",
            "ref",
            "parents",
            "extent_item_pos",
            "total_refs"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "__resolve_indirect_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "380-453",
          "snippet": "static int __resolve_indirect_refs(struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_path *path, u64 time_seq,\n\t\t\t\t   struct list_head *head,\n\t\t\t\t   const u64 *extent_item_pos, u64 total_refs,\n\t\t\t\t   u64 root_objectid)\n{\n\tint err;\n\tint ret = 0;\n\tstruct __prelim_ref *ref;\n\tstruct __prelim_ref *ref_safe;\n\tstruct __prelim_ref *new_ref;\n\tstruct ulist *parents;\n\tstruct ulist_node *node;\n\tstruct ulist_iterator uiter;\n\n\tparents = ulist_alloc(GFP_NOFS);\n\tif (!parents)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * _safe allows us to insert directly after the current item without\n\t * iterating over the newly inserted items.\n\t * we're also allowed to re-assign ref during iteration.\n\t */\n\tlist_for_each_entry_safe(ref, ref_safe, head, list) {\n\t\tif (ref->parent)\t/* already direct */\n\t\t\tcontinue;\n\t\tif (ref->count == 0)\n\t\t\tcontinue;\n\t\tif (root_objectid && ref->root_id != root_objectid) {\n\t\t\tret = BACKREF_FOUND_SHARED;\n\t\t\tgoto out;\n\t\t}\n\t\terr = __resolve_indirect_ref(fs_info, path, time_seq, ref,\n\t\t\t\t\t     parents, extent_item_pos,\n\t\t\t\t\t     total_refs);\n\t\t/*\n\t\t * we can only tolerate ENOENT,otherwise,we should catch error\n\t\t * and return directly.\n\t\t */\n\t\tif (err == -ENOENT) {\n\t\t\tcontinue;\n\t\t} else if (err) {\n\t\t\tret = err;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* we put the first parent into the ref at hand */\n\t\tULIST_ITER_INIT(&uiter);\n\t\tnode = ulist_next(parents, &uiter);\n\t\tref->parent = node ? node->val : 0;\n\t\tref->inode_list = node ?\n\t\t\t(struct extent_inode_elem *)(uintptr_t)node->aux : NULL;\n\n\t\t/* additional parents require new refs being added here */\n\t\twhile ((node = ulist_next(parents, &uiter))) {\n\t\t\tnew_ref = kmem_cache_alloc(btrfs_prelim_ref_cache,\n\t\t\t\t\t\t   GFP_NOFS);\n\t\t\tif (!new_ref) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(new_ref, ref, sizeof(*ref));\n\t\t\tnew_ref->parent = node->val;\n\t\t\tnew_ref->inode_list = (struct extent_inode_elem *)\n\t\t\t\t\t\t\t(uintptr_t)node->aux;\n\t\t\tlist_add(&new_ref->list, &ref->list);\n\t\t}\n\t\tulist_reinit(parents);\n\t}\nout:\n\tulist_free(parents);\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ref",
            "ref_safe",
            "head",
            "list"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_alloc",
          "args": [
            "GFP_NOFS"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "92-102",
          "snippet": "struct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nstruct ulist *ulist_alloc(gfp_t gfp_mask)\n{\n\tstruct ulist *ulist = kmalloc(sizeof(*ulist), gfp_mask);\n\n\tif (!ulist)\n\t\treturn NULL;\n\n\tulist_init(ulist);\n\n\treturn ulist;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\n#define BACKREF_FOUND_SHARED 6\n\nstatic struct kmem_cache *btrfs_prelim_ref_cache;\n\nstatic int __resolve_indirect_refs(struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_path *path, u64 time_seq,\n\t\t\t\t   struct list_head *head,\n\t\t\t\t   const u64 *extent_item_pos, u64 total_refs,\n\t\t\t\t   u64 root_objectid)\n{\n\tint err;\n\tint ret = 0;\n\tstruct __prelim_ref *ref;\n\tstruct __prelim_ref *ref_safe;\n\tstruct __prelim_ref *new_ref;\n\tstruct ulist *parents;\n\tstruct ulist_node *node;\n\tstruct ulist_iterator uiter;\n\n\tparents = ulist_alloc(GFP_NOFS);\n\tif (!parents)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * _safe allows us to insert directly after the current item without\n\t * iterating over the newly inserted items.\n\t * we're also allowed to re-assign ref during iteration.\n\t */\n\tlist_for_each_entry_safe(ref, ref_safe, head, list) {\n\t\tif (ref->parent)\t/* already direct */\n\t\t\tcontinue;\n\t\tif (ref->count == 0)\n\t\t\tcontinue;\n\t\tif (root_objectid && ref->root_id != root_objectid) {\n\t\t\tret = BACKREF_FOUND_SHARED;\n\t\t\tgoto out;\n\t\t}\n\t\terr = __resolve_indirect_ref(fs_info, path, time_seq, ref,\n\t\t\t\t\t     parents, extent_item_pos,\n\t\t\t\t\t     total_refs);\n\t\t/*\n\t\t * we can only tolerate ENOENT,otherwise,we should catch error\n\t\t * and return directly.\n\t\t */\n\t\tif (err == -ENOENT) {\n\t\t\tcontinue;\n\t\t} else if (err) {\n\t\t\tret = err;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* we put the first parent into the ref at hand */\n\t\tULIST_ITER_INIT(&uiter);\n\t\tnode = ulist_next(parents, &uiter);\n\t\tref->parent = node ? node->val : 0;\n\t\tref->inode_list = node ?\n\t\t\t(struct extent_inode_elem *)(uintptr_t)node->aux : NULL;\n\n\t\t/* additional parents require new refs being added here */\n\t\twhile ((node = ulist_next(parents, &uiter))) {\n\t\t\tnew_ref = kmem_cache_alloc(btrfs_prelim_ref_cache,\n\t\t\t\t\t\t   GFP_NOFS);\n\t\t\tif (!new_ref) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(new_ref, ref, sizeof(*ref));\n\t\t\tnew_ref->parent = node->val;\n\t\t\tnew_ref->inode_list = (struct extent_inode_elem *)\n\t\t\t\t\t\t\t(uintptr_t)node->aux;\n\t\t\tlist_add(&new_ref->list, &ref->list);\n\t\t}\n\t\tulist_reinit(parents);\n\t}\nout:\n\tulist_free(parents);\n\treturn ret;\n}"
  },
  {
    "function_name": "__resolve_indirect_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "308-375",
    "snippet": "static int __resolve_indirect_ref(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_path *path, u64 time_seq,\n\t\t\t\t  struct __prelim_ref *ref,\n\t\t\t\t  struct ulist *parents,\n\t\t\t\t  const u64 *extent_item_pos, u64 total_refs)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key root_key;\n\tstruct extent_buffer *eb;\n\tint ret = 0;\n\tint root_level;\n\tint level = ref->level;\n\tint index;\n\n\troot_key.objectid = ref->root_id;\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = (u64)-1;\n\n\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\troot = btrfs_read_fs_root_no_name(fs_info, &root_key);\n\tif (IS_ERR(root)) {\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\tret = PTR_ERR(root);\n\t\tgoto out;\n\t}\n\n\tif (path->search_commit_root)\n\t\troot_level = btrfs_header_level(root->commit_root);\n\telse\n\t\troot_level = btrfs_old_root_level(root, time_seq);\n\n\tif (root_level + 1 == level) {\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\tgoto out;\n\t}\n\n\tpath->lowest_level = level;\n\tret = btrfs_search_old_slot(root, &ref->key_for_search, path, time_seq);\n\n\t/* root node has been locked, we can release @subvol_srcu safely here */\n\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\tpr_debug(\"search slot in root %llu (level %d, ref count %d) returned \"\n\t\t \"%d for key (%llu %u %llu)\\n\",\n\t\t ref->root_id, level, ref->count, ret,\n\t\t ref->key_for_search.objectid, ref->key_for_search.type,\n\t\t ref->key_for_search.offset);\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[level];\n\twhile (!eb) {\n\t\tif (WARN_ON(!level)) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tlevel--;\n\t\teb = path->nodes[level];\n\t}\n\n\tret = add_all_parents(root, path, parents, ref, level, time_seq,\n\t\t\t      extent_item_pos, total_refs);\nout:\n\tpath->lowest_level = 0;\n\tbtrfs_release_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_release_path",
          "args": [
            "path"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_release_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "121-136",
          "snippet": "noinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nnoinline void btrfs_release_path(struct btrfs_path *p)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_MAX_LEVEL; i++) {\n\t\tp->slots[i] = 0;\n\t\tif (!p->nodes[i])\n\t\t\tcontinue;\n\t\tif (p->locks[i]) {\n\t\t\tbtrfs_tree_unlock_rw(p->nodes[i], p->locks[i]);\n\t\t\tp->locks[i] = 0;\n\t\t}\n\t\tfree_extent_buffer(p->nodes[i]);\n\t\tp->nodes[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_all_parents",
          "args": [
            "root",
            "path",
            "parents",
            "ref",
            "level",
            "time_seq",
            "extent_item_pos",
            "total_refs"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "add_all_parents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "224-302",
          "snippet": "static int add_all_parents(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct ulist *parents, struct __prelim_ref *ref,\n\t\t\t   int level, u64 time_seq, const u64 *extent_item_pos,\n\t\t\t   u64 total_refs)\n{\n\tint ret = 0;\n\tint slot;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tstruct btrfs_key *key_for_search = &ref->key_for_search;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_inode_elem *eie = NULL, *old = NULL;\n\tu64 disk_byte;\n\tu64 wanted_disk_byte = ref->wanted_disk_byte;\n\tu64 count = 0;\n\n\tif (level != 0) {\n\t\teb = path->nodes[level];\n\t\tret = ulist_add(parents, eb->start, 0, GFP_NOFS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We normally enter this function with the path already pointing to\n\t * the first item to check. But sometimes, we may enter it with\n\t * slot==nritems. In that case, go to the next leaf before we continue.\n\t */\n\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0]))\n\t\tret = btrfs_next_old_leaf(root, path, time_seq);\n\n\twhile (!ret && count < total_refs) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\n\t\tif (key.objectid != key_for_search->objectid ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\t\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\n\t\tif (disk_byte == wanted_disk_byte) {\n\t\t\teie = NULL;\n\t\t\told = NULL;\n\t\t\tcount++;\n\t\t\tif (extent_item_pos) {\n\t\t\t\tret = check_extent_in_eb(&key, eb, fi,\n\t\t\t\t\t\t*extent_item_pos,\n\t\t\t\t\t\t&eie);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret > 0)\n\t\t\t\tgoto next;\n\t\t\tret = ulist_add_merge_ptr(parents, eb->start,\n\t\t\t\t\t\t  eie, (void **)&old, GFP_NOFS);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (!ret && extent_item_pos) {\n\t\t\t\twhile (old->next)\n\t\t\t\t\told = old->next;\n\t\t\t\told->next = eie;\n\t\t\t}\n\t\t\teie = NULL;\n\t\t}\nnext:\n\t\tret = btrfs_next_old_item(root, path, time_seq);\n\t}\n\n\tif (ret > 0)\n\t\tret = 0;\n\telse if (ret < 0)\n\t\tfree_inode_elem_list(eie);\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int add_all_parents(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct ulist *parents, struct __prelim_ref *ref,\n\t\t\t   int level, u64 time_seq, const u64 *extent_item_pos,\n\t\t\t   u64 total_refs)\n{\n\tint ret = 0;\n\tint slot;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tstruct btrfs_key *key_for_search = &ref->key_for_search;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_inode_elem *eie = NULL, *old = NULL;\n\tu64 disk_byte;\n\tu64 wanted_disk_byte = ref->wanted_disk_byte;\n\tu64 count = 0;\n\n\tif (level != 0) {\n\t\teb = path->nodes[level];\n\t\tret = ulist_add(parents, eb->start, 0, GFP_NOFS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We normally enter this function with the path already pointing to\n\t * the first item to check. But sometimes, we may enter it with\n\t * slot==nritems. In that case, go to the next leaf before we continue.\n\t */\n\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0]))\n\t\tret = btrfs_next_old_leaf(root, path, time_seq);\n\n\twhile (!ret && count < total_refs) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\n\t\tif (key.objectid != key_for_search->objectid ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\t\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\n\t\tif (disk_byte == wanted_disk_byte) {\n\t\t\teie = NULL;\n\t\t\told = NULL;\n\t\t\tcount++;\n\t\t\tif (extent_item_pos) {\n\t\t\t\tret = check_extent_in_eb(&key, eb, fi,\n\t\t\t\t\t\t*extent_item_pos,\n\t\t\t\t\t\t&eie);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret > 0)\n\t\t\t\tgoto next;\n\t\t\tret = ulist_add_merge_ptr(parents, eb->start,\n\t\t\t\t\t\t  eie, (void **)&old, GFP_NOFS);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (!ret && extent_item_pos) {\n\t\t\t\twhile (old->next)\n\t\t\t\t\told = old->next;\n\t\t\t\told->next = eie;\n\t\t\t}\n\t\t\teie = NULL;\n\t\t}\nnext:\n\t\tret = btrfs_next_old_item(root, path, time_seq);\n\t}\n\n\tif (ret > 0)\n\t\tret = 0;\n\telse if (ret < 0)\n\t\tfree_inode_elem_list(eie);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!level"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"search slot in root %llu (level %d, ref count %d) returned \"\n\t\t \"%d for key (%llu %u %llu)\\n\"",
            "ref->root_id",
            "level",
            "ref->count",
            "ret",
            "ref->key_for_search.objectid",
            "ref->key_for_search.type",
            "ref->key_for_search.offset"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_search_old_slot",
          "args": [
            "root",
            "&ref->key_for_search",
            "path",
            "time_seq"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_search_old_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "2945-3043",
          "snippet": "int btrfs_search_old_slot(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct btrfs_path *p, u64 time_seq)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tu8 lowest_level = 0;\n\tint prev_cmp = -1;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(p->nodes[0] != NULL);\n\n\tif (p->search_commit_root) {\n\t\tBUG_ON(time_seq);\n\t\treturn btrfs_search_slot(NULL, root, key, p, 0, 0);\n\t}\n\nagain:\n\tb = get_old_root(root, time_seq);\n\tlevel = btrfs_header_level(b);\n\tp->locks[level] = BTRFS_READ_LOCK;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t */\n\t\tbtrfs_unlock_up_safe(p, level + 1);\n\n\t\t/*\n\t\t * Since we can unwind eb's we want to do a real search every\n\t\t * time.\n\t\t */\n\t\tprev_cmp = -1;\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(NULL, root, p, &b, level,\n\t\t\t\t\t\t    slot, key, time_seq);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\tif (!err) {\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tb = tree_mod_log_rewind(root->fs_info, p, b, time_seq);\n\t\t\tif (!b) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\tp->nodes[level] = b;\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0)\n\t\tbtrfs_release_path(p);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nint btrfs_search_old_slot(struct btrfs_root *root, struct btrfs_key *key,\n\t\t\t  struct btrfs_path *p, u64 time_seq)\n{\n\tstruct extent_buffer *b;\n\tint slot;\n\tint ret;\n\tint err;\n\tint level;\n\tint lowest_unlock = 1;\n\tu8 lowest_level = 0;\n\tint prev_cmp = -1;\n\n\tlowest_level = p->lowest_level;\n\tWARN_ON(p->nodes[0] != NULL);\n\n\tif (p->search_commit_root) {\n\t\tBUG_ON(time_seq);\n\t\treturn btrfs_search_slot(NULL, root, key, p, 0, 0);\n\t}\n\nagain:\n\tb = get_old_root(root, time_seq);\n\tlevel = btrfs_header_level(b);\n\tp->locks[level] = BTRFS_READ_LOCK;\n\n\twhile (b) {\n\t\tlevel = btrfs_header_level(b);\n\t\tp->nodes[level] = b;\n\t\tbtrfs_clear_path_blocking(p, NULL, 0);\n\n\t\t/*\n\t\t * we have a lock on b and as long as we aren't changing\n\t\t * the tree, there is no way to for the items in b to change.\n\t\t * It is safe to drop the lock on our parent before we\n\t\t * go through the expensive btree search on b.\n\t\t */\n\t\tbtrfs_unlock_up_safe(p, level + 1);\n\n\t\t/*\n\t\t * Since we can unwind eb's we want to do a real search every\n\t\t * time.\n\t\t */\n\t\tprev_cmp = -1;\n\t\tret = key_search(b, key, level, &prev_cmp, &slot);\n\n\t\tif (level != 0) {\n\t\t\tint dec = 0;\n\t\t\tif (ret && slot > 0) {\n\t\t\t\tdec = 1;\n\t\t\t\tslot -= 1;\n\t\t\t}\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\n\t\t\tif (level == lowest_level) {\n\t\t\t\tif (dec)\n\t\t\t\t\tp->slots[level]++;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = read_block_for_search(NULL, root, p, &b, level,\n\t\t\t\t\t\t    slot, key, time_seq);\n\t\t\tif (err == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tif (err) {\n\t\t\t\tret = err;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tlevel = btrfs_header_level(b);\n\t\t\terr = btrfs_tree_read_lock_atomic(b);\n\t\t\tif (!err) {\n\t\t\t\tbtrfs_set_path_blocking(p);\n\t\t\t\tbtrfs_tree_read_lock(b);\n\t\t\t\tbtrfs_clear_path_blocking(p, b,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tb = tree_mod_log_rewind(root->fs_info, p, b, time_seq);\n\t\t\tif (!b) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tp->locks[level] = BTRFS_READ_LOCK;\n\t\t\tp->nodes[level] = b;\n\t\t} else {\n\t\t\tp->slots[level] = slot;\n\t\t\tunlock_up(p, level, lowest_unlock, 0, NULL);\n\t\t\tgoto done;\n\t\t}\n\t}\n\tret = 1;\ndone:\n\tif (!p->leave_spinning)\n\t\tbtrfs_set_path_blocking(p);\n\tif (ret < 0)\n\t\tbtrfs_release_path(p);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_old_root_level",
          "args": [
            "root",
            "time_seq"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_old_root_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1482-1497",
          "snippet": "int btrfs_old_root_level(struct btrfs_root *root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tint level;\n\tstruct extent_buffer *eb_root = btrfs_root_node(root);\n\n\ttm = __tree_mod_log_oldest_root(root->fs_info, eb_root, time_seq);\n\tif (tm && tm->op == MOD_LOG_ROOT_REPLACE) {\n\t\tlevel = tm->old_root.level;\n\t} else {\n\t\tlevel = btrfs_header_level(eb_root);\n\t}\n\tfree_extent_buffer(eb_root);\n\n\treturn level;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic noinline struct;\n\nint btrfs_old_root_level(struct btrfs_root *root, u64 time_seq)\n{\n\tstruct tree_mod_elem *tm;\n\tint level;\n\tstruct extent_buffer *eb_root = btrfs_root_node(root);\n\n\ttm = __tree_mod_log_oldest_root(root->fs_info, eb_root, time_seq);\n\tif (tm && tm->op == MOD_LOG_ROOT_REPLACE) {\n\t\tlevel = tm->old_root.level;\n\t} else {\n\t\tlevel = btrfs_header_level(eb_root);\n\t}\n\tfree_extent_buffer(eb_root);\n\n\treturn level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "root->commit_root"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&fs_info->subvol_srcu",
            "index"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "fs_info",
            "&root_key"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&fs_info->subvol_srcu"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int __resolve_indirect_ref(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct btrfs_path *path, u64 time_seq,\n\t\t\t\t  struct __prelim_ref *ref,\n\t\t\t\t  struct ulist *parents,\n\t\t\t\t  const u64 *extent_item_pos, u64 total_refs)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_key root_key;\n\tstruct extent_buffer *eb;\n\tint ret = 0;\n\tint root_level;\n\tint level = ref->level;\n\tint index;\n\n\troot_key.objectid = ref->root_id;\n\troot_key.type = BTRFS_ROOT_ITEM_KEY;\n\troot_key.offset = (u64)-1;\n\n\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\n\troot = btrfs_read_fs_root_no_name(fs_info, &root_key);\n\tif (IS_ERR(root)) {\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\tret = PTR_ERR(root);\n\t\tgoto out;\n\t}\n\n\tif (path->search_commit_root)\n\t\troot_level = btrfs_header_level(root->commit_root);\n\telse\n\t\troot_level = btrfs_old_root_level(root, time_seq);\n\n\tif (root_level + 1 == level) {\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\tgoto out;\n\t}\n\n\tpath->lowest_level = level;\n\tret = btrfs_search_old_slot(root, &ref->key_for_search, path, time_seq);\n\n\t/* root node has been locked, we can release @subvol_srcu safely here */\n\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\tpr_debug(\"search slot in root %llu (level %d, ref count %d) returned \"\n\t\t \"%d for key (%llu %u %llu)\\n\",\n\t\t ref->root_id, level, ref->count, ret,\n\t\t ref->key_for_search.objectid, ref->key_for_search.type,\n\t\t ref->key_for_search.offset);\n\tif (ret < 0)\n\t\tgoto out;\n\n\teb = path->nodes[level];\n\twhile (!eb) {\n\t\tif (WARN_ON(!level)) {\n\t\t\tret = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tlevel--;\n\t\teb = path->nodes[level];\n\t}\n\n\tret = add_all_parents(root, path, parents, ref, level, time_seq,\n\t\t\t      extent_item_pos, total_refs);\nout:\n\tpath->lowest_level = 0;\n\tbtrfs_release_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "add_all_parents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "224-302",
    "snippet": "static int add_all_parents(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct ulist *parents, struct __prelim_ref *ref,\n\t\t\t   int level, u64 time_seq, const u64 *extent_item_pos,\n\t\t\t   u64 total_refs)\n{\n\tint ret = 0;\n\tint slot;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tstruct btrfs_key *key_for_search = &ref->key_for_search;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_inode_elem *eie = NULL, *old = NULL;\n\tu64 disk_byte;\n\tu64 wanted_disk_byte = ref->wanted_disk_byte;\n\tu64 count = 0;\n\n\tif (level != 0) {\n\t\teb = path->nodes[level];\n\t\tret = ulist_add(parents, eb->start, 0, GFP_NOFS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We normally enter this function with the path already pointing to\n\t * the first item to check. But sometimes, we may enter it with\n\t * slot==nritems. In that case, go to the next leaf before we continue.\n\t */\n\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0]))\n\t\tret = btrfs_next_old_leaf(root, path, time_seq);\n\n\twhile (!ret && count < total_refs) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\n\t\tif (key.objectid != key_for_search->objectid ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\t\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\n\t\tif (disk_byte == wanted_disk_byte) {\n\t\t\teie = NULL;\n\t\t\told = NULL;\n\t\t\tcount++;\n\t\t\tif (extent_item_pos) {\n\t\t\t\tret = check_extent_in_eb(&key, eb, fi,\n\t\t\t\t\t\t*extent_item_pos,\n\t\t\t\t\t\t&eie);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret > 0)\n\t\t\t\tgoto next;\n\t\t\tret = ulist_add_merge_ptr(parents, eb->start,\n\t\t\t\t\t\t  eie, (void **)&old, GFP_NOFS);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (!ret && extent_item_pos) {\n\t\t\t\twhile (old->next)\n\t\t\t\t\told = old->next;\n\t\t\t\told->next = eie;\n\t\t\t}\n\t\t\teie = NULL;\n\t\t}\nnext:\n\t\tret = btrfs_next_old_item(root, path, time_seq);\n\t}\n\n\tif (ret > 0)\n\t\tret = 0;\n\telse if (ret < 0)\n\t\tfree_inode_elem_list(eie);\n\treturn ret;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_inode_elem_list",
          "args": [
            "eie"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "free_inode_elem_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "72-80",
          "snippet": "static void free_inode_elem_list(struct extent_inode_elem *eie)\n{\n\tstruct extent_inode_elem *eie_next;\n\n\tfor (; eie; eie = eie_next) {\n\t\teie_next = eie->next;\n\t\tkfree(eie);\n\t}\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic void free_inode_elem_list(struct extent_inode_elem *eie)\n{\n\tstruct extent_inode_elem *eie_next;\n\n\tfor (; eie; eie = eie_next) {\n\t\teie_next = eie->next;\n\t\tkfree(eie);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_old_item",
          "args": [
            "root",
            "path",
            "time_seq"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_old_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3592-3599",
          "snippet": "static inline int btrfs_next_old_item(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *p, u64 time_seq)\n{\n\t++p->slots[0];\n\tif (p->slots[0] >= btrfs_header_nritems(p->nodes[0]))\n\t\treturn btrfs_next_old_leaf(root, p, time_seq);\n\treturn 0;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline int btrfs_next_old_item(struct btrfs_root *root,\n\t\t\t\t      struct btrfs_path *p, u64 time_seq)\n{\n\t++p->slots[0];\n\tif (p->slots[0] >= btrfs_header_nritems(p->nodes[0]))\n\t\treturn btrfs_next_old_leaf(root, p, time_seq);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ulist_add_merge_ptr",
          "args": [
            "parents",
            "eb->start",
            "eie",
            "(void **)&old",
            "GFP_NOFS"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_add_merge_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.h",
          "lines": "62-73",
          "snippet": "static inline int ulist_add_merge_ptr(struct ulist *ulist, u64 val, void *aux,\n\t\t\t\t      void **old_aux, gfp_t gfp_mask)\n{\n#if BITS_PER_LONG == 32\n\tu64 old64 = (uintptr_t)*old_aux;\n\tint ret = ulist_add_merge(ulist, val, (uintptr_t)aux, &old64, gfp_mask);\n\t*old_aux = (void *)((uintptr_t)old64);\n\treturn ret;\n#else\n\treturn ulist_add_merge(ulist, val, (u64)aux, (u64 *)old_aux, gfp_mask);\n#endif\n}",
          "includes": [
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rbtree.h>\n#include <linux/list.h>\n\nstatic inline int ulist_add_merge_ptr(struct ulist *ulist, u64 val, void *aux,\n\t\t\t\t      void **old_aux, gfp_t gfp_mask)\n{\n#if BITS_PER_LONG == 32\n\tu64 old64 = (uintptr_t)*old_aux;\n\tint ret = ulist_add_merge(ulist, val, (uintptr_t)aux, &old64, gfp_mask);\n\t*old_aux = (void *)((uintptr_t)old64);\n\treturn ret;\n#else\n\treturn ulist_add_merge(ulist, val, (u64)aux, (u64 *)old_aux, gfp_mask);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_extent_in_eb",
          "args": [
            "&key",
            "eb",
            "fi",
            "*extent_item_pos",
            "&eie"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "check_extent_in_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "37-70",
          "snippet": "static int check_extent_in_eb(struct btrfs_key *key, struct extent_buffer *eb,\n\t\t\t\tstruct btrfs_file_extent_item *fi,\n\t\t\t\tu64 extent_item_pos,\n\t\t\t\tstruct extent_inode_elem **eie)\n{\n\tu64 offset = 0;\n\tstruct extent_inode_elem *e;\n\n\tif (!btrfs_file_extent_compression(eb, fi) &&\n\t    !btrfs_file_extent_encryption(eb, fi) &&\n\t    !btrfs_file_extent_other_encoding(eb, fi)) {\n\t\tu64 data_offset;\n\t\tu64 data_len;\n\n\t\tdata_offset = btrfs_file_extent_offset(eb, fi);\n\t\tdata_len = btrfs_file_extent_num_bytes(eb, fi);\n\n\t\tif (extent_item_pos < data_offset ||\n\t\t    extent_item_pos >= data_offset + data_len)\n\t\t\treturn 1;\n\t\toffset = extent_item_pos - data_offset;\n\t}\n\n\te = kmalloc(sizeof(*e), GFP_NOFS);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->next = *eie;\n\te->inum = key->objectid;\n\te->offset = key->offset + offset;\n\t*eie = e;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int check_extent_in_eb(struct btrfs_key *key, struct extent_buffer *eb,\n\t\t\t\tstruct btrfs_file_extent_item *fi,\n\t\t\t\tu64 extent_item_pos,\n\t\t\t\tstruct extent_inode_elem **eie)\n{\n\tu64 offset = 0;\n\tstruct extent_inode_elem *e;\n\n\tif (!btrfs_file_extent_compression(eb, fi) &&\n\t    !btrfs_file_extent_encryption(eb, fi) &&\n\t    !btrfs_file_extent_other_encoding(eb, fi)) {\n\t\tu64 data_offset;\n\t\tu64 data_len;\n\n\t\tdata_offset = btrfs_file_extent_offset(eb, fi);\n\t\tdata_len = btrfs_file_extent_num_bytes(eb, fi);\n\n\t\tif (extent_item_pos < data_offset ||\n\t\t    extent_item_pos >= data_offset + data_len)\n\t\t\treturn 1;\n\t\toffset = extent_item_pos - data_offset;\n\t}\n\n\te = kmalloc(sizeof(*e), GFP_NOFS);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->next = *eie;\n\te->inum = key->objectid;\n\te->offset = key->offset + offset;\n\t*eie = e;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "eb",
            "fi"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_file_extent_item"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&key",
            "slot"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_next_old_leaf",
          "args": [
            "root",
            "path",
            "time_seq"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_next_old_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "5651-5822",
          "snippet": "int btrfs_next_old_leaf(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tu64 time_seq)\n{\n\tint slot;\n\tint level;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *next;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint ret;\n\tint old_spinning = path->leave_spinning;\n\tint next_rw_lock = 0;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tif (nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, nritems - 1);\nagain:\n\tlevel = 1;\n\tnext = NULL;\n\tnext_rw_lock = 0;\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->leave_spinning = 1;\n\n\tif (time_seq)\n\t\tret = btrfs_search_old_slot(root, &key, path, time_seq);\n\telse\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tpath->keep_locks = 0;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t/*\n\t * by releasing the path above we dropped all our locks.  A balance\n\t * could have added more items next to the key that used to be\n\t * at the very end of the block.  So, check again here and\n\t * advance the path if there are now more items available.\n\t */\n\tif (nritems > 0 && path->slots[0] < nritems - 1) {\n\t\tif (ret == 0)\n\t\t\tpath->slots[0]++;\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\t/*\n\t * So the above check misses one case:\n\t * - after releasing the path above, someone has removed the item that\n\t *   used to be at the very end of the block, and balance between leafs\n\t *   gets another one with bigger key.offset to replace it.\n\t *\n\t * This one should be returned as well, or we can get leaf corruption\n\t * later(esp. in __btrfs_drop_extents()).\n\t *\n\t * And a bit more explanation about this check,\n\t * with ret > 0, the key isn't found, the path points to the slot\n\t * where it should be inserted, so the path->slots[0] item must be the\n\t * bigger one.\n\t */\n\tif (nritems > 0 && ret > 0 && path->slots[0] == nritems - 1) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level]) {\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tlevel++;\n\t\t\tif (level == BTRFS_MAX_LEVEL) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (next) {\n\t\t\tbtrfs_tree_unlock_rw(next, next_rw_lock);\n\t\t\tfree_extent_buffer(next);\n\t\t}\n\n\t\tnext = c;\n\t\tnext_rw_lock = path->locks[level];\n\t\tret = read_block_for_search(NULL, root, path, &next, level,\n\t\t\t\t\t    slot, &key, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret && time_seq) {\n\t\t\t\t/*\n\t\t\t\t * If we don't get the lock, we may be racing\n\t\t\t\t * with push_leaf_left, holding that lock while\n\t\t\t\t * itself waiting for the leaf we've currently\n\t\t\t\t * locked. To solve this situation, we give up\n\t\t\t\t * on our lock and cycle.\n\t\t\t\t */\n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (!ret) {\n\t\t\t\tbtrfs_set_path_blocking(path);\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t\tbtrfs_clear_path_blocking(path, next,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tnext_rw_lock = BTRFS_READ_LOCK;\n\t\t}\n\t\tbreak;\n\t}\n\tpath->slots[level] = slot;\n\twhile (1) {\n\t\tlevel--;\n\t\tc = path->nodes[level];\n\t\tif (path->locks[level])\n\t\t\tbtrfs_tree_unlock_rw(c, path->locks[level]);\n\n\t\tfree_extent_buffer(c);\n\t\tpath->nodes[level] = next;\n\t\tpath->slots[level] = 0;\n\t\tif (!path->skip_locking)\n\t\t\tpath->locks[level] = next_rw_lock;\n\t\tif (!level)\n\t\t\tbreak;\n\n\t\tret = read_block_for_search(NULL, root, path, &next, level,\n\t\t\t\t\t    0, &key, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret) {\n\t\t\t\tbtrfs_set_path_blocking(path);\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t\tbtrfs_clear_path_blocking(path, next,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tnext_rw_lock = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\tret = 0;\ndone:\n\tunlock_up(path, 0, 1, 0, NULL);\n\tpath->leave_spinning = old_spinning;\n\tif (!old_spinning)\n\t\tbtrfs_set_path_blocking(path);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);",
            "static void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int split_node(struct btrfs_trans_handle *trans, struct btrfs_root\n\t\t      *root, struct btrfs_path *path, int level);\nstatic void del_ptr(struct btrfs_root *root, struct btrfs_path *path,\n\t\t    int level, int slot);\nstatic noinline struct;\n\nint btrfs_next_old_leaf(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\tu64 time_seq)\n{\n\tint slot;\n\tint level;\n\tstruct extent_buffer *c;\n\tstruct extent_buffer *next;\n\tstruct btrfs_key key;\n\tu32 nritems;\n\tint ret;\n\tint old_spinning = path->leave_spinning;\n\tint next_rw_lock = 0;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\tif (nritems == 0)\n\t\treturn 1;\n\n\tbtrfs_item_key_to_cpu(path->nodes[0], &key, nritems - 1);\nagain:\n\tlevel = 1;\n\tnext = NULL;\n\tnext_rw_lock = 0;\n\tbtrfs_release_path(path);\n\n\tpath->keep_locks = 1;\n\tpath->leave_spinning = 1;\n\n\tif (time_seq)\n\t\tret = btrfs_search_old_slot(root, &key, path, time_seq);\n\telse\n\t\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tpath->keep_locks = 0;\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnritems = btrfs_header_nritems(path->nodes[0]);\n\t/*\n\t * by releasing the path above we dropped all our locks.  A balance\n\t * could have added more items next to the key that used to be\n\t * at the very end of the block.  So, check again here and\n\t * advance the path if there are now more items available.\n\t */\n\tif (nritems > 0 && path->slots[0] < nritems - 1) {\n\t\tif (ret == 0)\n\t\t\tpath->slots[0]++;\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\t/*\n\t * So the above check misses one case:\n\t * - after releasing the path above, someone has removed the item that\n\t *   used to be at the very end of the block, and balance between leafs\n\t *   gets another one with bigger key.offset to replace it.\n\t *\n\t * This one should be returned as well, or we can get leaf corruption\n\t * later(esp. in __btrfs_drop_extents()).\n\t *\n\t * And a bit more explanation about this check,\n\t * with ret > 0, the key isn't found, the path points to the slot\n\t * where it should be inserted, so the path->slots[0] item must be the\n\t * bigger one.\n\t */\n\tif (nritems > 0 && ret > 0 && path->slots[0] == nritems - 1) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\twhile (level < BTRFS_MAX_LEVEL) {\n\t\tif (!path->nodes[level]) {\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tslot = path->slots[level] + 1;\n\t\tc = path->nodes[level];\n\t\tif (slot >= btrfs_header_nritems(c)) {\n\t\t\tlevel++;\n\t\t\tif (level == BTRFS_MAX_LEVEL) {\n\t\t\t\tret = 1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (next) {\n\t\t\tbtrfs_tree_unlock_rw(next, next_rw_lock);\n\t\t\tfree_extent_buffer(next);\n\t\t}\n\n\t\tnext = c;\n\t\tnext_rw_lock = path->locks[level];\n\t\tret = read_block_for_search(NULL, root, path, &next, level,\n\t\t\t\t\t    slot, &key, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret && time_seq) {\n\t\t\t\t/*\n\t\t\t\t * If we don't get the lock, we may be racing\n\t\t\t\t * with push_leaf_left, holding that lock while\n\t\t\t\t * itself waiting for the leaf we've currently\n\t\t\t\t * locked. To solve this situation, we give up\n\t\t\t\t * on our lock and cycle.\n\t\t\t\t */\n\t\t\t\tfree_extent_buffer(next);\n\t\t\t\tbtrfs_release_path(path);\n\t\t\t\tcond_resched();\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tif (!ret) {\n\t\t\t\tbtrfs_set_path_blocking(path);\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t\tbtrfs_clear_path_blocking(path, next,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tnext_rw_lock = BTRFS_READ_LOCK;\n\t\t}\n\t\tbreak;\n\t}\n\tpath->slots[level] = slot;\n\twhile (1) {\n\t\tlevel--;\n\t\tc = path->nodes[level];\n\t\tif (path->locks[level])\n\t\t\tbtrfs_tree_unlock_rw(c, path->locks[level]);\n\n\t\tfree_extent_buffer(c);\n\t\tpath->nodes[level] = next;\n\t\tpath->slots[level] = 0;\n\t\tif (!path->skip_locking)\n\t\t\tpath->locks[level] = next_rw_lock;\n\t\tif (!level)\n\t\t\tbreak;\n\n\t\tret = read_block_for_search(NULL, root, path, &next, level,\n\t\t\t\t\t    0, &key, 0);\n\t\tif (ret == -EAGAIN)\n\t\t\tgoto again;\n\n\t\tif (ret < 0) {\n\t\t\tbtrfs_release_path(path);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!path->skip_locking) {\n\t\t\tret = btrfs_try_tree_read_lock(next);\n\t\t\tif (!ret) {\n\t\t\t\tbtrfs_set_path_blocking(path);\n\t\t\t\tbtrfs_tree_read_lock(next);\n\t\t\t\tbtrfs_clear_path_blocking(path, next,\n\t\t\t\t\t\t\t  BTRFS_READ_LOCK);\n\t\t\t}\n\t\t\tnext_rw_lock = BTRFS_READ_LOCK;\n\t\t}\n\t}\n\tret = 0;\ndone:\n\tunlock_up(path, 0, 1, 0, NULL);\n\tpath->leave_spinning = old_spinning;\n\tif (!old_spinning)\n\t\tbtrfs_set_path_blocking(path);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "path->nodes[0]"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ulist_add",
          "args": [
            "parents",
            "eb->start",
            "0",
            "GFP_NOFS"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "ulist_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ulist.c",
          "lines": "177-180",
          "snippet": "int ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"ulist.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"ulist.h\"\n#include <linux/slab.h>\n\nint ulist_add(struct ulist *ulist, u64 val, u64 aux, gfp_t gfp_mask)\n{\n\treturn ulist_add_merge(ulist, val, aux, NULL, gfp_mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int add_all_parents(struct btrfs_root *root, struct btrfs_path *path,\n\t\t\t   struct ulist *parents, struct __prelim_ref *ref,\n\t\t\t   int level, u64 time_seq, const u64 *extent_item_pos,\n\t\t\t   u64 total_refs)\n{\n\tint ret = 0;\n\tint slot;\n\tstruct extent_buffer *eb;\n\tstruct btrfs_key key;\n\tstruct btrfs_key *key_for_search = &ref->key_for_search;\n\tstruct btrfs_file_extent_item *fi;\n\tstruct extent_inode_elem *eie = NULL, *old = NULL;\n\tu64 disk_byte;\n\tu64 wanted_disk_byte = ref->wanted_disk_byte;\n\tu64 count = 0;\n\n\tif (level != 0) {\n\t\teb = path->nodes[level];\n\t\tret = ulist_add(parents, eb->start, 0, GFP_NOFS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We normally enter this function with the path already pointing to\n\t * the first item to check. But sometimes, we may enter it with\n\t * slot==nritems. In that case, go to the next leaf before we continue.\n\t */\n\tif (path->slots[0] >= btrfs_header_nritems(path->nodes[0]))\n\t\tret = btrfs_next_old_leaf(root, path, time_seq);\n\n\twhile (!ret && count < total_refs) {\n\t\teb = path->nodes[0];\n\t\tslot = path->slots[0];\n\n\t\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\n\t\tif (key.objectid != key_for_search->objectid ||\n\t\t    key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tbreak;\n\n\t\tfi = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\t\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\n\t\tif (disk_byte == wanted_disk_byte) {\n\t\t\teie = NULL;\n\t\t\told = NULL;\n\t\t\tcount++;\n\t\t\tif (extent_item_pos) {\n\t\t\t\tret = check_extent_in_eb(&key, eb, fi,\n\t\t\t\t\t\t*extent_item_pos,\n\t\t\t\t\t\t&eie);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret > 0)\n\t\t\t\tgoto next;\n\t\t\tret = ulist_add_merge_ptr(parents, eb->start,\n\t\t\t\t\t\t  eie, (void **)&old, GFP_NOFS);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (!ret && extent_item_pos) {\n\t\t\t\twhile (old->next)\n\t\t\t\t\told = old->next;\n\t\t\t\told->next = eie;\n\t\t\t}\n\t\t\teie = NULL;\n\t\t}\nnext:\n\t\tret = btrfs_next_old_item(root, path, time_seq);\n\t}\n\n\tif (ret > 0)\n\t\tret = 0;\n\telse if (ret < 0)\n\t\tfree_inode_elem_list(eie);\n\treturn ret;\n}"
  },
  {
    "function_name": "__add_prelim_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "194-222",
    "snippet": "static int __add_prelim_ref(struct list_head *head, u64 root_id,\n\t\t\t    struct btrfs_key *key, int level,\n\t\t\t    u64 parent, u64 wanted_disk_byte, int count,\n\t\t\t    gfp_t gfp_mask)\n{\n\tstruct __prelim_ref *ref;\n\n\tif (root_id == BTRFS_DATA_RELOC_TREE_OBJECTID)\n\t\treturn 0;\n\n\tref = kmem_cache_alloc(btrfs_prelim_ref_cache, gfp_mask);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->root_id = root_id;\n\tif (key)\n\t\tref->key_for_search = *key;\n\telse\n\t\tmemset(&ref->key_for_search, 0, sizeof(ref->key_for_search));\n\n\tref->inode_list = NULL;\n\tref->level = level;\n\tref->count = count;\n\tref->parent = parent;\n\tref->wanted_disk_byte = wanted_disk_byte;\n\tlist_add_tail(&ref->list, head);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_prelim_ref_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&ref->list",
            "head"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ref->key_for_search",
            "0",
            "sizeof(ref->key_for_search)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "btrfs_prelim_ref_cache",
            "gfp_mask"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic struct kmem_cache *btrfs_prelim_ref_cache;\n\nstatic int __add_prelim_ref(struct list_head *head, u64 root_id,\n\t\t\t    struct btrfs_key *key, int level,\n\t\t\t    u64 parent, u64 wanted_disk_byte, int count,\n\t\t\t    gfp_t gfp_mask)\n{\n\tstruct __prelim_ref *ref;\n\n\tif (root_id == BTRFS_DATA_RELOC_TREE_OBJECTID)\n\t\treturn 0;\n\n\tref = kmem_cache_alloc(btrfs_prelim_ref_cache, gfp_mask);\n\tif (!ref)\n\t\treturn -ENOMEM;\n\n\tref->root_id = root_id;\n\tif (key)\n\t\tref->key_for_search = *key;\n\telse\n\t\tmemset(&ref->key_for_search, 0, sizeof(ref->key_for_search));\n\n\tref->inode_list = NULL;\n\tref->level = level;\n\tref->count = count;\n\tref->parent = parent;\n\tref->wanted_disk_byte = wanted_disk_byte;\n\tlist_add_tail(&ref->list, head);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_prelim_ref_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "149-153",
    "snippet": "void btrfs_prelim_ref_exit(void)\n{\n\tif (btrfs_prelim_ref_cache)\n\t\tkmem_cache_destroy(btrfs_prelim_ref_cache);\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_prelim_ref_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "btrfs_prelim_ref_cache"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic struct kmem_cache *btrfs_prelim_ref_cache;\n\nvoid btrfs_prelim_ref_exit(void)\n{\n\tif (btrfs_prelim_ref_cache)\n\t\tkmem_cache_destroy(btrfs_prelim_ref_cache);\n}"
  },
  {
    "function_name": "btrfs_prelim_ref_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "137-147",
    "snippet": "int __init btrfs_prelim_ref_init(void)\n{\n\tbtrfs_prelim_ref_cache = kmem_cache_create(\"btrfs_prelim_ref\",\n\t\t\t\t\tsizeof(struct __prelim_ref),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!btrfs_prelim_ref_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *btrfs_prelim_ref_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"btrfs_prelim_ref\"",
            "sizeof(struct __prelim_ref)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "NULL"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic struct kmem_cache *btrfs_prelim_ref_cache;\n\nint __init btrfs_prelim_ref_init(void)\n{\n\tbtrfs_prelim_ref_cache = kmem_cache_create(\"btrfs_prelim_ref\",\n\t\t\t\t\tsizeof(struct __prelim_ref),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!btrfs_prelim_ref_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "find_extent_in_eb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "82-119",
    "snippet": "static int find_extent_in_eb(struct extent_buffer *eb, u64 wanted_disk_byte,\n\t\t\t\tu64 extent_item_pos,\n\t\t\t\tstruct extent_inode_elem **eie)\n{\n\tu64 disk_byte;\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *fi;\n\tint slot;\n\tint nritems;\n\tint extent_type;\n\tint ret;\n\n\t/*\n\t * from the shared data ref, we only have the leaf but we need\n\t * the key. thus, we must look into all items and see that we\n\t * find one (some) with a reference to our extent item.\n\t */\n\tnritems = btrfs_header_nritems(eb);\n\tfor (slot = 0; slot < nritems; ++slot) {\n\t\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\t\tif (key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tcontinue;\n\t\tfi = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\t\textent_type = btrfs_file_extent_type(eb, fi);\n\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE)\n\t\t\tcontinue;\n\t\t/* don't skip BTRFS_FILE_EXTENT_PREALLOC, we can handle that */\n\t\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\t\tif (disk_byte != wanted_disk_byte)\n\t\t\tcontinue;\n\n\t\tret = check_extent_in_eb(&key, eb, fi, extent_item_pos, eie);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_extent_in_eb",
          "args": [
            "&key",
            "eb",
            "fi",
            "extent_item_pos",
            "eie"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "check_extent_in_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "37-70",
          "snippet": "static int check_extent_in_eb(struct btrfs_key *key, struct extent_buffer *eb,\n\t\t\t\tstruct btrfs_file_extent_item *fi,\n\t\t\t\tu64 extent_item_pos,\n\t\t\t\tstruct extent_inode_elem **eie)\n{\n\tu64 offset = 0;\n\tstruct extent_inode_elem *e;\n\n\tif (!btrfs_file_extent_compression(eb, fi) &&\n\t    !btrfs_file_extent_encryption(eb, fi) &&\n\t    !btrfs_file_extent_other_encoding(eb, fi)) {\n\t\tu64 data_offset;\n\t\tu64 data_len;\n\n\t\tdata_offset = btrfs_file_extent_offset(eb, fi);\n\t\tdata_len = btrfs_file_extent_num_bytes(eb, fi);\n\n\t\tif (extent_item_pos < data_offset ||\n\t\t    extent_item_pos >= data_offset + data_len)\n\t\t\treturn 1;\n\t\toffset = extent_item_pos - data_offset;\n\t}\n\n\te = kmalloc(sizeof(*e), GFP_NOFS);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->next = *eie;\n\te->inum = key->objectid;\n\te->offset = key->offset + offset;\n\t*eie = e;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int check_extent_in_eb(struct btrfs_key *key, struct extent_buffer *eb,\n\t\t\t\tstruct btrfs_file_extent_item *fi,\n\t\t\t\tu64 extent_item_pos,\n\t\t\t\tstruct extent_inode_elem **eie)\n{\n\tu64 offset = 0;\n\tstruct extent_inode_elem *e;\n\n\tif (!btrfs_file_extent_compression(eb, fi) &&\n\t    !btrfs_file_extent_encryption(eb, fi) &&\n\t    !btrfs_file_extent_other_encoding(eb, fi)) {\n\t\tu64 data_offset;\n\t\tu64 data_len;\n\n\t\tdata_offset = btrfs_file_extent_offset(eb, fi);\n\t\tdata_len = btrfs_file_extent_num_bytes(eb, fi);\n\n\t\tif (extent_item_pos < data_offset ||\n\t\t    extent_item_pos >= data_offset + data_len)\n\t\t\treturn 1;\n\t\toffset = extent_item_pos - data_offset;\n\t}\n\n\te = kmalloc(sizeof(*e), GFP_NOFS);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->next = *eie;\n\te->inum = key->objectid;\n\te->offset = key->offset + offset;\n\t*eie = e;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_disk_bytenr",
          "args": [
            "eb",
            "fi"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_type",
          "args": [
            "eb",
            "fi"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_ptr",
          "args": [
            "eb",
            "slot",
            "structbtrfs_file_extent_item"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_item_key_to_cpu",
          "args": [
            "eb",
            "&key",
            "slot"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2755-2761",
          "snippet": "static inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_item_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int find_extent_in_eb(struct extent_buffer *eb, u64 wanted_disk_byte,\n\t\t\t\tu64 extent_item_pos,\n\t\t\t\tstruct extent_inode_elem **eie)\n{\n\tu64 disk_byte;\n\tstruct btrfs_key key;\n\tstruct btrfs_file_extent_item *fi;\n\tint slot;\n\tint nritems;\n\tint extent_type;\n\tint ret;\n\n\t/*\n\t * from the shared data ref, we only have the leaf but we need\n\t * the key. thus, we must look into all items and see that we\n\t * find one (some) with a reference to our extent item.\n\t */\n\tnritems = btrfs_header_nritems(eb);\n\tfor (slot = 0; slot < nritems; ++slot) {\n\t\tbtrfs_item_key_to_cpu(eb, &key, slot);\n\t\tif (key.type != BTRFS_EXTENT_DATA_KEY)\n\t\t\tcontinue;\n\t\tfi = btrfs_item_ptr(eb, slot, struct btrfs_file_extent_item);\n\t\textent_type = btrfs_file_extent_type(eb, fi);\n\t\tif (extent_type == BTRFS_FILE_EXTENT_INLINE)\n\t\t\tcontinue;\n\t\t/* don't skip BTRFS_FILE_EXTENT_PREALLOC, we can handle that */\n\t\tdisk_byte = btrfs_file_extent_disk_bytenr(eb, fi);\n\t\tif (disk_byte != wanted_disk_byte)\n\t\t\tcontinue;\n\n\t\tret = check_extent_in_eb(&key, eb, fi, extent_item_pos, eie);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_inode_elem_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "72-80",
    "snippet": "static void free_inode_elem_list(struct extent_inode_elem *eie)\n{\n\tstruct extent_inode_elem *eie_next;\n\n\tfor (; eie; eie = eie_next) {\n\t\teie_next = eie->next;\n\t\tkfree(eie);\n\t}\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "eie"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic void free_inode_elem_list(struct extent_inode_elem *eie)\n{\n\tstruct extent_inode_elem *eie_next;\n\n\tfor (; eie; eie = eie_next) {\n\t\teie_next = eie->next;\n\t\tkfree(eie);\n\t}\n}"
  },
  {
    "function_name": "check_extent_in_eb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
    "lines": "37-70",
    "snippet": "static int check_extent_in_eb(struct btrfs_key *key, struct extent_buffer *eb,\n\t\t\t\tstruct btrfs_file_extent_item *fi,\n\t\t\t\tu64 extent_item_pos,\n\t\t\t\tstruct extent_inode_elem **eie)\n{\n\tu64 offset = 0;\n\tstruct extent_inode_elem *e;\n\n\tif (!btrfs_file_extent_compression(eb, fi) &&\n\t    !btrfs_file_extent_encryption(eb, fi) &&\n\t    !btrfs_file_extent_other_encoding(eb, fi)) {\n\t\tu64 data_offset;\n\t\tu64 data_len;\n\n\t\tdata_offset = btrfs_file_extent_offset(eb, fi);\n\t\tdata_len = btrfs_file_extent_num_bytes(eb, fi);\n\n\t\tif (extent_item_pos < data_offset ||\n\t\t    extent_item_pos >= data_offset + data_len)\n\t\t\treturn 1;\n\t\toffset = extent_item_pos - data_offset;\n\t}\n\n\te = kmalloc(sizeof(*e), GFP_NOFS);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->next = *eie;\n\te->inum = key->objectid;\n\te->offset = key->offset + offset;\n\t*eie = e;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"locking.h\"",
      "#include \"delayed-ref.h\"",
      "#include \"transaction.h\"",
      "#include \"ulist.h\"",
      "#include \"backref.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include <linux/vmalloc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*e)",
            "GFP_NOFS"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_num_bytes",
          "args": [
            "eb",
            "fi"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_offset",
          "args": [
            "eb",
            "fi"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_other_encoding",
          "args": [
            "eb",
            "fi"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_encryption",
          "args": [
            "eb",
            "fi"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_file_extent_compression",
          "args": [
            "eb",
            "fi"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic int check_extent_in_eb(struct btrfs_key *key, struct extent_buffer *eb,\n\t\t\t\tstruct btrfs_file_extent_item *fi,\n\t\t\t\tu64 extent_item_pos,\n\t\t\t\tstruct extent_inode_elem **eie)\n{\n\tu64 offset = 0;\n\tstruct extent_inode_elem *e;\n\n\tif (!btrfs_file_extent_compression(eb, fi) &&\n\t    !btrfs_file_extent_encryption(eb, fi) &&\n\t    !btrfs_file_extent_other_encoding(eb, fi)) {\n\t\tu64 data_offset;\n\t\tu64 data_len;\n\n\t\tdata_offset = btrfs_file_extent_offset(eb, fi);\n\t\tdata_len = btrfs_file_extent_num_bytes(eb, fi);\n\n\t\tif (extent_item_pos < data_offset ||\n\t\t    extent_item_pos >= data_offset + data_len)\n\t\t\treturn 1;\n\t\toffset = extent_item_pos - data_offset;\n\t}\n\n\te = kmalloc(sizeof(*e), GFP_NOFS);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->next = *eie;\n\te->inum = key->objectid;\n\te->offset = key->offset + offset;\n\t*eie = e;\n\n\treturn 0;\n}"
  }
]